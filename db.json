{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-yilia/source/mobile.d238ee.js","path":"mobile.d238ee.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/main.234bc0.css","path":"main.234bc0.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/slider.885efe.js","path":"slider.885efe.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/main.234bc0.js","path":"main.234bc0.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/show.png","path":"img/show.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/logo.jpg","path":"img/logo.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"e826265426093331c83813579a8bf40aa1455784","modified":1508034847000},{"_id":"themes/hexo-theme-yilia/.DS_Store","hash":"0b84e5f7597e3782645374e9f52c0659b08ad8f0","modified":1491093678000},{"_id":"themes/hexo-theme-yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/_config.yml","hash":"25efb98e4399e259c79260e1572a87ecea1610eb","modified":1504447458000},{"_id":"themes/hexo-theme-yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/package.json","hash":"946b26ae0dff42c590068f0a58ecd326ed059b68","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/webpack.config.js","hash":"c4dca5c60822c90359e48fad373be768ae9fb43d","modified":1491092347000},{"_id":"source/_posts/.DS_Store","hash":"67ca02010a9f20e07b77f79fe5fe631237a2c3dd","modified":1506261128000},{"_id":"source/_posts/2017-04-04.md","hash":"7f3680ad803fa25bb7de5f4cec0d0256064c4ce5","modified":1504357277000},{"_id":"source/_posts/2017-04-11.md","hash":"b6540a66f0ae229bbf600f9933541ae7bbab51e7","modified":1503752313000},{"_id":"source/_posts/2017-04-10.md","hash":"2007b7532a86a9a051c140444b8c8d672c5fed10","modified":1503752313000},{"_id":"source/_posts/2017-05-02.md","hash":"7fedceed371345b4ea84d6edca285a6fd115d30d","modified":1503752313000},{"_id":"source/_posts/2017-05-07.md","hash":"659c113fdeec3ee0af857e7a678e13bf68a2d5e2","modified":1503752313000},{"_id":"source/_posts/2017-06-10.md","hash":"54c2d41c8a1d30a11125b1675b65ad5d908f224b","modified":1504357400000},{"_id":"source/_posts/2017-06-11.md","hash":"bba7cd0287d97f8c0d7f45bd0d7b69eb931e50be","modified":1504357352000},{"_id":"source/_posts/2017-06-12.md","hash":"56ab56d99a85e2649738da4bca9ed242051fdef6","modified":1504411254000},{"_id":"source/_posts/ajax.md","hash":"64e183b97cca8a579321426cf5bfe557e31137cf","modified":1503752313000},{"_id":"source/_posts/vue-ssr.md","hash":"d203eb2182c5db477941c967e0dc9bc5fd1a4ef7","modified":1503752313000},{"_id":"source/_posts/vue-ssr2.md","hash":"ea8e62902507106a4bf631f47da9bb83fab3b7b4","modified":1503752313000},{"_id":"source/_posts/vue-ssr3.md","hash":"62915e65956ca7d59bf764f83bbebfb065b585b2","modified":1503752313000},{"_id":"source/_posts/webgl-2017-07-01.md","hash":"76a07991a8c0428aa9d81bb436f870c959eaafbb","modified":1504412158000},{"_id":"source/_posts/webgl-2017-07-02.md","hash":"a35d04de0101fdf3d7c6df7f1a8d6d469c7bfe7a","modified":1504499616000},{"_id":"source/_posts/webgl-2017-07-03.md","hash":"cbf0ef1180b2753cab9aec69c238aabe449756b0","modified":1504499605000},{"_id":"source/_posts/webgl-2017-07-04.md","hash":"08eb5650d403f375646881d276af3272bc47dedc","modified":1504619271000},{"_id":"source/_posts/webgl-2017-07-06.md","hash":"cff250464061984c19a2850fe6d1709894bd5bc0","modified":1507192265000},{"_id":"source/_posts/webgl-2017-07-08.md","hash":"8114ba06023ba3ca90b92aa36f8b385f2a882f92","modified":1507290442000},{"_id":"source/_posts/webgl-2017-07-09.md","hash":"ef96908a6cff2bb7cd77b2a53dbeb5efe9bf8ccc","modified":1508034021000},{"_id":"source/_posts/webgl-2017-07-11.md","hash":"fe8188fe4f33e62054fc7c6044c098bcb1ebe030","modified":1509874698000},{"_id":"source/_posts/webgl-2017-07-12.md","hash":"91166fc3904fea3e7489794a5913f8562c0b0b07","modified":1509272021000},{"_id":"source/_posts/webgl-2017-07-10.md","hash":"5e0756df8d9f10efee56cb913645e41b69e0dcd7","modified":1508040600000},{"_id":"themes/hexo-theme-yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1491092347000},{"_id":"source/categories/index.md","hash":"8cdcbc26f07f436675a5a5eb3bc84a1a7bbd63e2","modified":1491115574000},{"_id":"themes/hexo-theme-yilia/.git/ORIG_HEAD","hash":"ec274ad8176ea701ec280f2352a47451b498c39a","modified":1491092391000},{"_id":"themes/hexo-theme-yilia/.git/FETCH_HEAD","hash":"5885194d6adf0f9790b410a42f0f9642e9f2a770","modified":1491092391000},{"_id":"themes/hexo-theme-yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/index","hash":"0cfa1aa7ac01258ba2fcac875cd13e1c783d45d4","modified":1503204623000},{"_id":"themes/hexo-theme-yilia/.git/packed-refs","hash":"144a02fde3eaced071755091d413698cb7e8382d","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source/.DS_Store","hash":"4cf2103ba402ede4e35924760df7b32fff7525cb","modified":1491093678000},{"_id":"themes/hexo-theme-yilia/source/mobile.d238ee.js","hash":"a054884092af1cc5c2c14e5e11a4dac6d9254481","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/.DS_Store","hash":"6bd59b6930c3f152d22826a8daeea4fd54fe7cc1","modified":1491543561000},{"_id":"themes/hexo-theme-yilia/source/main.234bc0.css","hash":"0ba37e8f05b5efd14ec9a5eab28ae0c0a06abd5c","modified":1504442545000},{"_id":"themes/hexo-theme-yilia/source/slider.885efe.js","hash":"1f1a6548c6016cc132bf65a1701cc8421a1f8414","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source/main.234bc0.js","hash":"988c141a741441812bcf4c408ef530d7a01522f3","modified":1491092347000},{"_id":"source/_posts/2017-05-07/1.png","hash":"b3afc9f9b15595ca71cb9f7a3f9a150009c41f4e","modified":1494162933000},{"_id":"source/_posts/2017-05-07/2.png","hash":"63dc5115954f65778dac9be5b64da7a66d28b997","modified":1494162948000},{"_id":"source/_posts/2017-05-07/3.png","hash":"f35883f1d4a930a5ed9090f32c58fe6f4ec21841","modified":1494163229000},{"_id":"source/_posts/2017-06-11/01.jpeg","hash":"a082a77ecb145c4bf5ac40420eb9dd79aa45cdb3","modified":1503820393000},{"_id":"source/_posts/2017-06-11/02.jpeg","hash":"4bfb34072f539b8367d62220d63ff09f64f8263e","modified":1503820436000},{"_id":"source/_posts/2017-06-12/01.jpeg","hash":"edbd185f826339e53b0e5589a061ed551f815a9e","modified":1504357891000},{"_id":"source/_posts/2017-06-12/02.jpeg","hash":"9fd24d8ad11fec889adbad561319e7c39bbb3cdd","modified":1504362705000},{"_id":"source/_posts/2017-06-12/03.jpeg","hash":"0b012a70995089687e185731d39284dae19724f2","modified":1504362730000},{"_id":"source/_posts/2017-06-12/05.jpeg","hash":"f4832a8ff5b1b440b48d40754a29c77164512da9","modified":1504409726000},{"_id":"source/_posts/2017-06-12/06.jpeg","hash":"7632d800121462464cd159837319398b8af9925d","modified":1504410596000},{"_id":"source/_posts/ajax/111.png","hash":"2055c99c7528d767b60e30d092f940bdeae34507","modified":1491095615000},{"_id":"source/_posts/vue-ssr2/2.jpeg","hash":"2dcb76db17520c9302d7c86b3fa7618b7bd2ce3b","modified":1503752313000},{"_id":"source/_posts/vue-ssr2/3.jpeg","hash":"5b8c1a59b6bb1e55b0beb27b47852718981782f2","modified":1503752313000},{"_id":"source/_posts/webgl-2017-07-01/03.jpeg","hash":"bc6b53c34104f47984e0ca30200ab9e5ed8ff8e5","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-01/.DS_Store","hash":"6a611939b3f11e4ab9cb79fa282767cb708c7f53","modified":1503755974000},{"_id":"source/_posts/webgl-2017-07-01/04.jpeg","hash":"b12449f26e6e1f57ee795b3dd2ab40b69d7e6ea7","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-01/07.jpeg","hash":"5859052106fca9a386b97116c72f3815ebd407bd","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-01/09.jpeg","hash":"ac7dd15c2dd685fe54f04cb2279739f6e913cd77","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-01/10.jpeg","hash":"07d2cf14b7a4bb486e2c44d89c08d9873093df32","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-01/11.jpeg","hash":"6460798902cac012f6cecb3216c51a4dd14a46fc","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-01/13.jpeg","hash":"02d7caa28587d7198402cfb9500db3ab85fb6eae","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-01/12.jpeg","hash":"d792adaf7049bab3a419fc176d4d62afb0299514","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-01/14.jpeg","hash":"2ad46d294f5286bd1f665513a77059dc9490c84b","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-03/01.jpeg","hash":"22bdda31eb9bac80277080fd2424f677b15d0171","modified":1504422835000},{"_id":"source/_posts/webgl-2017-07-03/02.jpeg","hash":"e623a9a82048e7e534d8ce0596963f8f74481acf","modified":1504433289000},{"_id":"source/_posts/webgl-2017-07-03/05.jpeg","hash":"f15a6bc585bbf21f72d2faa63d26f74e4860a108","modified":1504444618000},{"_id":"source/_posts/webgl-2017-07-04/01.jpeg","hash":"d77e822505fe4adfb187fc6cc69e354e021b6541","modified":1504532729000},{"_id":"source/_posts/webgl-2017-07-04/02.jpeg","hash":"710b23c1dc6623db1343c19a419c439c824ffa93","modified":1504618531000},{"_id":"source/_posts/webgl-2017-07-04/03.jpeg","hash":"a6249aeadec43f859853462815b2e98de144d414","modified":1504618800000},{"_id":"source/_posts/webgl-2017-07-04/04.jpeg","hash":"f0bec32549570dea08ec88dee6bc868437d1ff89","modified":1504619037000},{"_id":"source/_posts/webgl-2017-07-06/1.jpeg","hash":"5aa58e09552aedf5cebc18ddbc11e056d3fd1da1","modified":1506244164000},{"_id":"source/_posts/webgl-2017-07-06/2.jpeg","hash":"aca0c62ee7ce7b649a31238ebe7eb7b8cf4e8df0","modified":1506244876000},{"_id":"source/_posts/webgl-2017-07-06/3.jpeg","hash":"2b1e062d7124cffe0e381bd5abffcc28b3909590","modified":1506245139000},{"_id":"source/_posts/webgl-2017-07-06/4.jpeg","hash":"a6de64667296657f43373603ff515506a0e52de1","modified":1506245670000},{"_id":"source/_posts/webgl-2017-07-08/.DS_Store","hash":"89cd76026009acbf3c46fab308de948407309ab7","modified":1506261127000},{"_id":"source/_posts/webgl-2017-07-08/2.jpeg","hash":"7419ba73e6f8c5bc2dfcb710daf25c95a55ae2bd","modified":1507196719000},{"_id":"source/_posts/webgl-2017-07-08/3.jpeg","hash":"7b802131222c42748ab93d43a8d4f1a6b61185e0","modified":1507289059000},{"_id":"source/_posts/webgl-2017-07-08/6.jpeg","hash":"9058c301b9f79d31954c74812db9da8c8c98f751","modified":1507290227000},{"_id":"source/_posts/webgl-2017-07-09/1.jpeg","hash":"65f82116bc3403c6751d71940c9a4e287fca844f","modified":1508033616000},{"_id":"source/_posts/webgl-2017-07-08/7.jpeg","hash":"fda2210e8c0ae280ed63b18e316eb51c1ba5215a","modified":1507290411000},{"_id":"source/_posts/webgl-2017-07-10/1.jpeg","hash":"6488f62098428ca180b53f7a3d7399a6ea4d9b68","modified":1508036245000},{"_id":"source/_posts/webgl-2017-07-10/2.jpeg","hash":"c7b2839321301ed0ed01227bf1d3a9a01b4a0b96","modified":1508040568000},{"_id":"source/_posts/webgl-2017-07-11/01.jpeg","hash":"c8dff683ee454fbd46a3d11806fad3d71c16c0ac","modified":1509262476000},{"_id":"source/_posts/webgl-2017-07-11/4.jpeg","hash":"7ee581b83f58f086b902520d7ad8a578b5935023","modified":1509266622000},{"_id":"themes/hexo-theme-yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1491092317000},{"_id":"themes/hexo-theme-yilia/.git/logs/HEAD","hash":"a809e105d052f880c1d2aa45840dff50e85330e7","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/article.ejs","hash":"2caf8cc76d0a814680a11b6e8c3765032b54138f","modified":1504356977000},{"_id":"themes/hexo-theme-yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/footer.ejs","hash":"1d1ba016fc3999e43d5a3af7908cd4fb4113cfab","modified":1491114892000},{"_id":"themes/hexo-theme-yilia/layout/_partial/css.ejs","hash":"1b91850e8708ce4c83e3cc3f474921182d792308","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/tools.ejs","hash":"f5e98b6013c968afb867626ed6617cd1cedc3d3a","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/script.ejs","hash":"c4a0f16d554e7e7007856d45b78443d7bf0b40b7","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source/img/.DS_Store","hash":"5abb8453dc15577d5fa0fa02c41ebb7159cffc04","modified":1504356218000},{"_id":"themes/hexo-theme-yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source/img/show.png","hash":"bfe9486ee51f9037434279cf2b0ff5ddc84d886f","modified":1504356206000},{"_id":"themes/hexo-theme-yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/js/fix.js","hash":"17be4f27eb8951835c29dafd0f6ba1b18e47cc6b","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/archive.scss","hash":"b750499d5120f963b683d0c96ac3f345c714e448","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/article-inner.scss","hash":"ce24ab7049be634c17a163e2db39f1f0b1f7c119","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/article-nav.scss","hash":"b68772aa2b47d0ed89ce95d4e9d3d27931fe885c","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/duoshuo.scss","hash":"5e3feefbbba70d8da0ec2c75db41762dd4762a81","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/fonts.scss","hash":"3f5808a49a7365e3f813f78ba96b692f7ca27886","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/left.scss","hash":"0ce6345a86c44e3fea5a4aa439614541112538f3","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/mobile.scss","hash":"12abb65289eed5391d657b963a20f96a473b1cbd","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/main.scss","hash":"40c055e8360973a75db7c13f3280a4f465f9e5e3","modified":1503194536000},{"_id":"themes/hexo-theme-yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/tools.scss","hash":"61917c928d09783a3bc8a91503a59ab3a8696e90","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1491092347000},{"_id":"source/_posts/2017-06-12/04.jpeg","hash":"2f8a989fe72d65e2866bccd1b6b3b46f013695a8","modified":1504408948000},{"_id":"source/_posts/vue-ssr/11.png","hash":"ab5ed2f6789ff7bb6ff7132e8e3df5f01faf69e5","modified":1503143598000},{"_id":"source/_posts/vue-ssr/22.jpeg","hash":"85b1ea4114f8700acb8733a0055ff086f19c11fe","modified":1503144085000},{"_id":"source/_posts/webgl-2017-07-01/01.jpeg","hash":"42447f5818e428c21ed64984747a0195863f11b2","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-01/05.jpeg","hash":"c566f55816e17e0090bf5828253d6110db733764","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-01/06.jpeg","hash":"51cee3ed4d1b432fa6a57058e4f520108e5eefbd","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-01/08.jpeg","hash":"c465bcedddb5afeece69b4e9e19f31da04156735","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-02/01.jpeg","hash":"11889ad055dd286dc343fa9298822a0cd53cde8a","modified":1504413597000},{"_id":"source/_posts/webgl-2017-07-02/02.jpeg","hash":"6b414b4841c552f3b2b6f4ef4acabf876b686bd6","modified":1504413871000},{"_id":"source/_posts/webgl-2017-07-03/03.jpeg","hash":"6e7796a03b6b3696c84583d90dd511e824319ae2","modified":1504433792000},{"_id":"source/_posts/webgl-2017-07-03/04.jpeg","hash":"d763e811ab78817019418ff895e5228068980f61","modified":1504443719000},{"_id":"source/_posts/webgl-2017-07-06/5.jpeg","hash":"f2244b58aa5d5a3bece6a6e72ea4231490644fe4","modified":1506260305000},{"_id":"source/_posts/webgl-2017-07-08/5.jpeg","hash":"f2244b58aa5d5a3bece6a6e72ea4231490644fe4","modified":1506260305000},{"_id":"source/_posts/webgl-2017-07-11/2.jpeg","hash":"bad0cc3d5f473a2999e36987dc01f3e281eeb248","modified":1509263605000},{"_id":"source/_posts/webgl-2017-07-11/3.jpeg","hash":"b4f0f4f2f7ae48a7f1c92fd450580df0953a1784","modified":1509264388000},{"_id":"source/_posts/webgl-2017-07-12/1.jpeg","hash":"33e5989b7e3033971fdf1748e919e7678e6f43c5","modified":1509271910000},{"_id":"themes/hexo-theme-yilia/source/img/logo.jpg","hash":"7ddb617f784f4b5dbfecddf32600c19749087ecd","modified":1491093635000},{"_id":"source/_posts/vue-ssr2/4.jpeg","hash":"12de3851c4c673e3a549f16d1a9059e9299e0137","modified":1503752313000},{"_id":"source/_posts/vue-ssr3/11.jpeg","hash":"5a94d2a1847cb115eaa07d7089cfa3f95f89ea20","modified":1503752313000},{"_id":"source/_posts/webgl-2017-07-01/15.jpeg","hash":"45617c40cacf2cf6aad91759fef16502fc673f2a","modified":1503805985000},{"_id":"themes/hexo-theme-yilia/.git/refs/heads/master","hash":"ec274ad8176ea701ec280f2352a47451b498c39a","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/.git/objects/pack/pack-7cbda1a00de83cde49bfab56b11029c9d89eaeba.idx","hash":"a61b8f72c229073a53ea75276b885df11940a11a","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/duoshuo.ejs","hash":"57018a5825aca8d277b161ed0990dd9c5a031cc0","modified":1503149201000},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1491092347000},{"_id":"source/_posts/vue-ssr2/1.jpeg","hash":"5749f39a018e4b53e0c332e8208870ad8f82997c","modified":1503752313000},{"_id":"source/_posts/webgl-2017-07-01/02.jpeg","hash":"2a4a8313c0e80fd6a125266fb6d813ddba4b4cdd","modified":1503805985000},{"_id":"source/_posts/webgl-2017-07-08/1.jpeg","hash":"b8e7a031918613633a970eac447c9b33adc3ad78","modified":1507194087000},{"_id":"themes/hexo-theme-yilia/.git/logs/refs/heads/master","hash":"a809e105d052f880c1d2aa45840dff50e85330e7","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/.git/logs/refs/remotes/origin/HEAD","hash":"a809e105d052f880c1d2aa45840dff50e85330e7","modified":1491092347000},{"_id":"themes/hexo-theme-yilia/.git/objects/pack/pack-7cbda1a00de83cde49bfab56b11029c9d89eaeba.pack","hash":"20c4b1f9c67efe010d0ae13728a02a3bb7d29a84","modified":1491092347000},{"_id":"source/_posts/webgl-2017-07-11/6.jpeg","hash":"c87b67ab322e61fcd7e67234b8739b196f0feddc","modified":1509871103000},{"_id":"source/_posts/webgl-2017-07-11/7.jpeg","hash":"d9b3de79ab6f3c0343b897e062a3f8c919b96a67","modified":1509872699000},{"_id":"source/_posts/webgl-2017-07-11/8.jpeg","hash":"63af8df9399d14bd90e796bb7910d7cc647702d8","modified":1509873203000},{"_id":"source/_posts/webgl-2017-07-11/5.jpeg","hash":"37eca1e94c2bba4f56cd8fe94315ae66061ca36e","modified":1509870947000},{"_id":"public/content.json","hash":"e5e6b984eb1b157f2891ce25588d344744a4bd0e","modified":1509874766758},{"_id":"public/categories/index.html","hash":"e6e2217a52199870bea4188044937d5191635ab0","modified":1509874767065},{"_id":"public/webgl-2017-07-11/index.html","hash":"5e892d0d7437523f061b4fa54804e13ea2d65112","modified":1509874767065},{"_id":"public/webgl-2017-07-12/index.html","hash":"e6f4e96e8ba86378da1bff2320ea8a11eb086621","modified":1509874767065},{"_id":"public/webgl-2017-07-10/index.html","hash":"03c57a62eaddfc770018be05cf385f96c5013d2e","modified":1509874767065},{"_id":"public/webgl-2017-07-09/index.html","hash":"1489a689e60be9fc563c0ae6cd280f2a93242334","modified":1509874767065},{"_id":"public/webgl-2017-07-08/index.html","hash":"08428406c0e20032f31e3950b7d6c124cb1fb2af","modified":1509874767065},{"_id":"public/webgl-2017-07-06/index.html","hash":"9d7e39cd2c590cd99c91dc06f849a557a5e57965","modified":1509874767065},{"_id":"public/webgl-2017-07-04/index.html","hash":"5d1547b8d2af396dff4c4eae8ff5a113a31eba8f","modified":1509874767065},{"_id":"public/webgl-2017-07-03/index.html","hash":"43336c3efdbf51588b773b46c0915e33092bb063","modified":1509874767065},{"_id":"public/webgl-2017-07-02/index.html","hash":"c352d02cbf8a42d8ddde5cfb5db47fce24887e93","modified":1509874767066},{"_id":"public/webgl-2017-07-01/index.html","hash":"09d35eae6aaaf388e02449e468eba1b7ad87c621","modified":1509874767066},{"_id":"public/2017-06-12/index.html","hash":"b8639129f6d30154dc07261a6d0e5ef3c9115e7c","modified":1509874767066},{"_id":"public/2017-06-11/index.html","hash":"0464ea73869848e167869678db7eb856b7079f30","modified":1509874767066},{"_id":"public/2017-06-10/index.html","hash":"4d061ca64242e2f6504424774c5ddbd63799d803","modified":1509874767066},{"_id":"public/vue-ssr3/index.html","hash":"39d882a3b33d844fa7a6ba7b8816091c948aa47f","modified":1509874767066},{"_id":"public/vue-ssr2/index.html","hash":"a32875ce25c4c982ced2db1173d79246d42bdce1","modified":1509874767066},{"_id":"public/vue-ssr/index.html","hash":"4b563e13a0d0eeeacffe4e1fd8382ec896d383ae","modified":1509874767066},{"_id":"public/2017-05-07/index.html","hash":"80c948c4dad5bda40078d33f4edfe072c4f67baf","modified":1509874767066},{"_id":"public/2017-05-02/index.html","hash":"b7be5259236e1b6365afad49b78b0ad724d7ddd2","modified":1509874767066},{"_id":"public/2017-04-11/index.html","hash":"b41f0d08572df5df2d7d68ad495b54ba7448c3c7","modified":1509874767066},{"_id":"public/2017-04-10/index.html","hash":"e8d6aef50a9d5af02f781518490d644ead8ab02a","modified":1509874767066},{"_id":"public/2017-04-04/index.html","hash":"da36d2b0385793f3141847b71cff7922c2e9fda9","modified":1509874767066},{"_id":"public/ajax/index.html","hash":"912d501ff654997d8cdaaad85895c237fa5148e4","modified":1509874767066},{"_id":"public/categories/js/index.html","hash":"47d6e1fb3ee335f0e64992b6698333cdd0d6cb50","modified":1509874767067},{"_id":"public/archives/index.html","hash":"fdba6100efd45f42c0a7ed4488bde978e9d23738","modified":1509874767067},{"_id":"public/archives/page/2/index.html","hash":"94191b79fc577d765ba75a28f6bc874feebf375c","modified":1509874767067},{"_id":"public/archives/page/3/index.html","hash":"ee5c02380a6411347f84d44fe11ccb1110f34806","modified":1509874767067},{"_id":"public/archives/2017/index.html","hash":"b32ea0d1dfd7692a9d63e3835bc321e4381b63e1","modified":1509874767067},{"_id":"public/archives/2017/page/2/index.html","hash":"343312de03751c1348002fe8f8902866ae8fad80","modified":1509874767067},{"_id":"public/archives/2017/page/3/index.html","hash":"e42d3907b9a7b136307a2224a41fcc275ef33381","modified":1509874767067},{"_id":"public/archives/2017/04/index.html","hash":"fbadbef1c7bd3a37f0b8eeb93affb44abe4e14d0","modified":1509874767067},{"_id":"public/archives/2017/05/index.html","hash":"5fc3daf4212529166bbbb303f15922d3090702c3","modified":1509874767067},{"_id":"public/archives/2017/06/index.html","hash":"ce5857d498bbcf9eef334bc47a9417c7def4f745","modified":1509874767067},{"_id":"public/archives/2017/07/index.html","hash":"0a8149e1b4541f084aec7c387243dd12ec27c121","modified":1509874767067},{"_id":"public/index.html","hash":"8719fe1eeba64325f09ad7e6784a3fe16bcf032c","modified":1509874767067},{"_id":"public/page/2/index.html","hash":"31073add242dc6e14637f43ce082e1ff3dee52be","modified":1509874767067},{"_id":"public/page/3/index.html","hash":"9f88bd0931a0999971046e3e7cc2570d99e49738","modified":1509874767067},{"_id":"public/tags/javascript/index.html","hash":"2ad983428ecf3c93e6086177878e4ca847e02b72","modified":1509874767067},{"_id":"public/tags/javascript/page/2/index.html","hash":"614e487cee0668af8443b46eb2ac631e17178c16","modified":1509874767067},{"_id":"public/tags/javascript/page/3/index.html","hash":"4d777f284f9a4107f105b5e67e368d9fb9292c0d","modified":1509874767067},{"_id":"public/tags/node/index.html","hash":"9c2b12ca46ce97826b264b085c405c32a5a59abc","modified":1509874767068},{"_id":"public/tags/es6/index.html","hash":"d3399df9820742931666a31166d2ab8fe1efcf3d","modified":1509874767069},{"_id":"public/tags/ajax/index.html","hash":"bf9728775138c38f590a3a399cc887e089e07891","modified":1509874767069},{"_id":"public/tags/react/index.html","hash":"2a9236dca471685359996e4bc328ac78b5ed6ed8","modified":1509874767070},{"_id":"public/tags/302/index.html","hash":"ca8da71dedf7db412dfde3ab91daeaa5190bb221","modified":1509874767070},{"_id":"public/tags/vue/index.html","hash":"9ec701b764a277d849603fbd6acdaf1dab81b494","modified":1509874767070},{"_id":"public/tags/webgl/index.html","hash":"65859a4cfaed8a72a1c24c78a53d3dd0e0326550","modified":1509874767070},{"_id":"public/webgl-2017-07-11/7.jpeg","hash":"d9b3de79ab6f3c0343b897e062a3f8c919b96a67","modified":1509874767074},{"_id":"public/webgl-2017-07-11/8.jpeg","hash":"63af8df9399d14bd90e796bb7910d7cc647702d8","modified":1509874767074},{"_id":"public/webgl-2017-07-11/6.jpeg","hash":"c87b67ab322e61fcd7e67234b8739b196f0feddc","modified":1509874767074},{"_id":"public/webgl-2017-07-11/5.jpeg","hash":"37eca1e94c2bba4f56cd8fe94315ae66061ca36e","modified":1509874767075}],"Category":[{"name":"javascript","_id":"cj9mi36rj000ilmldivoj7wpd"}],"Data":[],"Page":[{"title":"文章类别","date":"2017-04-02T06:43:41.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章类别\ndate: 2017-04-02 14:43:41\n---\n","updated":"2017-04-02T06:46:14.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj9mi36qd0001lmldrb2patv6","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"nodejs的process.nextTick方法理解和使用","comments":1,"toc":true,"date":"2017-04-04T09:49:45.000Z","_content":"今天重新温习了下nodejs开发指南中的核心模块全局对象中的process进程模块，其实nextTick和我目前使用的vue中的nextTick方法有些异曲同工之妙，于是上网搜整理了一些资料，详细的了解下nextTick到底该如何理解并且在实际项目中哪些地方会用到这个方法。\n\nNode.js是单线程的，基于事件循环，非阻塞IO的。事件循环中使用一个事件队列，在每个时间点上，系统只会处理一个事件，即使电脑有多个CPU核心，也无法同时并行的处理多个事件。因此，node.js适合处理I／O型的应用，不适合那种CPU运算密集型的应用。在I／O型的应用中，给每一个输入输出定义一个回调函数，node.js会自动将其加入到事件轮询的处理队列里，当I／O操作完成后，这个回调函数会被触发，系统会继续处理其他的请求。\n\n<!-- more -->\n\n## 理解\n\n在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的**下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时**；与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。\n\n在这种处理模式下，process.nextTick()的意思就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行。我们来看一个例子。例子中有一个foo()，你想在下一个时间点上调用他，可以这么做：\n\n``` javascript\nfunction foo() {\n    console.error('foo');\n}\nprocess.nextTick(foo);\nconsole.error('bar');\n```\n\n运行上面的代码，你从下面终端打印的信息会看到，\"bar\"的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。\n\n``` javascript\nbar\nfoo\n```\n\n你也可以使用setTimeout()函数来达到貌似同样的执行效果：\n\n``` javascript\nsetTimeout(foo, 0);\nconsole.log('bar');\n```\n\n但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时。process.nextTick()定义的调用会创建一个新的队列。在当前的队列里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须结束队列操作。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的队列。\n\n## 具体使用场景\n#### 在多个事件里交叉执行CPU运算密集型的任务\n\n在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。\n\n但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。\n\n``` javascript\nvar http = require('http');\nfunction compute() {\n    // performs complicated calculations continuously\n   // ...\n    process.nextTick(compute);\n}\nhttp.createServer(function(req, res) {\n     res.writeHead(200, {'Content-Type': 'text/plain'});\n     res.end('Hello World');\n}).listen(5000, '127.0.0.1');\ncompute();\n```\n\n在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。\n\n当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。\n\n#### 保持回调函数异步执行的原则\n\n当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则：\n\n``` javascript\nfunction maybeSync(arg, cb) {\n  if (arg) {\n    cb();\n    return;\n  }\n\n  fs.stat('file', cb);\n}\nmaybeSync(true, function() {\n  foo();\n});\nbar();\n```\n这段代码不明确的地方是, 我们不清楚foo()和bar()哪个会被先调用，使用nextTick将回调函数变成异步的。这样写更好：\n\n``` javascript\nfunction definitelyAsync(arg, cb) {\n  if (arg) {\n    process.nextTick(cb);\n    return;\n  }\n\t\n  fs.stat('file', cb);\n}\n```\t\n\n#### 用在事件触发过程中\n\n来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写：\n\n``` javascript\nvar EventEmitter = require('events').EventEmitter;\nfunction StreamLibrary(resourceName) { \n    this.emit('start');\n    // read from the file, and for every chunk read, do:       \n    this.emit('data', chunkRead);      \n}\nStreamLibrary.prototype.__proto__ = EventEmitter.prototype;   // inherit from EventEmitter\n```\t\n\n下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件：\n\n``` javascript\nvar stream = new StreamLibrary('fooResource');\nstream.on('start', function() {\n    console.log('Reading has started');\n});\nstream.on('data', function(chunk) {\n    console.log('Received: ' + chunk);\n});\n```\t\n\n但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本：\n\n``` javascript\nfunction StreamLibrary(resourceName) {\n    var self = this;\n    process.nextTick(function() {\n        self.emit('start');\n    });\n    // read from the file, and for every chunk read, do:       \n    this.emit('data', chunkRead);\n}\n```\t","source":"_posts/2017-04-04.md","raw":"---\ntitle: nodejs的process.nextTick方法理解和使用\ncomments: true\ntoc: true\ndate: 2017-04-04 17:49:45\ntags: \n    - 'javascript'\n    - 'node'\n---\n今天重新温习了下nodejs开发指南中的核心模块全局对象中的process进程模块，其实nextTick和我目前使用的vue中的nextTick方法有些异曲同工之妙，于是上网搜整理了一些资料，详细的了解下nextTick到底该如何理解并且在实际项目中哪些地方会用到这个方法。\n\nNode.js是单线程的，基于事件循环，非阻塞IO的。事件循环中使用一个事件队列，在每个时间点上，系统只会处理一个事件，即使电脑有多个CPU核心，也无法同时并行的处理多个事件。因此，node.js适合处理I／O型的应用，不适合那种CPU运算密集型的应用。在I／O型的应用中，给每一个输入输出定义一个回调函数，node.js会自动将其加入到事件轮询的处理队列里，当I／O操作完成后，这个回调函数会被触发，系统会继续处理其他的请求。\n\n<!-- more -->\n\n## 理解\n\n在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的**下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时**；与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。\n\n在这种处理模式下，process.nextTick()的意思就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行。我们来看一个例子。例子中有一个foo()，你想在下一个时间点上调用他，可以这么做：\n\n``` javascript\nfunction foo() {\n    console.error('foo');\n}\nprocess.nextTick(foo);\nconsole.error('bar');\n```\n\n运行上面的代码，你从下面终端打印的信息会看到，\"bar\"的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。\n\n``` javascript\nbar\nfoo\n```\n\n你也可以使用setTimeout()函数来达到貌似同样的执行效果：\n\n``` javascript\nsetTimeout(foo, 0);\nconsole.log('bar');\n```\n\n但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时。process.nextTick()定义的调用会创建一个新的队列。在当前的队列里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须结束队列操作。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的队列。\n\n## 具体使用场景\n#### 在多个事件里交叉执行CPU运算密集型的任务\n\n在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。\n\n但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。\n\n``` javascript\nvar http = require('http');\nfunction compute() {\n    // performs complicated calculations continuously\n   // ...\n    process.nextTick(compute);\n}\nhttp.createServer(function(req, res) {\n     res.writeHead(200, {'Content-Type': 'text/plain'});\n     res.end('Hello World');\n}).listen(5000, '127.0.0.1');\ncompute();\n```\n\n在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。\n\n当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。\n\n#### 保持回调函数异步执行的原则\n\n当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则：\n\n``` javascript\nfunction maybeSync(arg, cb) {\n  if (arg) {\n    cb();\n    return;\n  }\n\n  fs.stat('file', cb);\n}\nmaybeSync(true, function() {\n  foo();\n});\nbar();\n```\n这段代码不明确的地方是, 我们不清楚foo()和bar()哪个会被先调用，使用nextTick将回调函数变成异步的。这样写更好：\n\n``` javascript\nfunction definitelyAsync(arg, cb) {\n  if (arg) {\n    process.nextTick(cb);\n    return;\n  }\n\t\n  fs.stat('file', cb);\n}\n```\t\n\n#### 用在事件触发过程中\n\n来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写：\n\n``` javascript\nvar EventEmitter = require('events').EventEmitter;\nfunction StreamLibrary(resourceName) { \n    this.emit('start');\n    // read from the file, and for every chunk read, do:       \n    this.emit('data', chunkRead);      \n}\nStreamLibrary.prototype.__proto__ = EventEmitter.prototype;   // inherit from EventEmitter\n```\t\n\n下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件：\n\n``` javascript\nvar stream = new StreamLibrary('fooResource');\nstream.on('start', function() {\n    console.log('Reading has started');\n});\nstream.on('data', function(chunk) {\n    console.log('Received: ' + chunk);\n});\n```\t\n\n但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本：\n\n``` javascript\nfunction StreamLibrary(resourceName) {\n    var self = this;\n    process.nextTick(function() {\n        self.emit('start');\n    });\n    // read from the file, and for every chunk read, do:       \n    this.emit('data', chunkRead);\n}\n```\t","slug":"2017-04-04","published":1,"updated":"2017-09-02T13:01:17.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36q80000lmlda0btjmke","content":"<p>今天重新温习了下nodejs开发指南中的核心模块全局对象中的process进程模块，其实nextTick和我目前使用的vue中的nextTick方法有些异曲同工之妙，于是上网搜整理了一些资料，详细的了解下nextTick到底该如何理解并且在实际项目中哪些地方会用到这个方法。</p>\n<p>Node.js是单线程的，基于事件循环，非阻塞IO的。事件循环中使用一个事件队列，在每个时间点上，系统只会处理一个事件，即使电脑有多个CPU核心，也无法同时并行的处理多个事件。因此，node.js适合处理I／O型的应用，不适合那种CPU运算密集型的应用。在I／O型的应用中，给每一个输入输出定义一个回调函数，node.js会自动将其加入到事件轮询的处理队列里，当I／O操作完成后，这个回调函数会被触发，系统会继续处理其他的请求。</p>\n<a id=\"more\"></a>\n<h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的<strong>下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时</strong>；与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。</p>\n<p>在这种处理模式下，process.nextTick()的意思就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行。我们来看一个例子。例子中有一个foo()，你想在下一个时间点上调用他，可以这么做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">'foo'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">process.nextTick(foo);</div><div class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"string\">'bar'</span>);</div></pre></td></tr></table></figure>\n<p>运行上面的代码，你从下面终端打印的信息会看到，”bar”的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">bar</div><div class=\"line\">foo</div></pre></td></tr></table></figure>\n<p>你也可以使用setTimeout()函数来达到貌似同样的执行效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(foo, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>);</div></pre></td></tr></table></figure>\n<p>但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时。process.nextTick()定义的调用会创建一个新的队列。在当前的队列里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须结束队列操作。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的队列。</p>\n<h2 id=\"具体使用场景\"><a href=\"#具体使用场景\" class=\"headerlink\" title=\"具体使用场景\"></a>具体使用场景</h2><h4 id=\"在多个事件里交叉执行CPU运算密集型的任务\"><a href=\"#在多个事件里交叉执行CPU运算密集型的任务\" class=\"headerlink\" title=\"在多个事件里交叉执行CPU运算密集型的任务\"></a>在多个事件里交叉执行CPU运算密集型的任务</h4><p>在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。</p>\n<p>但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compute</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// performs complicated calculations continuously</span></div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">    process.nextTick(compute);</div><div class=\"line\">&#125;</div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">     res.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span>&#125;);</div><div class=\"line\">     res.end(<span class=\"string\">'Hello World'</span>);</div><div class=\"line\">&#125;).listen(<span class=\"number\">5000</span>, <span class=\"string\">'127.0.0.1'</span>);</div><div class=\"line\">compute();</div></pre></td></tr></table></figure>\n<p>在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。</p>\n<p>当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。</p>\n<h4 id=\"保持回调函数异步执行的原则\"><a href=\"#保持回调函数异步执行的原则\" class=\"headerlink\" title=\"保持回调函数异步执行的原则\"></a>保持回调函数异步执行的原则</h4><p>当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">maybeSync</span>(<span class=\"params\">arg, cb</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (arg) &#123;</div><div class=\"line\">    cb();</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  fs.stat(<span class=\"string\">'file'</span>, cb);</div><div class=\"line\">&#125;</div><div class=\"line\">maybeSync(<span class=\"literal\">true</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  foo();</div><div class=\"line\">&#125;);</div><div class=\"line\">bar();</div></pre></td></tr></table></figure>\n<p>这段代码不明确的地方是, 我们不清楚foo()和bar()哪个会被先调用，使用nextTick将回调函数变成异步的。这样写更好：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">definitelyAsync</span>(<span class=\"params\">arg, cb</span>) </span>{\n  <span class=\"keyword\">if</span> (arg) {\n    process.nextTick(cb);\n    <span class=\"keyword\">return</span>;\n  }\n\n  fs.stat(<span class=\"string\">'file'</span>, cb);\n}\n</code></pre>\n<h4 id=\"用在事件触发过程中\"><a href=\"#用在事件触发过程中\" class=\"headerlink\" title=\"用在事件触发过程中\"></a>用在事件触发过程中</h4><p>来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写：</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">var</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>).EventEmitter;\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">StreamLibrary</span>(<span class=\"params\">resourceName</span>) </span>{ \n    <span class=\"keyword\">this</span>.emit(<span class=\"string\">'start'</span>);\n    <span class=\"comment\">// read from the file, and for every chunk read, do:       </span>\n    <span class=\"keyword\">this</span>.emit(<span class=\"string\">'data'</span>, chunkRead);      \n}\nStreamLibrary.prototype.__proto__ = EventEmitter.prototype;   <span class=\"comment\">// inherit from EventEmitter</span>\n</code></pre>\n<p>下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件：</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">var</span> stream = <span class=\"keyword\">new</span> StreamLibrary(<span class=\"string\">'fooResource'</span>);\nstream.on(<span class=\"string\">'start'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Reading has started'</span>);\n});\nstream.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk</span>) </span>{\n    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Received: '</span> + chunk);\n});\n</code></pre>\n<p>但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">StreamLibrary</span>(<span class=\"params\">resourceName</span>) </span>{\n    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;\n    process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n        self.emit(<span class=\"string\">'start'</span>);\n    });\n    <span class=\"comment\">// read from the file, and for every chunk read, do:       </span>\n    <span class=\"keyword\">this</span>.emit(<span class=\"string\">'data'</span>, chunkRead);\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>今天重新温习了下nodejs开发指南中的核心模块全局对象中的process进程模块，其实nextTick和我目前使用的vue中的nextTick方法有些异曲同工之妙，于是上网搜整理了一些资料，详细的了解下nextTick到底该如何理解并且在实际项目中哪些地方会用到这个方法。</p>\n<p>Node.js是单线程的，基于事件循环，非阻塞IO的。事件循环中使用一个事件队列，在每个时间点上，系统只会处理一个事件，即使电脑有多个CPU核心，也无法同时并行的处理多个事件。因此，node.js适合处理I／O型的应用，不适合那种CPU运算密集型的应用。在I／O型的应用中，给每一个输入输出定义一个回调函数，node.js会自动将其加入到事件轮询的处理队列里，当I／O操作完成后，这个回调函数会被触发，系统会继续处理其他的请求。</p>","more":"<h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的<strong>下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时</strong>；与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。</p>\n<p>在这种处理模式下，process.nextTick()的意思就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行。我们来看一个例子。例子中有一个foo()，你想在下一个时间点上调用他，可以这么做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">'foo'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">process.nextTick(foo);</div><div class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"string\">'bar'</span>);</div></pre></td></tr></table></figure>\n<p>运行上面的代码，你从下面终端打印的信息会看到，”bar”的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">bar</div><div class=\"line\">foo</div></pre></td></tr></table></figure>\n<p>你也可以使用setTimeout()函数来达到貌似同样的执行效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(foo, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>);</div></pre></td></tr></table></figure>\n<p>但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时。process.nextTick()定义的调用会创建一个新的队列。在当前的队列里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须结束队列操作。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的队列。</p>\n<h2 id=\"具体使用场景\"><a href=\"#具体使用场景\" class=\"headerlink\" title=\"具体使用场景\"></a>具体使用场景</h2><h4 id=\"在多个事件里交叉执行CPU运算密集型的任务\"><a href=\"#在多个事件里交叉执行CPU运算密集型的任务\" class=\"headerlink\" title=\"在多个事件里交叉执行CPU运算密集型的任务\"></a>在多个事件里交叉执行CPU运算密集型的任务</h4><p>在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。</p>\n<p>但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compute</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// performs complicated calculations continuously</span></div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">    process.nextTick(compute);</div><div class=\"line\">&#125;</div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">     res.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span>&#125;);</div><div class=\"line\">     res.end(<span class=\"string\">'Hello World'</span>);</div><div class=\"line\">&#125;).listen(<span class=\"number\">5000</span>, <span class=\"string\">'127.0.0.1'</span>);</div><div class=\"line\">compute();</div></pre></td></tr></table></figure>\n<p>在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。</p>\n<p>当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。</p>\n<h4 id=\"保持回调函数异步执行的原则\"><a href=\"#保持回调函数异步执行的原则\" class=\"headerlink\" title=\"保持回调函数异步执行的原则\"></a>保持回调函数异步执行的原则</h4><p>当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">maybeSync</span>(<span class=\"params\">arg, cb</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (arg) &#123;</div><div class=\"line\">    cb();</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  fs.stat(<span class=\"string\">'file'</span>, cb);</div><div class=\"line\">&#125;</div><div class=\"line\">maybeSync(<span class=\"literal\">true</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  foo();</div><div class=\"line\">&#125;);</div><div class=\"line\">bar();</div></pre></td></tr></table></figure>\n<p>这段代码不明确的地方是, 我们不清楚foo()和bar()哪个会被先调用，使用nextTick将回调函数变成异步的。这样写更好：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">definitelyAsync</span>(<span class=\"params\">arg, cb</span>) </span>{\n  <span class=\"keyword\">if</span> (arg) {\n    process.nextTick(cb);\n    <span class=\"keyword\">return</span>;\n  }\n\n  fs.stat(<span class=\"string\">'file'</span>, cb);\n}\n</code></pre>\n<h4 id=\"用在事件触发过程中\"><a href=\"#用在事件触发过程中\" class=\"headerlink\" title=\"用在事件触发过程中\"></a>用在事件触发过程中</h4><p>来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写：</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">var</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>).EventEmitter;\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">StreamLibrary</span>(<span class=\"params\">resourceName</span>) </span>{ \n    <span class=\"keyword\">this</span>.emit(<span class=\"string\">'start'</span>);\n    <span class=\"comment\">// read from the file, and for every chunk read, do:       </span>\n    <span class=\"keyword\">this</span>.emit(<span class=\"string\">'data'</span>, chunkRead);      \n}\nStreamLibrary.prototype.__proto__ = EventEmitter.prototype;   <span class=\"comment\">// inherit from EventEmitter</span>\n</code></pre>\n<p>下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件：</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">var</span> stream = <span class=\"keyword\">new</span> StreamLibrary(<span class=\"string\">'fooResource'</span>);\nstream.on(<span class=\"string\">'start'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Reading has started'</span>);\n});\nstream.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk</span>) </span>{\n    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Received: '</span> + chunk);\n});\n</code></pre>\n<p>但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">StreamLibrary</span>(<span class=\"params\">resourceName</span>) </span>{\n    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;\n    process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n        self.emit(<span class=\"string\">'start'</span>);\n    });\n    <span class=\"comment\">// read from the file, and for every chunk read, do:       </span>\n    <span class=\"keyword\">this</span>.emit(<span class=\"string\">'data'</span>, chunkRead);\n}\n</code></pre>"},{"title":"详解javascript对象方法Object.assign()痛点","comments":1,"date":"2017-04-11T13:55:28.000Z","_content":"\n## 函数原型\n\n首先看一下函数的定义：\n函数参数为一个目标对象（该对象作为最终的返回值）,源对象(此处可以为任意多个)。通过调用该函数可以拷贝所有可被枚举的自有属性值到目标对象中。\n\nObject.assign(target, ...sources)\n\n这里我们需要强调的三点是：\n\n1. 可被枚举的属性\n1. 自有属性\n1. string或者Symbol类型是可以被直接分配的\n\n拷贝过程中将调用源对象的getter方法，并在target对象上使用setter方法实现目标对象的拷贝。\n\n<!-- more -->\n\n## 函数实例\n\n这里我们通过几个MDN上的例子来介绍一下使用方法：\n\n### 实例一\n\n我们参考上面的原型函数说明即可知道其最开始的o1因为设置为target，则调用其setter方法设置了其他对象的属性到自身。\n\n\n``` javascript\n\nvar o1 = { a: 1 };\nvar o2 = { b: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign(o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.\n\n```\n\n### 实例二\n\n我们自定义了一些对象，这些对象有一些包含了不可枚举的属性,另外注意使用 Object.defineProperty 初始化的对象默认是不可枚举的属性。对于可枚举的对象我们可以直接使用Object.keys()获得,或者使用for-in循环遍历出来.\n\n对于不可枚举的属性，使用Object.assign的时候将被自动忽略。\n\n\n``` javascript\n\nvar obj = Object.create({ foo: 1 }, { // foo is an inherit property.\n  bar: {\n    value: 2  // bar is a non-enumerable property.\n  },\n  baz: {\n    value: 3,\n    enumerable: true  // baz is an own enumerable property.\n  }\n});\n\nvar copy = Object.assign({}, obj);\nconsole.log(copy); // { baz: 3 } \n\n``` \n\n### 实例三\n\n对于只读的属性，当分配新的对象覆盖他的时候，将抛出异常:\n\n\n``` javascript\n\nvar target = Object.defineProperty({}, 'foo', {\n  value: 1,\n  writable: false\n}); \n\nObject.assign(target, { bar: 2 })\n\n//{bar: 2, foo: 1}\n\nObject.assign(target, { foo: 2 })\n//Uncaught TypeError: Cannot assign to read only property 'foo' of object '#<Object>'(…)\n\n``` \n\n\n## Polyfill\n\n这里我们简单的看下如何实现es5版本的Object.assign：\n\n实现步骤：\n\n判断是否原生支持该函数，如果不存在的话创建一个立即执行函数，该函数将创建一个assign函数绑定到Object上。\n\n判断参数是否正确(目的对象不能为空，我们可以直接设置{}传递进去,但必须设置该值)\n使用Object在原有的对象基础上返回该对象，并保存为out使用for…in循环遍历出所有的可枚举的自有对象。并复制给新的目标对象(hasOwnProperty返回非原型链上的属性)源码如下：\n\n\n``` javascript\n\n if (typeof Object.assign != 'function') {\n  (function () {\n    Object.assign = function (target) {\n     'use strict';\n     if (target === undefined || target === null) {\n       throw new TypeError('Cannot convert undefined or null to object');\n     }\n    \n     var output = Object(target);\n     for (var index = 1; index < arguments.length; index++) {\n       var source = arguments[index];\n       if (source !== undefined && source !== null) {\n         for (var nextKey in source) {\n           if (source.hasOwnProperty(nextKey)) {\n             output[nextKey] = source[nextKey];\n           }\n         }\n       }\n     }\n     return output;\n    };\n})();\n}\n\n``` \n\n## 扩展内容\n\n### 深度拷贝和前拷贝\n\njavascript中存储对象都是存地址的，所以浅拷贝是都指向同一块内存区块，而深拷贝则是另外开辟了一块区域，下面实例也可以看出这一点：\n\n\n``` javascript\n\n// 浅拷贝\nconst a = {t: 1, p: 'gg'};\nconst b = a;\nb.t = 3;\nconsole.log(a); // {t: 3, p: 'gg'}\nconsole.log(b); // {t: 3, p: 'gg'}\n\n//深拷贝\nconst c = {t: 1, p: 'gg'};\nconst d = deepCopy(c);\nd.t = 3;\nconsole.log(c); // {t: 1, p: 'gg'}\nconsole.log(d); // {t: 3, p: 'gg'}\n\n``` \n\n可以明显看出，浅拷贝在改变其中一个值时，会导致其他也一起改变，而深拷贝不会。\n\n我需要的是深拷贝的方法，然后发现原来es6 中有Object.assign() 这个方法，感觉可以拿来用了。 \n贴一下两个官方例子：\n\n\n``` javascript\n\n// Cloning an object\nvar obj = { a: 1 };\nvar copy = Object.assign({}, obj);\nconsole.log(copy); // { a: 1 }\n\n// Merging objects\nvar o1 = { a: 1 };\nvar o2 = { b: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign(o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.\n\n```\n\n是不是很完美，又可以clone又可以merge。在我这种情况下，我觉得我的代码量又可以减少了，比如：\n\n\n``` javascript\n\nconst defaultOpt = {\n    title: 'hello', \n    name: 'oo', \n    type: 'line'\n};\n// 原来可能需要这样\nconst opt1 = deepCopy(a);\nopt1.title = 'opt1';\nopt1.type = 'bar';\nopt1.extra = 'extra'; // 额外增加配置\n// 现在只要这样\nconst opt2 = Object.assign({}, a, {\n    title: 'opt2', \n    type: 'bar', \n    extra: 'extra'\n});\n\n```\n\n不过，很快，问题出现了，那就是merge和我想象的不一样且看例子：\n\n\n``` javascript\n\nconst defaultOpt = {\n    title: {\n        text: 'hello world',\n        subtext: 'It\\'s my world.'\n    }\n};\n\nconst opt = Object.assign({}, defaultOpt, {\n    title: {\n        subtext: 'Yes, your world.'\n    }\n});\n\nconsole.log(opt);\n\n// 预期结果\n{\n    title: {\n        text: 'hello world',\n        subtext: 'Yes, your world.'\n    }\n}\n// 实际结果\n{\n    title: {\n        subtext: 'Yes, your world.'\n    }\n}\n\n```\n\n原本想的是它只会覆盖subtext ，然而其实它直接覆盖了整个title ，这个让我比较郁闷，相当于它只merge根属性，下面的就不做处理了。 \n代码只能重构成相对麻烦一点的：\n\n``` javascript\n\nconst defaultOpt = {\n    title: {\n        text: 'hello world',\n        subtext: 'It\\'s my world.'\n    }\n};\n\nconst opt = Object.assign({}, defaultOpt);\nopt.title.subtext = 'Yes, your world.';\n\nconsole.log(opt);\n// 结果正常\n{\n    title: {\n        text: 'hello world',\n        subtext: 'Yes, your world.'\n    }\n}\n```\n\n这样用虽然麻烦一点，但是也还好，可以用了。不过。。。很快，又出现问题了，如下：\n\n``` javascript\nconst defaultOpt = {\n    title: {\n        text: 'hello world',\n        subtext: 'It\\'s my world.'\n    } \n};\n\nconst opt1 = Object.assign({}, defaultOpt);\nconst opt2 = Object.assign({}, defaultOpt);\nopt2.title.subtext = 'Yes, your world.';\n\nconsole.log('opt1:');\nconsole.log(opt1);\nconsole.log('opt2:');\nconsole.log(opt2);\n\n// 结果\nopt1:\n{\n    title: {\n        text: 'hello world',\n        subtext: 'Yes, your world.'\n    }\n}\nopt2:\n{\n    title: {\n        text: 'hello world',\n        subtext: 'Yes, your world.'\n    }\n}\n```\n\n上面结果发现两个配置变得一模一样，而其实我们并没有去更改opt1 的subtext ，只是改了opt2 的。 \n这说明一点：在title 这一层只是简单的浅拷贝 ，而没有继续深入的深拷贝。 \n\n**Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。用的时候，还是要注意这个问题的。**不过github上已经有很多好的解决方案，比如deep-merge 通过递归的方式逐层的去调用assign函数。Lodash提供了深拷贝的api方法，其实熟悉jquery的同学，extend这个api就能直接完美解决深拷贝的问题。\n\n\n#### 附\n\n发现一个可以简单实现深拷贝的方法，当然，有一定限制，如下：\n\n``` bash\nconst obj1 = JSON.parse(JSON.stringify(obj));\n``` \n\n思路就是将一个对象转成json字符串，然后又将字符串转回对象。但是在使用中还是会存在问题，进过测试会把function替换掉，使用的时候还得注意。","source":"_posts/2017-04-11.md","raw":"---\ntitle: 详解javascript对象方法Object.assign()痛点\ncomments: true\ndate: 2017-04-11 21:55:28\ntags: \n    - 'javascript'\n    - 'es6'\n---\n\n## 函数原型\n\n首先看一下函数的定义：\n函数参数为一个目标对象（该对象作为最终的返回值）,源对象(此处可以为任意多个)。通过调用该函数可以拷贝所有可被枚举的自有属性值到目标对象中。\n\nObject.assign(target, ...sources)\n\n这里我们需要强调的三点是：\n\n1. 可被枚举的属性\n1. 自有属性\n1. string或者Symbol类型是可以被直接分配的\n\n拷贝过程中将调用源对象的getter方法，并在target对象上使用setter方法实现目标对象的拷贝。\n\n<!-- more -->\n\n## 函数实例\n\n这里我们通过几个MDN上的例子来介绍一下使用方法：\n\n### 实例一\n\n我们参考上面的原型函数说明即可知道其最开始的o1因为设置为target，则调用其setter方法设置了其他对象的属性到自身。\n\n\n``` javascript\n\nvar o1 = { a: 1 };\nvar o2 = { b: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign(o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.\n\n```\n\n### 实例二\n\n我们自定义了一些对象，这些对象有一些包含了不可枚举的属性,另外注意使用 Object.defineProperty 初始化的对象默认是不可枚举的属性。对于可枚举的对象我们可以直接使用Object.keys()获得,或者使用for-in循环遍历出来.\n\n对于不可枚举的属性，使用Object.assign的时候将被自动忽略。\n\n\n``` javascript\n\nvar obj = Object.create({ foo: 1 }, { // foo is an inherit property.\n  bar: {\n    value: 2  // bar is a non-enumerable property.\n  },\n  baz: {\n    value: 3,\n    enumerable: true  // baz is an own enumerable property.\n  }\n});\n\nvar copy = Object.assign({}, obj);\nconsole.log(copy); // { baz: 3 } \n\n``` \n\n### 实例三\n\n对于只读的属性，当分配新的对象覆盖他的时候，将抛出异常:\n\n\n``` javascript\n\nvar target = Object.defineProperty({}, 'foo', {\n  value: 1,\n  writable: false\n}); \n\nObject.assign(target, { bar: 2 })\n\n//{bar: 2, foo: 1}\n\nObject.assign(target, { foo: 2 })\n//Uncaught TypeError: Cannot assign to read only property 'foo' of object '#<Object>'(…)\n\n``` \n\n\n## Polyfill\n\n这里我们简单的看下如何实现es5版本的Object.assign：\n\n实现步骤：\n\n判断是否原生支持该函数，如果不存在的话创建一个立即执行函数，该函数将创建一个assign函数绑定到Object上。\n\n判断参数是否正确(目的对象不能为空，我们可以直接设置{}传递进去,但必须设置该值)\n使用Object在原有的对象基础上返回该对象，并保存为out使用for…in循环遍历出所有的可枚举的自有对象。并复制给新的目标对象(hasOwnProperty返回非原型链上的属性)源码如下：\n\n\n``` javascript\n\n if (typeof Object.assign != 'function') {\n  (function () {\n    Object.assign = function (target) {\n     'use strict';\n     if (target === undefined || target === null) {\n       throw new TypeError('Cannot convert undefined or null to object');\n     }\n    \n     var output = Object(target);\n     for (var index = 1; index < arguments.length; index++) {\n       var source = arguments[index];\n       if (source !== undefined && source !== null) {\n         for (var nextKey in source) {\n           if (source.hasOwnProperty(nextKey)) {\n             output[nextKey] = source[nextKey];\n           }\n         }\n       }\n     }\n     return output;\n    };\n})();\n}\n\n``` \n\n## 扩展内容\n\n### 深度拷贝和前拷贝\n\njavascript中存储对象都是存地址的，所以浅拷贝是都指向同一块内存区块，而深拷贝则是另外开辟了一块区域，下面实例也可以看出这一点：\n\n\n``` javascript\n\n// 浅拷贝\nconst a = {t: 1, p: 'gg'};\nconst b = a;\nb.t = 3;\nconsole.log(a); // {t: 3, p: 'gg'}\nconsole.log(b); // {t: 3, p: 'gg'}\n\n//深拷贝\nconst c = {t: 1, p: 'gg'};\nconst d = deepCopy(c);\nd.t = 3;\nconsole.log(c); // {t: 1, p: 'gg'}\nconsole.log(d); // {t: 3, p: 'gg'}\n\n``` \n\n可以明显看出，浅拷贝在改变其中一个值时，会导致其他也一起改变，而深拷贝不会。\n\n我需要的是深拷贝的方法，然后发现原来es6 中有Object.assign() 这个方法，感觉可以拿来用了。 \n贴一下两个官方例子：\n\n\n``` javascript\n\n// Cloning an object\nvar obj = { a: 1 };\nvar copy = Object.assign({}, obj);\nconsole.log(copy); // { a: 1 }\n\n// Merging objects\nvar o1 = { a: 1 };\nvar o2 = { b: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign(o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.\n\n```\n\n是不是很完美，又可以clone又可以merge。在我这种情况下，我觉得我的代码量又可以减少了，比如：\n\n\n``` javascript\n\nconst defaultOpt = {\n    title: 'hello', \n    name: 'oo', \n    type: 'line'\n};\n// 原来可能需要这样\nconst opt1 = deepCopy(a);\nopt1.title = 'opt1';\nopt1.type = 'bar';\nopt1.extra = 'extra'; // 额外增加配置\n// 现在只要这样\nconst opt2 = Object.assign({}, a, {\n    title: 'opt2', \n    type: 'bar', \n    extra: 'extra'\n});\n\n```\n\n不过，很快，问题出现了，那就是merge和我想象的不一样且看例子：\n\n\n``` javascript\n\nconst defaultOpt = {\n    title: {\n        text: 'hello world',\n        subtext: 'It\\'s my world.'\n    }\n};\n\nconst opt = Object.assign({}, defaultOpt, {\n    title: {\n        subtext: 'Yes, your world.'\n    }\n});\n\nconsole.log(opt);\n\n// 预期结果\n{\n    title: {\n        text: 'hello world',\n        subtext: 'Yes, your world.'\n    }\n}\n// 实际结果\n{\n    title: {\n        subtext: 'Yes, your world.'\n    }\n}\n\n```\n\n原本想的是它只会覆盖subtext ，然而其实它直接覆盖了整个title ，这个让我比较郁闷，相当于它只merge根属性，下面的就不做处理了。 \n代码只能重构成相对麻烦一点的：\n\n``` javascript\n\nconst defaultOpt = {\n    title: {\n        text: 'hello world',\n        subtext: 'It\\'s my world.'\n    }\n};\n\nconst opt = Object.assign({}, defaultOpt);\nopt.title.subtext = 'Yes, your world.';\n\nconsole.log(opt);\n// 结果正常\n{\n    title: {\n        text: 'hello world',\n        subtext: 'Yes, your world.'\n    }\n}\n```\n\n这样用虽然麻烦一点，但是也还好，可以用了。不过。。。很快，又出现问题了，如下：\n\n``` javascript\nconst defaultOpt = {\n    title: {\n        text: 'hello world',\n        subtext: 'It\\'s my world.'\n    } \n};\n\nconst opt1 = Object.assign({}, defaultOpt);\nconst opt2 = Object.assign({}, defaultOpt);\nopt2.title.subtext = 'Yes, your world.';\n\nconsole.log('opt1:');\nconsole.log(opt1);\nconsole.log('opt2:');\nconsole.log(opt2);\n\n// 结果\nopt1:\n{\n    title: {\n        text: 'hello world',\n        subtext: 'Yes, your world.'\n    }\n}\nopt2:\n{\n    title: {\n        text: 'hello world',\n        subtext: 'Yes, your world.'\n    }\n}\n```\n\n上面结果发现两个配置变得一模一样，而其实我们并没有去更改opt1 的subtext ，只是改了opt2 的。 \n这说明一点：在title 这一层只是简单的浅拷贝 ，而没有继续深入的深拷贝。 \n\n**Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。用的时候，还是要注意这个问题的。**不过github上已经有很多好的解决方案，比如deep-merge 通过递归的方式逐层的去调用assign函数。Lodash提供了深拷贝的api方法，其实熟悉jquery的同学，extend这个api就能直接完美解决深拷贝的问题。\n\n\n#### 附\n\n发现一个可以简单实现深拷贝的方法，当然，有一定限制，如下：\n\n``` bash\nconst obj1 = JSON.parse(JSON.stringify(obj));\n``` \n\n思路就是将一个对象转成json字符串，然后又将字符串转回对象。但是在使用中还是会存在问题，进过测试会把function替换掉，使用的时候还得注意。","slug":"2017-04-11","published":1,"updated":"2017-08-26T12:58:33.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36qf0002lmldqax0zclp","content":"<h2 id=\"函数原型\"><a href=\"#函数原型\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h2><p>首先看一下函数的定义：<br>函数参数为一个目标对象（该对象作为最终的返回值）,源对象(此处可以为任意多个)。通过调用该函数可以拷贝所有可被枚举的自有属性值到目标对象中。</p>\n<p>Object.assign(target, …sources)</p>\n<p>这里我们需要强调的三点是：</p>\n<ol>\n<li>可被枚举的属性</li>\n<li>自有属性</li>\n<li>string或者Symbol类型是可以被直接分配的</li>\n</ol>\n<p>拷贝过程中将调用源对象的getter方法，并在target对象上使用setter方法实现目标对象的拷贝。</p>\n<a id=\"more\"></a>\n<h2 id=\"函数实例\"><a href=\"#函数实例\" class=\"headerlink\" title=\"函数实例\"></a>函数实例</h2><p>这里我们通过几个MDN上的例子来介绍一下使用方法：</p>\n<h3 id=\"实例一\"><a href=\"#实例一\" class=\"headerlink\" title=\"实例一\"></a>实例一</h3><p>我们参考上面的原型函数说明即可知道其最开始的o1因为设置为target，则调用其setter方法设置了其他对象的属性到自身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o1 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> o2 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> o3 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">3</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.assign(o1, o2, o3);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; a: 1, b: 2, c: 3 &#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(o1);  <span class=\"comment\">// &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed.</span></div></pre></td></tr></table></figure>\n<h3 id=\"实例二\"><a href=\"#实例二\" class=\"headerlink\" title=\"实例二\"></a>实例二</h3><p>我们自定义了一些对象，这些对象有一些包含了不可枚举的属性,另外注意使用 Object.defineProperty 初始化的对象默认是不可枚举的属性。对于可枚举的对象我们可以直接使用Object.keys()获得,或者使用for-in循环遍历出来.</p>\n<p>对于不可枚举的属性，使用Object.assign的时候将被自动忽略。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(&#123; <span class=\"attr\">foo</span>: <span class=\"number\">1</span> &#125;, &#123; <span class=\"comment\">// foo is an inherit property.</span></div><div class=\"line\">  bar: &#123;</div><div class=\"line\">    value: <span class=\"number\">2</span>  <span class=\"comment\">// bar is a non-enumerable property.</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  baz: &#123;</div><div class=\"line\">    value: <span class=\"number\">3</span>,</div><div class=\"line\">    enumerable: <span class=\"literal\">true</span>  <span class=\"comment\">// baz is an own enumerable property.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> copy = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, obj);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(copy); <span class=\"comment\">// &#123; baz: 3 &#125; </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">### 实例三</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">对于只读的属性，当分配新的对象覆盖他的时候，将抛出异常:</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> javascript</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> target = <span class=\"built_in\">Object</span>.defineProperty(&#123;&#125;, <span class=\"string\">'foo'</span>, &#123;</div><div class=\"line\">  value: <span class=\"number\">1</span>,</div><div class=\"line\">  writable: <span class=\"literal\">false</span></div><div class=\"line\">&#125;); </div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(target, &#123; <span class=\"attr\">bar</span>: <span class=\"number\">2</span> &#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//&#123;bar: 2, foo: 1&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(target, &#123; <span class=\"attr\">foo</span>: <span class=\"number\">2</span> &#125;)</div><div class=\"line\"><span class=\"comment\">//Uncaught TypeError: Cannot assign to read only property 'foo' of object '#&lt;Object&gt;'(…)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">## Polyfill</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">这里我们简单的看下如何实现es5版本的Object.assign：</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">实现步骤：</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">判断是否原生支持该函数，如果不存在的话创建一个立即执行函数，该函数将创建一个assign函数绑定到Object上。</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">判断参数是否正确(目的对象不能为空，我们可以直接设置&#123;&#125;传递进去,但必须设置该值)</span></div><div class=\"line\"><span class=\"string\">使用Object在原有的对象基础上返回该对象，并保存为out使用for…in循环遍历出所有的可枚举的自有对象。并复制给新的目标对象(hasOwnProperty返回非原型链上的属性)源码如下：</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> javascript</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>.assign != <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">Object</span>.assign = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target</span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">     'use strict'</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (target === <span class=\"literal\">undefined</span> || target === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Cannot convert undefined or null to object'</span>);</div><div class=\"line\">     &#125;</div><div class=\"line\">    </div><div class=\"line\">     <span class=\"keyword\">var</span> output = <span class=\"built_in\">Object</span>(target);</div><div class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">1</span>; index &lt; <span class=\"built_in\">arguments</span>.length; index++) &#123;</div><div class=\"line\">       <span class=\"keyword\">var</span> source = <span class=\"built_in\">arguments</span>[index];</div><div class=\"line\">       <span class=\"keyword\">if</span> (source !== <span class=\"literal\">undefined</span> &amp;&amp; source !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> nextKey <span class=\"keyword\">in</span> source) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (source.hasOwnProperty(nextKey)) &#123;</div><div class=\"line\">             output[nextKey] = source[nextKey];</div><div class=\"line\">           &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> output;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;)();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">## 扩展内容</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">### 深度拷贝和前拷贝</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">javascript中存储对象都是存地址的，所以浅拷贝是都指向同一块内存区块，而深拷贝则是另外开辟了一块区域，下面实例也可以看出这一点：</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> javascript</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 浅拷贝</span></div><div class=\"line\"><span class=\"keyword\">const</span> a = &#123;<span class=\"attr\">t</span>: <span class=\"number\">1</span>, <span class=\"attr\">p</span>: <span class=\"string\">'gg'</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> b = a;</div><div class=\"line\">b.t = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// &#123;t: 3, p: 'gg'&#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// &#123;t: 3, p: 'gg'&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//深拷贝</span></div><div class=\"line\"><span class=\"keyword\">const</span> c = &#123;<span class=\"attr\">t</span>: <span class=\"number\">1</span>, <span class=\"attr\">p</span>: <span class=\"string\">'gg'</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> d = deepCopy(c);</div><div class=\"line\">d.t = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// &#123;t: 1, p: 'gg'&#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(d); <span class=\"comment\">// &#123;t: 3, p: 'gg'&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">可以明显看出，浅拷贝在改变其中一个值时，会导致其他也一起改变，而深拷贝不会。</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">我需要的是深拷贝的方法，然后发现原来es6 中有Object.assign() 这个方法，感觉可以拿来用了。 </span></div><div class=\"line\"><span class=\"string\">贴一下两个官方例子：</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> javascript</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Cloning an object</span></div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> copy = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, obj);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(copy); <span class=\"comment\">// &#123; a: 1 &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Merging objects</span></div><div class=\"line\"><span class=\"keyword\">var</span> o1 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> o2 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> o3 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">3</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.assign(o1, o2, o3);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; a: 1, b: 2, c: 3 &#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(o1);  <span class=\"comment\">// &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed.</span></div></pre></td></tr></table></figure>\n<p>是不是很完美，又可以clone又可以merge。在我这种情况下，我觉得我的代码量又可以减少了，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> defaultOpt = &#123;</div><div class=\"line\">    title: <span class=\"string\">'hello'</span>, </div><div class=\"line\">    name: <span class=\"string\">'oo'</span>, </div><div class=\"line\">    type: <span class=\"string\">'line'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 原来可能需要这样</span></div><div class=\"line\"><span class=\"keyword\">const</span> opt1 = deepCopy(a);</div><div class=\"line\">opt1.title = <span class=\"string\">'opt1'</span>;</div><div class=\"line\">opt1.type = <span class=\"string\">'bar'</span>;</div><div class=\"line\">opt1.extra = <span class=\"string\">'extra'</span>; <span class=\"comment\">// 额外增加配置</span></div><div class=\"line\"><span class=\"comment\">// 现在只要这样</span></div><div class=\"line\"><span class=\"keyword\">const</span> opt2 = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, a, &#123;</div><div class=\"line\">    title: <span class=\"string\">'opt2'</span>, </div><div class=\"line\">    type: <span class=\"string\">'bar'</span>, </div><div class=\"line\">    extra: <span class=\"string\">'extra'</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>不过，很快，问题出现了，那就是merge和我想象的不一样且看例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> defaultOpt = &#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'It\\'s my world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> opt = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, defaultOpt, &#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(opt);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 预期结果</span></div><div class=\"line\">&#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 实际结果</span></div><div class=\"line\">&#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原本想的是它只会覆盖subtext ，然而其实它直接覆盖了整个title ，这个让我比较郁闷，相当于它只merge根属性，下面的就不做处理了。<br>代码只能重构成相对麻烦一点的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> defaultOpt = &#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'It\\'s my world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> opt = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, defaultOpt);</div><div class=\"line\">opt.title.subtext = <span class=\"string\">'Yes, your world.'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(opt);</div><div class=\"line\"><span class=\"comment\">// 结果正常</span></div><div class=\"line\">&#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样用虽然麻烦一点，但是也还好，可以用了。不过。。。很快，又出现问题了，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> defaultOpt = &#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'It\\'s my world.'</span></div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> opt1 = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, defaultOpt);</div><div class=\"line\"><span class=\"keyword\">const</span> opt2 = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, defaultOpt);</div><div class=\"line\">opt2.title.subtext = <span class=\"string\">'Yes, your world.'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'opt1:'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(opt1);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'opt2:'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(opt2);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 结果</span></div><div class=\"line\">opt1:</div><div class=\"line\">&#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">opt2:</div><div class=\"line\">&#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面结果发现两个配置变得一模一样，而其实我们并没有去更改opt1 的subtext ，只是改了opt2 的。<br>这说明一点：在title 这一层只是简单的浅拷贝 ，而没有继续深入的深拷贝。 </p>\n<p><strong>Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。用的时候，还是要注意这个问题的。</strong>不过github上已经有很多好的解决方案，比如deep-merge 通过递归的方式逐层的去调用assign函数。Lodash提供了深拷贝的api方法，其实熟悉jquery的同学，extend这个api就能直接完美解决深拷贝的问题。</p>\n<h4 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h4><p>发现一个可以简单实现深拷贝的方法，当然，有一定限制，如下：</p>\n<pre><code class=\"bash\">const obj1 = JSON.parse(JSON.stringify(obj));\n</code></pre>\n<p>思路就是将一个对象转成json字符串，然后又将字符串转回对象。但是在使用中还是会存在问题，进过测试会把function替换掉，使用的时候还得注意。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"函数原型\"><a href=\"#函数原型\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h2><p>首先看一下函数的定义：<br>函数参数为一个目标对象（该对象作为最终的返回值）,源对象(此处可以为任意多个)。通过调用该函数可以拷贝所有可被枚举的自有属性值到目标对象中。</p>\n<p>Object.assign(target, …sources)</p>\n<p>这里我们需要强调的三点是：</p>\n<ol>\n<li>可被枚举的属性</li>\n<li>自有属性</li>\n<li>string或者Symbol类型是可以被直接分配的</li>\n</ol>\n<p>拷贝过程中将调用源对象的getter方法，并在target对象上使用setter方法实现目标对象的拷贝。</p>","more":"<h2 id=\"函数实例\"><a href=\"#函数实例\" class=\"headerlink\" title=\"函数实例\"></a>函数实例</h2><p>这里我们通过几个MDN上的例子来介绍一下使用方法：</p>\n<h3 id=\"实例一\"><a href=\"#实例一\" class=\"headerlink\" title=\"实例一\"></a>实例一</h3><p>我们参考上面的原型函数说明即可知道其最开始的o1因为设置为target，则调用其setter方法设置了其他对象的属性到自身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> o1 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> o2 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> o3 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">3</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.assign(o1, o2, o3);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; a: 1, b: 2, c: 3 &#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(o1);  <span class=\"comment\">// &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed.</span></div></pre></td></tr></table></figure>\n<h3 id=\"实例二\"><a href=\"#实例二\" class=\"headerlink\" title=\"实例二\"></a>实例二</h3><p>我们自定义了一些对象，这些对象有一些包含了不可枚举的属性,另外注意使用 Object.defineProperty 初始化的对象默认是不可枚举的属性。对于可枚举的对象我们可以直接使用Object.keys()获得,或者使用for-in循环遍历出来.</p>\n<p>对于不可枚举的属性，使用Object.assign的时候将被自动忽略。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(&#123; <span class=\"attr\">foo</span>: <span class=\"number\">1</span> &#125;, &#123; <span class=\"comment\">// foo is an inherit property.</span></div><div class=\"line\">  bar: &#123;</div><div class=\"line\">    value: <span class=\"number\">2</span>  <span class=\"comment\">// bar is a non-enumerable property.</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  baz: &#123;</div><div class=\"line\">    value: <span class=\"number\">3</span>,</div><div class=\"line\">    enumerable: <span class=\"literal\">true</span>  <span class=\"comment\">// baz is an own enumerable property.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> copy = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, obj);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(copy); <span class=\"comment\">// &#123; baz: 3 &#125; </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">### 实例三</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">对于只读的属性，当分配新的对象覆盖他的时候，将抛出异常:</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> javascript</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> target = <span class=\"built_in\">Object</span>.defineProperty(&#123;&#125;, <span class=\"string\">'foo'</span>, &#123;</div><div class=\"line\">  value: <span class=\"number\">1</span>,</div><div class=\"line\">  writable: <span class=\"literal\">false</span></div><div class=\"line\">&#125;); </div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(target, &#123; <span class=\"attr\">bar</span>: <span class=\"number\">2</span> &#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//&#123;bar: 2, foo: 1&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(target, &#123; <span class=\"attr\">foo</span>: <span class=\"number\">2</span> &#125;)</div><div class=\"line\"><span class=\"comment\">//Uncaught TypeError: Cannot assign to read only property 'foo' of object '#&lt;Object&gt;'(…)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">## Polyfill</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">这里我们简单的看下如何实现es5版本的Object.assign：</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">实现步骤：</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">判断是否原生支持该函数，如果不存在的话创建一个立即执行函数，该函数将创建一个assign函数绑定到Object上。</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">判断参数是否正确(目的对象不能为空，我们可以直接设置&#123;&#125;传递进去,但必须设置该值)</span></div><div class=\"line\"><span class=\"string\">使用Object在原有的对象基础上返回该对象，并保存为out使用for…in循环遍历出所有的可枚举的自有对象。并复制给新的目标对象(hasOwnProperty返回非原型链上的属性)源码如下：</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> javascript</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>.assign != <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">Object</span>.assign = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target</span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">     'use strict'</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (target === <span class=\"literal\">undefined</span> || target === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Cannot convert undefined or null to object'</span>);</div><div class=\"line\">     &#125;</div><div class=\"line\">    </div><div class=\"line\">     <span class=\"keyword\">var</span> output = <span class=\"built_in\">Object</span>(target);</div><div class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">1</span>; index &lt; <span class=\"built_in\">arguments</span>.length; index++) &#123;</div><div class=\"line\">       <span class=\"keyword\">var</span> source = <span class=\"built_in\">arguments</span>[index];</div><div class=\"line\">       <span class=\"keyword\">if</span> (source !== <span class=\"literal\">undefined</span> &amp;&amp; source !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> nextKey <span class=\"keyword\">in</span> source) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (source.hasOwnProperty(nextKey)) &#123;</div><div class=\"line\">             output[nextKey] = source[nextKey];</div><div class=\"line\">           &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> output;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;)();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">## 扩展内容</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">### 深度拷贝和前拷贝</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">javascript中存储对象都是存地址的，所以浅拷贝是都指向同一块内存区块，而深拷贝则是另外开辟了一块区域，下面实例也可以看出这一点：</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> javascript</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 浅拷贝</span></div><div class=\"line\"><span class=\"keyword\">const</span> a = &#123;<span class=\"attr\">t</span>: <span class=\"number\">1</span>, <span class=\"attr\">p</span>: <span class=\"string\">'gg'</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> b = a;</div><div class=\"line\">b.t = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// &#123;t: 3, p: 'gg'&#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// &#123;t: 3, p: 'gg'&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//深拷贝</span></div><div class=\"line\"><span class=\"keyword\">const</span> c = &#123;<span class=\"attr\">t</span>: <span class=\"number\">1</span>, <span class=\"attr\">p</span>: <span class=\"string\">'gg'</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> d = deepCopy(c);</div><div class=\"line\">d.t = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// &#123;t: 1, p: 'gg'&#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(d); <span class=\"comment\">// &#123;t: 3, p: 'gg'&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">可以明显看出，浅拷贝在改变其中一个值时，会导致其他也一起改变，而深拷贝不会。</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">我需要的是深拷贝的方法，然后发现原来es6 中有Object.assign() 这个方法，感觉可以拿来用了。 </span></div><div class=\"line\"><span class=\"string\">贴一下两个官方例子：</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> javascript</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Cloning an object</span></div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> copy = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, obj);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(copy); <span class=\"comment\">// &#123; a: 1 &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Merging objects</span></div><div class=\"line\"><span class=\"keyword\">var</span> o1 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> o2 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> o3 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">3</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.assign(o1, o2, o3);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; a: 1, b: 2, c: 3 &#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(o1);  <span class=\"comment\">// &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed.</span></div></pre></td></tr></table></figure>\n<p>是不是很完美，又可以clone又可以merge。在我这种情况下，我觉得我的代码量又可以减少了，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> defaultOpt = &#123;</div><div class=\"line\">    title: <span class=\"string\">'hello'</span>, </div><div class=\"line\">    name: <span class=\"string\">'oo'</span>, </div><div class=\"line\">    type: <span class=\"string\">'line'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 原来可能需要这样</span></div><div class=\"line\"><span class=\"keyword\">const</span> opt1 = deepCopy(a);</div><div class=\"line\">opt1.title = <span class=\"string\">'opt1'</span>;</div><div class=\"line\">opt1.type = <span class=\"string\">'bar'</span>;</div><div class=\"line\">opt1.extra = <span class=\"string\">'extra'</span>; <span class=\"comment\">// 额外增加配置</span></div><div class=\"line\"><span class=\"comment\">// 现在只要这样</span></div><div class=\"line\"><span class=\"keyword\">const</span> opt2 = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, a, &#123;</div><div class=\"line\">    title: <span class=\"string\">'opt2'</span>, </div><div class=\"line\">    type: <span class=\"string\">'bar'</span>, </div><div class=\"line\">    extra: <span class=\"string\">'extra'</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>不过，很快，问题出现了，那就是merge和我想象的不一样且看例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> defaultOpt = &#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'It\\'s my world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> opt = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, defaultOpt, &#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(opt);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 预期结果</span></div><div class=\"line\">&#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 实际结果</span></div><div class=\"line\">&#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原本想的是它只会覆盖subtext ，然而其实它直接覆盖了整个title ，这个让我比较郁闷，相当于它只merge根属性，下面的就不做处理了。<br>代码只能重构成相对麻烦一点的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> defaultOpt = &#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'It\\'s my world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> opt = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, defaultOpt);</div><div class=\"line\">opt.title.subtext = <span class=\"string\">'Yes, your world.'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(opt);</div><div class=\"line\"><span class=\"comment\">// 结果正常</span></div><div class=\"line\">&#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样用虽然麻烦一点，但是也还好，可以用了。不过。。。很快，又出现问题了，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> defaultOpt = &#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'It\\'s my world.'</span></div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> opt1 = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, defaultOpt);</div><div class=\"line\"><span class=\"keyword\">const</span> opt2 = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, defaultOpt);</div><div class=\"line\">opt2.title.subtext = <span class=\"string\">'Yes, your world.'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'opt1:'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(opt1);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'opt2:'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(opt2);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 结果</span></div><div class=\"line\">opt1:</div><div class=\"line\">&#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">opt2:</div><div class=\"line\">&#123;</div><div class=\"line\">    title: &#123;</div><div class=\"line\">        text: <span class=\"string\">'hello world'</span>,</div><div class=\"line\">        subtext: <span class=\"string\">'Yes, your world.'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面结果发现两个配置变得一模一样，而其实我们并没有去更改opt1 的subtext ，只是改了opt2 的。<br>这说明一点：在title 这一层只是简单的浅拷贝 ，而没有继续深入的深拷贝。 </p>\n<p><strong>Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。用的时候，还是要注意这个问题的。</strong>不过github上已经有很多好的解决方案，比如deep-merge 通过递归的方式逐层的去调用assign函数。Lodash提供了深拷贝的api方法，其实熟悉jquery的同学，extend这个api就能直接完美解决深拷贝的问题。</p>\n<h4 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h4><p>发现一个可以简单实现深拷贝的方法，当然，有一定限制，如下：</p>\n<pre><code class=\"bash\">const obj1 = JSON.parse(JSON.stringify(obj));\n</code></pre>\n<p>思路就是将一个对象转成json字符串，然后又将字符串转回对象。但是在使用中还是会存在问题，进过测试会把function替换掉，使用的时候还得注意。</p>"},{"title":"理解JavaScript函数式编程","comments":1,"date":"2017-04-10T14:14:43.000Z","_content":"JavaScript 函数式编程是一个存在了很久的话题，但似乎从 2016 年开始，它变得越来越火热。这可能是因为 ES6 语法对于函数式编程更为友好，也可能是因为诸如 RxJS (ReactiveX) 等函数式框架的流行。\n\n看过许多关于函数式编程的讲解，但是其中大部分是停留在理论层面，还有一些是仅针对 Haskell 等纯函数式编程语言的。而本文旨在聊一聊我眼中的函数式编程在 JavaScript 中的具体实践，之所以是 “我眼中的” 即我所说的仅代表个人观点，可能和部分 严格概念 是有冲突的。\n\n本文将略去一大堆形式化的概念介绍，重点展示在 JavaScript 中到底什么是函数式的代码、函数式代码与一般写法有什么区别、函数式的代码能给我们带来什么好处以及常见的一些函数式模型都有哪些。\n\n<!-- more -->\n\n## 函数式编程\n\n我认为函数式编程可以理解为，以函数作为主要载体的编程方式，用函数去拆解、抽象一般的表达式\n\n与命令式相比，这样做的好处在哪？主要有以下几点：\n\n1. 语义更加清晰\n1. 可复用性更高\n1. 可维护性更好\n1. 作用域局限，副作用少\n\n## 基本的函数式编程\n下面例子是一个具体的函数式体现\n\n``` javascript\n// 一般写法\nconst arr = ['apple', 'pen', 'apple-pen'];\nfor(const i in arr){\n  const c = arr[i][0];\n  arr[i] = c.toUpperCase() + arr[i].slice(1);\n}\n\nconsole.log(arr);\n\n\n// 函数式写法一\nfunction upperFirst(word) {\n  return word[0].toUpperCase() + word.slice(1);\n}\n\nfunction wordToUpperCase(arr) {\n  return arr.map(upperFirst);\n}\n\nconsole.log(wordToUpperCase(['apple', 'pen', 'apple-pen']));\n\n\n// 函数式写法二\nconsole.log(arr.map(['apple', 'pen', 'apple-pen'], word => word[0].toUpperCase() + word.slice(1)));\n\n```\n\n当情况变得更加复杂时，表达式的写法会遇到几个问题：\n\n1. 表意不明显，逐渐变得难以维护\n1. 复用性差，会产生更多的代码量\n1. 会产生很多中间变量\n\n\n函数式编程很好的解决了上述问题。首先参看 函数式写法一，它利用了函数封装性将功能做拆解（粒度不唯一），并封装为不同的函数，而再利用组合的调用达到目的。这样做使得表意清晰，易于维护、复用以及扩展。其次利用 高阶函数，Array.map 代替 for…of 做数组遍历，减少了中间变量和操作。\n\n而 函数式写法一 和 函数式写法二 之间的主要差别在于，可以考虑函数是否后续有复用的可能，如果没有，则后者更优。\n\n\n## 链式优化\n\n从上面 函数式写法二 中我们可以看出，函数式代码在写的过程中，很容易造成 横向延展，即产生多层嵌套，下面我们举个比较极端点的例子。\n\n``` javascript\n// 计算数字之和\n\n\n// 一般写法\nconsole.log(1 + 2 + 3 - 4)\n\n\n// 函数式写法\nfunction sum(a, b) {\n  return a + b;\n}\n\nfunction sub(a, b) {\n  return a - b;\n}\n\nconsole.log(sub(sum(sum(1, 2), 3), 4);\n\n``` \n\n本例仅为展示 横向延展 的比较极端的情况，随着函数的嵌套层数不断增多，导致代码的可读性大幅下降，还很容易产生错误。\n\n在这种情况下，我们可以考虑多种优化方式，比如下面的 链式优化 。\n\n``` javascript\n// 优化写法 (嗯，你没看错，这就是 lodash 的链式写法)\nconst utils = {\n  chain(a) {\n    this._temp = a;\n    return this;\n  },\n  sum(b) {\n    this._temp += b;\n    return this;\n  },\n  sub(b) {\n    this._temp -= b;\n    return this;\n  },\n  value() {\n    const _temp = this._temp;\n    this._temp = undefined;\n    return _temp;\n  }\n};\n\nconsole.log(utils.chain(1).sum(2).sum(3).sub(4).value());\n\n``` \n\n这样改写后，结构会整体变得比较清晰，而且链的每一环在做什么也可以很容易的展现出来。函数的嵌套和链式的对比还有一个很好的例子，那就是 回调函数 和 Promise 模式。\n\n``` javascript\n// 顺序请求两个接口\n\n\n// 回调函数\nimport $ from 'jquery';\n$.post('a/url/to/target', (rs) => {\n  if(rs){\n    $.post('a/url/to/another/target', (rs2) => {\n      if(rs2){\n        $.post('a/url/to/third/target');\n      }\n    });\n  }\n});\n\n\n// Promise\nimport request from 'catta';  // catta 是一个轻量级请求工具，支持 fetch,jsonp,ajax，无依赖\nrequest('a/url/to/target')\n  .then(rs => rs ? $.post('a/url/to/another/target') : Promise.reject())\n  .then(rs2 => rs2 ? $.post('a/url/to/third/target') : Promise.reject());\n``` \n\n随着回调函数嵌套层级和单层复杂度增加，它将会变得臃肿且难以维护，而 Promise 的链式结构，在高复杂度时，仍能纵向扩展，而且层次隔离很清晰。\n\n## 常见的函数式编程模型\n\n### 闭包（Closure）\n\n可以保留局部变量不被释放的代码块，被称为一个闭包\n\n闭包的概念比较抽象，相信大家都或多或少知道、用到这个特性\n\n那么闭包到底能给我们带来什么好处？\n\n先来看一下如何创建一个闭包：\n\n``` javascript\n// 创建一个闭包\nfunction makeCounter() {\n  let k = 0;\n\n  return function() {\n    return ++k;\n  };\n}\n\nconst counter = makeCounter();\n\nconsole.log(counter());  // 1\nconsole.log(counter());  // 2\n\n``` \nmakeCounter 这个函数的代码块，在返回的函数中，对局部变量 k ，进行了引用，导致局部变量无法在函数执行结束后，被系统回收掉，从而产生了闭包。而这个闭包的作用就是，“保留住“ 了局部变量，使内层函数调用时，可以重复使用该变量；而不同于全局变量，该变量只能在函数内部被引用。\n\n换句话说，闭包其实就是创造出了一些函数私有的 ”持久化变量“。\n\n所以从这个例子，我们可以总结出，闭包的创造条件是：\n\n1. 存在内、外两层函数\n1. 内层函数对外层函数的局部变量进行了引用\n\n\n###闭包的用途\n\n闭包的主要用途就是可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等等。\n\n``` javascript\n// 简单的缓存工具\n// 匿名函数创造了一个闭包\nconst cache = (function() {\n  const store = {};\n  \n  return {\n    get(key) {\n      return store[key];\n    },\n    set(key, val) {\n      store[key] = val;\n    }\n  }\n}());\n\ncache.set('a', 1);\ncache.get('a');  // 1\n\n``` \n上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。\n\n###闭包的弊端\n\n持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。\n\n##高阶函数\n\n接受或者返回一个函数的函数称为高阶函数\n\n听上去很高冷的一个词汇，但是其实我们经常用到，只是原来不知道他们的名字而已。JavaScript 语言是原生支持高阶函数的，因为 JavaScript 的函数是一等公民，它既可以作为参数又可以作为另一个函数的返回值使用。\n\n我们经常可以在 JavaScript 中见到许多原生的高阶函数，例如 Array.map , Array.reduce , Array.filter\n\n下面以 map 为例，我们看看他是如何使用的\n\n###map （映射）\n\n映射是对集合而言的，即把集合的每一项都做相同的变换，产生一个新的集合\n\nmap 作为一个高阶函数，他接受一个函数参数作为映射的逻辑\n\n``` javascript\n\n// 数组中每一项加一，组成一个新数组\n\n// 一般写法\nconst arr = [1,2,3];\nconst rs = [];\nfor(const n of arr){\n  rs.push(++n);\n}\nconsole.log(rs)\n\n\n// map改写\nconst arr = [1,2,3];\nconst rs = arr.map(n => ++n);\n\n``` \n\n上面一般写法，利用 for...of 循环的方式遍历数组会产生额外的操作，而且有改变原数组的风险\n\n而 map 函数封装了必要的操作，使我们仅需要关心映射逻辑的函数实现即可，减少了代码量，也降低了副作用产生的风险。\n\n###柯里化（Currying）\n\n给定一个函数的部分参数，生成一个接受其他参数的新函数\n\n可能不常听到这个名词，但是用过 undescore 或 lodash 的人都见过他。\n\n有一个神奇的 _.partial 函数，它就是柯里化的实现\n\n``` javascript\n// 获取目标文件对基础路径的相对路径\n\n\n// 一般写法\nconst BASE = '/path/to/base';\nconst relativePath = path.relative(BASE, '/some/path');\n\n\n// _.parical 改写\nconst BASE = '/path/to/base';\nconst relativeFromBase = _.partial(path.relative, BASE);\n\nconst relativePath = relativeFromBase('/some/path');\n``` \n通过 _.partial ，我们得到了新的函数 relativeFromBase ，这个函数在调用时就相当于调用 path.relative ，并默认将第一个参数传入 BASE ，后续传入的参数顺序后置。\n\n本例中，我们真正想完成的操作是每次获得相对于 BASE 的路径，而非相对于任何路径。柯里化可以使我们只关心函数的部分参数，使函数的用途更加清晰，调用更加简单。\n\n###组合（Composing）\n\n将多个函数的能力合并，创造一个新的函数\n\n同样你第一次见到他可能还是在 lodash 中，compose 方法（现在叫 flow）\n\n``` javascript\n// 数组中每个单词大写，做 Base64\n\n\n// 一般写法 (其中一种)\nconst arr = ['pen', 'apple', 'applypen'];\nconst rs = [];\nfor(const w of arr){\n  rs.push(btoa(w.toUpperCase()));\n}\nconsole.log(rs);\n\n\n// _.flow 改写\nconst arr = ['pen', 'apple', 'applypen'];\nconst upperAndBase64 = _.partialRight(_.map, _.flow(_.upperCase, btoa));\nconsole.log(upperAndBase64(arr));\n``` \n_.flow 将转大写和转 Base64 的函数的能力合并，生成一个新的函数。方便作为参数函数或后续复用。\n\n##自己的观点\n\n我理解的 JavaScript 函数式编程，将可以复用的功能提取出来，用函数方法来代替其实就是基本的函数编程思想，其实到最后会面临两个问题，一个是函数共用性好还是函数功能细分好，这其实都是根据自己具体需求而定的，个人认为函数功能还是细分好，这样方便维护，功能实现代码逻辑清晰。\n\n函数式编程就是书写清新的逻辑代码，其实也是一种解耦的形式罢了。","source":"_posts/2017-04-10.md","raw":"---\ntitle: 理解JavaScript函数式编程\ncomments: true\ndate: 2017-04-10 22:14:43\ntags: \n    - 'javascript'\n---\nJavaScript 函数式编程是一个存在了很久的话题，但似乎从 2016 年开始，它变得越来越火热。这可能是因为 ES6 语法对于函数式编程更为友好，也可能是因为诸如 RxJS (ReactiveX) 等函数式框架的流行。\n\n看过许多关于函数式编程的讲解，但是其中大部分是停留在理论层面，还有一些是仅针对 Haskell 等纯函数式编程语言的。而本文旨在聊一聊我眼中的函数式编程在 JavaScript 中的具体实践，之所以是 “我眼中的” 即我所说的仅代表个人观点，可能和部分 严格概念 是有冲突的。\n\n本文将略去一大堆形式化的概念介绍，重点展示在 JavaScript 中到底什么是函数式的代码、函数式代码与一般写法有什么区别、函数式的代码能给我们带来什么好处以及常见的一些函数式模型都有哪些。\n\n<!-- more -->\n\n## 函数式编程\n\n我认为函数式编程可以理解为，以函数作为主要载体的编程方式，用函数去拆解、抽象一般的表达式\n\n与命令式相比，这样做的好处在哪？主要有以下几点：\n\n1. 语义更加清晰\n1. 可复用性更高\n1. 可维护性更好\n1. 作用域局限，副作用少\n\n## 基本的函数式编程\n下面例子是一个具体的函数式体现\n\n``` javascript\n// 一般写法\nconst arr = ['apple', 'pen', 'apple-pen'];\nfor(const i in arr){\n  const c = arr[i][0];\n  arr[i] = c.toUpperCase() + arr[i].slice(1);\n}\n\nconsole.log(arr);\n\n\n// 函数式写法一\nfunction upperFirst(word) {\n  return word[0].toUpperCase() + word.slice(1);\n}\n\nfunction wordToUpperCase(arr) {\n  return arr.map(upperFirst);\n}\n\nconsole.log(wordToUpperCase(['apple', 'pen', 'apple-pen']));\n\n\n// 函数式写法二\nconsole.log(arr.map(['apple', 'pen', 'apple-pen'], word => word[0].toUpperCase() + word.slice(1)));\n\n```\n\n当情况变得更加复杂时，表达式的写法会遇到几个问题：\n\n1. 表意不明显，逐渐变得难以维护\n1. 复用性差，会产生更多的代码量\n1. 会产生很多中间变量\n\n\n函数式编程很好的解决了上述问题。首先参看 函数式写法一，它利用了函数封装性将功能做拆解（粒度不唯一），并封装为不同的函数，而再利用组合的调用达到目的。这样做使得表意清晰，易于维护、复用以及扩展。其次利用 高阶函数，Array.map 代替 for…of 做数组遍历，减少了中间变量和操作。\n\n而 函数式写法一 和 函数式写法二 之间的主要差别在于，可以考虑函数是否后续有复用的可能，如果没有，则后者更优。\n\n\n## 链式优化\n\n从上面 函数式写法二 中我们可以看出，函数式代码在写的过程中，很容易造成 横向延展，即产生多层嵌套，下面我们举个比较极端点的例子。\n\n``` javascript\n// 计算数字之和\n\n\n// 一般写法\nconsole.log(1 + 2 + 3 - 4)\n\n\n// 函数式写法\nfunction sum(a, b) {\n  return a + b;\n}\n\nfunction sub(a, b) {\n  return a - b;\n}\n\nconsole.log(sub(sum(sum(1, 2), 3), 4);\n\n``` \n\n本例仅为展示 横向延展 的比较极端的情况，随着函数的嵌套层数不断增多，导致代码的可读性大幅下降，还很容易产生错误。\n\n在这种情况下，我们可以考虑多种优化方式，比如下面的 链式优化 。\n\n``` javascript\n// 优化写法 (嗯，你没看错，这就是 lodash 的链式写法)\nconst utils = {\n  chain(a) {\n    this._temp = a;\n    return this;\n  },\n  sum(b) {\n    this._temp += b;\n    return this;\n  },\n  sub(b) {\n    this._temp -= b;\n    return this;\n  },\n  value() {\n    const _temp = this._temp;\n    this._temp = undefined;\n    return _temp;\n  }\n};\n\nconsole.log(utils.chain(1).sum(2).sum(3).sub(4).value());\n\n``` \n\n这样改写后，结构会整体变得比较清晰，而且链的每一环在做什么也可以很容易的展现出来。函数的嵌套和链式的对比还有一个很好的例子，那就是 回调函数 和 Promise 模式。\n\n``` javascript\n// 顺序请求两个接口\n\n\n// 回调函数\nimport $ from 'jquery';\n$.post('a/url/to/target', (rs) => {\n  if(rs){\n    $.post('a/url/to/another/target', (rs2) => {\n      if(rs2){\n        $.post('a/url/to/third/target');\n      }\n    });\n  }\n});\n\n\n// Promise\nimport request from 'catta';  // catta 是一个轻量级请求工具，支持 fetch,jsonp,ajax，无依赖\nrequest('a/url/to/target')\n  .then(rs => rs ? $.post('a/url/to/another/target') : Promise.reject())\n  .then(rs2 => rs2 ? $.post('a/url/to/third/target') : Promise.reject());\n``` \n\n随着回调函数嵌套层级和单层复杂度增加，它将会变得臃肿且难以维护，而 Promise 的链式结构，在高复杂度时，仍能纵向扩展，而且层次隔离很清晰。\n\n## 常见的函数式编程模型\n\n### 闭包（Closure）\n\n可以保留局部变量不被释放的代码块，被称为一个闭包\n\n闭包的概念比较抽象，相信大家都或多或少知道、用到这个特性\n\n那么闭包到底能给我们带来什么好处？\n\n先来看一下如何创建一个闭包：\n\n``` javascript\n// 创建一个闭包\nfunction makeCounter() {\n  let k = 0;\n\n  return function() {\n    return ++k;\n  };\n}\n\nconst counter = makeCounter();\n\nconsole.log(counter());  // 1\nconsole.log(counter());  // 2\n\n``` \nmakeCounter 这个函数的代码块，在返回的函数中，对局部变量 k ，进行了引用，导致局部变量无法在函数执行结束后，被系统回收掉，从而产生了闭包。而这个闭包的作用就是，“保留住“ 了局部变量，使内层函数调用时，可以重复使用该变量；而不同于全局变量，该变量只能在函数内部被引用。\n\n换句话说，闭包其实就是创造出了一些函数私有的 ”持久化变量“。\n\n所以从这个例子，我们可以总结出，闭包的创造条件是：\n\n1. 存在内、外两层函数\n1. 内层函数对外层函数的局部变量进行了引用\n\n\n###闭包的用途\n\n闭包的主要用途就是可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等等。\n\n``` javascript\n// 简单的缓存工具\n// 匿名函数创造了一个闭包\nconst cache = (function() {\n  const store = {};\n  \n  return {\n    get(key) {\n      return store[key];\n    },\n    set(key, val) {\n      store[key] = val;\n    }\n  }\n}());\n\ncache.set('a', 1);\ncache.get('a');  // 1\n\n``` \n上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。\n\n###闭包的弊端\n\n持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。\n\n##高阶函数\n\n接受或者返回一个函数的函数称为高阶函数\n\n听上去很高冷的一个词汇，但是其实我们经常用到，只是原来不知道他们的名字而已。JavaScript 语言是原生支持高阶函数的，因为 JavaScript 的函数是一等公民，它既可以作为参数又可以作为另一个函数的返回值使用。\n\n我们经常可以在 JavaScript 中见到许多原生的高阶函数，例如 Array.map , Array.reduce , Array.filter\n\n下面以 map 为例，我们看看他是如何使用的\n\n###map （映射）\n\n映射是对集合而言的，即把集合的每一项都做相同的变换，产生一个新的集合\n\nmap 作为一个高阶函数，他接受一个函数参数作为映射的逻辑\n\n``` javascript\n\n// 数组中每一项加一，组成一个新数组\n\n// 一般写法\nconst arr = [1,2,3];\nconst rs = [];\nfor(const n of arr){\n  rs.push(++n);\n}\nconsole.log(rs)\n\n\n// map改写\nconst arr = [1,2,3];\nconst rs = arr.map(n => ++n);\n\n``` \n\n上面一般写法，利用 for...of 循环的方式遍历数组会产生额外的操作，而且有改变原数组的风险\n\n而 map 函数封装了必要的操作，使我们仅需要关心映射逻辑的函数实现即可，减少了代码量，也降低了副作用产生的风险。\n\n###柯里化（Currying）\n\n给定一个函数的部分参数，生成一个接受其他参数的新函数\n\n可能不常听到这个名词，但是用过 undescore 或 lodash 的人都见过他。\n\n有一个神奇的 _.partial 函数，它就是柯里化的实现\n\n``` javascript\n// 获取目标文件对基础路径的相对路径\n\n\n// 一般写法\nconst BASE = '/path/to/base';\nconst relativePath = path.relative(BASE, '/some/path');\n\n\n// _.parical 改写\nconst BASE = '/path/to/base';\nconst relativeFromBase = _.partial(path.relative, BASE);\n\nconst relativePath = relativeFromBase('/some/path');\n``` \n通过 _.partial ，我们得到了新的函数 relativeFromBase ，这个函数在调用时就相当于调用 path.relative ，并默认将第一个参数传入 BASE ，后续传入的参数顺序后置。\n\n本例中，我们真正想完成的操作是每次获得相对于 BASE 的路径，而非相对于任何路径。柯里化可以使我们只关心函数的部分参数，使函数的用途更加清晰，调用更加简单。\n\n###组合（Composing）\n\n将多个函数的能力合并，创造一个新的函数\n\n同样你第一次见到他可能还是在 lodash 中，compose 方法（现在叫 flow）\n\n``` javascript\n// 数组中每个单词大写，做 Base64\n\n\n// 一般写法 (其中一种)\nconst arr = ['pen', 'apple', 'applypen'];\nconst rs = [];\nfor(const w of arr){\n  rs.push(btoa(w.toUpperCase()));\n}\nconsole.log(rs);\n\n\n// _.flow 改写\nconst arr = ['pen', 'apple', 'applypen'];\nconst upperAndBase64 = _.partialRight(_.map, _.flow(_.upperCase, btoa));\nconsole.log(upperAndBase64(arr));\n``` \n_.flow 将转大写和转 Base64 的函数的能力合并，生成一个新的函数。方便作为参数函数或后续复用。\n\n##自己的观点\n\n我理解的 JavaScript 函数式编程，将可以复用的功能提取出来，用函数方法来代替其实就是基本的函数编程思想，其实到最后会面临两个问题，一个是函数共用性好还是函数功能细分好，这其实都是根据自己具体需求而定的，个人认为函数功能还是细分好，这样方便维护，功能实现代码逻辑清晰。\n\n函数式编程就是书写清新的逻辑代码，其实也是一种解耦的形式罢了。","slug":"2017-04-10","published":1,"updated":"2017-08-26T12:58:33.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36qm0004lmldw6enqe83","content":"<p>JavaScript 函数式编程是一个存在了很久的话题，但似乎从 2016 年开始，它变得越来越火热。这可能是因为 ES6 语法对于函数式编程更为友好，也可能是因为诸如 RxJS (ReactiveX) 等函数式框架的流行。</p>\n<p>看过许多关于函数式编程的讲解，但是其中大部分是停留在理论层面，还有一些是仅针对 Haskell 等纯函数式编程语言的。而本文旨在聊一聊我眼中的函数式编程在 JavaScript 中的具体实践，之所以是 “我眼中的” 即我所说的仅代表个人观点，可能和部分 严格概念 是有冲突的。</p>\n<p>本文将略去一大堆形式化的概念介绍，重点展示在 JavaScript 中到底什么是函数式的代码、函数式代码与一般写法有什么区别、函数式的代码能给我们带来什么好处以及常见的一些函数式模型都有哪些。</p>\n<a id=\"more\"></a>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><p>我认为函数式编程可以理解为，以函数作为主要载体的编程方式，用函数去拆解、抽象一般的表达式</p>\n<p>与命令式相比，这样做的好处在哪？主要有以下几点：</p>\n<ol>\n<li>语义更加清晰</li>\n<li>可复用性更高</li>\n<li>可维护性更好</li>\n<li>作用域局限，副作用少</li>\n</ol>\n<h2 id=\"基本的函数式编程\"><a href=\"#基本的函数式编程\" class=\"headerlink\" title=\"基本的函数式编程\"></a>基本的函数式编程</h2><p>下面例子是一个具体的函数式体现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 一般写法</span></div><div class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">'apple'</span>, <span class=\"string\">'pen'</span>, <span class=\"string\">'apple-pen'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> i <span class=\"keyword\">in</span> arr)&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> c = arr[i][<span class=\"number\">0</span>];</div><div class=\"line\">  arr[i] = c.toUpperCase() + arr[i].slice(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 函数式写法一</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upperFirst</span>(<span class=\"params\">word</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> word[<span class=\"number\">0</span>].toUpperCase() + word.slice(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wordToUpperCase</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> arr.map(upperFirst);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(wordToUpperCase([<span class=\"string\">'apple'</span>, <span class=\"string\">'pen'</span>, <span class=\"string\">'apple-pen'</span>]));</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 函数式写法二</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr.map([<span class=\"string\">'apple'</span>, <span class=\"string\">'pen'</span>, <span class=\"string\">'apple-pen'</span>], word =&gt; word[<span class=\"number\">0</span>].toUpperCase() + word.slice(<span class=\"number\">1</span>)));</div></pre></td></tr></table></figure>\n<p>当情况变得更加复杂时，表达式的写法会遇到几个问题：</p>\n<ol>\n<li>表意不明显，逐渐变得难以维护</li>\n<li>复用性差，会产生更多的代码量</li>\n<li>会产生很多中间变量</li>\n</ol>\n<p>函数式编程很好的解决了上述问题。首先参看 函数式写法一，它利用了函数封装性将功能做拆解（粒度不唯一），并封装为不同的函数，而再利用组合的调用达到目的。这样做使得表意清晰，易于维护、复用以及扩展。其次利用 高阶函数，Array.map 代替 for…of 做数组遍历，减少了中间变量和操作。</p>\n<p>而 函数式写法一 和 函数式写法二 之间的主要差别在于，可以考虑函数是否后续有复用的可能，如果没有，则后者更优。</p>\n<h2 id=\"链式优化\"><a href=\"#链式优化\" class=\"headerlink\" title=\"链式优化\"></a>链式优化</h2><p>从上面 函数式写法二 中我们可以看出，函数式代码在写的过程中，很容易造成 横向延展，即产生多层嵌套，下面我们举个比较极端点的例子。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 计算数字之和</span>\n\n\n<span class=\"comment\">// 一般写法</span>\n<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + <span class=\"number\">2</span> + <span class=\"number\">3</span> - <span class=\"number\">4</span>)\n\n\n<span class=\"comment\">// 函数式写法</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>{\n  <span class=\"keyword\">return</span> a + b;\n}\n\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sub</span>(<span class=\"params\">a, b</span>) </span>{\n  <span class=\"keyword\">return</span> a - b;\n}\n\n<span class=\"built_in\">console</span>.log(sub(sum(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>), <span class=\"number\">3</span>), <span class=\"number\">4</span>);\n</code></pre>\n<p>本例仅为展示 横向延展 的比较极端的情况，随着函数的嵌套层数不断增多，导致代码的可读性大幅下降，还很容易产生错误。</p>\n<p>在这种情况下，我们可以考虑多种优化方式，比如下面的 链式优化 。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 优化写法 (嗯，你没看错，这就是 lodash 的链式写法)</span>\n<span class=\"keyword\">const</span> utils = {\n  chain(a) {\n    <span class=\"keyword\">this</span>._temp = a;\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;\n  },\n  sum(b) {\n    <span class=\"keyword\">this</span>._temp += b;\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;\n  },\n  sub(b) {\n    <span class=\"keyword\">this</span>._temp -= b;\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;\n  },\n  value() {\n    <span class=\"keyword\">const</span> _temp = <span class=\"keyword\">this</span>._temp;\n    <span class=\"keyword\">this</span>._temp = <span class=\"literal\">undefined</span>;\n    <span class=\"keyword\">return</span> _temp;\n  }\n};\n\n<span class=\"built_in\">console</span>.log(utils.chain(<span class=\"number\">1</span>).sum(<span class=\"number\">2</span>).sum(<span class=\"number\">3</span>).sub(<span class=\"number\">4</span>).value());\n</code></pre>\n<p>这样改写后，结构会整体变得比较清晰，而且链的每一环在做什么也可以很容易的展现出来。函数的嵌套和链式的对比还有一个很好的例子，那就是 回调函数 和 Promise 模式。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 顺序请求两个接口</span>\n\n\n<span class=\"comment\">// 回调函数</span>\n<span class=\"keyword\">import</span> $ <span class=\"keyword\">from</span> <span class=\"string\">'jquery'</span>;\n$.post(<span class=\"string\">'a/url/to/target'</span>, (rs) =&gt; {\n  <span class=\"keyword\">if</span>(rs){\n    $.post(<span class=\"string\">'a/url/to/another/target'</span>, (rs2) =&gt; {\n      <span class=\"keyword\">if</span>(rs2){\n        $.post(<span class=\"string\">'a/url/to/third/target'</span>);\n      }\n    });\n  }\n});\n\n\n<span class=\"comment\">// Promise</span>\n<span class=\"keyword\">import</span> request <span class=\"keyword\">from</span> <span class=\"string\">'catta'</span>;  <span class=\"comment\">// catta 是一个轻量级请求工具，支持 fetch,jsonp,ajax，无依赖</span>\nrequest(<span class=\"string\">'a/url/to/target'</span>)\n  .then(<span class=\"function\"><span class=\"params\">rs</span> =&gt;</span> rs ? $.post(<span class=\"string\">'a/url/to/another/target'</span>) : <span class=\"built_in\">Promise</span>.reject())\n  .then(<span class=\"function\"><span class=\"params\">rs2</span> =&gt;</span> rs2 ? $.post(<span class=\"string\">'a/url/to/third/target'</span>) : <span class=\"built_in\">Promise</span>.reject());\n</code></pre>\n<p>随着回调函数嵌套层级和单层复杂度增加，它将会变得臃肿且难以维护，而 Promise 的链式结构，在高复杂度时，仍能纵向扩展，而且层次隔离很清晰。</p>\n<h2 id=\"常见的函数式编程模型\"><a href=\"#常见的函数式编程模型\" class=\"headerlink\" title=\"常见的函数式编程模型\"></a>常见的函数式编程模型</h2><h3 id=\"闭包（Closure）\"><a href=\"#闭包（Closure）\" class=\"headerlink\" title=\"闭包（Closure）\"></a>闭包（Closure）</h3><p>可以保留局部变量不被释放的代码块，被称为一个闭包</p>\n<p>闭包的概念比较抽象，相信大家都或多或少知道、用到这个特性</p>\n<p>那么闭包到底能给我们带来什么好处？</p>\n<p>先来看一下如何创建一个闭包：</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 创建一个闭包</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeCounter</span>(<span class=\"params\"></span>) </span>{\n  <span class=\"keyword\">let</span> k = <span class=\"number\">0</span>;\n\n  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> ++k;\n  };\n}\n\n<span class=\"keyword\">const</span> counter = makeCounter();\n\n<span class=\"built_in\">console</span>.log(counter());  <span class=\"comment\">// 1</span>\n<span class=\"built_in\">console</span>.log(counter());  <span class=\"comment\">// 2</span>\n</code></pre>\n<p>makeCounter 这个函数的代码块，在返回的函数中，对局部变量 k ，进行了引用，导致局部变量无法在函数执行结束后，被系统回收掉，从而产生了闭包。而这个闭包的作用就是，“保留住“ 了局部变量，使内层函数调用时，可以重复使用该变量；而不同于全局变量，该变量只能在函数内部被引用。</p>\n<p>换句话说，闭包其实就是创造出了一些函数私有的 ”持久化变量“。</p>\n<p>所以从这个例子，我们可以总结出，闭包的创造条件是：</p>\n<ol>\n<li>存在内、外两层函数</li>\n<li>内层函数对外层函数的局部变量进行了引用</li>\n</ol>\n<p>###闭包的用途</p>\n<p>闭包的主要用途就是可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等等。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 简单的缓存工具</span>\n<span class=\"comment\">// 匿名函数创造了一个闭包</span>\n<span class=\"keyword\">const</span> cache = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n  <span class=\"keyword\">const</span> store = {};\n\n  <span class=\"keyword\">return</span> {\n    get(key) {\n      <span class=\"keyword\">return</span> store[key];\n    },\n    set(key, val) {\n      store[key] = val;\n    }\n  }\n}());\n\ncache.set(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>);\ncache.get(<span class=\"string\">'a'</span>);  <span class=\"comment\">// 1</span>\n</code></pre>\n<p>上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。</p>\n<p>###闭包的弊端</p>\n<p>持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。</p>\n<p>##高阶函数</p>\n<p>接受或者返回一个函数的函数称为高阶函数</p>\n<p>听上去很高冷的一个词汇，但是其实我们经常用到，只是原来不知道他们的名字而已。JavaScript 语言是原生支持高阶函数的，因为 JavaScript 的函数是一等公民，它既可以作为参数又可以作为另一个函数的返回值使用。</p>\n<p>我们经常可以在 JavaScript 中见到许多原生的高阶函数，例如 Array.map , Array.reduce , Array.filter</p>\n<p>下面以 map 为例，我们看看他是如何使用的</p>\n<p>###map （映射）</p>\n<p>映射是对集合而言的，即把集合的每一项都做相同的变换，产生一个新的集合</p>\n<p>map 作为一个高阶函数，他接受一个函数参数作为映射的逻辑</p>\n<pre><code class=\"javascript\">\n<span class=\"comment\">// 数组中每一项加一，组成一个新数组</span>\n\n<span class=\"comment\">// 一般写法</span>\n<span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];\n<span class=\"keyword\">const</span> rs = [];\n<span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> n <span class=\"keyword\">of</span> arr){\n  rs.push(++n);\n}\n<span class=\"built_in\">console</span>.log(rs)\n\n\n<span class=\"comment\">// map改写</span>\n<span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];\n<span class=\"keyword\">const</span> rs = arr.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> ++n);\n</code></pre>\n<p>上面一般写法，利用 for…of 循环的方式遍历数组会产生额外的操作，而且有改变原数组的风险</p>\n<p>而 map 函数封装了必要的操作，使我们仅需要关心映射逻辑的函数实现即可，减少了代码量，也降低了副作用产生的风险。</p>\n<p>###柯里化（Currying）</p>\n<p>给定一个函数的部分参数，生成一个接受其他参数的新函数</p>\n<p>可能不常听到这个名词，但是用过 undescore 或 lodash 的人都见过他。</p>\n<p>有一个神奇的 _.partial 函数，它就是柯里化的实现</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 获取目标文件对基础路径的相对路径</span>\n\n\n<span class=\"comment\">// 一般写法</span>\n<span class=\"keyword\">const</span> BASE = <span class=\"string\">'/path/to/base'</span>;\n<span class=\"keyword\">const</span> relativePath = path.relative(BASE, <span class=\"string\">'/some/path'</span>);\n\n\n<span class=\"comment\">// _.parical 改写</span>\n<span class=\"keyword\">const</span> BASE = <span class=\"string\">'/path/to/base'</span>;\n<span class=\"keyword\">const</span> relativeFromBase = _.partial(path.relative, BASE);\n\n<span class=\"keyword\">const</span> relativePath = relativeFromBase(<span class=\"string\">'/some/path'</span>);\n</code></pre>\n<p>通过 _.partial ，我们得到了新的函数 relativeFromBase ，这个函数在调用时就相当于调用 path.relative ，并默认将第一个参数传入 BASE ，后续传入的参数顺序后置。</p>\n<p>本例中，我们真正想完成的操作是每次获得相对于 BASE 的路径，而非相对于任何路径。柯里化可以使我们只关心函数的部分参数，使函数的用途更加清晰，调用更加简单。</p>\n<p>###组合（Composing）</p>\n<p>将多个函数的能力合并，创造一个新的函数</p>\n<p>同样你第一次见到他可能还是在 lodash 中，compose 方法（现在叫 flow）</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 数组中每个单词大写，做 Base64</span>\n\n\n<span class=\"comment\">// 一般写法 (其中一种)</span>\n<span class=\"keyword\">const</span> arr = [<span class=\"string\">'pen'</span>, <span class=\"string\">'apple'</span>, <span class=\"string\">'applypen'</span>];\n<span class=\"keyword\">const</span> rs = [];\n<span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> w <span class=\"keyword\">of</span> arr){\n  rs.push(btoa(w.toUpperCase()));\n}\n<span class=\"built_in\">console</span>.log(rs);\n\n\n<span class=\"comment\">// _.flow 改写</span>\n<span class=\"keyword\">const</span> arr = [<span class=\"string\">'pen'</span>, <span class=\"string\">'apple'</span>, <span class=\"string\">'applypen'</span>];\n<span class=\"keyword\">const</span> upperAndBase64 = _.partialRight(_.map, _.flow(_.upperCase, btoa));\n<span class=\"built_in\">console</span>.log(upperAndBase64(arr));\n</code></pre>\n<p>_.flow 将转大写和转 Base64 的函数的能力合并，生成一个新的函数。方便作为参数函数或后续复用。</p>\n<p>##自己的观点</p>\n<p>我理解的 JavaScript 函数式编程，将可以复用的功能提取出来，用函数方法来代替其实就是基本的函数编程思想，其实到最后会面临两个问题，一个是函数共用性好还是函数功能细分好，这其实都是根据自己具体需求而定的，个人认为函数功能还是细分好，这样方便维护，功能实现代码逻辑清晰。</p>\n<p>函数式编程就是书写清新的逻辑代码，其实也是一种解耦的形式罢了。</p>\n","site":{"data":{}},"excerpt":"<p>JavaScript 函数式编程是一个存在了很久的话题，但似乎从 2016 年开始，它变得越来越火热。这可能是因为 ES6 语法对于函数式编程更为友好，也可能是因为诸如 RxJS (ReactiveX) 等函数式框架的流行。</p>\n<p>看过许多关于函数式编程的讲解，但是其中大部分是停留在理论层面，还有一些是仅针对 Haskell 等纯函数式编程语言的。而本文旨在聊一聊我眼中的函数式编程在 JavaScript 中的具体实践，之所以是 “我眼中的” 即我所说的仅代表个人观点，可能和部分 严格概念 是有冲突的。</p>\n<p>本文将略去一大堆形式化的概念介绍，重点展示在 JavaScript 中到底什么是函数式的代码、函数式代码与一般写法有什么区别、函数式的代码能给我们带来什么好处以及常见的一些函数式模型都有哪些。</p>","more":"<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><p>我认为函数式编程可以理解为，以函数作为主要载体的编程方式，用函数去拆解、抽象一般的表达式</p>\n<p>与命令式相比，这样做的好处在哪？主要有以下几点：</p>\n<ol>\n<li>语义更加清晰</li>\n<li>可复用性更高</li>\n<li>可维护性更好</li>\n<li>作用域局限，副作用少</li>\n</ol>\n<h2 id=\"基本的函数式编程\"><a href=\"#基本的函数式编程\" class=\"headerlink\" title=\"基本的函数式编程\"></a>基本的函数式编程</h2><p>下面例子是一个具体的函数式体现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 一般写法</span></div><div class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">'apple'</span>, <span class=\"string\">'pen'</span>, <span class=\"string\">'apple-pen'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> i <span class=\"keyword\">in</span> arr)&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> c = arr[i][<span class=\"number\">0</span>];</div><div class=\"line\">  arr[i] = c.toUpperCase() + arr[i].slice(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 函数式写法一</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upperFirst</span>(<span class=\"params\">word</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> word[<span class=\"number\">0</span>].toUpperCase() + word.slice(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wordToUpperCase</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> arr.map(upperFirst);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(wordToUpperCase([<span class=\"string\">'apple'</span>, <span class=\"string\">'pen'</span>, <span class=\"string\">'apple-pen'</span>]));</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 函数式写法二</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr.map([<span class=\"string\">'apple'</span>, <span class=\"string\">'pen'</span>, <span class=\"string\">'apple-pen'</span>], word =&gt; word[<span class=\"number\">0</span>].toUpperCase() + word.slice(<span class=\"number\">1</span>)));</div></pre></td></tr></table></figure>\n<p>当情况变得更加复杂时，表达式的写法会遇到几个问题：</p>\n<ol>\n<li>表意不明显，逐渐变得难以维护</li>\n<li>复用性差，会产生更多的代码量</li>\n<li>会产生很多中间变量</li>\n</ol>\n<p>函数式编程很好的解决了上述问题。首先参看 函数式写法一，它利用了函数封装性将功能做拆解（粒度不唯一），并封装为不同的函数，而再利用组合的调用达到目的。这样做使得表意清晰，易于维护、复用以及扩展。其次利用 高阶函数，Array.map 代替 for…of 做数组遍历，减少了中间变量和操作。</p>\n<p>而 函数式写法一 和 函数式写法二 之间的主要差别在于，可以考虑函数是否后续有复用的可能，如果没有，则后者更优。</p>\n<h2 id=\"链式优化\"><a href=\"#链式优化\" class=\"headerlink\" title=\"链式优化\"></a>链式优化</h2><p>从上面 函数式写法二 中我们可以看出，函数式代码在写的过程中，很容易造成 横向延展，即产生多层嵌套，下面我们举个比较极端点的例子。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 计算数字之和</span>\n\n\n<span class=\"comment\">// 一般写法</span>\n<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + <span class=\"number\">2</span> + <span class=\"number\">3</span> - <span class=\"number\">4</span>)\n\n\n<span class=\"comment\">// 函数式写法</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>{\n  <span class=\"keyword\">return</span> a + b;\n}\n\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sub</span>(<span class=\"params\">a, b</span>) </span>{\n  <span class=\"keyword\">return</span> a - b;\n}\n\n<span class=\"built_in\">console</span>.log(sub(sum(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>), <span class=\"number\">3</span>), <span class=\"number\">4</span>);\n</code></pre>\n<p>本例仅为展示 横向延展 的比较极端的情况，随着函数的嵌套层数不断增多，导致代码的可读性大幅下降，还很容易产生错误。</p>\n<p>在这种情况下，我们可以考虑多种优化方式，比如下面的 链式优化 。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 优化写法 (嗯，你没看错，这就是 lodash 的链式写法)</span>\n<span class=\"keyword\">const</span> utils = {\n  chain(a) {\n    <span class=\"keyword\">this</span>._temp = a;\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;\n  },\n  sum(b) {\n    <span class=\"keyword\">this</span>._temp += b;\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;\n  },\n  sub(b) {\n    <span class=\"keyword\">this</span>._temp -= b;\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;\n  },\n  value() {\n    <span class=\"keyword\">const</span> _temp = <span class=\"keyword\">this</span>._temp;\n    <span class=\"keyword\">this</span>._temp = <span class=\"literal\">undefined</span>;\n    <span class=\"keyword\">return</span> _temp;\n  }\n};\n\n<span class=\"built_in\">console</span>.log(utils.chain(<span class=\"number\">1</span>).sum(<span class=\"number\">2</span>).sum(<span class=\"number\">3</span>).sub(<span class=\"number\">4</span>).value());\n</code></pre>\n<p>这样改写后，结构会整体变得比较清晰，而且链的每一环在做什么也可以很容易的展现出来。函数的嵌套和链式的对比还有一个很好的例子，那就是 回调函数 和 Promise 模式。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 顺序请求两个接口</span>\n\n\n<span class=\"comment\">// 回调函数</span>\n<span class=\"keyword\">import</span> $ <span class=\"keyword\">from</span> <span class=\"string\">'jquery'</span>;\n$.post(<span class=\"string\">'a/url/to/target'</span>, (rs) =&gt; {\n  <span class=\"keyword\">if</span>(rs){\n    $.post(<span class=\"string\">'a/url/to/another/target'</span>, (rs2) =&gt; {\n      <span class=\"keyword\">if</span>(rs2){\n        $.post(<span class=\"string\">'a/url/to/third/target'</span>);\n      }\n    });\n  }\n});\n\n\n<span class=\"comment\">// Promise</span>\n<span class=\"keyword\">import</span> request <span class=\"keyword\">from</span> <span class=\"string\">'catta'</span>;  <span class=\"comment\">// catta 是一个轻量级请求工具，支持 fetch,jsonp,ajax，无依赖</span>\nrequest(<span class=\"string\">'a/url/to/target'</span>)\n  .then(<span class=\"function\"><span class=\"params\">rs</span> =&gt;</span> rs ? $.post(<span class=\"string\">'a/url/to/another/target'</span>) : <span class=\"built_in\">Promise</span>.reject())\n  .then(<span class=\"function\"><span class=\"params\">rs2</span> =&gt;</span> rs2 ? $.post(<span class=\"string\">'a/url/to/third/target'</span>) : <span class=\"built_in\">Promise</span>.reject());\n</code></pre>\n<p>随着回调函数嵌套层级和单层复杂度增加，它将会变得臃肿且难以维护，而 Promise 的链式结构，在高复杂度时，仍能纵向扩展，而且层次隔离很清晰。</p>\n<h2 id=\"常见的函数式编程模型\"><a href=\"#常见的函数式编程模型\" class=\"headerlink\" title=\"常见的函数式编程模型\"></a>常见的函数式编程模型</h2><h3 id=\"闭包（Closure）\"><a href=\"#闭包（Closure）\" class=\"headerlink\" title=\"闭包（Closure）\"></a>闭包（Closure）</h3><p>可以保留局部变量不被释放的代码块，被称为一个闭包</p>\n<p>闭包的概念比较抽象，相信大家都或多或少知道、用到这个特性</p>\n<p>那么闭包到底能给我们带来什么好处？</p>\n<p>先来看一下如何创建一个闭包：</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 创建一个闭包</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeCounter</span>(<span class=\"params\"></span>) </span>{\n  <span class=\"keyword\">let</span> k = <span class=\"number\">0</span>;\n\n  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> ++k;\n  };\n}\n\n<span class=\"keyword\">const</span> counter = makeCounter();\n\n<span class=\"built_in\">console</span>.log(counter());  <span class=\"comment\">// 1</span>\n<span class=\"built_in\">console</span>.log(counter());  <span class=\"comment\">// 2</span>\n</code></pre>\n<p>makeCounter 这个函数的代码块，在返回的函数中，对局部变量 k ，进行了引用，导致局部变量无法在函数执行结束后，被系统回收掉，从而产生了闭包。而这个闭包的作用就是，“保留住“ 了局部变量，使内层函数调用时，可以重复使用该变量；而不同于全局变量，该变量只能在函数内部被引用。</p>\n<p>换句话说，闭包其实就是创造出了一些函数私有的 ”持久化变量“。</p>\n<p>所以从这个例子，我们可以总结出，闭包的创造条件是：</p>\n<ol>\n<li>存在内、外两层函数</li>\n<li>内层函数对外层函数的局部变量进行了引用</li>\n</ol>\n<p>###闭包的用途</p>\n<p>闭包的主要用途就是可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等等。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 简单的缓存工具</span>\n<span class=\"comment\">// 匿名函数创造了一个闭包</span>\n<span class=\"keyword\">const</span> cache = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n  <span class=\"keyword\">const</span> store = {};\n\n  <span class=\"keyword\">return</span> {\n    get(key) {\n      <span class=\"keyword\">return</span> store[key];\n    },\n    set(key, val) {\n      store[key] = val;\n    }\n  }\n}());\n\ncache.set(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>);\ncache.get(<span class=\"string\">'a'</span>);  <span class=\"comment\">// 1</span>\n</code></pre>\n<p>上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。</p>\n<p>###闭包的弊端</p>\n<p>持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。</p>\n<p>##高阶函数</p>\n<p>接受或者返回一个函数的函数称为高阶函数</p>\n<p>听上去很高冷的一个词汇，但是其实我们经常用到，只是原来不知道他们的名字而已。JavaScript 语言是原生支持高阶函数的，因为 JavaScript 的函数是一等公民，它既可以作为参数又可以作为另一个函数的返回值使用。</p>\n<p>我们经常可以在 JavaScript 中见到许多原生的高阶函数，例如 Array.map , Array.reduce , Array.filter</p>\n<p>下面以 map 为例，我们看看他是如何使用的</p>\n<p>###map （映射）</p>\n<p>映射是对集合而言的，即把集合的每一项都做相同的变换，产生一个新的集合</p>\n<p>map 作为一个高阶函数，他接受一个函数参数作为映射的逻辑</p>\n<pre><code class=\"javascript\">\n<span class=\"comment\">// 数组中每一项加一，组成一个新数组</span>\n\n<span class=\"comment\">// 一般写法</span>\n<span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];\n<span class=\"keyword\">const</span> rs = [];\n<span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> n <span class=\"keyword\">of</span> arr){\n  rs.push(++n);\n}\n<span class=\"built_in\">console</span>.log(rs)\n\n\n<span class=\"comment\">// map改写</span>\n<span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];\n<span class=\"keyword\">const</span> rs = arr.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> ++n);\n</code></pre>\n<p>上面一般写法，利用 for…of 循环的方式遍历数组会产生额外的操作，而且有改变原数组的风险</p>\n<p>而 map 函数封装了必要的操作，使我们仅需要关心映射逻辑的函数实现即可，减少了代码量，也降低了副作用产生的风险。</p>\n<p>###柯里化（Currying）</p>\n<p>给定一个函数的部分参数，生成一个接受其他参数的新函数</p>\n<p>可能不常听到这个名词，但是用过 undescore 或 lodash 的人都见过他。</p>\n<p>有一个神奇的 _.partial 函数，它就是柯里化的实现</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 获取目标文件对基础路径的相对路径</span>\n\n\n<span class=\"comment\">// 一般写法</span>\n<span class=\"keyword\">const</span> BASE = <span class=\"string\">'/path/to/base'</span>;\n<span class=\"keyword\">const</span> relativePath = path.relative(BASE, <span class=\"string\">'/some/path'</span>);\n\n\n<span class=\"comment\">// _.parical 改写</span>\n<span class=\"keyword\">const</span> BASE = <span class=\"string\">'/path/to/base'</span>;\n<span class=\"keyword\">const</span> relativeFromBase = _.partial(path.relative, BASE);\n\n<span class=\"keyword\">const</span> relativePath = relativeFromBase(<span class=\"string\">'/some/path'</span>);\n</code></pre>\n<p>通过 _.partial ，我们得到了新的函数 relativeFromBase ，这个函数在调用时就相当于调用 path.relative ，并默认将第一个参数传入 BASE ，后续传入的参数顺序后置。</p>\n<p>本例中，我们真正想完成的操作是每次获得相对于 BASE 的路径，而非相对于任何路径。柯里化可以使我们只关心函数的部分参数，使函数的用途更加清晰，调用更加简单。</p>\n<p>###组合（Composing）</p>\n<p>将多个函数的能力合并，创造一个新的函数</p>\n<p>同样你第一次见到他可能还是在 lodash 中，compose 方法（现在叫 flow）</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 数组中每个单词大写，做 Base64</span>\n\n\n<span class=\"comment\">// 一般写法 (其中一种)</span>\n<span class=\"keyword\">const</span> arr = [<span class=\"string\">'pen'</span>, <span class=\"string\">'apple'</span>, <span class=\"string\">'applypen'</span>];\n<span class=\"keyword\">const</span> rs = [];\n<span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> w <span class=\"keyword\">of</span> arr){\n  rs.push(btoa(w.toUpperCase()));\n}\n<span class=\"built_in\">console</span>.log(rs);\n\n\n<span class=\"comment\">// _.flow 改写</span>\n<span class=\"keyword\">const</span> arr = [<span class=\"string\">'pen'</span>, <span class=\"string\">'apple'</span>, <span class=\"string\">'applypen'</span>];\n<span class=\"keyword\">const</span> upperAndBase64 = _.partialRight(_.map, _.flow(_.upperCase, btoa));\n<span class=\"built_in\">console</span>.log(upperAndBase64(arr));\n</code></pre>\n<p>_.flow 将转大写和转 Base64 的函数的能力合并，生成一个新的函数。方便作为参数函数或后续复用。</p>\n<p>##自己的观点</p>\n<p>我理解的 JavaScript 函数式编程，将可以复用的功能提取出来，用函数方法来代替其实就是基本的函数编程思想，其实到最后会面临两个问题，一个是函数共用性好还是函数功能细分好，这其实都是根据自己具体需求而定的，个人认为函数功能还是细分好，这样方便维护，功能实现代码逻辑清晰。</p>\n<p>函数式编程就是书写清新的逻辑代码，其实也是一种解耦的形式罢了。</p>"},{"title":"axios基本使用介绍","comments":1,"date":"2017-05-02T10:56:15.000Z","_content":"\naxios建议使用高版本浏览器，目前在手机端使用频繁，但是在低版本的安卓上其实是有兼容性问题的，安卓4.2就开始出问题了，主要是由于Promise不支持，需要额外引入兼容包来处理。并且axios也是vue官方推荐使用的库。\n\n{% codeblock lang:javascript %}\nrequire('es6-promise').polyfill();\n{% endcodeblock %}\n\n> 发送一个GET请求，代码示例如下：\n\n{% codeblock lang:javascript %}\n//通过给定的ID来发送请求\naxios.get('/user?ID=12345')\n  .then(function(response){\n    console.log(response);\n  })\n  .catch(function(err){\n    console.log(err);\n  });\n//以上请求也可以通过这种方式来发送\naxios.get('/user',{\n  params:{\n    ID:12345\n  }\n})\n.then(function(response){\n  console.log(response);\n})\n.catch(function(err){\n  console.log(err);\n});\n{% endcodeblock %}\n\n<!-- more -->\n\n> 发送一个POST请求，代码示例如下：\n\n{% codeblock lang:javascript %}\naxios.post('/user',{\n  firstName:'Fred',\n  lastName:'Flintstone'\n})\n.then(function(res){\n  console.log(res);\n})\n.catch(function(err){\n  console.log(err);\n});\n{% endcodeblock %}\n\n>一次性并发多个请求，代码示例如下：\n\n{% codeblock lang:javascript %}\nfunction getUserAccount(){\n  return axios.get('/user/12345');\n}\nfunction getUserPermissions(){\n  return axios.get('/user/12345/permissions');\n}\naxios.all([getUserAccount(),getUserPermissions()])\n  .then(axios.spread(function(acct,perms){\n    //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果\n  }))\n{% endcodeblock %}\n\n>axios可以通过配置（config）来发送请求，代码示例如下：\n\n{% codeblock lang:javascript %}\n//发送一个`POST`请求\naxios({\n    method:\"POST\",\n    url:'/user/12345',\n    data:{\n        firstName:\"Fred\",\n        lastName:\"Flintstone\"\n    }\n});\n{% endcodeblock %}\n\n>请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名,注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明\n\n{% codeblock lang:javascript %}\naxios.request(config);\naxios.get(url[,config]);\naxios.delete(url[,config]);\naxios.head(url[,config]);\naxios.post(url[,data[,config]]);\naxios.put(url[,data[,config]])\naxios.patch(url[,data[,config]])\n{% endcodeblock %}\n\n>并发请求（concurrency）,即是帮助处理并发请求的辅助函数\n\n{% codeblock lang:javascript %}\n//iterable是一个可以迭代的参数如数组等\naxios.all(iterable)\n//callback要等到所有请求都完成才会执行\naxios.spread(callback)\n{% endcodeblock %}\n\n>创建一个axios实例，并且可以自定义其配置\n\n1、axios.create([config])\n{% codeblock lang:javascript %}\nvar instance = axios.create({\n  baseURL:\"https://some-domain.com/api/\",\n  timeout:1000,\n  headers: {'X-Custom-Header':'foobar'}\n});\n{% endcodeblock %}\n\n2、实例的方法，注意已经定义的配置将和利用create创建的实例的配置合并\n{% codeblock lang:javascript %}\naxios#request(config)\naxios#get(url[,config])\naxios#delete(url[,config])\naxios#head(url[,config])\naxios#post(url[,data[,config]])\naxios#put(url[,data[,config]])\naxios#patch(url[,data[,config]])\n{% endcodeblock %}\n\n>请求的配置（request config），以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求\n\n{% codeblock lang:javascript %}\n{\n  //`url`是请求的服务器地址\n  url:'/user',\n  //`method`是请求资源的方式\n  method:'get'//default\n  //如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面\n  //当`url`是相对地址的时候，设置`baseURL`会非常的方便\n  baseURL:'https://some-domain.com/api/',\n  //`transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动\n  //该选项只适用于以下请求方式：`put/post/patch`\n  //数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream`\n  transformRequest:[function(data){\n    //在这里根据自己的需求改变数据\n    return data;\n  }],\n  //`transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动\n  transformResponse:[function(data){\n    //在这里根据自己的需求改变数据\n    return data;\n  }],\n  //`headers`选项是需要被发送的自定义请求头信息\n  headers: {'X-Requested-With':'XMLHttpRequest'},\n  //`params`选项是要随请求一起发送的请求参数----一般链接在URL后面\n  //他的类型必须是一个纯对象或者是URLSearchParams对象\n  params: {\n    ID:12345\n  },\n  //`paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化\n  //例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param)\n  paramsSerializer: function(params){\n    return Qs.stringify(params,{arrayFormat:'brackets'})\n  },\n  //`data`选项是作为一个请求体而需要被发送的数据\n  //该选项只适用于方法：`put/post/patch`\n  //当没有设置`transformRequest`选项时dada必须是以下几种类型之一\n  //string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams\n  //仅仅浏览器：FormData/File/Bold\n  //仅node:Stream\n  data {\n    firstName:\"Fred\"\n  },\n  //`timeout`选项定义了请求发出的延迟毫秒数\n  //如果请求花费的时间超过延迟的时间，那么请求会被终止\n\n  timeout:1000,\n  //`withCredentails`选项表明了是否是跨域请求\n  \n  withCredentials:false,//default\n  //`adapter`适配器选项允许自定义处理请求，这会使得测试变得方便\n  //返回一个promise,并提供验证返回\n  adapter: function(config){\n    /*..........*/\n  },\n  //`auth`表明HTTP基础的认证应该被使用，并提供证书\n  //这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息\n  auth: {\n    username:\"zhangsan\",\n    password: \"s00sdkf\"\n  },\n  //返回数据的格式\n  //其可选项是arraybuffer,blob,document,json,text,stream\n  responseType:'json',//default\n  //\n  xsrfCookieName: 'XSRF-TOKEN',//default\n  xsrfHeaderName:'X-XSRF-TOKEN',//default\n  //`onUploadProgress`上传进度事件\n  onUploadProgress:function(progressEvent){\n    //下载进度的事件\nonDownloadProgress:function(progressEvent){\n}\n  },\n  //相应内容的最大值\n  maxContentLength:2000,\n  //`validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise\n  //如果`validateStatus`返回true(或者设置为`null`或者`undefined`),那么promise的状态将会是resolved,否则其状态就是rejected\n  validateStatus:function(status){\n    return status >= 200 && status <300;//default\n  },\n  //`maxRedirects`定义了在nodejs中重定向的最大数量\n  maxRedirects: 5,//default\n  //`httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理\n  //keeyAlive在选项中没有被默认激活\n  httpAgent: new http.Agent({keeyAlive:true}),\n  httpsAgent: new https.Agent({keeyAlive:true}),\n  //proxy定义了主机名字和端口号，\n  //`auth`表明http基本认证应该与proxy代理链接，并提供证书\n  //这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的`Proxy-Authorization`  header\n  proxy: {\n    host:'127.0.0.1',\n    port: 9000,\n    auth: {\n      username:'skda',\n      password:'radsd'\n    }\n  },\n  //`cancelToken`定义了一个用于取消请求的cancel token\n  //详见cancelation部分\n  cancelToken: new cancelToken(function(cancel){\n\n  })\n}\n{% endcodeblock %}\n\n >请求返回的内容\n\n{% codeblock lang:javascript %}\n {\n  data:{},\n  status:200,\n  //从服务器返回的http状态文本\n  statusText:'OK',\n  //响应头信息\n  headers: {},\n  //`config`是在请求的时候的一些配置信息\n  config: {}\n}\n{% endcodeblock %}\n\n>默认配置\n\n1、全局默认配置\n{% codeblock lang:javascript %}\naxios.defaults.baseURL = 'http://api.exmple.com';\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\naxios.defaults.headers.post['content-Type'] = 'appliction/x-www-form-urlencoded';\n{% endcodeblock %}\n\n2、自定义的实例默认设置\n{% codeblock lang:javascript %}\n//当创建实例的时候配置默认配置\nvar instance = axios.create({\n    baseURL: 'https://api.example.com'\n});\n\n//当实例创建时候修改配置\ninstance.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN;\n{% endcodeblock %}\n\n3、配置中的有优先级，config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。\n{% codeblock lang:javascript %}\n//创建一个实例的时候会使用libray目录中的默认配置\n//在这里timeout配置的值为0，来自于libray的默认值\nvar instance = axios.create();\n//回覆盖掉library的默认值\n//现在所有的请求都要等2.5S之后才会发出\ninstance.defaults.timeout = 2500;\n//这里的timeout回覆盖之前的2.5S变成5s\ninstance.get('/longRequest',{\n  timeout: 5000\n});\n{% endcodeblock %}\n\n>拦截器\n\n1、你可以在请求、响应在到达then/catch之前拦截他们\n{% codeblock lang:javascript %}\n//添加一个请求拦截器\naxios.interceptors.request.use(function(config){\n  //在请求发出之前进行一些操作\n  return config;\n},function(err){\n  //Do something with request error\n  return Promise.reject(error);\n});\n//添加一个响应拦截器\naxios.interceptors.response.use(function(res){\n  //在这里对返回的数据进行处理\n  return res;\n},function(err){\n  //Do something with response error\n  return Promise.reject(error);\n})\n{% endcodeblock %}\n\n2、取消拦截器\n{% codeblock lang:javascript %}\nvar myInterceptor = axios.interceptor.request.use(function(){/*....*/});\naxios.interceptors.request.eject(myInterceptor);\n{% endcodeblock %}\n\n3、给自定义的axios实例添加拦截器\n{% codeblock lang:javascript %}\nvar instance = axios.create();\ninstance.interceptors.request.use(function(){})\n{% endcodeblock %}\n\n>错误处理\n\n{% codeblock lang:javascript %}\naxios.get('/user/12345')\n  .catch(function(error){\n    if(error.response){\n      //请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内\n      console.log(error.response.data);\n      console.log(error.response.status);\n      console.log(error.response.header);\n    }else {\n      //一些错误是在设置请求的时候触发\n      console.log('Error',error.message);\n    }\n    console.log(error.config);\n  });\n{% endcodeblock %}\n\n>取消,你可以通过一个cancel token来取消一个请求\n\n1、你可以通过CancelToken.source工厂函数来创建一个cancel token\n{% codeblock lang:javascript %}\nvar CancelToken = axios.CancelToken;\nvar source = CancelToken.source();\n\naxios.get('/user/12345',{\n  cancelToken: source.token\n}).catch(function(thrown){\n  if(axios.isCancel(thrown)){\n    console.log('Request canceled',thrown.message);\n  }else {\n    //handle error\n  }\n});\n\n//取消请求（信息的参数可以设置的）\nsource.cance(\"操作被用户取消\");\n{% endcodeblock %}\n\n2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:\n{% codeblock lang:javascript %}\nvar cancelToken = axios.CancelToken;\nvar cance;\naxios.get('/user/12345',{\n  cancelToken: new CancelToken(function(c){\n    //这个executor函数接受一个cancel function作为参数\n    cancel = c;\n  })\n})\n//取消请求\ncancel();\n{% endcodeblock %}\n\n>使用 application/x-www-form-urlencoded 格式化,默认情况下，axios串联js对象为 JSON 格式。为了发送 application/x-wwww-form-urlencoded 格式数据，你可以使用一下的设置。在浏览器中你可以如下使用 URLSearchParams API:\n\n{% codeblock lang:javascript %}\nvar params = new URLSearchParams();\nparams.append('param1','value1');\nparams.append('param2','value2');\naxios.post('/foo',params);\n{% endcodeblock %}\n\n><font color=\"red\">URLSearchParams 不支持所有的浏览器</font>,polyfill可用（确保垫片在浏览器全局环境中）,同样还有其他方法，片段代码如下：\n\n{% codeblock lang:javascript %}\nvar qs = require('qs');\naxios.post('/foo', qs.stringify({'bar':123}));\n{% endcodeblock %}\n\n>如果在node环境中，可以使用以下querystring方法，代码片段如下：\n\n{% codeblock lang:javascript %}\nvar querystring = require('querystring');\naxios.post('http://something.com/', querystring.stringify({foo:'bar'}));\n{% endcodeblock %}\n\n>axios 基于原生的ES6 Promise 实现。如果环境不支持请使用es6-promise这个库来处理。","source":"_posts/2017-05-02.md","raw":"---\ntitle: 'axios基本使用介绍'\ncomments: true\ndate: 2017-05-02 18:56:15\ntags: \n    - 'javascript'\n    - 'ajax'\n---\n\naxios建议使用高版本浏览器，目前在手机端使用频繁，但是在低版本的安卓上其实是有兼容性问题的，安卓4.2就开始出问题了，主要是由于Promise不支持，需要额外引入兼容包来处理。并且axios也是vue官方推荐使用的库。\n\n{% codeblock lang:javascript %}\nrequire('es6-promise').polyfill();\n{% endcodeblock %}\n\n> 发送一个GET请求，代码示例如下：\n\n{% codeblock lang:javascript %}\n//通过给定的ID来发送请求\naxios.get('/user?ID=12345')\n  .then(function(response){\n    console.log(response);\n  })\n  .catch(function(err){\n    console.log(err);\n  });\n//以上请求也可以通过这种方式来发送\naxios.get('/user',{\n  params:{\n    ID:12345\n  }\n})\n.then(function(response){\n  console.log(response);\n})\n.catch(function(err){\n  console.log(err);\n});\n{% endcodeblock %}\n\n<!-- more -->\n\n> 发送一个POST请求，代码示例如下：\n\n{% codeblock lang:javascript %}\naxios.post('/user',{\n  firstName:'Fred',\n  lastName:'Flintstone'\n})\n.then(function(res){\n  console.log(res);\n})\n.catch(function(err){\n  console.log(err);\n});\n{% endcodeblock %}\n\n>一次性并发多个请求，代码示例如下：\n\n{% codeblock lang:javascript %}\nfunction getUserAccount(){\n  return axios.get('/user/12345');\n}\nfunction getUserPermissions(){\n  return axios.get('/user/12345/permissions');\n}\naxios.all([getUserAccount(),getUserPermissions()])\n  .then(axios.spread(function(acct,perms){\n    //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果\n  }))\n{% endcodeblock %}\n\n>axios可以通过配置（config）来发送请求，代码示例如下：\n\n{% codeblock lang:javascript %}\n//发送一个`POST`请求\naxios({\n    method:\"POST\",\n    url:'/user/12345',\n    data:{\n        firstName:\"Fred\",\n        lastName:\"Flintstone\"\n    }\n});\n{% endcodeblock %}\n\n>请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名,注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明\n\n{% codeblock lang:javascript %}\naxios.request(config);\naxios.get(url[,config]);\naxios.delete(url[,config]);\naxios.head(url[,config]);\naxios.post(url[,data[,config]]);\naxios.put(url[,data[,config]])\naxios.patch(url[,data[,config]])\n{% endcodeblock %}\n\n>并发请求（concurrency）,即是帮助处理并发请求的辅助函数\n\n{% codeblock lang:javascript %}\n//iterable是一个可以迭代的参数如数组等\naxios.all(iterable)\n//callback要等到所有请求都完成才会执行\naxios.spread(callback)\n{% endcodeblock %}\n\n>创建一个axios实例，并且可以自定义其配置\n\n1、axios.create([config])\n{% codeblock lang:javascript %}\nvar instance = axios.create({\n  baseURL:\"https://some-domain.com/api/\",\n  timeout:1000,\n  headers: {'X-Custom-Header':'foobar'}\n});\n{% endcodeblock %}\n\n2、实例的方法，注意已经定义的配置将和利用create创建的实例的配置合并\n{% codeblock lang:javascript %}\naxios#request(config)\naxios#get(url[,config])\naxios#delete(url[,config])\naxios#head(url[,config])\naxios#post(url[,data[,config]])\naxios#put(url[,data[,config]])\naxios#patch(url[,data[,config]])\n{% endcodeblock %}\n\n>请求的配置（request config），以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求\n\n{% codeblock lang:javascript %}\n{\n  //`url`是请求的服务器地址\n  url:'/user',\n  //`method`是请求资源的方式\n  method:'get'//default\n  //如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面\n  //当`url`是相对地址的时候，设置`baseURL`会非常的方便\n  baseURL:'https://some-domain.com/api/',\n  //`transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动\n  //该选项只适用于以下请求方式：`put/post/patch`\n  //数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream`\n  transformRequest:[function(data){\n    //在这里根据自己的需求改变数据\n    return data;\n  }],\n  //`transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动\n  transformResponse:[function(data){\n    //在这里根据自己的需求改变数据\n    return data;\n  }],\n  //`headers`选项是需要被发送的自定义请求头信息\n  headers: {'X-Requested-With':'XMLHttpRequest'},\n  //`params`选项是要随请求一起发送的请求参数----一般链接在URL后面\n  //他的类型必须是一个纯对象或者是URLSearchParams对象\n  params: {\n    ID:12345\n  },\n  //`paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化\n  //例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param)\n  paramsSerializer: function(params){\n    return Qs.stringify(params,{arrayFormat:'brackets'})\n  },\n  //`data`选项是作为一个请求体而需要被发送的数据\n  //该选项只适用于方法：`put/post/patch`\n  //当没有设置`transformRequest`选项时dada必须是以下几种类型之一\n  //string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams\n  //仅仅浏览器：FormData/File/Bold\n  //仅node:Stream\n  data {\n    firstName:\"Fred\"\n  },\n  //`timeout`选项定义了请求发出的延迟毫秒数\n  //如果请求花费的时间超过延迟的时间，那么请求会被终止\n\n  timeout:1000,\n  //`withCredentails`选项表明了是否是跨域请求\n  \n  withCredentials:false,//default\n  //`adapter`适配器选项允许自定义处理请求，这会使得测试变得方便\n  //返回一个promise,并提供验证返回\n  adapter: function(config){\n    /*..........*/\n  },\n  //`auth`表明HTTP基础的认证应该被使用，并提供证书\n  //这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息\n  auth: {\n    username:\"zhangsan\",\n    password: \"s00sdkf\"\n  },\n  //返回数据的格式\n  //其可选项是arraybuffer,blob,document,json,text,stream\n  responseType:'json',//default\n  //\n  xsrfCookieName: 'XSRF-TOKEN',//default\n  xsrfHeaderName:'X-XSRF-TOKEN',//default\n  //`onUploadProgress`上传进度事件\n  onUploadProgress:function(progressEvent){\n    //下载进度的事件\nonDownloadProgress:function(progressEvent){\n}\n  },\n  //相应内容的最大值\n  maxContentLength:2000,\n  //`validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise\n  //如果`validateStatus`返回true(或者设置为`null`或者`undefined`),那么promise的状态将会是resolved,否则其状态就是rejected\n  validateStatus:function(status){\n    return status >= 200 && status <300;//default\n  },\n  //`maxRedirects`定义了在nodejs中重定向的最大数量\n  maxRedirects: 5,//default\n  //`httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理\n  //keeyAlive在选项中没有被默认激活\n  httpAgent: new http.Agent({keeyAlive:true}),\n  httpsAgent: new https.Agent({keeyAlive:true}),\n  //proxy定义了主机名字和端口号，\n  //`auth`表明http基本认证应该与proxy代理链接，并提供证书\n  //这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的`Proxy-Authorization`  header\n  proxy: {\n    host:'127.0.0.1',\n    port: 9000,\n    auth: {\n      username:'skda',\n      password:'radsd'\n    }\n  },\n  //`cancelToken`定义了一个用于取消请求的cancel token\n  //详见cancelation部分\n  cancelToken: new cancelToken(function(cancel){\n\n  })\n}\n{% endcodeblock %}\n\n >请求返回的内容\n\n{% codeblock lang:javascript %}\n {\n  data:{},\n  status:200,\n  //从服务器返回的http状态文本\n  statusText:'OK',\n  //响应头信息\n  headers: {},\n  //`config`是在请求的时候的一些配置信息\n  config: {}\n}\n{% endcodeblock %}\n\n>默认配置\n\n1、全局默认配置\n{% codeblock lang:javascript %}\naxios.defaults.baseURL = 'http://api.exmple.com';\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\naxios.defaults.headers.post['content-Type'] = 'appliction/x-www-form-urlencoded';\n{% endcodeblock %}\n\n2、自定义的实例默认设置\n{% codeblock lang:javascript %}\n//当创建实例的时候配置默认配置\nvar instance = axios.create({\n    baseURL: 'https://api.example.com'\n});\n\n//当实例创建时候修改配置\ninstance.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN;\n{% endcodeblock %}\n\n3、配置中的有优先级，config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。\n{% codeblock lang:javascript %}\n//创建一个实例的时候会使用libray目录中的默认配置\n//在这里timeout配置的值为0，来自于libray的默认值\nvar instance = axios.create();\n//回覆盖掉library的默认值\n//现在所有的请求都要等2.5S之后才会发出\ninstance.defaults.timeout = 2500;\n//这里的timeout回覆盖之前的2.5S变成5s\ninstance.get('/longRequest',{\n  timeout: 5000\n});\n{% endcodeblock %}\n\n>拦截器\n\n1、你可以在请求、响应在到达then/catch之前拦截他们\n{% codeblock lang:javascript %}\n//添加一个请求拦截器\naxios.interceptors.request.use(function(config){\n  //在请求发出之前进行一些操作\n  return config;\n},function(err){\n  //Do something with request error\n  return Promise.reject(error);\n});\n//添加一个响应拦截器\naxios.interceptors.response.use(function(res){\n  //在这里对返回的数据进行处理\n  return res;\n},function(err){\n  //Do something with response error\n  return Promise.reject(error);\n})\n{% endcodeblock %}\n\n2、取消拦截器\n{% codeblock lang:javascript %}\nvar myInterceptor = axios.interceptor.request.use(function(){/*....*/});\naxios.interceptors.request.eject(myInterceptor);\n{% endcodeblock %}\n\n3、给自定义的axios实例添加拦截器\n{% codeblock lang:javascript %}\nvar instance = axios.create();\ninstance.interceptors.request.use(function(){})\n{% endcodeblock %}\n\n>错误处理\n\n{% codeblock lang:javascript %}\naxios.get('/user/12345')\n  .catch(function(error){\n    if(error.response){\n      //请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内\n      console.log(error.response.data);\n      console.log(error.response.status);\n      console.log(error.response.header);\n    }else {\n      //一些错误是在设置请求的时候触发\n      console.log('Error',error.message);\n    }\n    console.log(error.config);\n  });\n{% endcodeblock %}\n\n>取消,你可以通过一个cancel token来取消一个请求\n\n1、你可以通过CancelToken.source工厂函数来创建一个cancel token\n{% codeblock lang:javascript %}\nvar CancelToken = axios.CancelToken;\nvar source = CancelToken.source();\n\naxios.get('/user/12345',{\n  cancelToken: source.token\n}).catch(function(thrown){\n  if(axios.isCancel(thrown)){\n    console.log('Request canceled',thrown.message);\n  }else {\n    //handle error\n  }\n});\n\n//取消请求（信息的参数可以设置的）\nsource.cance(\"操作被用户取消\");\n{% endcodeblock %}\n\n2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:\n{% codeblock lang:javascript %}\nvar cancelToken = axios.CancelToken;\nvar cance;\naxios.get('/user/12345',{\n  cancelToken: new CancelToken(function(c){\n    //这个executor函数接受一个cancel function作为参数\n    cancel = c;\n  })\n})\n//取消请求\ncancel();\n{% endcodeblock %}\n\n>使用 application/x-www-form-urlencoded 格式化,默认情况下，axios串联js对象为 JSON 格式。为了发送 application/x-wwww-form-urlencoded 格式数据，你可以使用一下的设置。在浏览器中你可以如下使用 URLSearchParams API:\n\n{% codeblock lang:javascript %}\nvar params = new URLSearchParams();\nparams.append('param1','value1');\nparams.append('param2','value2');\naxios.post('/foo',params);\n{% endcodeblock %}\n\n><font color=\"red\">URLSearchParams 不支持所有的浏览器</font>,polyfill可用（确保垫片在浏览器全局环境中）,同样还有其他方法，片段代码如下：\n\n{% codeblock lang:javascript %}\nvar qs = require('qs');\naxios.post('/foo', qs.stringify({'bar':123}));\n{% endcodeblock %}\n\n>如果在node环境中，可以使用以下querystring方法，代码片段如下：\n\n{% codeblock lang:javascript %}\nvar querystring = require('querystring');\naxios.post('http://something.com/', querystring.stringify({foo:'bar'}));\n{% endcodeblock %}\n\n>axios 基于原生的ES6 Promise 实现。如果环境不支持请使用es6-promise这个库来处理。","slug":"2017-05-02","published":1,"updated":"2017-08-26T12:58:33.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36qu0005lmld5deopm8d","content":"<p>axios建议使用高版本浏览器，目前在手机端使用频繁，但是在低版本的安卓上其实是有兼容性问题的，安卓4.2就开始出问题了，主要是由于Promise不支持，需要额外引入兼容包来处理。并且axios也是vue官方推荐使用的库。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'es6-promise'</span>).polyfill();</div></pre></td></tr></table></figure>\n<blockquote>\n<p>发送一个GET请求，代码示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//通过给定的ID来发送请求</span></div><div class=\"line\">axios.get(<span class=\"string\">'/user?ID=12345'</span>)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(response);</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">  &#125;);</div><div class=\"line\"><span class=\"comment\">//以上请求也可以通过这种方式来发送</span></div><div class=\"line\">axios.get(<span class=\"string\">'/user'</span>,&#123;</div><div class=\"line\">  params:&#123;</div><div class=\"line\">    ID:<span class=\"number\">12345</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(response);</div><div class=\"line\">&#125;)</div><div class=\"line\">.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<blockquote>\n<p>发送一个POST请求，代码示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios.post(<span class=\"string\">'/user'</span>,&#123;</div><div class=\"line\">  firstName:<span class=\"string\">'Fred'</span>,</div><div class=\"line\">  lastName:<span class=\"string\">'Flintstone'</span></div><div class=\"line\">&#125;)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(res);</div><div class=\"line\">&#125;)</div><div class=\"line\">.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>一次性并发多个请求，代码示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserAccount</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/12345'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserPermissions</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/12345/permissions'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">axios.all([getUserAccount(),getUserPermissions()])</div><div class=\"line\">  .then(axios.spread(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">acct,perms</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果</span></div><div class=\"line\">  &#125;))</div></pre></td></tr></table></figure>\n<blockquote>\n<p>axios可以通过配置（config）来发送请求，代码示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发送一个`POST`请求</span></div><div class=\"line\">axios(&#123;</div><div class=\"line\">    method:<span class=\"string\">\"POST\"</span>,</div><div class=\"line\">    url:<span class=\"string\">'/user/12345'</span>,</div><div class=\"line\">    data:&#123;</div><div class=\"line\">        firstName:<span class=\"string\">\"Fred\"</span>,</div><div class=\"line\">        lastName:<span class=\"string\">\"Flintstone\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名,注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios.request(config);</div><div class=\"line\">axios.get(url[,config]);</div><div class=\"line\">axios.delete(url[,config]);</div><div class=\"line\">axios.head(url[,config]);</div><div class=\"line\">axios.post(url[,data[,config]]);</div><div class=\"line\">axios.put(url[,data[,config]])</div><div class=\"line\">axios.patch(url[,data[,config]])</div></pre></td></tr></table></figure>\n<blockquote>\n<p>并发请求（concurrency）,即是帮助处理并发请求的辅助函数</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//iterable是一个可以迭代的参数如数组等</span></div><div class=\"line\">axios.all(iterable)</div><div class=\"line\"><span class=\"comment\">//callback要等到所有请求都完成才会执行</span></div><div class=\"line\">axios.spread(callback)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>创建一个axios实例，并且可以自定义其配置</p>\n</blockquote>\n<p>1、axios.create([config])<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> instance = axios.create(&#123;</div><div class=\"line\">  baseURL:<span class=\"string\">\"https://some-domain.com/api/\"</span>,</div><div class=\"line\">  timeout:<span class=\"number\">1000</span>,</div><div class=\"line\">  headers: &#123;<span class=\"string\">'X-Custom-Header'</span>:<span class=\"string\">'foobar'</span>&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>2、实例的方法，注意已经定义的配置将和利用create创建的实例的配置合并<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios#request(config)</div><div class=\"line\">axios#get(url[,config])</div><div class=\"line\">axios#delete(url[,config])</div><div class=\"line\">axios#head(url[,config])</div><div class=\"line\">axios#post(url[,data[,config]])</div><div class=\"line\">axios#put(url[,data[,config]])</div><div class=\"line\">axios#patch(url[,data[,config]])</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>请求的配置（request config），以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"comment\">//`url`是请求的服务器地址</span></div><div class=\"line\">  url:<span class=\"string\">'/user'</span>,</div><div class=\"line\">  <span class=\"comment\">//`method`是请求资源的方式</span></div><div class=\"line\">  method:<span class=\"string\">'get'</span><span class=\"comment\">//default</span></div><div class=\"line\">  <span class=\"comment\">//如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面</span></div><div class=\"line\">  <span class=\"comment\">//当`url`是相对地址的时候，设置`baseURL`会非常的方便</span></div><div class=\"line\">  baseURL:<span class=\"string\">'https://some-domain.com/api/'</span>,</div><div class=\"line\">  <span class=\"comment\">//`transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动</span></div><div class=\"line\">  <span class=\"comment\">//该选项只适用于以下请求方式：`put/post/patch`</span></div><div class=\"line\">  <span class=\"comment\">//数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream`</span></div><div class=\"line\">  transformRequest:[<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//在这里根据自己的需求改变数据</span></div><div class=\"line\">    <span class=\"keyword\">return</span> data;</div><div class=\"line\">  &#125;],</div><div class=\"line\">  <span class=\"comment\">//`transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动</span></div><div class=\"line\">  transformResponse:[<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//在这里根据自己的需求改变数据</span></div><div class=\"line\">    <span class=\"keyword\">return</span> data;</div><div class=\"line\">  &#125;],</div><div class=\"line\">  <span class=\"comment\">//`headers`选项是需要被发送的自定义请求头信息</span></div><div class=\"line\">  headers: &#123;<span class=\"string\">'X-Requested-With'</span>:<span class=\"string\">'XMLHttpRequest'</span>&#125;,</div><div class=\"line\">  <span class=\"comment\">//`params`选项是要随请求一起发送的请求参数----一般链接在URL后面</span></div><div class=\"line\">  <span class=\"comment\">//他的类型必须是一个纯对象或者是URLSearchParams对象</span></div><div class=\"line\">  params: &#123;</div><div class=\"line\">    ID:<span class=\"number\">12345</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化</span></div><div class=\"line\">  <span class=\"comment\">//例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param)</span></div><div class=\"line\">  paramsSerializer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">params</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Qs.stringify(params,&#123;<span class=\"attr\">arrayFormat</span>:<span class=\"string\">'brackets'</span>&#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`data`选项是作为一个请求体而需要被发送的数据</span></div><div class=\"line\">  <span class=\"comment\">//该选项只适用于方法：`put/post/patch`</span></div><div class=\"line\">  <span class=\"comment\">//当没有设置`transformRequest`选项时dada必须是以下几种类型之一</span></div><div class=\"line\">  <span class=\"comment\">//string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams</span></div><div class=\"line\">  <span class=\"comment\">//仅仅浏览器：FormData/File/Bold</span></div><div class=\"line\">  <span class=\"comment\">//仅node:Stream</span></div><div class=\"line\">  data &#123;</div><div class=\"line\">    firstName:<span class=\"string\">\"Fred\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`timeout`选项定义了请求发出的延迟毫秒数</span></div><div class=\"line\">  <span class=\"comment\">//如果请求花费的时间超过延迟的时间，那么请求会被终止</span></div><div class=\"line\"></div><div class=\"line\">  timeout:<span class=\"number\">1000</span>,</div><div class=\"line\">  <span class=\"comment\">//`withCredentails`选项表明了是否是跨域请求</span></div><div class=\"line\">  </div><div class=\"line\">  withCredentials:<span class=\"literal\">false</span>,<span class=\"comment\">//default</span></div><div class=\"line\">  <span class=\"comment\">//`adapter`适配器选项允许自定义处理请求，这会使得测试变得方便</span></div><div class=\"line\">  <span class=\"comment\">//返回一个promise,并提供验证返回</span></div><div class=\"line\">  adapter: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">config</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">/*..........*/</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`auth`表明HTTP基础的认证应该被使用，并提供证书</span></div><div class=\"line\">  <span class=\"comment\">//这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息</span></div><div class=\"line\">  auth: &#123;</div><div class=\"line\">    username:<span class=\"string\">\"zhangsan\"</span>,</div><div class=\"line\">    password: <span class=\"string\">\"s00sdkf\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//返回数据的格式</span></div><div class=\"line\">  <span class=\"comment\">//其可选项是arraybuffer,blob,document,json,text,stream</span></div><div class=\"line\">  responseType:<span class=\"string\">'json'</span>,<span class=\"comment\">//default</span></div><div class=\"line\">  <span class=\"comment\">//</span></div><div class=\"line\">  xsrfCookieName: <span class=\"string\">'XSRF-TOKEN'</span>,<span class=\"comment\">//default</span></div><div class=\"line\">  xsrfHeaderName:<span class=\"string\">'X-XSRF-TOKEN'</span>,<span class=\"comment\">//default</span></div><div class=\"line\">  <span class=\"comment\">//`onUploadProgress`上传进度事件</span></div><div class=\"line\">  onUploadProgress:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">progressEvent</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//下载进度的事件</span></div><div class=\"line\">onDownloadProgress:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">progressEvent</span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//相应内容的最大值</span></div><div class=\"line\">  maxContentLength:<span class=\"number\">2000</span>,</div><div class=\"line\">  <span class=\"comment\">//`validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise</span></div><div class=\"line\">  <span class=\"comment\">//如果`validateStatus`返回true(或者设置为`null`或者`undefined`),那么promise的状态将会是resolved,否则其状态就是rejected</span></div><div class=\"line\">  validateStatus:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">status</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> status &gt;= <span class=\"number\">200</span> &amp;&amp; status &lt;<span class=\"number\">300</span>;<span class=\"comment\">//default</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`maxRedirects`定义了在nodejs中重定向的最大数量</span></div><div class=\"line\">  maxRedirects: <span class=\"number\">5</span>,<span class=\"comment\">//default</span></div><div class=\"line\">  <span class=\"comment\">//`httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理</span></div><div class=\"line\">  <span class=\"comment\">//keeyAlive在选项中没有被默认激活</span></div><div class=\"line\">  httpAgent: <span class=\"keyword\">new</span> http.Agent(&#123;<span class=\"attr\">keeyAlive</span>:<span class=\"literal\">true</span>&#125;),</div><div class=\"line\">  httpsAgent: <span class=\"keyword\">new</span> https.Agent(&#123;<span class=\"attr\">keeyAlive</span>:<span class=\"literal\">true</span>&#125;),</div><div class=\"line\">  <span class=\"comment\">//proxy定义了主机名字和端口号，</span></div><div class=\"line\">  <span class=\"comment\">//`auth`表明http基本认证应该与proxy代理链接，并提供证书</span></div><div class=\"line\">  <span class=\"comment\">//这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的`Proxy-Authorization`  header</span></div><div class=\"line\">  proxy: &#123;</div><div class=\"line\">    host:<span class=\"string\">'127.0.0.1'</span>,</div><div class=\"line\">    port: <span class=\"number\">9000</span>,</div><div class=\"line\">    auth: &#123;</div><div class=\"line\">      username:<span class=\"string\">'skda'</span>,</div><div class=\"line\">      password:<span class=\"string\">'radsd'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`cancelToken`定义了一个用于取消请求的cancel token</span></div><div class=\"line\">  <span class=\"comment\">//详见cancelation部分</span></div><div class=\"line\">  cancelToken: <span class=\"keyword\">new</span> cancelToken(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cancel</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>请求返回的内容</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> &#123;</div><div class=\"line\">  data:&#123;&#125;,</div><div class=\"line\">  status:<span class=\"number\">200</span>,</div><div class=\"line\">  <span class=\"comment\">//从服务器返回的http状态文本</span></div><div class=\"line\">  statusText:<span class=\"string\">'OK'</span>,</div><div class=\"line\">  <span class=\"comment\">//响应头信息</span></div><div class=\"line\">  headers: &#123;&#125;,</div><div class=\"line\">  <span class=\"comment\">//`config`是在请求的时候的一些配置信息</span></div><div class=\"line\">  config: &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>默认配置</p>\n</blockquote>\n<p>1、全局默认配置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios.defaults.baseURL = <span class=\"string\">'http://api.exmple.com'</span>;</div><div class=\"line\">axios.defaults.headers.common[<span class=\"string\">'Authorization'</span>] = AUTH_TOKEN;</div><div class=\"line\">axios.defaults.headers.post[<span class=\"string\">'content-Type'</span>] = <span class=\"string\">'appliction/x-www-form-urlencoded'</span>;</div></pre></td></tr></table></figure></p>\n<p>2、自定义的实例默认设置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//当创建实例的时候配置默认配置</span></div><div class=\"line\"><span class=\"keyword\">var</span> instance = axios.create(&#123;</div><div class=\"line\">    baseURL: <span class=\"string\">'https://api.example.com'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//当实例创建时候修改配置</span></div><div class=\"line\">instance.defaults.headers.common[<span class=\"string\">\"Authorization\"</span>] = AUTH_TOKEN;</div></pre></td></tr></table></figure></p>\n<p>3、配置中的有优先级，config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个实例的时候会使用libray目录中的默认配置</span></div><div class=\"line\"><span class=\"comment\">//在这里timeout配置的值为0，来自于libray的默认值</span></div><div class=\"line\"><span class=\"keyword\">var</span> instance = axios.create();</div><div class=\"line\"><span class=\"comment\">//回覆盖掉library的默认值</span></div><div class=\"line\"><span class=\"comment\">//现在所有的请求都要等2.5S之后才会发出</span></div><div class=\"line\">instance.defaults.timeout = <span class=\"number\">2500</span>;</div><div class=\"line\"><span class=\"comment\">//这里的timeout回覆盖之前的2.5S变成5s</span></div><div class=\"line\">instance.get(<span class=\"string\">'/longRequest'</span>,&#123;</div><div class=\"line\">  timeout: <span class=\"number\">5000</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>拦截器</p>\n</blockquote>\n<p>1、你可以在请求、响应在到达then/catch之前拦截他们<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//添加一个请求拦截器</span></div><div class=\"line\">axios.interceptors.request.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">config</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//在请求发出之前进行一些操作</span></div><div class=\"line\">  <span class=\"keyword\">return</span> config;</div><div class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//Do something with request error</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//添加一个响应拦截器</span></div><div class=\"line\">axios.interceptors.response.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//在这里对返回的数据进行处理</span></div><div class=\"line\">  <span class=\"keyword\">return</span> res;</div><div class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//Do something with response error</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>2、取消拦截器<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myInterceptor = axios.interceptor.request.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">/*....*/</span>&#125;);</div><div class=\"line\">axios.interceptors.request.eject(myInterceptor);</div></pre></td></tr></table></figure></p>\n<p>3、给自定义的axios实例添加拦截器<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> instance = axios.create();</div><div class=\"line\">instance.interceptors.request.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>错误处理</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios.get(<span class=\"string\">'/user/12345'</span>)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error.response)&#123;</div><div class=\"line\">      <span class=\"comment\">//请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内</span></div><div class=\"line\">      <span class=\"built_in\">console</span>.log(error.response.data);</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(error.response.status);</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(error.response.header);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">//一些错误是在设置请求的时候触发</span></div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Error'</span>,error.message);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(error.config);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>取消,你可以通过一个cancel token来取消一个请求</p>\n</blockquote>\n<p>1、你可以通过CancelToken.source工厂函数来创建一个cancel token<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CancelToken = axios.CancelToken;</div><div class=\"line\"><span class=\"keyword\">var</span> source = CancelToken.source();</div><div class=\"line\"></div><div class=\"line\">axios.get(<span class=\"string\">'/user/12345'</span>,&#123;</div><div class=\"line\">  cancelToken: source.token</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">thrown</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(axios.isCancel(thrown))&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Request canceled'</span>,thrown.message);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//handle error</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//取消请求（信息的参数可以设置的）</span></div><div class=\"line\">source.cance(<span class=\"string\">\"操作被用户取消\"</span>);</div></pre></td></tr></table></figure></p>\n<p>2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cancelToken = axios.CancelToken;</div><div class=\"line\"><span class=\"keyword\">var</span> cance;</div><div class=\"line\">axios.get(<span class=\"string\">'/user/12345'</span>,&#123;</div><div class=\"line\">  cancelToken: <span class=\"keyword\">new</span> CancelToken(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//这个executor函数接受一个cancel function作为参数</span></div><div class=\"line\">    cancel = c;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//取消请求</span></div><div class=\"line\">cancel();</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用 application/x-www-form-urlencoded 格式化,默认情况下，axios串联js对象为 JSON 格式。为了发送 application/x-wwww-form-urlencoded 格式数据，你可以使用一下的设置。在浏览器中你可以如下使用 URLSearchParams API:</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> params = <span class=\"keyword\">new</span> URLSearchParams();</div><div class=\"line\">params.append(<span class=\"string\">'param1'</span>,<span class=\"string\">'value1'</span>);</div><div class=\"line\">params.append(<span class=\"string\">'param2'</span>,<span class=\"string\">'value2'</span>);</div><div class=\"line\">axios.post(<span class=\"string\">'/foo'</span>,params);</div></pre></td></tr></table></figure>\n<blockquote>\n<p><font color=\"red\">URLSearchParams 不支持所有的浏览器</font>,polyfill可用（确保垫片在浏览器全局环境中）,同样还有其他方法，片段代码如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> qs = <span class=\"built_in\">require</span>(<span class=\"string\">'qs'</span>);</div><div class=\"line\">axios.post(<span class=\"string\">'/foo'</span>, qs.stringify(&#123;<span class=\"string\">'bar'</span>:<span class=\"number\">123</span>&#125;));</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果在node环境中，可以使用以下querystring方法，代码片段如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</div><div class=\"line\">axios.post(<span class=\"string\">'http://something.com/'</span>, querystring.stringify(&#123;<span class=\"attr\">foo</span>:<span class=\"string\">'bar'</span>&#125;));</div></pre></td></tr></table></figure>\n<blockquote>\n<p>axios 基于原生的ES6 Promise 实现。如果环境不支持请使用es6-promise这个库来处理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>axios建议使用高版本浏览器，目前在手机端使用频繁，但是在低版本的安卓上其实是有兼容性问题的，安卓4.2就开始出问题了，主要是由于Promise不支持，需要额外引入兼容包来处理。并且axios也是vue官方推荐使用的库。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'es6-promise'</span>).polyfill();</div></pre></td></tr></table></figure>\n<blockquote>\n<p>发送一个GET请求，代码示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//通过给定的ID来发送请求</span></div><div class=\"line\">axios.get(<span class=\"string\">'/user?ID=12345'</span>)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(response);</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">  &#125;);</div><div class=\"line\"><span class=\"comment\">//以上请求也可以通过这种方式来发送</span></div><div class=\"line\">axios.get(<span class=\"string\">'/user'</span>,&#123;</div><div class=\"line\">  params:&#123;</div><div class=\"line\">    ID:<span class=\"number\">12345</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(response);</div><div class=\"line\">&#125;)</div><div class=\"line\">.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>","more":"<blockquote>\n<p>发送一个POST请求，代码示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios.post(<span class=\"string\">'/user'</span>,&#123;</div><div class=\"line\">  firstName:<span class=\"string\">'Fred'</span>,</div><div class=\"line\">  lastName:<span class=\"string\">'Flintstone'</span></div><div class=\"line\">&#125;)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(res);</div><div class=\"line\">&#125;)</div><div class=\"line\">.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>一次性并发多个请求，代码示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserAccount</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/12345'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserPermissions</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/12345/permissions'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">axios.all([getUserAccount(),getUserPermissions()])</div><div class=\"line\">  .then(axios.spread(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">acct,perms</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果</span></div><div class=\"line\">  &#125;))</div></pre></td></tr></table></figure>\n<blockquote>\n<p>axios可以通过配置（config）来发送请求，代码示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发送一个`POST`请求</span></div><div class=\"line\">axios(&#123;</div><div class=\"line\">    method:<span class=\"string\">\"POST\"</span>,</div><div class=\"line\">    url:<span class=\"string\">'/user/12345'</span>,</div><div class=\"line\">    data:&#123;</div><div class=\"line\">        firstName:<span class=\"string\">\"Fred\"</span>,</div><div class=\"line\">        lastName:<span class=\"string\">\"Flintstone\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名,注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios.request(config);</div><div class=\"line\">axios.get(url[,config]);</div><div class=\"line\">axios.delete(url[,config]);</div><div class=\"line\">axios.head(url[,config]);</div><div class=\"line\">axios.post(url[,data[,config]]);</div><div class=\"line\">axios.put(url[,data[,config]])</div><div class=\"line\">axios.patch(url[,data[,config]])</div></pre></td></tr></table></figure>\n<blockquote>\n<p>并发请求（concurrency）,即是帮助处理并发请求的辅助函数</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//iterable是一个可以迭代的参数如数组等</span></div><div class=\"line\">axios.all(iterable)</div><div class=\"line\"><span class=\"comment\">//callback要等到所有请求都完成才会执行</span></div><div class=\"line\">axios.spread(callback)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>创建一个axios实例，并且可以自定义其配置</p>\n</blockquote>\n<p>1、axios.create([config])<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> instance = axios.create(&#123;</div><div class=\"line\">  baseURL:<span class=\"string\">\"https://some-domain.com/api/\"</span>,</div><div class=\"line\">  timeout:<span class=\"number\">1000</span>,</div><div class=\"line\">  headers: &#123;<span class=\"string\">'X-Custom-Header'</span>:<span class=\"string\">'foobar'</span>&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>2、实例的方法，注意已经定义的配置将和利用create创建的实例的配置合并<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios#request(config)</div><div class=\"line\">axios#get(url[,config])</div><div class=\"line\">axios#delete(url[,config])</div><div class=\"line\">axios#head(url[,config])</div><div class=\"line\">axios#post(url[,data[,config]])</div><div class=\"line\">axios#put(url[,data[,config]])</div><div class=\"line\">axios#patch(url[,data[,config]])</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>请求的配置（request config），以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"comment\">//`url`是请求的服务器地址</span></div><div class=\"line\">  url:<span class=\"string\">'/user'</span>,</div><div class=\"line\">  <span class=\"comment\">//`method`是请求资源的方式</span></div><div class=\"line\">  method:<span class=\"string\">'get'</span><span class=\"comment\">//default</span></div><div class=\"line\">  <span class=\"comment\">//如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面</span></div><div class=\"line\">  <span class=\"comment\">//当`url`是相对地址的时候，设置`baseURL`会非常的方便</span></div><div class=\"line\">  baseURL:<span class=\"string\">'https://some-domain.com/api/'</span>,</div><div class=\"line\">  <span class=\"comment\">//`transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动</span></div><div class=\"line\">  <span class=\"comment\">//该选项只适用于以下请求方式：`put/post/patch`</span></div><div class=\"line\">  <span class=\"comment\">//数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream`</span></div><div class=\"line\">  transformRequest:[<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//在这里根据自己的需求改变数据</span></div><div class=\"line\">    <span class=\"keyword\">return</span> data;</div><div class=\"line\">  &#125;],</div><div class=\"line\">  <span class=\"comment\">//`transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动</span></div><div class=\"line\">  transformResponse:[<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//在这里根据自己的需求改变数据</span></div><div class=\"line\">    <span class=\"keyword\">return</span> data;</div><div class=\"line\">  &#125;],</div><div class=\"line\">  <span class=\"comment\">//`headers`选项是需要被发送的自定义请求头信息</span></div><div class=\"line\">  headers: &#123;<span class=\"string\">'X-Requested-With'</span>:<span class=\"string\">'XMLHttpRequest'</span>&#125;,</div><div class=\"line\">  <span class=\"comment\">//`params`选项是要随请求一起发送的请求参数----一般链接在URL后面</span></div><div class=\"line\">  <span class=\"comment\">//他的类型必须是一个纯对象或者是URLSearchParams对象</span></div><div class=\"line\">  params: &#123;</div><div class=\"line\">    ID:<span class=\"number\">12345</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化</span></div><div class=\"line\">  <span class=\"comment\">//例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param)</span></div><div class=\"line\">  paramsSerializer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">params</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Qs.stringify(params,&#123;<span class=\"attr\">arrayFormat</span>:<span class=\"string\">'brackets'</span>&#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`data`选项是作为一个请求体而需要被发送的数据</span></div><div class=\"line\">  <span class=\"comment\">//该选项只适用于方法：`put/post/patch`</span></div><div class=\"line\">  <span class=\"comment\">//当没有设置`transformRequest`选项时dada必须是以下几种类型之一</span></div><div class=\"line\">  <span class=\"comment\">//string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams</span></div><div class=\"line\">  <span class=\"comment\">//仅仅浏览器：FormData/File/Bold</span></div><div class=\"line\">  <span class=\"comment\">//仅node:Stream</span></div><div class=\"line\">  data &#123;</div><div class=\"line\">    firstName:<span class=\"string\">\"Fred\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`timeout`选项定义了请求发出的延迟毫秒数</span></div><div class=\"line\">  <span class=\"comment\">//如果请求花费的时间超过延迟的时间，那么请求会被终止</span></div><div class=\"line\"></div><div class=\"line\">  timeout:<span class=\"number\">1000</span>,</div><div class=\"line\">  <span class=\"comment\">//`withCredentails`选项表明了是否是跨域请求</span></div><div class=\"line\">  </div><div class=\"line\">  withCredentials:<span class=\"literal\">false</span>,<span class=\"comment\">//default</span></div><div class=\"line\">  <span class=\"comment\">//`adapter`适配器选项允许自定义处理请求，这会使得测试变得方便</span></div><div class=\"line\">  <span class=\"comment\">//返回一个promise,并提供验证返回</span></div><div class=\"line\">  adapter: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">config</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">/*..........*/</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`auth`表明HTTP基础的认证应该被使用，并提供证书</span></div><div class=\"line\">  <span class=\"comment\">//这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息</span></div><div class=\"line\">  auth: &#123;</div><div class=\"line\">    username:<span class=\"string\">\"zhangsan\"</span>,</div><div class=\"line\">    password: <span class=\"string\">\"s00sdkf\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//返回数据的格式</span></div><div class=\"line\">  <span class=\"comment\">//其可选项是arraybuffer,blob,document,json,text,stream</span></div><div class=\"line\">  responseType:<span class=\"string\">'json'</span>,<span class=\"comment\">//default</span></div><div class=\"line\">  <span class=\"comment\">//</span></div><div class=\"line\">  xsrfCookieName: <span class=\"string\">'XSRF-TOKEN'</span>,<span class=\"comment\">//default</span></div><div class=\"line\">  xsrfHeaderName:<span class=\"string\">'X-XSRF-TOKEN'</span>,<span class=\"comment\">//default</span></div><div class=\"line\">  <span class=\"comment\">//`onUploadProgress`上传进度事件</span></div><div class=\"line\">  onUploadProgress:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">progressEvent</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//下载进度的事件</span></div><div class=\"line\">onDownloadProgress:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">progressEvent</span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//相应内容的最大值</span></div><div class=\"line\">  maxContentLength:<span class=\"number\">2000</span>,</div><div class=\"line\">  <span class=\"comment\">//`validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise</span></div><div class=\"line\">  <span class=\"comment\">//如果`validateStatus`返回true(或者设置为`null`或者`undefined`),那么promise的状态将会是resolved,否则其状态就是rejected</span></div><div class=\"line\">  validateStatus:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">status</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> status &gt;= <span class=\"number\">200</span> &amp;&amp; status &lt;<span class=\"number\">300</span>;<span class=\"comment\">//default</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`maxRedirects`定义了在nodejs中重定向的最大数量</span></div><div class=\"line\">  maxRedirects: <span class=\"number\">5</span>,<span class=\"comment\">//default</span></div><div class=\"line\">  <span class=\"comment\">//`httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理</span></div><div class=\"line\">  <span class=\"comment\">//keeyAlive在选项中没有被默认激活</span></div><div class=\"line\">  httpAgent: <span class=\"keyword\">new</span> http.Agent(&#123;<span class=\"attr\">keeyAlive</span>:<span class=\"literal\">true</span>&#125;),</div><div class=\"line\">  httpsAgent: <span class=\"keyword\">new</span> https.Agent(&#123;<span class=\"attr\">keeyAlive</span>:<span class=\"literal\">true</span>&#125;),</div><div class=\"line\">  <span class=\"comment\">//proxy定义了主机名字和端口号，</span></div><div class=\"line\">  <span class=\"comment\">//`auth`表明http基本认证应该与proxy代理链接，并提供证书</span></div><div class=\"line\">  <span class=\"comment\">//这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的`Proxy-Authorization`  header</span></div><div class=\"line\">  proxy: &#123;</div><div class=\"line\">    host:<span class=\"string\">'127.0.0.1'</span>,</div><div class=\"line\">    port: <span class=\"number\">9000</span>,</div><div class=\"line\">    auth: &#123;</div><div class=\"line\">      username:<span class=\"string\">'skda'</span>,</div><div class=\"line\">      password:<span class=\"string\">'radsd'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">//`cancelToken`定义了一个用于取消请求的cancel token</span></div><div class=\"line\">  <span class=\"comment\">//详见cancelation部分</span></div><div class=\"line\">  cancelToken: <span class=\"keyword\">new</span> cancelToken(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cancel</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>请求返回的内容</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> &#123;</div><div class=\"line\">  data:&#123;&#125;,</div><div class=\"line\">  status:<span class=\"number\">200</span>,</div><div class=\"line\">  <span class=\"comment\">//从服务器返回的http状态文本</span></div><div class=\"line\">  statusText:<span class=\"string\">'OK'</span>,</div><div class=\"line\">  <span class=\"comment\">//响应头信息</span></div><div class=\"line\">  headers: &#123;&#125;,</div><div class=\"line\">  <span class=\"comment\">//`config`是在请求的时候的一些配置信息</span></div><div class=\"line\">  config: &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>默认配置</p>\n</blockquote>\n<p>1、全局默认配置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios.defaults.baseURL = <span class=\"string\">'http://api.exmple.com'</span>;</div><div class=\"line\">axios.defaults.headers.common[<span class=\"string\">'Authorization'</span>] = AUTH_TOKEN;</div><div class=\"line\">axios.defaults.headers.post[<span class=\"string\">'content-Type'</span>] = <span class=\"string\">'appliction/x-www-form-urlencoded'</span>;</div></pre></td></tr></table></figure></p>\n<p>2、自定义的实例默认设置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//当创建实例的时候配置默认配置</span></div><div class=\"line\"><span class=\"keyword\">var</span> instance = axios.create(&#123;</div><div class=\"line\">    baseURL: <span class=\"string\">'https://api.example.com'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//当实例创建时候修改配置</span></div><div class=\"line\">instance.defaults.headers.common[<span class=\"string\">\"Authorization\"</span>] = AUTH_TOKEN;</div></pre></td></tr></table></figure></p>\n<p>3、配置中的有优先级，config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个实例的时候会使用libray目录中的默认配置</span></div><div class=\"line\"><span class=\"comment\">//在这里timeout配置的值为0，来自于libray的默认值</span></div><div class=\"line\"><span class=\"keyword\">var</span> instance = axios.create();</div><div class=\"line\"><span class=\"comment\">//回覆盖掉library的默认值</span></div><div class=\"line\"><span class=\"comment\">//现在所有的请求都要等2.5S之后才会发出</span></div><div class=\"line\">instance.defaults.timeout = <span class=\"number\">2500</span>;</div><div class=\"line\"><span class=\"comment\">//这里的timeout回覆盖之前的2.5S变成5s</span></div><div class=\"line\">instance.get(<span class=\"string\">'/longRequest'</span>,&#123;</div><div class=\"line\">  timeout: <span class=\"number\">5000</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>拦截器</p>\n</blockquote>\n<p>1、你可以在请求、响应在到达then/catch之前拦截他们<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//添加一个请求拦截器</span></div><div class=\"line\">axios.interceptors.request.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">config</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//在请求发出之前进行一些操作</span></div><div class=\"line\">  <span class=\"keyword\">return</span> config;</div><div class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//Do something with request error</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//添加一个响应拦截器</span></div><div class=\"line\">axios.interceptors.response.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//在这里对返回的数据进行处理</span></div><div class=\"line\">  <span class=\"keyword\">return</span> res;</div><div class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//Do something with response error</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>2、取消拦截器<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myInterceptor = axios.interceptor.request.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">/*....*/</span>&#125;);</div><div class=\"line\">axios.interceptors.request.eject(myInterceptor);</div></pre></td></tr></table></figure></p>\n<p>3、给自定义的axios实例添加拦截器<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> instance = axios.create();</div><div class=\"line\">instance.interceptors.request.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>错误处理</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios.get(<span class=\"string\">'/user/12345'</span>)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error.response)&#123;</div><div class=\"line\">      <span class=\"comment\">//请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内</span></div><div class=\"line\">      <span class=\"built_in\">console</span>.log(error.response.data);</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(error.response.status);</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(error.response.header);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">//一些错误是在设置请求的时候触发</span></div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Error'</span>,error.message);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(error.config);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>取消,你可以通过一个cancel token来取消一个请求</p>\n</blockquote>\n<p>1、你可以通过CancelToken.source工厂函数来创建一个cancel token<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CancelToken = axios.CancelToken;</div><div class=\"line\"><span class=\"keyword\">var</span> source = CancelToken.source();</div><div class=\"line\"></div><div class=\"line\">axios.get(<span class=\"string\">'/user/12345'</span>,&#123;</div><div class=\"line\">  cancelToken: source.token</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">thrown</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(axios.isCancel(thrown))&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Request canceled'</span>,thrown.message);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//handle error</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//取消请求（信息的参数可以设置的）</span></div><div class=\"line\">source.cance(<span class=\"string\">\"操作被用户取消\"</span>);</div></pre></td></tr></table></figure></p>\n<p>2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cancelToken = axios.CancelToken;</div><div class=\"line\"><span class=\"keyword\">var</span> cance;</div><div class=\"line\">axios.get(<span class=\"string\">'/user/12345'</span>,&#123;</div><div class=\"line\">  cancelToken: <span class=\"keyword\">new</span> CancelToken(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//这个executor函数接受一个cancel function作为参数</span></div><div class=\"line\">    cancel = c;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//取消请求</span></div><div class=\"line\">cancel();</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用 application/x-www-form-urlencoded 格式化,默认情况下，axios串联js对象为 JSON 格式。为了发送 application/x-wwww-form-urlencoded 格式数据，你可以使用一下的设置。在浏览器中你可以如下使用 URLSearchParams API:</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> params = <span class=\"keyword\">new</span> URLSearchParams();</div><div class=\"line\">params.append(<span class=\"string\">'param1'</span>,<span class=\"string\">'value1'</span>);</div><div class=\"line\">params.append(<span class=\"string\">'param2'</span>,<span class=\"string\">'value2'</span>);</div><div class=\"line\">axios.post(<span class=\"string\">'/foo'</span>,params);</div></pre></td></tr></table></figure>\n<blockquote>\n<p><font color=\"red\">URLSearchParams 不支持所有的浏览器</font>,polyfill可用（确保垫片在浏览器全局环境中）,同样还有其他方法，片段代码如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> qs = <span class=\"built_in\">require</span>(<span class=\"string\">'qs'</span>);</div><div class=\"line\">axios.post(<span class=\"string\">'/foo'</span>, qs.stringify(&#123;<span class=\"string\">'bar'</span>:<span class=\"number\">123</span>&#125;));</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果在node环境中，可以使用以下querystring方法，代码片段如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</div><div class=\"line\">axios.post(<span class=\"string\">'http://something.com/'</span>, querystring.stringify(&#123;<span class=\"attr\">foo</span>:<span class=\"string\">'bar'</span>&#125;));</div></pre></td></tr></table></figure>\n<blockquote>\n<p>axios 基于原生的ES6 Promise 实现。如果环境不支持请使用es6-promise这个库来处理。</p>\n</blockquote>"},{"title":"浅谈webworker的使用场景","comments":1,"date":"2017-05-07T13:09:11.000Z","_content":"\n### 一、webWorker之初体验\n\n在\"setTimeout那些事儿\"中，说到JavaScript是单线程。也就是同一时间只能做同一事情。\n\n也好理解，作为浏览器脚本语言，如果JavaScript不是单线程，那么就有点棘手了。比如，与用户交互或者对DOM进行操作时，在一个线程上修改某个DOM，另外的线程删除DOM，这时浏览器该如何抉择呢?\n\n所以，JavaScript是单线程也是有背景的。\n\n<!-- more -->\n\n\n如下：\n\n{% codeblock lang:html %}\n<!DOCTYPE html>\n    <head>\n        <title>singleThread</title>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n    </head>\n    <body>\n        <script>\n            //添加到任务队列中，待同步任务所处的‘执行栈’执行完毕，1秒后执行任务队列中的这个匿名函数\n            setTimeout(function(){\n                console.log('come on');\n            },1000);\n            //只要不关闭该alert，‘执行栈’就没结束，从而也就不会进入到任务队列中\n            alert('waiting');\n        </script>\n    </body>\n</html>\n{% endcodeblock %}\n\n但，HTML5引入了一个工作线程（webWorker）的概念。它允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。\n\n简而言之，就是允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。\n\n从而，可以用webWorker来处理一些比较耗时的计算。\n\n如下，主页面：\n\n{% codeblock lang:html %}\n<!DOCTYPE html>\n    <head>\n        <title>worker</title>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n        <script>\n            function init(){\n                //创建一个Worker对象，并向它传递将在新线程中执行的脚本url\n                var worker = new Worker('worker.js');\n                //接收worker传递过来的数据\n                worker.onmessage = function(event){\n                    document.getElementById('result').innerHTML+=event.data+\"<br/>\" ;\n                };\n            };\n        </script>\n    </head>\n    <body onload = \"init()\">\n        <div id=\"result\"></div>\n    </body>\n</html>\n{% endcodeblock %}\n\n下面是worker.js的内容:\n\n{% codeblock lang:javascript %}\nvar i = 0;\nfunction timedCount(){\n    for(var j = 0, sum = 0; j < 100; j++){\n        for(var i = 0; i < 100000000; i++){\n            sum+=i;\n        };\n    };\n    //将得到的sum发送回主线程\n    postMessage(sum);\n};\n//将执行timedCount前的时间，通过postMessage发送回主线程\npostMessage('Before computing, '+new Date());\ntimedCount();\n//结束timedCount后，将结束时间发送回主线程\npostMessage('After computing, ' +new Date());\n{% endcodeblock %}\n\n\n上面代码执行的流程是：创建的worker对象，并用onmessage方法接收worker.js里面postMessage传递过来的数据(event.data)，并将数据追加到div#result中。\n\n所以，执行上面的代码结果如下：\n\n![1](/webworker/1.png)\n\n待worker.js中的timedCount方法运算完后，执行postMessage操作，向主线程传数据，得图二。期间，并不影响主线程的运作。\n\n![2](webworker/2.png)\n\n\n\n### 二、webWorker之常用ＡＰＩ\n\n接下来，再来看看关于worker的常用API：\n\n#### 1、postMessage(data)\n\n子线程与主线程之间互相通信使用方法，传递的data为任意值。\n\n{% codeblock lang:javascript %}\n//worker = new Worker('url');\n//worker.postMessage传递给子线程数据，对象\nworker.postMessage({first:1,second:2});\n\n//子线程中也可以使用postMessage，如传递字符串\npostMessage(‘test’);\n{% endcodeblock %}\n\n#### 2、terminate()\n\n主线程中终止worker，此后无法再利用其进行消息传递。注意：一旦terminate后，无法重新启用，只能另外创建。\n\n{% codeblock lang:javascript %}\n//worker = new Worker('url');\nworker.terminate();\n{% endcodeblock %} \n\n如，主页面：\n\n{% codeblock lang:html %}\n<!DOCTYPE html>\n    <head>\n        <title>worker</title>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n        <script>\n            function init(){\n                var worker = new Worker('worker.js');\n                //每隔100毫秒，向子线程传递{name: 'monkey'}信息\n                setInterval(function(){\n                    worker.postMessage({name: 'monkey'});\n                },100);\n                //当主线程worker收到来自子线程的消息后，触发message事件\n                worker.onmessage = function(event){\n                    document.getElementById('result').innerHTML+=event.data+\"<br/>\" ;\n                    //主线程使用terminate方法中断与子线程来往，在浏览器中只能显示一次event.data\n                    worker.terminate();\n                };\n            };\n        </script>\n    </head>\n    <body onload = \"init()\">\n        <div id=\"result\"></div>\n    </body>\n</html>\n{% endcodeblock %} \n\n子线程worker.js代码：\n\n{% codeblock lang:javascript %}\n<script>\n//当主线程发来信息后，触发该message事件\nonmessage = function(event){\n    //向主线程发送event.data.name信息\n    postMessage(event.data.name);\n};\n</script>\n{% endcodeblock %} \n\n#### 3、message\n\n当有消息发送时，触发该事件。且，消息发送是双向的，消息内容可通过data来获取。\n\nmessage使用，可见terminate中的demo\n\n#### 4、error\n\n出错处理。且错误消息可以通过e.message来获取。\n\n如下：\n\n{% codeblock lang:javascript %}\n//worker = new Worker('url');\nworker.onerror = function(e){\n    //打印出错消息\n    console.log(e.message);\n    //中断与子线程的联系\n    worker.terminate();\n}\n{% endcodeblock %} \n\n另：worker线程从上到下同步运行它的代码，然后进入异步阶段来对事件及计时器响应，如果worker注册了message事件处理程序，只要其有可能触发，worker就一直在内存中，不会退出，所以通信完毕后得手动在主线程中terminate或者子线程中close掉，但如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，他就会退出。\n\n### 三、worker上下文\n先看下面这段代码：\n\n主页面：\n\n{% codeblock lang:javascript %}\n<!DOCTYPE html>\n    <head>\n        <title>worker</title>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n        <script>\n            function init(){\n                var worker = new Worker('worker.js');\n                //接收消息事件\n                worker.onmessage = function(event){\n                    console.log(event.data);\n                };\n                //错误信息事件\n                worker.onerror = function(e){\n                    console.log('erro: ' + e.message);\n                    //终止线程\n                    worker.terminate();\n                };\n            };\n        </script>\n    </head>\n    <body onload = \"init()\">\n        \n    </body>\n</html>\n{% endcodeblock %}\n\nworker.js\n\n{% codeblock lang:javascript %}\n//window对象的alert方法\nalert(1);\nonmessage = function(event){\n    //向主线程发送event.data.name信息\n    postMessage(event.data.name);\n};\n{% endcodeblock %}\n\n执行上面代码结果：\n\n![3](webworker/3.png)\n\n\n为什么会这样呢？原因是alert为window对象的方法，所以会报错undefined。\n\nworker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做WorkerGlobalScope的东东，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。\nWorkerGlobalScope作用域下的常用属性、方法如下：\n\n#### 1、self\n\n　　我们可以使用 WorkerGlobalScope 的 self 属性来或者这个对象本身的引用\n\n#### 2、location\n\n　　location 属性返回当线程被创建出来的时候与之关联的 WorkerLocation 对象，它表示用于初始化这个工作线程的脚步资源的绝对 URL，即使页面被多次重定向后，这个 URL 资源位置也不会改变。\n\n#### 3、close\n\n　　关闭当前线程，与terminate作用类似\n\n#### 4、importScripts\n\n　　我们可以通过importScripts()方法通过url在worker中加载库函数\n\n#### 5、XMLHttpRequest\n\n　　有了它，才能发出Ajax请求\n\n#### 6、setTimeout/setInterval以及addEventListener/postMessage\n\n### 四、关于worker\n我们可以做什么：\n\n　　1.可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信\n\n　　2.可以在worker中通过importScripts(url)加载另外的脚本文件\n\n　　3.可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval()\n\n　　4.可以使用XMLHttpRequest来发送请求\n\n　　5.可以访问navigator的部分属性\n\n局限性：\n\n　　1.不能跨域加载JS\n\n　　2.worker内代码不能访问DOM\n\n　　3.各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行\n\n　　4.IE这个新特性","source":"_posts/2017-05-07.md","raw":"---\ntitle: 浅谈webworker的使用场景\ncomments: true\ndate: 2017-05-07 21:09:11\ntags: \n    - 'javascript'\n---\n\n### 一、webWorker之初体验\n\n在\"setTimeout那些事儿\"中，说到JavaScript是单线程。也就是同一时间只能做同一事情。\n\n也好理解，作为浏览器脚本语言，如果JavaScript不是单线程，那么就有点棘手了。比如，与用户交互或者对DOM进行操作时，在一个线程上修改某个DOM，另外的线程删除DOM，这时浏览器该如何抉择呢?\n\n所以，JavaScript是单线程也是有背景的。\n\n<!-- more -->\n\n\n如下：\n\n{% codeblock lang:html %}\n<!DOCTYPE html>\n    <head>\n        <title>singleThread</title>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n    </head>\n    <body>\n        <script>\n            //添加到任务队列中，待同步任务所处的‘执行栈’执行完毕，1秒后执行任务队列中的这个匿名函数\n            setTimeout(function(){\n                console.log('come on');\n            },1000);\n            //只要不关闭该alert，‘执行栈’就没结束，从而也就不会进入到任务队列中\n            alert('waiting');\n        </script>\n    </body>\n</html>\n{% endcodeblock %}\n\n但，HTML5引入了一个工作线程（webWorker）的概念。它允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。\n\n简而言之，就是允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。\n\n从而，可以用webWorker来处理一些比较耗时的计算。\n\n如下，主页面：\n\n{% codeblock lang:html %}\n<!DOCTYPE html>\n    <head>\n        <title>worker</title>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n        <script>\n            function init(){\n                //创建一个Worker对象，并向它传递将在新线程中执行的脚本url\n                var worker = new Worker('worker.js');\n                //接收worker传递过来的数据\n                worker.onmessage = function(event){\n                    document.getElementById('result').innerHTML+=event.data+\"<br/>\" ;\n                };\n            };\n        </script>\n    </head>\n    <body onload = \"init()\">\n        <div id=\"result\"></div>\n    </body>\n</html>\n{% endcodeblock %}\n\n下面是worker.js的内容:\n\n{% codeblock lang:javascript %}\nvar i = 0;\nfunction timedCount(){\n    for(var j = 0, sum = 0; j < 100; j++){\n        for(var i = 0; i < 100000000; i++){\n            sum+=i;\n        };\n    };\n    //将得到的sum发送回主线程\n    postMessage(sum);\n};\n//将执行timedCount前的时间，通过postMessage发送回主线程\npostMessage('Before computing, '+new Date());\ntimedCount();\n//结束timedCount后，将结束时间发送回主线程\npostMessage('After computing, ' +new Date());\n{% endcodeblock %}\n\n\n上面代码执行的流程是：创建的worker对象，并用onmessage方法接收worker.js里面postMessage传递过来的数据(event.data)，并将数据追加到div#result中。\n\n所以，执行上面的代码结果如下：\n\n![1](/webworker/1.png)\n\n待worker.js中的timedCount方法运算完后，执行postMessage操作，向主线程传数据，得图二。期间，并不影响主线程的运作。\n\n![2](webworker/2.png)\n\n\n\n### 二、webWorker之常用ＡＰＩ\n\n接下来，再来看看关于worker的常用API：\n\n#### 1、postMessage(data)\n\n子线程与主线程之间互相通信使用方法，传递的data为任意值。\n\n{% codeblock lang:javascript %}\n//worker = new Worker('url');\n//worker.postMessage传递给子线程数据，对象\nworker.postMessage({first:1,second:2});\n\n//子线程中也可以使用postMessage，如传递字符串\npostMessage(‘test’);\n{% endcodeblock %}\n\n#### 2、terminate()\n\n主线程中终止worker，此后无法再利用其进行消息传递。注意：一旦terminate后，无法重新启用，只能另外创建。\n\n{% codeblock lang:javascript %}\n//worker = new Worker('url');\nworker.terminate();\n{% endcodeblock %} \n\n如，主页面：\n\n{% codeblock lang:html %}\n<!DOCTYPE html>\n    <head>\n        <title>worker</title>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n        <script>\n            function init(){\n                var worker = new Worker('worker.js');\n                //每隔100毫秒，向子线程传递{name: 'monkey'}信息\n                setInterval(function(){\n                    worker.postMessage({name: 'monkey'});\n                },100);\n                //当主线程worker收到来自子线程的消息后，触发message事件\n                worker.onmessage = function(event){\n                    document.getElementById('result').innerHTML+=event.data+\"<br/>\" ;\n                    //主线程使用terminate方法中断与子线程来往，在浏览器中只能显示一次event.data\n                    worker.terminate();\n                };\n            };\n        </script>\n    </head>\n    <body onload = \"init()\">\n        <div id=\"result\"></div>\n    </body>\n</html>\n{% endcodeblock %} \n\n子线程worker.js代码：\n\n{% codeblock lang:javascript %}\n<script>\n//当主线程发来信息后，触发该message事件\nonmessage = function(event){\n    //向主线程发送event.data.name信息\n    postMessage(event.data.name);\n};\n</script>\n{% endcodeblock %} \n\n#### 3、message\n\n当有消息发送时，触发该事件。且，消息发送是双向的，消息内容可通过data来获取。\n\nmessage使用，可见terminate中的demo\n\n#### 4、error\n\n出错处理。且错误消息可以通过e.message来获取。\n\n如下：\n\n{% codeblock lang:javascript %}\n//worker = new Worker('url');\nworker.onerror = function(e){\n    //打印出错消息\n    console.log(e.message);\n    //中断与子线程的联系\n    worker.terminate();\n}\n{% endcodeblock %} \n\n另：worker线程从上到下同步运行它的代码，然后进入异步阶段来对事件及计时器响应，如果worker注册了message事件处理程序，只要其有可能触发，worker就一直在内存中，不会退出，所以通信完毕后得手动在主线程中terminate或者子线程中close掉，但如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，他就会退出。\n\n### 三、worker上下文\n先看下面这段代码：\n\n主页面：\n\n{% codeblock lang:javascript %}\n<!DOCTYPE html>\n    <head>\n        <title>worker</title>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n        <script>\n            function init(){\n                var worker = new Worker('worker.js');\n                //接收消息事件\n                worker.onmessage = function(event){\n                    console.log(event.data);\n                };\n                //错误信息事件\n                worker.onerror = function(e){\n                    console.log('erro: ' + e.message);\n                    //终止线程\n                    worker.terminate();\n                };\n            };\n        </script>\n    </head>\n    <body onload = \"init()\">\n        \n    </body>\n</html>\n{% endcodeblock %}\n\nworker.js\n\n{% codeblock lang:javascript %}\n//window对象的alert方法\nalert(1);\nonmessage = function(event){\n    //向主线程发送event.data.name信息\n    postMessage(event.data.name);\n};\n{% endcodeblock %}\n\n执行上面代码结果：\n\n![3](webworker/3.png)\n\n\n为什么会这样呢？原因是alert为window对象的方法，所以会报错undefined。\n\nworker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做WorkerGlobalScope的东东，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。\nWorkerGlobalScope作用域下的常用属性、方法如下：\n\n#### 1、self\n\n　　我们可以使用 WorkerGlobalScope 的 self 属性来或者这个对象本身的引用\n\n#### 2、location\n\n　　location 属性返回当线程被创建出来的时候与之关联的 WorkerLocation 对象，它表示用于初始化这个工作线程的脚步资源的绝对 URL，即使页面被多次重定向后，这个 URL 资源位置也不会改变。\n\n#### 3、close\n\n　　关闭当前线程，与terminate作用类似\n\n#### 4、importScripts\n\n　　我们可以通过importScripts()方法通过url在worker中加载库函数\n\n#### 5、XMLHttpRequest\n\n　　有了它，才能发出Ajax请求\n\n#### 6、setTimeout/setInterval以及addEventListener/postMessage\n\n### 四、关于worker\n我们可以做什么：\n\n　　1.可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信\n\n　　2.可以在worker中通过importScripts(url)加载另外的脚本文件\n\n　　3.可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval()\n\n　　4.可以使用XMLHttpRequest来发送请求\n\n　　5.可以访问navigator的部分属性\n\n局限性：\n\n　　1.不能跨域加载JS\n\n　　2.worker内代码不能访问DOM\n\n　　3.各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行\n\n　　4.IE这个新特性","slug":"2017-05-07","published":1,"updated":"2017-08-26T12:58:33.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36qz0006lmldbnp1idcc","content":"<h3 id=\"一、webWorker之初体验\"><a href=\"#一、webWorker之初体验\" class=\"headerlink\" title=\"一、webWorker之初体验\"></a>一、webWorker之初体验</h3><p>在”setTimeout那些事儿”中，说到JavaScript是单线程。也就是同一时间只能做同一事情。</p>\n<p>也好理解，作为浏览器脚本语言，如果JavaScript不是单线程，那么就有点棘手了。比如，与用户交互或者对DOM进行操作时，在一个线程上修改某个DOM，另外的线程删除DOM，这时浏览器该如何抉择呢?</p>\n<p>所以，JavaScript是单线程也是有背景的。</p>\n<a id=\"more\"></a>\n<p>如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>singleThread<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=utf-8\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//添加到任务队列中，待同步任务所处的‘执行栈’执行完毕，1秒后执行任务队列中的这个匿名函数</span></span></div><div class=\"line\"><span class=\"javascript\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'come on'</span>);</span></div><div class=\"line\"><span class=\"undefined\">            &#125;,1000);</span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//只要不关闭该alert，‘执行栈’就没结束，从而也就不会进入到任务队列中</span></span></div><div class=\"line\"><span class=\"javascript\">            alert(<span class=\"string\">'waiting'</span>);</span></div><div class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>但，HTML5引入了一个工作线程（webWorker）的概念。它允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。</p>\n<p>简而言之，就是允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。</p>\n<p>从而，可以用webWorker来处理一些比较耗时的计算。</p>\n<p>如下，主页面：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>worker<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=utf-8\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//创建一个Worker对象，并向它传递将在新线程中执行的脚本url</span></span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>);</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//接收worker传递过来的数据</span></span></div><div class=\"line\"><span class=\"javascript\">                worker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'result'</span>).innerHTML+=event.data+<span class=\"string\">\"&lt;br/&gt;\"</span> ;</span></div><div class=\"line\"><span class=\"undefined\">                &#125;;</span></div><div class=\"line\"><span class=\"undefined\">            &#125;;</span></div><div class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span> = <span class=\"string\">\"init()\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"result\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>下面是worker.js的内容:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timedCount</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>; j &lt; <span class=\"number\">100</span>; j++)&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000000</span>; i++)&#123;</div><div class=\"line\">            sum+=i;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"comment\">//将得到的sum发送回主线程</span></div><div class=\"line\">    postMessage(sum);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">//将执行timedCount前的时间，通过postMessage发送回主线程</span></div><div class=\"line\">postMessage(<span class=\"string\">'Before computing, '</span>+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>());</div><div class=\"line\">timedCount();</div><div class=\"line\"><span class=\"comment\">//结束timedCount后，将结束时间发送回主线程</span></div><div class=\"line\">postMessage(<span class=\"string\">'After computing, '</span> +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>());</div></pre></td></tr></table></figure>\n<p>上面代码执行的流程是：创建的worker对象，并用onmessage方法接收worker.js里面postMessage传递过来的数据(event.data)，并将数据追加到div#result中。</p>\n<p>所以，执行上面的代码结果如下：</p>\n<p><img src=\"/webworker/1.png\" alt=\"1\"></p>\n<p>待worker.js中的timedCount方法运算完后，执行postMessage操作，向主线程传数据，得图二。期间，并不影响主线程的运作。</p>\n<p><img src=\"/2017-05-07/2.png\" alt=\"2\"></p>\n<h3 id=\"二、webWorker之常用API\"><a href=\"#二、webWorker之常用API\" class=\"headerlink\" title=\"二、webWorker之常用ＡＰＩ\"></a>二、webWorker之常用ＡＰＩ</h3><p>接下来，再来看看关于worker的常用API：</p>\n<h4 id=\"1、postMessage-data\"><a href=\"#1、postMessage-data\" class=\"headerlink\" title=\"1、postMessage(data)\"></a>1、postMessage(data)</h4><p>子线程与主线程之间互相通信使用方法，传递的data为任意值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//worker = new Worker('url');</span></div><div class=\"line\"><span class=\"comment\">//worker.postMessage传递给子线程数据，对象</span></div><div class=\"line\">worker.postMessage(&#123;<span class=\"attr\">first</span>:<span class=\"number\">1</span>,<span class=\"attr\">second</span>:<span class=\"number\">2</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//子线程中也可以使用postMessage，如传递字符串</span></div><div class=\"line\">postMessage(‘test’);</div></pre></td></tr></table></figure>\n<h4 id=\"2、terminate\"><a href=\"#2、terminate\" class=\"headerlink\" title=\"2、terminate()\"></a>2、terminate()</h4><p>主线程中终止worker，此后无法再利用其进行消息传递。注意：一旦terminate后，无法重新启用，只能另外创建。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//worker = new Worker('url');</span></div><div class=\"line\">worker.terminate();</div></pre></td></tr></table></figure> \n<p>如，主页面：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>worker<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=utf-8\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>);</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//每隔100毫秒，向子线程传递&#123;name: 'monkey'&#125;信息</span></span></div><div class=\"line\"><span class=\"javascript\">                setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                    worker.postMessage(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'monkey'</span>&#125;);</span></div><div class=\"line\"><span class=\"undefined\">                &#125;,100);</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//当主线程worker收到来自子线程的消息后，触发message事件</span></span></div><div class=\"line\"><span class=\"javascript\">                worker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'result'</span>).innerHTML+=event.data+<span class=\"string\">\"&lt;br/&gt;\"</span> ;</span></div><div class=\"line\"><span class=\"javascript\">                    <span class=\"comment\">//主线程使用terminate方法中断与子线程来往，在浏览器中只能显示一次event.data</span></span></div><div class=\"line\"><span class=\"undefined\">                    worker.terminate();</span></div><div class=\"line\"><span class=\"undefined\">                &#125;;</span></div><div class=\"line\"><span class=\"undefined\">            &#125;;</span></div><div class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span> = <span class=\"string\">\"init()\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"result\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure> \n<p>子线程worker.js代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\"><span class=\"comment\">//当主线程发来信息后，触发该message事件</span></div><div class=\"line\">onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//向主线程发送event.data.name信息</span></div><div class=\"line\">    postMessage(event.data.name);</div><div class=\"line\">&#125;;</div><div class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></div></pre></td></tr></table></figure> \n<h4 id=\"3、message\"><a href=\"#3、message\" class=\"headerlink\" title=\"3、message\"></a>3、message</h4><p>当有消息发送时，触发该事件。且，消息发送是双向的，消息内容可通过data来获取。</p>\n<p>message使用，可见terminate中的demo</p>\n<h4 id=\"4、error\"><a href=\"#4、error\" class=\"headerlink\" title=\"4、error\"></a>4、error</h4><p>出错处理。且错误消息可以通过e.message来获取。</p>\n<p>如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//worker = new Worker('url');</span></div><div class=\"line\">worker.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//打印出错消息</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(e.message);</div><div class=\"line\">    <span class=\"comment\">//中断与子线程的联系</span></div><div class=\"line\">    worker.terminate();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure> \n<p>另：worker线程从上到下同步运行它的代码，然后进入异步阶段来对事件及计时器响应，如果worker注册了message事件处理程序，只要其有可能触发，worker就一直在内存中，不会退出，所以通信完毕后得手动在主线程中terminate或者子线程中close掉，但如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，他就会退出。</p>\n<h3 id=\"三、worker上下文\"><a href=\"#三、worker上下文\" class=\"headerlink\" title=\"三、worker上下文\"></a>三、worker上下文</h3><p>先看下面这段代码：</p>\n<p>主页面：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">    &lt;head&gt;</div><div class=\"line\">        &lt;title&gt;worker&lt;<span class=\"regexp\">/title&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;meta http-equiv=\"Content-Type\" content=\"text/</span>html; charset=utf<span class=\"number\">-8</span><span class=\"string\">\"/&gt;</span></div><div class=\"line\"><span class=\"string\">        &lt;script&gt;</span></div><div class=\"line\"><span class=\"string\">            function init()&#123;</span></div><div class=\"line\"><span class=\"string\">                var worker = new Worker('worker.js');</span></div><div class=\"line\"><span class=\"string\">                //接收消息事件</span></div><div class=\"line\"><span class=\"string\">                worker.onmessage = function(event)&#123;</span></div><div class=\"line\"><span class=\"string\">                    console.log(event.data);</span></div><div class=\"line\"><span class=\"string\">                &#125;;</span></div><div class=\"line\"><span class=\"string\">                //错误信息事件</span></div><div class=\"line\"><span class=\"string\">                worker.onerror = function(e)&#123;</span></div><div class=\"line\"><span class=\"string\">                    console.log('erro: ' + e.message);</span></div><div class=\"line\"><span class=\"string\">                    //终止线程</span></div><div class=\"line\"><span class=\"string\">                    worker.terminate();</span></div><div class=\"line\"><span class=\"string\">                &#125;;</span></div><div class=\"line\"><span class=\"string\">            &#125;;</span></div><div class=\"line\"><span class=\"string\">        &lt;/script&gt;</span></div><div class=\"line\"><span class=\"string\">    &lt;/head&gt;</span></div><div class=\"line\"><span class=\"string\">    &lt;body onload = \"</span>init()<span class=\"string\">\"&gt;</span></div><div class=\"line\"><span class=\"string\">        </span></div><div class=\"line\"><span class=\"string\">    &lt;/body&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;/html&gt;</span></div></pre></td></tr></table></figure>\n<p>worker.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//window对象的alert方法</span></div><div class=\"line\">alert(<span class=\"number\">1</span>);</div><div class=\"line\">onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//向主线程发送event.data.name信息</span></div><div class=\"line\">    postMessage(event.data.name);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>执行上面代码结果：</p>\n<p><img src=\"/2017-05-07/3.png\" alt=\"3\"></p>\n<p>为什么会这样呢？原因是alert为window对象的方法，所以会报错undefined。</p>\n<p>worker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做WorkerGlobalScope的东东，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。<br>WorkerGlobalScope作用域下的常用属性、方法如下：</p>\n<h4 id=\"1、self\"><a href=\"#1、self\" class=\"headerlink\" title=\"1、self\"></a>1、self</h4><p>　　我们可以使用 WorkerGlobalScope 的 self 属性来或者这个对象本身的引用</p>\n<h4 id=\"2、location\"><a href=\"#2、location\" class=\"headerlink\" title=\"2、location\"></a>2、location</h4><p>　　location 属性返回当线程被创建出来的时候与之关联的 WorkerLocation 对象，它表示用于初始化这个工作线程的脚步资源的绝对 URL，即使页面被多次重定向后，这个 URL 资源位置也不会改变。</p>\n<h4 id=\"3、close\"><a href=\"#3、close\" class=\"headerlink\" title=\"3、close\"></a>3、close</h4><p>　　关闭当前线程，与terminate作用类似</p>\n<h4 id=\"4、importScripts\"><a href=\"#4、importScripts\" class=\"headerlink\" title=\"4、importScripts\"></a>4、importScripts</h4><p>　　我们可以通过importScripts()方法通过url在worker中加载库函数</p>\n<h4 id=\"5、XMLHttpRequest\"><a href=\"#5、XMLHttpRequest\" class=\"headerlink\" title=\"5、XMLHttpRequest\"></a>5、XMLHttpRequest</h4><p>　　有了它，才能发出Ajax请求</p>\n<h4 id=\"6、setTimeout-setInterval以及addEventListener-postMessage\"><a href=\"#6、setTimeout-setInterval以及addEventListener-postMessage\" class=\"headerlink\" title=\"6、setTimeout/setInterval以及addEventListener/postMessage\"></a>6、setTimeout/setInterval以及addEventListener/postMessage</h4><h3 id=\"四、关于worker\"><a href=\"#四、关于worker\" class=\"headerlink\" title=\"四、关于worker\"></a>四、关于worker</h3><p>我们可以做什么：</p>\n<p>　　1.可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信</p>\n<p>　　2.可以在worker中通过importScripts(url)加载另外的脚本文件</p>\n<p>　　3.可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval()</p>\n<p>　　4.可以使用XMLHttpRequest来发送请求</p>\n<p>　　5.可以访问navigator的部分属性</p>\n<p>局限性：</p>\n<p>　　1.不能跨域加载JS</p>\n<p>　　2.worker内代码不能访问DOM</p>\n<p>　　3.各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行</p>\n<p>　　4.IE这个新特性</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、webWorker之初体验\"><a href=\"#一、webWorker之初体验\" class=\"headerlink\" title=\"一、webWorker之初体验\"></a>一、webWorker之初体验</h3><p>在”setTimeout那些事儿”中，说到JavaScript是单线程。也就是同一时间只能做同一事情。</p>\n<p>也好理解，作为浏览器脚本语言，如果JavaScript不是单线程，那么就有点棘手了。比如，与用户交互或者对DOM进行操作时，在一个线程上修改某个DOM，另外的线程删除DOM，这时浏览器该如何抉择呢?</p>\n<p>所以，JavaScript是单线程也是有背景的。</p>","more":"<p>如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>singleThread<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=utf-8\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//添加到任务队列中，待同步任务所处的‘执行栈’执行完毕，1秒后执行任务队列中的这个匿名函数</span></span></div><div class=\"line\"><span class=\"javascript\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'come on'</span>);</span></div><div class=\"line\"><span class=\"undefined\">            &#125;,1000);</span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//只要不关闭该alert，‘执行栈’就没结束，从而也就不会进入到任务队列中</span></span></div><div class=\"line\"><span class=\"javascript\">            alert(<span class=\"string\">'waiting'</span>);</span></div><div class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>但，HTML5引入了一个工作线程（webWorker）的概念。它允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。</p>\n<p>简而言之，就是允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。</p>\n<p>从而，可以用webWorker来处理一些比较耗时的计算。</p>\n<p>如下，主页面：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>worker<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=utf-8\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//创建一个Worker对象，并向它传递将在新线程中执行的脚本url</span></span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>);</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//接收worker传递过来的数据</span></span></div><div class=\"line\"><span class=\"javascript\">                worker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'result'</span>).innerHTML+=event.data+<span class=\"string\">\"&lt;br/&gt;\"</span> ;</span></div><div class=\"line\"><span class=\"undefined\">                &#125;;</span></div><div class=\"line\"><span class=\"undefined\">            &#125;;</span></div><div class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span> = <span class=\"string\">\"init()\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"result\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>下面是worker.js的内容:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timedCount</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>; j &lt; <span class=\"number\">100</span>; j++)&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000000</span>; i++)&#123;</div><div class=\"line\">            sum+=i;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"comment\">//将得到的sum发送回主线程</span></div><div class=\"line\">    postMessage(sum);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">//将执行timedCount前的时间，通过postMessage发送回主线程</span></div><div class=\"line\">postMessage(<span class=\"string\">'Before computing, '</span>+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>());</div><div class=\"line\">timedCount();</div><div class=\"line\"><span class=\"comment\">//结束timedCount后，将结束时间发送回主线程</span></div><div class=\"line\">postMessage(<span class=\"string\">'After computing, '</span> +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>());</div></pre></td></tr></table></figure>\n<p>上面代码执行的流程是：创建的worker对象，并用onmessage方法接收worker.js里面postMessage传递过来的数据(event.data)，并将数据追加到div#result中。</p>\n<p>所以，执行上面的代码结果如下：</p>\n<p><img src=\"/webworker/1.png\" alt=\"1\"></p>\n<p>待worker.js中的timedCount方法运算完后，执行postMessage操作，向主线程传数据，得图二。期间，并不影响主线程的运作。</p>\n<p><img src=\"/2017-05-07/2.png\" alt=\"2\"></p>\n<h3 id=\"二、webWorker之常用API\"><a href=\"#二、webWorker之常用API\" class=\"headerlink\" title=\"二、webWorker之常用ＡＰＩ\"></a>二、webWorker之常用ＡＰＩ</h3><p>接下来，再来看看关于worker的常用API：</p>\n<h4 id=\"1、postMessage-data\"><a href=\"#1、postMessage-data\" class=\"headerlink\" title=\"1、postMessage(data)\"></a>1、postMessage(data)</h4><p>子线程与主线程之间互相通信使用方法，传递的data为任意值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//worker = new Worker('url');</span></div><div class=\"line\"><span class=\"comment\">//worker.postMessage传递给子线程数据，对象</span></div><div class=\"line\">worker.postMessage(&#123;<span class=\"attr\">first</span>:<span class=\"number\">1</span>,<span class=\"attr\">second</span>:<span class=\"number\">2</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//子线程中也可以使用postMessage，如传递字符串</span></div><div class=\"line\">postMessage(‘test’);</div></pre></td></tr></table></figure>\n<h4 id=\"2、terminate\"><a href=\"#2、terminate\" class=\"headerlink\" title=\"2、terminate()\"></a>2、terminate()</h4><p>主线程中终止worker，此后无法再利用其进行消息传递。注意：一旦terminate后，无法重新启用，只能另外创建。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//worker = new Worker('url');</span></div><div class=\"line\">worker.terminate();</div></pre></td></tr></table></figure> \n<p>如，主页面：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>worker<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=utf-8\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>);</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//每隔100毫秒，向子线程传递&#123;name: 'monkey'&#125;信息</span></span></div><div class=\"line\"><span class=\"javascript\">                setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                    worker.postMessage(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'monkey'</span>&#125;);</span></div><div class=\"line\"><span class=\"undefined\">                &#125;,100);</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//当主线程worker收到来自子线程的消息后，触发message事件</span></span></div><div class=\"line\"><span class=\"javascript\">                worker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">                    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'result'</span>).innerHTML+=event.data+<span class=\"string\">\"&lt;br/&gt;\"</span> ;</span></div><div class=\"line\"><span class=\"javascript\">                    <span class=\"comment\">//主线程使用terminate方法中断与子线程来往，在浏览器中只能显示一次event.data</span></span></div><div class=\"line\"><span class=\"undefined\">                    worker.terminate();</span></div><div class=\"line\"><span class=\"undefined\">                &#125;;</span></div><div class=\"line\"><span class=\"undefined\">            &#125;;</span></div><div class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span> = <span class=\"string\">\"init()\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"result\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure> \n<p>子线程worker.js代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\"><span class=\"comment\">//当主线程发来信息后，触发该message事件</span></div><div class=\"line\">onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//向主线程发送event.data.name信息</span></div><div class=\"line\">    postMessage(event.data.name);</div><div class=\"line\">&#125;;</div><div class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></div></pre></td></tr></table></figure> \n<h4 id=\"3、message\"><a href=\"#3、message\" class=\"headerlink\" title=\"3、message\"></a>3、message</h4><p>当有消息发送时，触发该事件。且，消息发送是双向的，消息内容可通过data来获取。</p>\n<p>message使用，可见terminate中的demo</p>\n<h4 id=\"4、error\"><a href=\"#4、error\" class=\"headerlink\" title=\"4、error\"></a>4、error</h4><p>出错处理。且错误消息可以通过e.message来获取。</p>\n<p>如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//worker = new Worker('url');</span></div><div class=\"line\">worker.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//打印出错消息</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(e.message);</div><div class=\"line\">    <span class=\"comment\">//中断与子线程的联系</span></div><div class=\"line\">    worker.terminate();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure> \n<p>另：worker线程从上到下同步运行它的代码，然后进入异步阶段来对事件及计时器响应，如果worker注册了message事件处理程序，只要其有可能触发，worker就一直在内存中，不会退出，所以通信完毕后得手动在主线程中terminate或者子线程中close掉，但如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，他就会退出。</p>\n<h3 id=\"三、worker上下文\"><a href=\"#三、worker上下文\" class=\"headerlink\" title=\"三、worker上下文\"></a>三、worker上下文</h3><p>先看下面这段代码：</p>\n<p>主页面：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">    &lt;head&gt;</div><div class=\"line\">        &lt;title&gt;worker&lt;<span class=\"regexp\">/title&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;meta http-equiv=\"Content-Type\" content=\"text/</span>html; charset=utf<span class=\"number\">-8</span><span class=\"string\">\"/&gt;</span></div><div class=\"line\"><span class=\"string\">        &lt;script&gt;</span></div><div class=\"line\"><span class=\"string\">            function init()&#123;</span></div><div class=\"line\"><span class=\"string\">                var worker = new Worker('worker.js');</span></div><div class=\"line\"><span class=\"string\">                //接收消息事件</span></div><div class=\"line\"><span class=\"string\">                worker.onmessage = function(event)&#123;</span></div><div class=\"line\"><span class=\"string\">                    console.log(event.data);</span></div><div class=\"line\"><span class=\"string\">                &#125;;</span></div><div class=\"line\"><span class=\"string\">                //错误信息事件</span></div><div class=\"line\"><span class=\"string\">                worker.onerror = function(e)&#123;</span></div><div class=\"line\"><span class=\"string\">                    console.log('erro: ' + e.message);</span></div><div class=\"line\"><span class=\"string\">                    //终止线程</span></div><div class=\"line\"><span class=\"string\">                    worker.terminate();</span></div><div class=\"line\"><span class=\"string\">                &#125;;</span></div><div class=\"line\"><span class=\"string\">            &#125;;</span></div><div class=\"line\"><span class=\"string\">        &lt;/script&gt;</span></div><div class=\"line\"><span class=\"string\">    &lt;/head&gt;</span></div><div class=\"line\"><span class=\"string\">    &lt;body onload = \"</span>init()<span class=\"string\">\"&gt;</span></div><div class=\"line\"><span class=\"string\">        </span></div><div class=\"line\"><span class=\"string\">    &lt;/body&gt;</span></div><div class=\"line\"><span class=\"string\">&lt;/html&gt;</span></div></pre></td></tr></table></figure>\n<p>worker.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//window对象的alert方法</span></div><div class=\"line\">alert(<span class=\"number\">1</span>);</div><div class=\"line\">onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//向主线程发送event.data.name信息</span></div><div class=\"line\">    postMessage(event.data.name);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>执行上面代码结果：</p>\n<p><img src=\"/2017-05-07/3.png\" alt=\"3\"></p>\n<p>为什么会这样呢？原因是alert为window对象的方法，所以会报错undefined。</p>\n<p>worker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做WorkerGlobalScope的东东，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。<br>WorkerGlobalScope作用域下的常用属性、方法如下：</p>\n<h4 id=\"1、self\"><a href=\"#1、self\" class=\"headerlink\" title=\"1、self\"></a>1、self</h4><p>　　我们可以使用 WorkerGlobalScope 的 self 属性来或者这个对象本身的引用</p>\n<h4 id=\"2、location\"><a href=\"#2、location\" class=\"headerlink\" title=\"2、location\"></a>2、location</h4><p>　　location 属性返回当线程被创建出来的时候与之关联的 WorkerLocation 对象，它表示用于初始化这个工作线程的脚步资源的绝对 URL，即使页面被多次重定向后，这个 URL 资源位置也不会改变。</p>\n<h4 id=\"3、close\"><a href=\"#3、close\" class=\"headerlink\" title=\"3、close\"></a>3、close</h4><p>　　关闭当前线程，与terminate作用类似</p>\n<h4 id=\"4、importScripts\"><a href=\"#4、importScripts\" class=\"headerlink\" title=\"4、importScripts\"></a>4、importScripts</h4><p>　　我们可以通过importScripts()方法通过url在worker中加载库函数</p>\n<h4 id=\"5、XMLHttpRequest\"><a href=\"#5、XMLHttpRequest\" class=\"headerlink\" title=\"5、XMLHttpRequest\"></a>5、XMLHttpRequest</h4><p>　　有了它，才能发出Ajax请求</p>\n<h4 id=\"6、setTimeout-setInterval以及addEventListener-postMessage\"><a href=\"#6、setTimeout-setInterval以及addEventListener-postMessage\" class=\"headerlink\" title=\"6、setTimeout/setInterval以及addEventListener/postMessage\"></a>6、setTimeout/setInterval以及addEventListener/postMessage</h4><h3 id=\"四、关于worker\"><a href=\"#四、关于worker\" class=\"headerlink\" title=\"四、关于worker\"></a>四、关于worker</h3><p>我们可以做什么：</p>\n<p>　　1.可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信</p>\n<p>　　2.可以在worker中通过importScripts(url)加载另外的脚本文件</p>\n<p>　　3.可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval()</p>\n<p>　　4.可以使用XMLHttpRequest来发送请求</p>\n<p>　　5.可以访问navigator的部分属性</p>\n<p>局限性：</p>\n<p>　　1.不能跨域加载JS</p>\n<p>　　2.worker内代码不能访问DOM</p>\n<p>　　3.各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行</p>\n<p>　　4.IE这个新特性</p>"},{"title":"React深入浅出系列--如何理解JSX","comments":1,"date":"2017-06-10T13:09:11.000Z","_content":"\n### 1、JSX介绍\n\n所谓JSX,是javascript的语法扩展，并不是一门新的编程语言，看起来有点像XML，让我们在javascript中可以编写像HTML一样的代码。例如以下示例代码：\n{% codeblock lang:javascript %}\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <div className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h2>Welcome to React</h2>\n        </div>\n      </div>\n    );\n  }\n}\n{% endcodeblock %}\nJSX中的这几段代码看起来和HTML几乎一模一样，可以使用div,button之类的标签，但是，JSX和HTML之间还是有不同之处。\n\n<!-- more -->\n>注意：React判断一个元素HTNML元素还是React组件的原则就是看第一个字母是否大写，小写的话，React会认为是HTML标签\n\n{% codeblock lang:javascript %}\nclass App extends Component {\n  render() {\n    return (\n      <hello/> //默认认为是html标签，错误写法\n      <Hello/> //默认是自定义Hello组件\n    );\n  }\n}\n{% endcodeblock %}\n\n### 2、事件绑定\n\n在早期时候绑定事件写法如下：\n{% codeblock lang:javascript %}\n  <button onclick=\"checkAndSubmit(this.form)\">Submit</button>\n{% endcodeblock %}\n随着业务不断复杂，虽然这种写法便于阅读，但是复杂的业务加上复杂的DOM结构，为了html和js解耦，所以绑定事件写法有如下变化，通过获取DOM节点，通过代理机制来绑定事件：\n{% codeblock lang:javascript %}\n  $('#my-button').on('click', this.checkAndSubmit.bind(this));\n{% endcodeblock %}\n然而react中的JSX绑定事件的写法格式如下：\n{% codeblock lang:javascript %}\n  <button onClick={this.checkAndSubmit.bind(this)}>Submit</button>\n{% endcodeblock %}\n>大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。<font color=\"red\">注意：在真正开发中，并不提倡给在组件添加事件中bind（this）这种写法，一般会在constructor的时候就绑定上下文this，这样在组件里面就不会因为多次绑定this而造成内存泄露。</font>\n\n### 3、JSX绑定事件和html绑定事件的区别\n\n  <b>在html添加事件有如下问题：</b>\n\n  1、在html中使用onclick添加的事件处理函数是在全局环境下执行的，这样会污染全局环境，很容易产生意料不到的后果。\n\n  2、给多个DOM添加onclick事件，可能会影响网页性能，毕竟，网页需要的事件处理函数越多，性能就会越低。\n\n  3、对于使用onclick的DOM元素，如果要动态地从DOM树中删掉的话，需要把对应的时间处理器注销，假如忘了注销，就可能造成内存泄露，这样的bug很难被发现。\n\n  <b>以上说的这些问题在JSX中都不存在，其有如下特点：</b>\n\n  1、JSX中添加onclick事件并没有直接在相应的html中添加事件，而是使用了事件委托的方式处理点击事件，无论有多少个onclick的出现，其实最后都只在DOM树上添加一个事件处理函数，并挂载在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定的函数，使用事件委托的性能比为每一个onclick都挂载一个事件函数要高。\n\n  2、jsx中同样可以添加自定义样式，外层定义一个样式对象，然后在jsx中将对象赋值给相应的dom上，这样真正意义上组件封装的思想（html，css，js在一起），提高复用性，大致写法如下：\n{% codeblock lang:javascript %}\nclass App extends Component {\n  render() {\n    const Style = {\n      margin:'10px'\n    }\n    return (\n      <div style={Style}>\n        <p>测试文字</p>\n      </div>\n    );\n  }\n}\n{% endcodeblock %}\n\n### 4、JSX编译\n\nJSX是一种新的语法，浏览器并不能直接运行，因此需要这种翻译器。这里我们推荐使用Babel编译JSX，打包编译建议使用Webpack，大致配置如下：\n{% codeblock lang:javascript %}\nmodule: {\n  loaders: [\n    { test: /\\.jsx?$/, loaders: ['babel-loader']}\n  ]\n}\n{% endcodeblock %}\n\n本文主要介绍JSX优势所在，在添加事件上性能高于普通的html添加事件形式，组件方式的开发模式，更利于代码的通用性和维护性，下一篇将为大家介绍React的理念／Virtual DOM／工作方式的优点。","source":"_posts/2017-06-10.md","raw":"---\ntitle: React深入浅出系列--如何理解JSX\ncomments: true\ndate: 2017-06-10 21:09:11\ntags: \n    - 'javascript'\n    - 'react'\n---\n\n### 1、JSX介绍\n\n所谓JSX,是javascript的语法扩展，并不是一门新的编程语言，看起来有点像XML，让我们在javascript中可以编写像HTML一样的代码。例如以下示例代码：\n{% codeblock lang:javascript %}\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <div className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h2>Welcome to React</h2>\n        </div>\n      </div>\n    );\n  }\n}\n{% endcodeblock %}\nJSX中的这几段代码看起来和HTML几乎一模一样，可以使用div,button之类的标签，但是，JSX和HTML之间还是有不同之处。\n\n<!-- more -->\n>注意：React判断一个元素HTNML元素还是React组件的原则就是看第一个字母是否大写，小写的话，React会认为是HTML标签\n\n{% codeblock lang:javascript %}\nclass App extends Component {\n  render() {\n    return (\n      <hello/> //默认认为是html标签，错误写法\n      <Hello/> //默认是自定义Hello组件\n    );\n  }\n}\n{% endcodeblock %}\n\n### 2、事件绑定\n\n在早期时候绑定事件写法如下：\n{% codeblock lang:javascript %}\n  <button onclick=\"checkAndSubmit(this.form)\">Submit</button>\n{% endcodeblock %}\n随着业务不断复杂，虽然这种写法便于阅读，但是复杂的业务加上复杂的DOM结构，为了html和js解耦，所以绑定事件写法有如下变化，通过获取DOM节点，通过代理机制来绑定事件：\n{% codeblock lang:javascript %}\n  $('#my-button').on('click', this.checkAndSubmit.bind(this));\n{% endcodeblock %}\n然而react中的JSX绑定事件的写法格式如下：\n{% codeblock lang:javascript %}\n  <button onClick={this.checkAndSubmit.bind(this)}>Submit</button>\n{% endcodeblock %}\n>大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。<font color=\"red\">注意：在真正开发中，并不提倡给在组件添加事件中bind（this）这种写法，一般会在constructor的时候就绑定上下文this，这样在组件里面就不会因为多次绑定this而造成内存泄露。</font>\n\n### 3、JSX绑定事件和html绑定事件的区别\n\n  <b>在html添加事件有如下问题：</b>\n\n  1、在html中使用onclick添加的事件处理函数是在全局环境下执行的，这样会污染全局环境，很容易产生意料不到的后果。\n\n  2、给多个DOM添加onclick事件，可能会影响网页性能，毕竟，网页需要的事件处理函数越多，性能就会越低。\n\n  3、对于使用onclick的DOM元素，如果要动态地从DOM树中删掉的话，需要把对应的时间处理器注销，假如忘了注销，就可能造成内存泄露，这样的bug很难被发现。\n\n  <b>以上说的这些问题在JSX中都不存在，其有如下特点：</b>\n\n  1、JSX中添加onclick事件并没有直接在相应的html中添加事件，而是使用了事件委托的方式处理点击事件，无论有多少个onclick的出现，其实最后都只在DOM树上添加一个事件处理函数，并挂载在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定的函数，使用事件委托的性能比为每一个onclick都挂载一个事件函数要高。\n\n  2、jsx中同样可以添加自定义样式，外层定义一个样式对象，然后在jsx中将对象赋值给相应的dom上，这样真正意义上组件封装的思想（html，css，js在一起），提高复用性，大致写法如下：\n{% codeblock lang:javascript %}\nclass App extends Component {\n  render() {\n    const Style = {\n      margin:'10px'\n    }\n    return (\n      <div style={Style}>\n        <p>测试文字</p>\n      </div>\n    );\n  }\n}\n{% endcodeblock %}\n\n### 4、JSX编译\n\nJSX是一种新的语法，浏览器并不能直接运行，因此需要这种翻译器。这里我们推荐使用Babel编译JSX，打包编译建议使用Webpack，大致配置如下：\n{% codeblock lang:javascript %}\nmodule: {\n  loaders: [\n    { test: /\\.jsx?$/, loaders: ['babel-loader']}\n  ]\n}\n{% endcodeblock %}\n\n本文主要介绍JSX优势所在，在添加事件上性能高于普通的html添加事件形式，组件方式的开发模式，更利于代码的通用性和维护性，下一篇将为大家介绍React的理念／Virtual DOM／工作方式的优点。","slug":"2017-06-10","published":1,"updated":"2017-09-02T13:03:20.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36r70008lmld8czfdf5m","content":"<h3 id=\"1、JSX介绍\"><a href=\"#1、JSX介绍\" class=\"headerlink\" title=\"1、JSX介绍\"></a>1、JSX介绍</h3><p>所谓JSX,是javascript的语法扩展，并不是一门新的编程语言，看起来有点像XML，让我们在javascript中可以编写像HTML一样的代码。例如以下示例代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</div><div class=\"line\">        &lt;div className=<span class=\"string\">\"App-header\"</span>&gt;</div><div class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</div><div class=\"line\">          &lt;h2&gt;Welcome to React&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</div><div class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    );</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div></pre></td></tr></table></figure><br>JSX中的这几段代码看起来和HTML几乎一模一样，可以使用div,button之类的标签，但是，JSX和HTML之间还是有不同之处。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>注意：React判断一个元素HTNML元素还是React组件的原则就是看第一个字母是否大写，小写的话，React会认为是HTML标签</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;hello/&gt; <span class=\"comment\">//默认认为是html标签，错误写法</span></div><div class=\"line\">      &lt;Hello/&gt; <span class=\"comment\">//默认是自定义Hello组件</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2、事件绑定\"><a href=\"#2、事件绑定\" class=\"headerlink\" title=\"2、事件绑定\"></a>2、事件绑定</h3><p>在早期时候绑定事件写法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button onclick=<span class=\"string\">\"checkAndSubmit(this.form)\"</span>&gt;Submit&lt;<span class=\"regexp\">/button&gt;</span></div></pre></td></tr></table></figure><br>随着业务不断复杂，虽然这种写法便于阅读，但是复杂的业务加上复杂的DOM结构，为了html和js解耦，所以绑定事件写法有如下变化，通过获取DOM节点，通过代理机制来绑定事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#my-button'</span>).on(<span class=\"string\">'click'</span>, <span class=\"keyword\">this</span>.checkAndSubmit.bind(<span class=\"keyword\">this</span>));</div></pre></td></tr></table></figure><br>然而react中的JSX绑定事件的写法格式如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button onClick=&#123;<span class=\"keyword\">this</span>.checkAndSubmit.bind(<span class=\"keyword\">this</span>)&#125;&gt;Submit&lt;<span class=\"regexp\">/button&gt;</span></div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。<font color=\"red\">注意：在真正开发中，并不提倡给在组件添加事件中bind（this）这种写法，一般会在constructor的时候就绑定上下文this，这样在组件里面就不会因为多次绑定this而造成内存泄露。</font></p>\n</blockquote>\n<h3 id=\"3、JSX绑定事件和html绑定事件的区别\"><a href=\"#3、JSX绑定事件和html绑定事件的区别\" class=\"headerlink\" title=\"3、JSX绑定事件和html绑定事件的区别\"></a>3、JSX绑定事件和html绑定事件的区别</h3><p>  <b>在html添加事件有如下问题：</b></p>\n<p>  1、在html中使用onclick添加的事件处理函数是在全局环境下执行的，这样会污染全局环境，很容易产生意料不到的后果。</p>\n<p>  2、给多个DOM添加onclick事件，可能会影响网页性能，毕竟，网页需要的事件处理函数越多，性能就会越低。</p>\n<p>  3、对于使用onclick的DOM元素，如果要动态地从DOM树中删掉的话，需要把对应的时间处理器注销，假如忘了注销，就可能造成内存泄露，这样的bug很难被发现。</p>\n<p>  <b>以上说的这些问题在JSX中都不存在，其有如下特点：</b></p>\n<p>  1、JSX中添加onclick事件并没有直接在相应的html中添加事件，而是使用了事件委托的方式处理点击事件，无论有多少个onclick的出现，其实最后都只在DOM树上添加一个事件处理函数，并挂载在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定的函数，使用事件委托的性能比为每一个onclick都挂载一个事件函数要高。</p>\n<p>  2、jsx中同样可以添加自定义样式，外层定义一个样式对象，然后在jsx中将对象赋值给相应的dom上，这样真正意义上组件封装的思想（html，css，js在一起），提高复用性，大致写法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> Style = &#123;</div><div class=\"line\">      margin:<span class=\"string\">'10px'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div style=&#123;Style&#125;&gt;</div><div class=\"line\">        &lt;p&gt;测试文字&lt;<span class=\"regexp\">/p&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4、JSX编译\"><a href=\"#4、JSX编译\" class=\"headerlink\" title=\"4、JSX编译\"></a>4、JSX编译</h3><p>JSX是一种新的语法，浏览器并不能直接运行，因此需要这种翻译器。这里我们推荐使用Babel编译JSX，打包编译建议使用Webpack，大致配置如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">  loaders: [</div><div class=\"line\">    &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.jsx?$/</span>, <span class=\"attr\">loaders</span>: [<span class=\"string\">'babel-loader'</span>]&#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>本文主要介绍JSX优势所在，在添加事件上性能高于普通的html添加事件形式，组件方式的开发模式，更利于代码的通用性和维护性，下一篇将为大家介绍React的理念／Virtual DOM／工作方式的优点。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1、JSX介绍\"><a href=\"#1、JSX介绍\" class=\"headerlink\" title=\"1、JSX介绍\"></a>1、JSX介绍</h3><p>所谓JSX,是javascript的语法扩展，并不是一门新的编程语言，看起来有点像XML，让我们在javascript中可以编写像HTML一样的代码。例如以下示例代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</div><div class=\"line\">        &lt;div className=<span class=\"string\">\"App-header\"</span>&gt;</div><div class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</div><div class=\"line\">          &lt;h2&gt;Welcome to React&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</div><div class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    );</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div></pre></td></tr></table></figure><br>JSX中的这几段代码看起来和HTML几乎一模一样，可以使用div,button之类的标签，但是，JSX和HTML之间还是有不同之处。</p>","more":"<blockquote>\n<p>注意：React判断一个元素HTNML元素还是React组件的原则就是看第一个字母是否大写，小写的话，React会认为是HTML标签</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;hello/&gt; <span class=\"comment\">//默认认为是html标签，错误写法</span></div><div class=\"line\">      &lt;Hello/&gt; <span class=\"comment\">//默认是自定义Hello组件</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2、事件绑定\"><a href=\"#2、事件绑定\" class=\"headerlink\" title=\"2、事件绑定\"></a>2、事件绑定</h3><p>在早期时候绑定事件写法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button onclick=<span class=\"string\">\"checkAndSubmit(this.form)\"</span>&gt;Submit&lt;<span class=\"regexp\">/button&gt;</span></div></pre></td></tr></table></figure><br>随着业务不断复杂，虽然这种写法便于阅读，但是复杂的业务加上复杂的DOM结构，为了html和js解耦，所以绑定事件写法有如下变化，通过获取DOM节点，通过代理机制来绑定事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#my-button'</span>).on(<span class=\"string\">'click'</span>, <span class=\"keyword\">this</span>.checkAndSubmit.bind(<span class=\"keyword\">this</span>));</div></pre></td></tr></table></figure><br>然而react中的JSX绑定事件的写法格式如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button onClick=&#123;<span class=\"keyword\">this</span>.checkAndSubmit.bind(<span class=\"keyword\">this</span>)&#125;&gt;Submit&lt;<span class=\"regexp\">/button&gt;</span></div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。<font color=\"red\">注意：在真正开发中，并不提倡给在组件添加事件中bind（this）这种写法，一般会在constructor的时候就绑定上下文this，这样在组件里面就不会因为多次绑定this而造成内存泄露。</font></p>\n</blockquote>\n<h3 id=\"3、JSX绑定事件和html绑定事件的区别\"><a href=\"#3、JSX绑定事件和html绑定事件的区别\" class=\"headerlink\" title=\"3、JSX绑定事件和html绑定事件的区别\"></a>3、JSX绑定事件和html绑定事件的区别</h3><p>  <b>在html添加事件有如下问题：</b></p>\n<p>  1、在html中使用onclick添加的事件处理函数是在全局环境下执行的，这样会污染全局环境，很容易产生意料不到的后果。</p>\n<p>  2、给多个DOM添加onclick事件，可能会影响网页性能，毕竟，网页需要的事件处理函数越多，性能就会越低。</p>\n<p>  3、对于使用onclick的DOM元素，如果要动态地从DOM树中删掉的话，需要把对应的时间处理器注销，假如忘了注销，就可能造成内存泄露，这样的bug很难被发现。</p>\n<p>  <b>以上说的这些问题在JSX中都不存在，其有如下特点：</b></p>\n<p>  1、JSX中添加onclick事件并没有直接在相应的html中添加事件，而是使用了事件委托的方式处理点击事件，无论有多少个onclick的出现，其实最后都只在DOM树上添加一个事件处理函数，并挂载在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定的函数，使用事件委托的性能比为每一个onclick都挂载一个事件函数要高。</p>\n<p>  2、jsx中同样可以添加自定义样式，外层定义一个样式对象，然后在jsx中将对象赋值给相应的dom上，这样真正意义上组件封装的思想（html，css，js在一起），提高复用性，大致写法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> Style = &#123;</div><div class=\"line\">      margin:<span class=\"string\">'10px'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div style=&#123;Style&#125;&gt;</div><div class=\"line\">        &lt;p&gt;测试文字&lt;<span class=\"regexp\">/p&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4、JSX编译\"><a href=\"#4、JSX编译\" class=\"headerlink\" title=\"4、JSX编译\"></a>4、JSX编译</h3><p>JSX是一种新的语法，浏览器并不能直接运行，因此需要这种翻译器。这里我们推荐使用Babel编译JSX，打包编译建议使用Webpack，大致配置如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">  loaders: [</div><div class=\"line\">    &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.jsx?$/</span>, <span class=\"attr\">loaders</span>: [<span class=\"string\">'babel-loader'</span>]&#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>本文主要介绍JSX优势所在，在添加事件上性能高于普通的html添加事件形式，组件方式的开发模式，更利于代码的通用性和维护性，下一篇将为大家介绍React的理念／Virtual DOM／工作方式的优点。</p>"},{"title":"React深入浅出系列--React的工作方式","comments":1,"toc":true,"date":"2017-06-11T13:09:11.000Z","_content":"\n### jQuery如何工作\n\n在讲解React的工作方式之前，先了解下jQuery的工作方式，我们使用jQuery给网页添加一个onclick事件基本写发如下：\n{% codeblock lang:html %}\n<div>\n  <button type=\"btn\" id=\"btn\">点击我</button>\n</div> \n<script>\n  $(function(){\n    $(\"#btn\").click(fucntion(){\n      // do some things\n    })\n  })\n</script>\n{% endcodeblock %}\n在jQuery的解决方案中，首先根据css规则找到id为btn的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。\n\n但是对于庞大的项目，这种模式会造成代码结构复杂，难易维护，每个jQuery的使用者都会有这种体会。\n\n<!-- more -->\n\n### React的理念\n\nreact给dom添加事件并不是通过选择器选中某个dom，然后添加相应的事件，使用react开发，开发者不需要关心dom的组成结构，只需关注数据从哪里来，该去哪个组件中显示，也就是关心整个数据流的走向，通过render函数将相应的数据显示在界面上，如果需要更新界面，只需要找到相应的数据data更新即可，用户界面自然会做出响应，所以说react也是响应式编程。\n\n### Virtual DOM\n\n对于改变普通的html中的DOM会造成页面的重排和重绘，这也是前端性能优化主要的方面，就是尽量减少对DOM的操作。其实虚拟DOM说的简单点就是js动态生成的html标签在js内存中存储，并没有实际插入到页面当中。例如使用createElement（'Button'）和DocumentFragment创建虚拟的标签。简单的虚拟DOM代码示例如下，主要是方面从简单的层面理解虚拟DOM：\n\n{% codeblock lang:javascript %}\nvar frag=document.createDocumentFragment();\nfor(var i=0;i<10;i++){\n   var l=document.createElement(\"li\");\n   l.innerHTML=\"ss\";\n   frag.appendChild(l);\n}\ndocument.getElementById(\"list\").appendChild(frag);\n{% endcodeblock %}\n\n当然React中的虚拟DOM并没有像以上的例子这么简单，但是核心思想是这样的，相比直接操作DOM而言，通过操作js生成的DOM数结构改变映射到页面上的内容能提高不少性能。虚拟DOM就是对DOM树的抽象，仅仅是存在与javascript空间的树形结构，例如最简单的形式如下：\n{% codeblock lang:javascript %}\nvar a = {\n  type: 'a',\n  props: {\n    children: 'React',\n    className: 'link',\n    href: 'facebook/react · GitHub'\n  },\n  _isReactElement: true\n}\n\nReact.render(a, document.body)\n{% endcodeblock %}\n\n虚拟DOM中有个核心算法就是diff算法，主要实现以下三个步骤：\n* 步骤一：用JS对象模拟DOM树\n* 步骤二：比较两棵虚拟DOM树的差异\n* 步骤三：把差异应用到真正的DOM树上\nreact会根据diff算法计算出需要更新改变虚拟DOM，从而只更新页面中映射的那一小块DOM。对于diff算法以及react性能优化后期会单独用一节分析。\n\n### React工作方式的优点\n\n传统化的jquery的方式直观易懂，但是随着项目变得庞大时，用jquery写出的代码往往相互纠缠，难以维护。\n\n<img width=\"400\" src=\"2017-06-11/01.jpeg\" title=\"jquery方式造成的纠缠代码结构\"/>\n\n使用react的方式，可以避免构建这样复杂的程序结构，无论何种事件，引发的都是react组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发这不需要关心。react利用函数式编程的思想来解决用户界面渲染问题，最大的优势能够提高开发效率，代码可维护性和可阅读性增强。\n\n<img width=\"400\" src=\"2017-06-11/02.jpeg\" title=\"react的程序流程\"/>\n\nreact会强制所有组件都按照这种由数据驱动渲染的模式来工作，无论应用多大，都让程序处于可控范围内。下一篇将为大家介绍如何设计高质量的React组件。\n\n\n\n","source":"_posts/2017-06-11.md","raw":"---\ntitle: React深入浅出系列--React的工作方式\ncomments: true\ntoc: true\ndate: 2017-06-11 21:09:11\ntags: \n    - 'javascript'\n    - 'react'\n---\n\n### jQuery如何工作\n\n在讲解React的工作方式之前，先了解下jQuery的工作方式，我们使用jQuery给网页添加一个onclick事件基本写发如下：\n{% codeblock lang:html %}\n<div>\n  <button type=\"btn\" id=\"btn\">点击我</button>\n</div> \n<script>\n  $(function(){\n    $(\"#btn\").click(fucntion(){\n      // do some things\n    })\n  })\n</script>\n{% endcodeblock %}\n在jQuery的解决方案中，首先根据css规则找到id为btn的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。\n\n但是对于庞大的项目，这种模式会造成代码结构复杂，难易维护，每个jQuery的使用者都会有这种体会。\n\n<!-- more -->\n\n### React的理念\n\nreact给dom添加事件并不是通过选择器选中某个dom，然后添加相应的事件，使用react开发，开发者不需要关心dom的组成结构，只需关注数据从哪里来，该去哪个组件中显示，也就是关心整个数据流的走向，通过render函数将相应的数据显示在界面上，如果需要更新界面，只需要找到相应的数据data更新即可，用户界面自然会做出响应，所以说react也是响应式编程。\n\n### Virtual DOM\n\n对于改变普通的html中的DOM会造成页面的重排和重绘，这也是前端性能优化主要的方面，就是尽量减少对DOM的操作。其实虚拟DOM说的简单点就是js动态生成的html标签在js内存中存储，并没有实际插入到页面当中。例如使用createElement（'Button'）和DocumentFragment创建虚拟的标签。简单的虚拟DOM代码示例如下，主要是方面从简单的层面理解虚拟DOM：\n\n{% codeblock lang:javascript %}\nvar frag=document.createDocumentFragment();\nfor(var i=0;i<10;i++){\n   var l=document.createElement(\"li\");\n   l.innerHTML=\"ss\";\n   frag.appendChild(l);\n}\ndocument.getElementById(\"list\").appendChild(frag);\n{% endcodeblock %}\n\n当然React中的虚拟DOM并没有像以上的例子这么简单，但是核心思想是这样的，相比直接操作DOM而言，通过操作js生成的DOM数结构改变映射到页面上的内容能提高不少性能。虚拟DOM就是对DOM树的抽象，仅仅是存在与javascript空间的树形结构，例如最简单的形式如下：\n{% codeblock lang:javascript %}\nvar a = {\n  type: 'a',\n  props: {\n    children: 'React',\n    className: 'link',\n    href: 'facebook/react · GitHub'\n  },\n  _isReactElement: true\n}\n\nReact.render(a, document.body)\n{% endcodeblock %}\n\n虚拟DOM中有个核心算法就是diff算法，主要实现以下三个步骤：\n* 步骤一：用JS对象模拟DOM树\n* 步骤二：比较两棵虚拟DOM树的差异\n* 步骤三：把差异应用到真正的DOM树上\nreact会根据diff算法计算出需要更新改变虚拟DOM，从而只更新页面中映射的那一小块DOM。对于diff算法以及react性能优化后期会单独用一节分析。\n\n### React工作方式的优点\n\n传统化的jquery的方式直观易懂，但是随着项目变得庞大时，用jquery写出的代码往往相互纠缠，难以维护。\n\n<img width=\"400\" src=\"2017-06-11/01.jpeg\" title=\"jquery方式造成的纠缠代码结构\"/>\n\n使用react的方式，可以避免构建这样复杂的程序结构，无论何种事件，引发的都是react组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发这不需要关心。react利用函数式编程的思想来解决用户界面渲染问题，最大的优势能够提高开发效率，代码可维护性和可阅读性增强。\n\n<img width=\"400\" src=\"2017-06-11/02.jpeg\" title=\"react的程序流程\"/>\n\nreact会强制所有组件都按照这种由数据驱动渲染的模式来工作，无论应用多大，都让程序处于可控范围内。下一篇将为大家介绍如何设计高质量的React组件。\n\n\n\n","slug":"2017-06-11","published":1,"updated":"2017-09-02T13:02:32.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36r9000almlda3wfio20","content":"<h3 id=\"jQuery如何工作\"><a href=\"#jQuery如何工作\" class=\"headerlink\" title=\"jQuery如何工作\"></a>jQuery如何工作</h3><p>在讲解React的工作方式之前，先了解下jQuery的工作方式，我们使用jQuery给网页添加一个onclick事件基本写发如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"btn\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btn\"</span>&gt;</span>点击我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">  $(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">    $(<span class=\"string\">\"#btn\"</span>).click(fucntion()&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// do some things</span></span></div><div class=\"line\"><span class=\"undefined\">    &#125;)</span></div><div class=\"line\"><span class=\"undefined\">  &#125;)</span></div><div class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure><br>在jQuery的解决方案中，首先根据css规则找到id为btn的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。</p>\n<p>但是对于庞大的项目，这种模式会造成代码结构复杂，难易维护，每个jQuery的使用者都会有这种体会。</p>\n<a id=\"more\"></a>\n<h3 id=\"React的理念\"><a href=\"#React的理念\" class=\"headerlink\" title=\"React的理念\"></a>React的理念</h3><p>react给dom添加事件并不是通过选择器选中某个dom，然后添加相应的事件，使用react开发，开发者不需要关心dom的组成结构，只需关注数据从哪里来，该去哪个组件中显示，也就是关心整个数据流的走向，通过render函数将相应的数据显示在界面上，如果需要更新界面，只需要找到相应的数据data更新即可，用户界面自然会做出响应，所以说react也是响应式编程。</p>\n<h3 id=\"Virtual-DOM\"><a href=\"#Virtual-DOM\" class=\"headerlink\" title=\"Virtual DOM\"></a>Virtual DOM</h3><p>对于改变普通的html中的DOM会造成页面的重排和重绘，这也是前端性能优化主要的方面，就是尽量减少对DOM的操作。其实虚拟DOM说的简单点就是js动态生成的html标签在js内存中存储，并没有实际插入到页面当中。例如使用createElement（’Button’）和DocumentFragment创建虚拟的标签。简单的虚拟DOM代码示例如下，主要是方面从简单的层面理解虚拟DOM：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> frag=<span class=\"built_in\">document</span>.createDocumentFragment();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> l=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</div><div class=\"line\">   l.innerHTML=<span class=\"string\">\"ss\"</span>;</div><div class=\"line\">   frag.appendChild(l);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"list\"</span>).appendChild(frag);</div></pre></td></tr></table></figure>\n<p>当然React中的虚拟DOM并没有像以上的例子这么简单，但是核心思想是这样的，相比直接操作DOM而言，通过操作js生成的DOM数结构改变映射到页面上的内容能提高不少性能。虚拟DOM就是对DOM树的抽象，仅仅是存在与javascript空间的树形结构，例如最简单的形式如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;</div><div class=\"line\">  type: <span class=\"string\">'a'</span>,</div><div class=\"line\">  props: &#123;</div><div class=\"line\">    children: <span class=\"string\">'React'</span>,</div><div class=\"line\">    className: <span class=\"string\">'link'</span>,</div><div class=\"line\">    href: <span class=\"string\">'facebook/react · GitHub'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  _isReactElement: <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">React.render(a, <span class=\"built_in\">document</span>.body)</div></pre></td></tr></table></figure></p>\n<p>虚拟DOM中有个核心算法就是diff算法，主要实现以下三个步骤：</p>\n<ul>\n<li>步骤一：用JS对象模拟DOM树</li>\n<li>步骤二：比较两棵虚拟DOM树的差异</li>\n<li>步骤三：把差异应用到真正的DOM树上<br>react会根据diff算法计算出需要更新改变虚拟DOM，从而只更新页面中映射的那一小块DOM。对于diff算法以及react性能优化后期会单独用一节分析。</li>\n</ul>\n<h3 id=\"React工作方式的优点\"><a href=\"#React工作方式的优点\" class=\"headerlink\" title=\"React工作方式的优点\"></a>React工作方式的优点</h3><p>传统化的jquery的方式直观易懂，但是随着项目变得庞大时，用jquery写出的代码往往相互纠缠，难以维护。</p>\n<p><img width=\"400\" src=\"/2017-06-11/01.jpeg\" title=\"jquery方式造成的纠缠代码结构\"></p>\n<p>使用react的方式，可以避免构建这样复杂的程序结构，无论何种事件，引发的都是react组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发这不需要关心。react利用函数式编程的思想来解决用户界面渲染问题，最大的优势能够提高开发效率，代码可维护性和可阅读性增强。</p>\n<p><img width=\"400\" src=\"/2017-06-11/02.jpeg\" title=\"react的程序流程\"></p>\n<p>react会强制所有组件都按照这种由数据驱动渲染的模式来工作，无论应用多大，都让程序处于可控范围内。下一篇将为大家介绍如何设计高质量的React组件。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"jQuery如何工作\"><a href=\"#jQuery如何工作\" class=\"headerlink\" title=\"jQuery如何工作\"></a>jQuery如何工作</h3><p>在讲解React的工作方式之前，先了解下jQuery的工作方式，我们使用jQuery给网页添加一个onclick事件基本写发如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"btn\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btn\"</span>&gt;</span>点击我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">  $(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">    $(<span class=\"string\">\"#btn\"</span>).click(fucntion()&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// do some things</span></span></div><div class=\"line\"><span class=\"undefined\">    &#125;)</span></div><div class=\"line\"><span class=\"undefined\">  &#125;)</span></div><div class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure><br>在jQuery的解决方案中，首先根据css规则找到id为btn的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。</p>\n<p>但是对于庞大的项目，这种模式会造成代码结构复杂，难易维护，每个jQuery的使用者都会有这种体会。</p>","more":"<h3 id=\"React的理念\"><a href=\"#React的理念\" class=\"headerlink\" title=\"React的理念\"></a>React的理念</h3><p>react给dom添加事件并不是通过选择器选中某个dom，然后添加相应的事件，使用react开发，开发者不需要关心dom的组成结构，只需关注数据从哪里来，该去哪个组件中显示，也就是关心整个数据流的走向，通过render函数将相应的数据显示在界面上，如果需要更新界面，只需要找到相应的数据data更新即可，用户界面自然会做出响应，所以说react也是响应式编程。</p>\n<h3 id=\"Virtual-DOM\"><a href=\"#Virtual-DOM\" class=\"headerlink\" title=\"Virtual DOM\"></a>Virtual DOM</h3><p>对于改变普通的html中的DOM会造成页面的重排和重绘，这也是前端性能优化主要的方面，就是尽量减少对DOM的操作。其实虚拟DOM说的简单点就是js动态生成的html标签在js内存中存储，并没有实际插入到页面当中。例如使用createElement（’Button’）和DocumentFragment创建虚拟的标签。简单的虚拟DOM代码示例如下，主要是方面从简单的层面理解虚拟DOM：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> frag=<span class=\"built_in\">document</span>.createDocumentFragment();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> l=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</div><div class=\"line\">   l.innerHTML=<span class=\"string\">\"ss\"</span>;</div><div class=\"line\">   frag.appendChild(l);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"list\"</span>).appendChild(frag);</div></pre></td></tr></table></figure>\n<p>当然React中的虚拟DOM并没有像以上的例子这么简单，但是核心思想是这样的，相比直接操作DOM而言，通过操作js生成的DOM数结构改变映射到页面上的内容能提高不少性能。虚拟DOM就是对DOM树的抽象，仅仅是存在与javascript空间的树形结构，例如最简单的形式如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;</div><div class=\"line\">  type: <span class=\"string\">'a'</span>,</div><div class=\"line\">  props: &#123;</div><div class=\"line\">    children: <span class=\"string\">'React'</span>,</div><div class=\"line\">    className: <span class=\"string\">'link'</span>,</div><div class=\"line\">    href: <span class=\"string\">'facebook/react · GitHub'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  _isReactElement: <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">React.render(a, <span class=\"built_in\">document</span>.body)</div></pre></td></tr></table></figure></p>\n<p>虚拟DOM中有个核心算法就是diff算法，主要实现以下三个步骤：</p>\n<ul>\n<li>步骤一：用JS对象模拟DOM树</li>\n<li>步骤二：比较两棵虚拟DOM树的差异</li>\n<li>步骤三：把差异应用到真正的DOM树上<br>react会根据diff算法计算出需要更新改变虚拟DOM，从而只更新页面中映射的那一小块DOM。对于diff算法以及react性能优化后期会单独用一节分析。</li>\n</ul>\n<h3 id=\"React工作方式的优点\"><a href=\"#React工作方式的优点\" class=\"headerlink\" title=\"React工作方式的优点\"></a>React工作方式的优点</h3><p>传统化的jquery的方式直观易懂，但是随着项目变得庞大时，用jquery写出的代码往往相互纠缠，难以维护。</p>\n<p><img width=\"400\" src=\"/2017-06-11/01.jpeg\" title=\"jquery方式造成的纠缠代码结构\"></p>\n<p>使用react的方式，可以避免构建这样复杂的程序结构，无论何种事件，引发的都是react组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发这不需要关心。react利用函数式编程的思想来解决用户界面渲染问题，最大的优势能够提高开发效率，代码可维护性和可阅读性增强。</p>\n<p><img width=\"400\" src=\"/2017-06-11/02.jpeg\" title=\"react的程序流程\"></p>\n<p>react会强制所有组件都按照这种由数据驱动渲染的模式来工作，无论应用多大，都让程序处于可控范围内。下一篇将为大家介绍如何设计高质量的React组件。</p>"},{"title":"React深入浅出系列--如何设计高质量的React组件","comments":1,"toc":true,"date":"2017-06-12T13:09:11.000Z","_content":"\n### 组件的设计要素\n\n在项目开发初期，针对模块或者组件的分配是及其重要，基本会按照“分而治之”的思想去合理的设计组件的功能以及扩展它们的复用性等等。拆分组件最关键的就是确定组件功能的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的职责，那这两个组件本身就不该被拆分，作为同一个组件或许更加合理。\n\n组件的划分需要满足两个基本原则：<b>高内聚</b>和<b>低耦合</b>\n\n<b>高内聚:</b>把逻辑紧密相关的内容放在一个组件中。早期开发html、css、js基本会以三个不同的文件存放，这样其实是违背高聚合的原则，react正好提供将跟组件相关的css、js、html放在一起的语法结构，这样一来，组件的复用性能够达到极致。\n\n<b>低耦合:</b>不同的组件之间的依赖关系要尽量弱化。也就是每个组件要尽量独立。保持整个系统的低耦合度，让不同的组件去实现不同的功能，复杂的功能是通过细分的组件组装起来完成的，这样设计的话，方便开发者写出低耦合的系统。\n\n<!-- more -->\n\n### react组件的数据\n\nreact组件的数据主要分两种：<b>prop</b>和<b>state</b>。无论prop、state的改变都可能引发组件的渲染，其实react有基本的规范，prop主要作为组件对外部的接口，负责接受其他组件传过来的数据参数等，state主要是组件内部定义的数据状态，仅仅属于当前组件内部使用，片段代码如下：\n\n{% codeblock lang:javascript %}\n// 定义一个子组件\nclass Counter extends Component {\n  constructor(props) {\n    // 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props\n    super(props);\n    //使用state定义自己内部状态数据\n    this.state = {\n      text: 1\n    }\n  }\n  render() {\n    const {caption} = this.props; //通过this.props来获取父亲组件传进来的caption值\n    return (\n      <div className=\"App\">\n        {this.state.text}\n      </div>\n    );\n  }\n}\n// 定义一个父组件\nclass ControlPanel extends Component {\n  render() {\n    console.log('enter ControlPanel render');\n    return (\n      <div style={style}>\n        <Counter caption=\"First\"/>\n      </div>\n    );\n  }\n};\n{% endcodeblock %}\n\n#### React中的prop\n\n给prop赋值和读取prop的值，以下只是代码片段，主要为了解释那些是赋值那些是读取值\n{% codeblock lang:javascript %}\n//在构造函数中读取父组件传过来的值\nconstructor(props) {\n    // 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props\n    super(props);\n    //使用state定义自己内部状态数据\n    this.state = {\n      text: 1\n    }\n  }\n\n//在render函数中返回一个组件，并且带上要给该组件传递的数据  \nreturn (\n    <Counter caption=\"First\"/>\n);\n{% endcodeblock %}\n\n如果一个组件需要定义自己的构造函数，一定要在构造函数的第一行通过super调用父级也就是React.Component的构造函数，只有这样才能通过this.props来获取父级传下来的数据。因此常常会在构造函数中绑定this的指向，避免在render中多次绑定而造成性能问题。\n\n#### propTypes的检查\n\n通过propTypes属性来定义prop规格，在组件渲染运行和静态代码检查时，都可以根据propTypes判断外部传递数据的格式是否正确，基本代码片段如下：\n{% codeblock lang:javascript %}\nCounter.propTypes = {\n  caption:PropTypes.string.isRequired,\n  initValue:PropTypes.number\n}\n{% endcodeblock %}\n其中要求caption必须是string类型，initValue必须是number类型，isRequired代表该caption必须传递，不能缺失，而initValue可以不传。\n\n所以在具体项目开发中，最好的方式是，在开发模式下带上propTypes，而在上线的时候可以去掉这些代码，可以用babel-react-optimize工具自动去除propTypes，这样部署到产品环境的代码就会更优。\n\n#### React中的state\n\nstate代表组件内部状态，常常用来定义组件内部初始值。组件内部的state必须是一个对象，不能是string或者number这样简单的数据类型。基本使用如下：\n{% codeblock lang:javascript %}\nconstructor(props) {\n    this.state = {\n      text: 1, // 使用state定义自己内部状态数据\n      num:props.num || 1 // 接受父组件传来的参数\n    }\n  }\n{% endcodeblock %}\n在当前组件对象内部通过this.state来访问内部定义的变量，如果要改变状态千万不要直接通过this.state赋值改变，使用react提供的setState这个方法来改变状态，这样改变能够直接触发组件重新render使得界面绑定的相应的状态更新。\n\n#### prop和state的对比\n\n* prop用于定义外部接口，state用于定义内部状态；\n* prop的赋值在外部世界使用组件时，state的赋值在组件内部；\n* 组件不应该改变prop的值，而state存在的目的就是让组件来改变的；\n\n一个子组件去修改props中的值，就是违背react的设计初衷，如果必须修改，建议使用组件内部状态先保存props，然后通过改变组件内部状态变相改变了props。\n\n### 使用prop建立组件间的通信\n\n应用示例如下：\n\n<img width=\"600\" src=\"2017-06-12/01.jpeg\" title=\"应用示例\"/>\n\n使用prop建立组件间的通信原理就是在子组件内部定义改变内部状态的方法并且触发父组件改变父组件的方法，并且在自组件自定一个空函数作为父子组件通信的桥接。\n\n具体实现代码如下，我们现在Counter子组件中定义需要改变状态的方法，除了触发改变内部状态的updateCount方法，同时也会触发父组件的this.props.onUpdate方法：\n{% codeblock lang:javascript %}\n  onClickIncrementButton() {\n    this.updateCount(true);\n  }\n\n  onClickDecrementButton() {\n    this.updateCount(false);\n  }\n\n  updateCount(isIncrement) {\n    const previousValue = this.state.count;\n    const newValue = isIncrement ? previousValue + 1 : previousValue - 1;\n\n    this.setState({count: newValue})\n    this.props.onUpdate(newValue, previousValue)\n  }\n{% endcodeblock %}\n\n接下来我们定义一个默认的空函数，来桥接父子组件通信，代码片段如下：\n{% codeblock lang:javascript %}\n  Counter.propTypes = {\n    caption: PropTypes.string.isRequired,\n    initValue: PropTypes.number,\n    onUpdate: PropTypes.func\n  };\n\n  Counter.defaultProps = {\n    initValue: 0,\n    onUpdate: f => f //什么都不做的函数\n  };\n{% endcodeblock %}\n\n并且在父组件中建立相应的更新方法，并且在render将onCounterUpdate方法以onUpdate名字传递给子组件中，自组件定义onUpdate来接受父组件传递下来的方法，从而解决了父子组件的通信，代码片段如下：\n{% codeblock lang:javascript %}\n  onCounterUpdate(newValue, previousValue) {\n    const valueChange = newValue - previousValue;\n    this.setState({ sum: this.state.sum + valueChange});\n  }\n  render() {\n    return (\n      <div style={style}>\n        <Counter onUpdate={this.onCounterUpdate} caption=\"First\" />\n        <Counter onUpdate={this.onCounterUpdate} caption=\"Second\" initValue={this.initValues[1]} />\n        <Counter onUpdate={this.onCounterUpdate} caption=\"Third\" initValue={this.initValues[2]} />\n        <hr/>\n        <div>Total Count: {this.state.sum}</div>\n      </div>\n    );\n  }\n{% endcodeblock %}\n\n### 使用prop传递参数的局限\n\n从上面的示例不难看出，子组件和父组件都各自维护一套属于自己的状态，并且通过update来相互通信，如果update内部内部逻辑出现bug，这个时候，计数器的结果到底是子组件的对还是父组件的对呢，这个时候就需要共享状态的概念出现，通过一个全局状态来同步各个子组件内部的状态，开发者也只要关注共享全局状态走向就行。\n\n组件状态不统一：\n<img width=\"300\" src=\"2017-06-12/02.jpeg\" title=\"组件状态不统一\"/>\n全局状态同步状态：\n<img width=\"300\" src=\"2017-06-12/03.jpeg\" title=\"全局状态同步状态\"/>\n\n如果一个系统中，存在多层嵌套组件，如果按照prop规则传递参数，岂不是非常麻烦，所以必须引入全局状态Redux，将在下节中为大家介绍基本的Redux思想及原理。\n\n### react生命周期介绍\n\n生命周期基本分成三个主要阶段：\n* 装载过程，组件第一次渲染过程\n* 更新过程，当组件重新渲染过程\n* 卸载过程，组件从DOM中删除过程\n\n#### 装载过程\n\n依次调用一下生命周期函数方法(按照es6最新语法介绍)：\n\n* constructor\n* defaultProps\n* componentWillMount\n* render\n* componentDidMount\n\n##### constructor\n\n这是es6中构造函数的写法，如果是无状态的React组件无需定义构造函数，因此定义构造函数基本的作用是：\n* 初始化state，在组件定义个函数中需要访问state状态。\n* 绑定函数的this上下文。\n\n代码片段如下：\n{% codeblock lang:javascript %}\nconstructor(props) {\n    super(props);\n    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);\n    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);\n  }\n{% endcodeblock %}\n\n##### defaultProps\n\n主要作用是给props定义初始值，基本写法如下：\n{% codeblock lang:javascript %}\nCounter.defaultProps = {\n  initValue: 0,\n  onUpdate: f => f //什么都不做的函数\n};\n{% endcodeblock %}\n\n##### render\n\n主要作用返回一个JSX描述的结构，最终再交付给React来操作渲染，组件在有些情况下如果不需要返回JSX结构，可以通过返回null或者false来告诉React不渲染任何DOM元素。\n\n>注意：在render中不要操作对状态的改变，应该在自定义函数中改变\n\n##### componentWillMount和componentDidMount\n\ncomponentWillMount在render函数之前调用，也就是DOM还没有挂载，这个时候如果调用this.setState修改状态也不会发生重新渲染，其实我们可以在创建构造函数中就做好在componentWillMount应该做的事情。此函数既可以在服务端被调用，也可以在浏览器端被调用。\n\ncomponentDidMount在render之后调用，也就是挂载DOM的操作，如果一个父组件嵌套多个子组件，这个时候挂载DOM的顺序是等到子组件全部调用render函数之后再开始挂载相应子组件的DOM。该函数只能在浏览器端被调用。如果需要对DOM操作的话，建议可以在componentDidMount中定义函数进行操作。DOM挂载顺序结果如下：\n\n<img width=\"700\" src=\"2017-06-12/04.jpeg\" title=\"DOM挂载顺序\"/>\n\n#### 更新过程\n* componentWillReceiveProps\n* shouldComponentUpdate\n* componentWillUpdate\n* render\n* componentDidUpdate\n\n##### componentWillReceiveProps\n这个函数是根据新的props的值来计算出是不是要更新组件内部state状态。同同时，只要父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发componentWillReceiveProps函数运行。\n\n在Counter组件中增加函数：\n{% codeblock lang:javascript %}\ncomponentWillReceiveProps(nextProps) {\n    console.log('enter componentWillReceiveProps ' + this.props.caption)\n  }\n{% endcodeblock %}\n\n在ControlPanel函数中定义强制更新函数：\n{% codeblock lang:javascript %}\nrender() {\n    console.log('enter ControlPanel render');\n    return (\n      <div style={style}>\n        <Counter onUpdate={this.onCounterUpdate} caption=\"First\" />\n        <Counter onUpdate={this.onCounterUpdate} caption=\"Second\" initValue={this.initValues[1]} />\n        <Counter onUpdate={this.onCounterUpdate} caption=\"Third\" initValue={this.initValues[2]} />\n        <button onClick={ () => this.forceUpdate() }>\n          Click me to re-render!\n        </button>\n        <hr/>\n        <div>Total Count: {this.state.sum}</div>\n      </div>\n    );\n{% endcodeblock %}\nControlPanel组件中触发了render函数，子组件中的componentWillReceiveProps都被触发了，但是并没有改变props的值，运行结果截图如下：\n<img width=\"700\" src=\"2017-06-12/05.jpeg\" title=\"更新过程\"/>\n\n这个函数会接受nextProps参数，一般会用nextProps（这一次渲染传入的值）与this.props（上一次渲染传入的值）进行比较，只有两者有变化的时候才会调用this.setState更新内部状态。\n\n##### shouldComponentUpdate\n\n主要作用根据nextProps, nextState接收的两个参数来判断组件是否需要执行render函数，react中这个函数如果不做任何设置，默认都是返回true，所以再做性能优化的时候，这个函数起到了至关重要的作用。\n在Counter组件中增加函数：\n{% codeblock lang:javascript %}\nshouldComponentUpdate(nextProps, nextState) {\n    return (nextProps.caption !== this.props.caption) ||\n           (nextState.count !== this.state.count);\n  }\n{% endcodeblock %}\n改变任何一个值，只会触发当前这个组件调用render函数，运行结构如下：\n<img width=\"700\" src=\"2017-06-12/05.jpeg\" title=\"性能优化过程\"/>\n\n##### componentWillUpdate和componentDidUpdate\n\n只要shouldComponentUpdate函数返回为true，就会以此调用componentWillUpdate、render、componentDidUpdate这三个函数，同样这两个函数即可以在服务端调用也可以在浏览器端调用。\n\n#### 卸载过程\n\n这个过程主要是卸载不使用的组件DOM元素，或者使用非React方式创建的DOM元素，还是非常有作用的，例如，如果在componentDidMount中可以使用了js原生创建了DOM元素，但是在组件卸载过程中没有清楚，这个时候会造成内存泄露，所以在使用卸载组件的函数，必须确定相关的DOM都清除。\n\n本篇简要的React组件的通信和基本的生命周期运行流程，在使用prop通信会有一定的局限，下节会引入Redux共享状态概念，来解决prop传递的局限，本篇涉及到的源码可以访问https://github.com/wqzwh/react-redux-demo/tree/master/src/demo/01 \n\n\n\n\n\n\n\n\n","source":"_posts/2017-06-12.md","raw":"---\ntitle: React深入浅出系列--如何设计高质量的React组件\ncomments: true\ntoc: true\ndate: 2017-06-12 21:09:11\ntags: \n    - 'javascript'\n    - 'react'\n---\n\n### 组件的设计要素\n\n在项目开发初期，针对模块或者组件的分配是及其重要，基本会按照“分而治之”的思想去合理的设计组件的功能以及扩展它们的复用性等等。拆分组件最关键的就是确定组件功能的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的职责，那这两个组件本身就不该被拆分，作为同一个组件或许更加合理。\n\n组件的划分需要满足两个基本原则：<b>高内聚</b>和<b>低耦合</b>\n\n<b>高内聚:</b>把逻辑紧密相关的内容放在一个组件中。早期开发html、css、js基本会以三个不同的文件存放，这样其实是违背高聚合的原则，react正好提供将跟组件相关的css、js、html放在一起的语法结构，这样一来，组件的复用性能够达到极致。\n\n<b>低耦合:</b>不同的组件之间的依赖关系要尽量弱化。也就是每个组件要尽量独立。保持整个系统的低耦合度，让不同的组件去实现不同的功能，复杂的功能是通过细分的组件组装起来完成的，这样设计的话，方便开发者写出低耦合的系统。\n\n<!-- more -->\n\n### react组件的数据\n\nreact组件的数据主要分两种：<b>prop</b>和<b>state</b>。无论prop、state的改变都可能引发组件的渲染，其实react有基本的规范，prop主要作为组件对外部的接口，负责接受其他组件传过来的数据参数等，state主要是组件内部定义的数据状态，仅仅属于当前组件内部使用，片段代码如下：\n\n{% codeblock lang:javascript %}\n// 定义一个子组件\nclass Counter extends Component {\n  constructor(props) {\n    // 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props\n    super(props);\n    //使用state定义自己内部状态数据\n    this.state = {\n      text: 1\n    }\n  }\n  render() {\n    const {caption} = this.props; //通过this.props来获取父亲组件传进来的caption值\n    return (\n      <div className=\"App\">\n        {this.state.text}\n      </div>\n    );\n  }\n}\n// 定义一个父组件\nclass ControlPanel extends Component {\n  render() {\n    console.log('enter ControlPanel render');\n    return (\n      <div style={style}>\n        <Counter caption=\"First\"/>\n      </div>\n    );\n  }\n};\n{% endcodeblock %}\n\n#### React中的prop\n\n给prop赋值和读取prop的值，以下只是代码片段，主要为了解释那些是赋值那些是读取值\n{% codeblock lang:javascript %}\n//在构造函数中读取父组件传过来的值\nconstructor(props) {\n    // 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props\n    super(props);\n    //使用state定义自己内部状态数据\n    this.state = {\n      text: 1\n    }\n  }\n\n//在render函数中返回一个组件，并且带上要给该组件传递的数据  \nreturn (\n    <Counter caption=\"First\"/>\n);\n{% endcodeblock %}\n\n如果一个组件需要定义自己的构造函数，一定要在构造函数的第一行通过super调用父级也就是React.Component的构造函数，只有这样才能通过this.props来获取父级传下来的数据。因此常常会在构造函数中绑定this的指向，避免在render中多次绑定而造成性能问题。\n\n#### propTypes的检查\n\n通过propTypes属性来定义prop规格，在组件渲染运行和静态代码检查时，都可以根据propTypes判断外部传递数据的格式是否正确，基本代码片段如下：\n{% codeblock lang:javascript %}\nCounter.propTypes = {\n  caption:PropTypes.string.isRequired,\n  initValue:PropTypes.number\n}\n{% endcodeblock %}\n其中要求caption必须是string类型，initValue必须是number类型，isRequired代表该caption必须传递，不能缺失，而initValue可以不传。\n\n所以在具体项目开发中，最好的方式是，在开发模式下带上propTypes，而在上线的时候可以去掉这些代码，可以用babel-react-optimize工具自动去除propTypes，这样部署到产品环境的代码就会更优。\n\n#### React中的state\n\nstate代表组件内部状态，常常用来定义组件内部初始值。组件内部的state必须是一个对象，不能是string或者number这样简单的数据类型。基本使用如下：\n{% codeblock lang:javascript %}\nconstructor(props) {\n    this.state = {\n      text: 1, // 使用state定义自己内部状态数据\n      num:props.num || 1 // 接受父组件传来的参数\n    }\n  }\n{% endcodeblock %}\n在当前组件对象内部通过this.state来访问内部定义的变量，如果要改变状态千万不要直接通过this.state赋值改变，使用react提供的setState这个方法来改变状态，这样改变能够直接触发组件重新render使得界面绑定的相应的状态更新。\n\n#### prop和state的对比\n\n* prop用于定义外部接口，state用于定义内部状态；\n* prop的赋值在外部世界使用组件时，state的赋值在组件内部；\n* 组件不应该改变prop的值，而state存在的目的就是让组件来改变的；\n\n一个子组件去修改props中的值，就是违背react的设计初衷，如果必须修改，建议使用组件内部状态先保存props，然后通过改变组件内部状态变相改变了props。\n\n### 使用prop建立组件间的通信\n\n应用示例如下：\n\n<img width=\"600\" src=\"2017-06-12/01.jpeg\" title=\"应用示例\"/>\n\n使用prop建立组件间的通信原理就是在子组件内部定义改变内部状态的方法并且触发父组件改变父组件的方法，并且在自组件自定一个空函数作为父子组件通信的桥接。\n\n具体实现代码如下，我们现在Counter子组件中定义需要改变状态的方法，除了触发改变内部状态的updateCount方法，同时也会触发父组件的this.props.onUpdate方法：\n{% codeblock lang:javascript %}\n  onClickIncrementButton() {\n    this.updateCount(true);\n  }\n\n  onClickDecrementButton() {\n    this.updateCount(false);\n  }\n\n  updateCount(isIncrement) {\n    const previousValue = this.state.count;\n    const newValue = isIncrement ? previousValue + 1 : previousValue - 1;\n\n    this.setState({count: newValue})\n    this.props.onUpdate(newValue, previousValue)\n  }\n{% endcodeblock %}\n\n接下来我们定义一个默认的空函数，来桥接父子组件通信，代码片段如下：\n{% codeblock lang:javascript %}\n  Counter.propTypes = {\n    caption: PropTypes.string.isRequired,\n    initValue: PropTypes.number,\n    onUpdate: PropTypes.func\n  };\n\n  Counter.defaultProps = {\n    initValue: 0,\n    onUpdate: f => f //什么都不做的函数\n  };\n{% endcodeblock %}\n\n并且在父组件中建立相应的更新方法，并且在render将onCounterUpdate方法以onUpdate名字传递给子组件中，自组件定义onUpdate来接受父组件传递下来的方法，从而解决了父子组件的通信，代码片段如下：\n{% codeblock lang:javascript %}\n  onCounterUpdate(newValue, previousValue) {\n    const valueChange = newValue - previousValue;\n    this.setState({ sum: this.state.sum + valueChange});\n  }\n  render() {\n    return (\n      <div style={style}>\n        <Counter onUpdate={this.onCounterUpdate} caption=\"First\" />\n        <Counter onUpdate={this.onCounterUpdate} caption=\"Second\" initValue={this.initValues[1]} />\n        <Counter onUpdate={this.onCounterUpdate} caption=\"Third\" initValue={this.initValues[2]} />\n        <hr/>\n        <div>Total Count: {this.state.sum}</div>\n      </div>\n    );\n  }\n{% endcodeblock %}\n\n### 使用prop传递参数的局限\n\n从上面的示例不难看出，子组件和父组件都各自维护一套属于自己的状态，并且通过update来相互通信，如果update内部内部逻辑出现bug，这个时候，计数器的结果到底是子组件的对还是父组件的对呢，这个时候就需要共享状态的概念出现，通过一个全局状态来同步各个子组件内部的状态，开发者也只要关注共享全局状态走向就行。\n\n组件状态不统一：\n<img width=\"300\" src=\"2017-06-12/02.jpeg\" title=\"组件状态不统一\"/>\n全局状态同步状态：\n<img width=\"300\" src=\"2017-06-12/03.jpeg\" title=\"全局状态同步状态\"/>\n\n如果一个系统中，存在多层嵌套组件，如果按照prop规则传递参数，岂不是非常麻烦，所以必须引入全局状态Redux，将在下节中为大家介绍基本的Redux思想及原理。\n\n### react生命周期介绍\n\n生命周期基本分成三个主要阶段：\n* 装载过程，组件第一次渲染过程\n* 更新过程，当组件重新渲染过程\n* 卸载过程，组件从DOM中删除过程\n\n#### 装载过程\n\n依次调用一下生命周期函数方法(按照es6最新语法介绍)：\n\n* constructor\n* defaultProps\n* componentWillMount\n* render\n* componentDidMount\n\n##### constructor\n\n这是es6中构造函数的写法，如果是无状态的React组件无需定义构造函数，因此定义构造函数基本的作用是：\n* 初始化state，在组件定义个函数中需要访问state状态。\n* 绑定函数的this上下文。\n\n代码片段如下：\n{% codeblock lang:javascript %}\nconstructor(props) {\n    super(props);\n    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);\n    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);\n  }\n{% endcodeblock %}\n\n##### defaultProps\n\n主要作用是给props定义初始值，基本写法如下：\n{% codeblock lang:javascript %}\nCounter.defaultProps = {\n  initValue: 0,\n  onUpdate: f => f //什么都不做的函数\n};\n{% endcodeblock %}\n\n##### render\n\n主要作用返回一个JSX描述的结构，最终再交付给React来操作渲染，组件在有些情况下如果不需要返回JSX结构，可以通过返回null或者false来告诉React不渲染任何DOM元素。\n\n>注意：在render中不要操作对状态的改变，应该在自定义函数中改变\n\n##### componentWillMount和componentDidMount\n\ncomponentWillMount在render函数之前调用，也就是DOM还没有挂载，这个时候如果调用this.setState修改状态也不会发生重新渲染，其实我们可以在创建构造函数中就做好在componentWillMount应该做的事情。此函数既可以在服务端被调用，也可以在浏览器端被调用。\n\ncomponentDidMount在render之后调用，也就是挂载DOM的操作，如果一个父组件嵌套多个子组件，这个时候挂载DOM的顺序是等到子组件全部调用render函数之后再开始挂载相应子组件的DOM。该函数只能在浏览器端被调用。如果需要对DOM操作的话，建议可以在componentDidMount中定义函数进行操作。DOM挂载顺序结果如下：\n\n<img width=\"700\" src=\"2017-06-12/04.jpeg\" title=\"DOM挂载顺序\"/>\n\n#### 更新过程\n* componentWillReceiveProps\n* shouldComponentUpdate\n* componentWillUpdate\n* render\n* componentDidUpdate\n\n##### componentWillReceiveProps\n这个函数是根据新的props的值来计算出是不是要更新组件内部state状态。同同时，只要父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发componentWillReceiveProps函数运行。\n\n在Counter组件中增加函数：\n{% codeblock lang:javascript %}\ncomponentWillReceiveProps(nextProps) {\n    console.log('enter componentWillReceiveProps ' + this.props.caption)\n  }\n{% endcodeblock %}\n\n在ControlPanel函数中定义强制更新函数：\n{% codeblock lang:javascript %}\nrender() {\n    console.log('enter ControlPanel render');\n    return (\n      <div style={style}>\n        <Counter onUpdate={this.onCounterUpdate} caption=\"First\" />\n        <Counter onUpdate={this.onCounterUpdate} caption=\"Second\" initValue={this.initValues[1]} />\n        <Counter onUpdate={this.onCounterUpdate} caption=\"Third\" initValue={this.initValues[2]} />\n        <button onClick={ () => this.forceUpdate() }>\n          Click me to re-render!\n        </button>\n        <hr/>\n        <div>Total Count: {this.state.sum}</div>\n      </div>\n    );\n{% endcodeblock %}\nControlPanel组件中触发了render函数，子组件中的componentWillReceiveProps都被触发了，但是并没有改变props的值，运行结果截图如下：\n<img width=\"700\" src=\"2017-06-12/05.jpeg\" title=\"更新过程\"/>\n\n这个函数会接受nextProps参数，一般会用nextProps（这一次渲染传入的值）与this.props（上一次渲染传入的值）进行比较，只有两者有变化的时候才会调用this.setState更新内部状态。\n\n##### shouldComponentUpdate\n\n主要作用根据nextProps, nextState接收的两个参数来判断组件是否需要执行render函数，react中这个函数如果不做任何设置，默认都是返回true，所以再做性能优化的时候，这个函数起到了至关重要的作用。\n在Counter组件中增加函数：\n{% codeblock lang:javascript %}\nshouldComponentUpdate(nextProps, nextState) {\n    return (nextProps.caption !== this.props.caption) ||\n           (nextState.count !== this.state.count);\n  }\n{% endcodeblock %}\n改变任何一个值，只会触发当前这个组件调用render函数，运行结构如下：\n<img width=\"700\" src=\"2017-06-12/05.jpeg\" title=\"性能优化过程\"/>\n\n##### componentWillUpdate和componentDidUpdate\n\n只要shouldComponentUpdate函数返回为true，就会以此调用componentWillUpdate、render、componentDidUpdate这三个函数，同样这两个函数即可以在服务端调用也可以在浏览器端调用。\n\n#### 卸载过程\n\n这个过程主要是卸载不使用的组件DOM元素，或者使用非React方式创建的DOM元素，还是非常有作用的，例如，如果在componentDidMount中可以使用了js原生创建了DOM元素，但是在组件卸载过程中没有清楚，这个时候会造成内存泄露，所以在使用卸载组件的函数，必须确定相关的DOM都清除。\n\n本篇简要的React组件的通信和基本的生命周期运行流程，在使用prop通信会有一定的局限，下节会引入Redux共享状态概念，来解决prop传递的局限，本篇涉及到的源码可以访问https://github.com/wqzwh/react-redux-demo/tree/master/src/demo/01 \n\n\n\n\n\n\n\n\n","slug":"2017-06-12","published":1,"updated":"2017-09-03T04:00:54.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36rc000clmldmgqkhx90","content":"<h3 id=\"组件的设计要素\"><a href=\"#组件的设计要素\" class=\"headerlink\" title=\"组件的设计要素\"></a>组件的设计要素</h3><p>在项目开发初期，针对模块或者组件的分配是及其重要，基本会按照“分而治之”的思想去合理的设计组件的功能以及扩展它们的复用性等等。拆分组件最关键的就是确定组件功能的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的职责，那这两个组件本身就不该被拆分，作为同一个组件或许更加合理。</p>\n<p>组件的划分需要满足两个基本原则：<b>高内聚</b>和<b>低耦合</b></p>\n<p><b>高内聚:</b>把逻辑紧密相关的内容放在一个组件中。早期开发html、css、js基本会以三个不同的文件存放，这样其实是违背高聚合的原则，react正好提供将跟组件相关的css、js、html放在一起的语法结构，这样一来，组件的复用性能够达到极致。</p>\n<p><b>低耦合:</b>不同的组件之间的依赖关系要尽量弱化。也就是每个组件要尽量独立。保持整个系统的低耦合度，让不同的组件去实现不同的功能，复杂的功能是通过细分的组件组装起来完成的，这样设计的话，方便开发者写出低耦合的系统。</p>\n<a id=\"more\"></a>\n<h3 id=\"react组件的数据\"><a href=\"#react组件的数据\" class=\"headerlink\" title=\"react组件的数据\"></a>react组件的数据</h3><p>react组件的数据主要分两种：<b>prop</b>和<b>state</b>。无论prop、state的改变都可能引发组件的渲染，其实react有基本的规范，prop主要作为组件对外部的接口，负责接受其他组件传过来的数据参数等，state主要是组件内部定义的数据状态，仅仅属于当前组件内部使用，片段代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义一个子组件</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"comment\">// 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props</span></div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"comment\">//使用state定义自己内部状态数据</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      text: <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> &#123;caption&#125; = <span class=\"keyword\">this</span>.props; <span class=\"comment\">//通过this.props来获取父亲组件传进来的caption值</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</div><div class=\"line\">        &#123;<span class=\"keyword\">this</span>.state.text&#125;</div><div class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    );</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div><div class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 定义一个父组件</span></div><div class=\"line\"><span class=\"regexp\">class ControlPanel extends Component &#123;</span></div><div class=\"line\"><span class=\"regexp\">  render() &#123;</span></div><div class=\"line\"><span class=\"regexp\">    console.log('enter ControlPanel render');</span></div><div class=\"line\"><span class=\"regexp\">    return (</span></div><div class=\"line\"><span class=\"regexp\">      &lt;div style=&#123;style&#125;&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;Counter caption=\"First\"/</span>&gt;</div><div class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    );</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;;</span></div></pre></td></tr></table></figure>\n<h4 id=\"React中的prop\"><a href=\"#React中的prop\" class=\"headerlink\" title=\"React中的prop\"></a>React中的prop</h4><p>给prop赋值和读取prop的值，以下只是代码片段，主要为了解释那些是赋值那些是读取值<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在构造函数中读取父组件传过来的值</span></div><div class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"comment\">// 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props</span></div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"comment\">//使用state定义自己内部状态数据</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      text: <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在render函数中返回一个组件，并且带上要给该组件传递的数据  </span></div><div class=\"line\"><span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;Counter caption=<span class=\"string\">\"First\"</span>/&gt;</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>如果一个组件需要定义自己的构造函数，一定要在构造函数的第一行通过super调用父级也就是React.Component的构造函数，只有这样才能通过this.props来获取父级传下来的数据。因此常常会在构造函数中绑定this的指向，避免在render中多次绑定而造成性能问题。</p>\n<h4 id=\"propTypes的检查\"><a href=\"#propTypes的检查\" class=\"headerlink\" title=\"propTypes的检查\"></a>propTypes的检查</h4><p>通过propTypes属性来定义prop规格，在组件渲染运行和静态代码检查时，都可以根据propTypes判断外部传递数据的格式是否正确，基本代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Counter.propTypes = &#123;</div><div class=\"line\">  caption:PropTypes.string.isRequired,</div><div class=\"line\">  initValue:PropTypes.number</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br>其中要求caption必须是string类型，initValue必须是number类型，isRequired代表该caption必须传递，不能缺失，而initValue可以不传。</p>\n<p>所以在具体项目开发中，最好的方式是，在开发模式下带上propTypes，而在上线的时候可以去掉这些代码，可以用babel-react-optimize工具自动去除propTypes，这样部署到产品环境的代码就会更优。</p>\n<h4 id=\"React中的state\"><a href=\"#React中的state\" class=\"headerlink\" title=\"React中的state\"></a>React中的state</h4><p>state代表组件内部状态，常常用来定义组件内部初始值。组件内部的state必须是一个对象，不能是string或者number这样简单的数据类型。基本使用如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      text: <span class=\"number\">1</span>, <span class=\"comment\">// 使用state定义自己内部状态数据</span></div><div class=\"line\">      num:props.num || <span class=\"number\">1</span> <span class=\"comment\">// 接受父组件传来的参数</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure><br>在当前组件对象内部通过this.state来访问内部定义的变量，如果要改变状态千万不要直接通过this.state赋值改变，使用react提供的setState这个方法来改变状态，这样改变能够直接触发组件重新render使得界面绑定的相应的状态更新。</p>\n<h4 id=\"prop和state的对比\"><a href=\"#prop和state的对比\" class=\"headerlink\" title=\"prop和state的对比\"></a>prop和state的对比</h4><ul>\n<li>prop用于定义外部接口，state用于定义内部状态；</li>\n<li>prop的赋值在外部世界使用组件时，state的赋值在组件内部；</li>\n<li>组件不应该改变prop的值，而state存在的目的就是让组件来改变的；</li>\n</ul>\n<p>一个子组件去修改props中的值，就是违背react的设计初衷，如果必须修改，建议使用组件内部状态先保存props，然后通过改变组件内部状态变相改变了props。</p>\n<h3 id=\"使用prop建立组件间的通信\"><a href=\"#使用prop建立组件间的通信\" class=\"headerlink\" title=\"使用prop建立组件间的通信\"></a>使用prop建立组件间的通信</h3><p>应用示例如下：</p>\n<p><img width=\"600\" src=\"/2017-06-12/01.jpeg\" title=\"应用示例\"></p>\n<p>使用prop建立组件间的通信原理就是在子组件内部定义改变内部状态的方法并且触发父组件改变父组件的方法，并且在自组件自定一个空函数作为父子组件通信的桥接。</p>\n<p>具体实现代码如下，我们现在Counter子组件中定义需要改变状态的方法，除了触发改变内部状态的updateCount方法，同时也会触发父组件的this.props.onUpdate方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">onClickIncrementButton() &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.updateCount(<span class=\"literal\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">onClickDecrementButton() &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.updateCount(<span class=\"literal\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">updateCount(isIncrement) &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> previousValue = <span class=\"keyword\">this</span>.state.count;</div><div class=\"line\">  <span class=\"keyword\">const</span> newValue = isIncrement ? previousValue + <span class=\"number\">1</span> : previousValue - <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">count</span>: newValue&#125;)</div><div class=\"line\">  <span class=\"keyword\">this</span>.props.onUpdate(newValue, previousValue)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来我们定义一个默认的空函数，来桥接父子组件通信，代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Counter.propTypes = &#123;</div><div class=\"line\">  caption: PropTypes.string.isRequired,</div><div class=\"line\">  initValue: PropTypes.number,</div><div class=\"line\">  onUpdate: PropTypes.func</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Counter.defaultProps = &#123;</div><div class=\"line\">  initValue: <span class=\"number\">0</span>,</div><div class=\"line\">  onUpdate: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f <span class=\"comment\">//什么都不做的函数</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>并且在父组件中建立相应的更新方法，并且在render将onCounterUpdate方法以onUpdate名字传递给子组件中，自组件定义onUpdate来接受父组件传递下来的方法，从而解决了父子组件的通信，代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">onCounterUpdate(newValue, previousValue) &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> valueChange = newValue - previousValue;</div><div class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">sum</span>: <span class=\"keyword\">this</span>.state.sum + valueChange&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">render() &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;div style=&#123;style&#125;&gt;</div><div class=\"line\">      &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"First\"</span> /&gt;</div><div class=\"line\">      &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"Second\"</span> initValue=&#123;<span class=\"keyword\">this</span>.initValues[<span class=\"number\">1</span>]&#125; /&gt;</div><div class=\"line\">      &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"Third\"</span> initValue=&#123;<span class=\"keyword\">this</span>.initValues[<span class=\"number\">2</span>]&#125; /&gt;</div><div class=\"line\">      &lt;hr/&gt;</div><div class=\"line\">      &lt;div&gt;Total Count: &#123;<span class=\"keyword\">this</span>.state.sum&#125;&lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"使用prop传递参数的局限\"><a href=\"#使用prop传递参数的局限\" class=\"headerlink\" title=\"使用prop传递参数的局限\"></a>使用prop传递参数的局限</h3><p>从上面的示例不难看出，子组件和父组件都各自维护一套属于自己的状态，并且通过update来相互通信，如果update内部内部逻辑出现bug，这个时候，计数器的结果到底是子组件的对还是父组件的对呢，这个时候就需要共享状态的概念出现，通过一个全局状态来同步各个子组件内部的状态，开发者也只要关注共享全局状态走向就行。</p>\n<p>组件状态不统一：<br><img width=\"300\" src=\"/2017-06-12/02.jpeg\" title=\"组件状态不统一\"><br>全局状态同步状态：<br><img width=\"300\" src=\"/2017-06-12/03.jpeg\" title=\"全局状态同步状态\"></p>\n<p>如果一个系统中，存在多层嵌套组件，如果按照prop规则传递参数，岂不是非常麻烦，所以必须引入全局状态Redux，将在下节中为大家介绍基本的Redux思想及原理。</p>\n<h3 id=\"react生命周期介绍\"><a href=\"#react生命周期介绍\" class=\"headerlink\" title=\"react生命周期介绍\"></a>react生命周期介绍</h3><p>生命周期基本分成三个主要阶段：</p>\n<ul>\n<li>装载过程，组件第一次渲染过程</li>\n<li>更新过程，当组件重新渲染过程</li>\n<li>卸载过程，组件从DOM中删除过程</li>\n</ul>\n<h4 id=\"装载过程\"><a href=\"#装载过程\" class=\"headerlink\" title=\"装载过程\"></a>装载过程</h4><p>依次调用一下生命周期函数方法(按照es6最新语法介绍)：</p>\n<ul>\n<li>constructor</li>\n<li>defaultProps</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n<h5 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h5><p>这是es6中构造函数的写法，如果是无状态的React组件无需定义构造函数，因此定义构造函数基本的作用是：</p>\n<ul>\n<li>初始化state，在组件定义个函数中需要访问state状态。</li>\n<li>绑定函数的this上下文。</li>\n</ul>\n<p>代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.onClickIncrementButton = <span class=\"keyword\">this</span>.onClickIncrementButton.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.onClickDecrementButton = <span class=\"keyword\">this</span>.onClickDecrementButton.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"defaultProps\"><a href=\"#defaultProps\" class=\"headerlink\" title=\"defaultProps\"></a>defaultProps</h5><p>主要作用是给props定义初始值，基本写法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Counter.defaultProps = &#123;</div><div class=\"line\">  initValue: <span class=\"number\">0</span>,</div><div class=\"line\">  onUpdate: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f <span class=\"comment\">//什么都不做的函数</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h5 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h5><p>主要作用返回一个JSX描述的结构，最终再交付给React来操作渲染，组件在有些情况下如果不需要返回JSX结构，可以通过返回null或者false来告诉React不渲染任何DOM元素。</p>\n<blockquote>\n<p>注意：在render中不要操作对状态的改变，应该在自定义函数中改变</p>\n</blockquote>\n<h5 id=\"componentWillMount和componentDidMount\"><a href=\"#componentWillMount和componentDidMount\" class=\"headerlink\" title=\"componentWillMount和componentDidMount\"></a>componentWillMount和componentDidMount</h5><p>componentWillMount在render函数之前调用，也就是DOM还没有挂载，这个时候如果调用this.setState修改状态也不会发生重新渲染，其实我们可以在创建构造函数中就做好在componentWillMount应该做的事情。此函数既可以在服务端被调用，也可以在浏览器端被调用。</p>\n<p>componentDidMount在render之后调用，也就是挂载DOM的操作，如果一个父组件嵌套多个子组件，这个时候挂载DOM的顺序是等到子组件全部调用render函数之后再开始挂载相应子组件的DOM。该函数只能在浏览器端被调用。如果需要对DOM操作的话，建议可以在componentDidMount中定义函数进行操作。DOM挂载顺序结果如下：</p>\n<p><img width=\"700\" src=\"/2017-06-12/04.jpeg\" title=\"DOM挂载顺序\"></p>\n<h4 id=\"更新过程\"><a href=\"#更新过程\" class=\"headerlink\" title=\"更新过程\"></a>更新过程</h4><ul>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n<h5 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h5><p>这个函数是根据新的props的值来计算出是不是要更新组件内部state状态。同同时，只要父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发componentWillReceiveProps函数运行。</p>\n<p>在Counter组件中增加函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">componentWillReceiveProps(nextProps) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'enter componentWillReceiveProps '</span> + <span class=\"keyword\">this</span>.props.caption)</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>在ControlPanel函数中定义强制更新函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">render() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'enter ControlPanel render'</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div style=&#123;style&#125;&gt;</div><div class=\"line\">        &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"First\"</span> /&gt;</div><div class=\"line\">        &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"Second\"</span> initValue=&#123;<span class=\"keyword\">this</span>.initValues[<span class=\"number\">1</span>]&#125; /&gt;</div><div class=\"line\">        &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"Third\"</span> initValue=&#123;<span class=\"keyword\">this</span>.initValues[<span class=\"number\">2</span>]&#125; /&gt;</div><div class=\"line\">        &lt;button onClick=&#123; () =&gt; <span class=\"keyword\">this</span>.forceUpdate() &#125;&gt;</div><div class=\"line\">          Click me to re-render!</div><div class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;hr/</span>&gt;</div><div class=\"line\">        &lt;div&gt;Total Count: &#123;<span class=\"keyword\">this</span>.state.sum&#125;&lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div></pre></td></tr></table></figure><br>ControlPanel组件中触发了render函数，子组件中的componentWillReceiveProps都被触发了，但是并没有改变props的值，运行结果截图如下：<br><img width=\"700\" src=\"/2017-06-12/05.jpeg\" title=\"更新过程\"></p>\n<p>这个函数会接受nextProps参数，一般会用nextProps（这一次渲染传入的值）与this.props（上一次渲染传入的值）进行比较，只有两者有变化的时候才会调用this.setState更新内部状态。</p>\n<h5 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h5><p>主要作用根据nextProps, nextState接收的两个参数来判断组件是否需要执行render函数，react中这个函数如果不做任何设置，默认都是返回true，所以再做性能优化的时候，这个函数起到了至关重要的作用。<br>在Counter组件中增加函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (nextProps.caption !== <span class=\"keyword\">this</span>.props.caption) ||</div><div class=\"line\">           (nextState.count !== <span class=\"keyword\">this</span>.state.count);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure><br>改变任何一个值，只会触发当前这个组件调用render函数，运行结构如下：<br><img width=\"700\" src=\"/2017-06-12/05.jpeg\" title=\"性能优化过程\"></p>\n<h5 id=\"componentWillUpdate和componentDidUpdate\"><a href=\"#componentWillUpdate和componentDidUpdate\" class=\"headerlink\" title=\"componentWillUpdate和componentDidUpdate\"></a>componentWillUpdate和componentDidUpdate</h5><p>只要shouldComponentUpdate函数返回为true，就会以此调用componentWillUpdate、render、componentDidUpdate这三个函数，同样这两个函数即可以在服务端调用也可以在浏览器端调用。</p>\n<h4 id=\"卸载过程\"><a href=\"#卸载过程\" class=\"headerlink\" title=\"卸载过程\"></a>卸载过程</h4><p>这个过程主要是卸载不使用的组件DOM元素，或者使用非React方式创建的DOM元素，还是非常有作用的，例如，如果在componentDidMount中可以使用了js原生创建了DOM元素，但是在组件卸载过程中没有清楚，这个时候会造成内存泄露，所以在使用卸载组件的函数，必须确定相关的DOM都清除。</p>\n<p>本篇简要的React组件的通信和基本的生命周期运行流程，在使用prop通信会有一定的局限，下节会引入Redux共享状态概念，来解决prop传递的局限，本篇涉及到的源码可以访问<a href=\"https://github.com/wqzwh/react-redux-demo/tree/master/src/demo/01\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/react-redux-demo/tree/master/src/demo/01</a> </p>\n","site":{"data":{}},"excerpt":"<h3 id=\"组件的设计要素\"><a href=\"#组件的设计要素\" class=\"headerlink\" title=\"组件的设计要素\"></a>组件的设计要素</h3><p>在项目开发初期，针对模块或者组件的分配是及其重要，基本会按照“分而治之”的思想去合理的设计组件的功能以及扩展它们的复用性等等。拆分组件最关键的就是确定组件功能的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的职责，那这两个组件本身就不该被拆分，作为同一个组件或许更加合理。</p>\n<p>组件的划分需要满足两个基本原则：<b>高内聚</b>和<b>低耦合</b></p>\n<p><b>高内聚:</b>把逻辑紧密相关的内容放在一个组件中。早期开发html、css、js基本会以三个不同的文件存放，这样其实是违背高聚合的原则，react正好提供将跟组件相关的css、js、html放在一起的语法结构，这样一来，组件的复用性能够达到极致。</p>\n<p><b>低耦合:</b>不同的组件之间的依赖关系要尽量弱化。也就是每个组件要尽量独立。保持整个系统的低耦合度，让不同的组件去实现不同的功能，复杂的功能是通过细分的组件组装起来完成的，这样设计的话，方便开发者写出低耦合的系统。</p>","more":"<h3 id=\"react组件的数据\"><a href=\"#react组件的数据\" class=\"headerlink\" title=\"react组件的数据\"></a>react组件的数据</h3><p>react组件的数据主要分两种：<b>prop</b>和<b>state</b>。无论prop、state的改变都可能引发组件的渲染，其实react有基本的规范，prop主要作为组件对外部的接口，负责接受其他组件传过来的数据参数等，state主要是组件内部定义的数据状态，仅仅属于当前组件内部使用，片段代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义一个子组件</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"comment\">// 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props</span></div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"comment\">//使用state定义自己内部状态数据</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      text: <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> &#123;caption&#125; = <span class=\"keyword\">this</span>.props; <span class=\"comment\">//通过this.props来获取父亲组件传进来的caption值</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</div><div class=\"line\">        &#123;<span class=\"keyword\">this</span>.state.text&#125;</div><div class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    );</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div><div class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 定义一个父组件</span></div><div class=\"line\"><span class=\"regexp\">class ControlPanel extends Component &#123;</span></div><div class=\"line\"><span class=\"regexp\">  render() &#123;</span></div><div class=\"line\"><span class=\"regexp\">    console.log('enter ControlPanel render');</span></div><div class=\"line\"><span class=\"regexp\">    return (</span></div><div class=\"line\"><span class=\"regexp\">      &lt;div style=&#123;style&#125;&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;Counter caption=\"First\"/</span>&gt;</div><div class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    );</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;;</span></div></pre></td></tr></table></figure>\n<h4 id=\"React中的prop\"><a href=\"#React中的prop\" class=\"headerlink\" title=\"React中的prop\"></a>React中的prop</h4><p>给prop赋值和读取prop的值，以下只是代码片段，主要为了解释那些是赋值那些是读取值<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在构造函数中读取父组件传过来的值</span></div><div class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"comment\">// 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props</span></div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"comment\">//使用state定义自己内部状态数据</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      text: <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在render函数中返回一个组件，并且带上要给该组件传递的数据  </span></div><div class=\"line\"><span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;Counter caption=<span class=\"string\">\"First\"</span>/&gt;</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>如果一个组件需要定义自己的构造函数，一定要在构造函数的第一行通过super调用父级也就是React.Component的构造函数，只有这样才能通过this.props来获取父级传下来的数据。因此常常会在构造函数中绑定this的指向，避免在render中多次绑定而造成性能问题。</p>\n<h4 id=\"propTypes的检查\"><a href=\"#propTypes的检查\" class=\"headerlink\" title=\"propTypes的检查\"></a>propTypes的检查</h4><p>通过propTypes属性来定义prop规格，在组件渲染运行和静态代码检查时，都可以根据propTypes判断外部传递数据的格式是否正确，基本代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Counter.propTypes = &#123;</div><div class=\"line\">  caption:PropTypes.string.isRequired,</div><div class=\"line\">  initValue:PropTypes.number</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br>其中要求caption必须是string类型，initValue必须是number类型，isRequired代表该caption必须传递，不能缺失，而initValue可以不传。</p>\n<p>所以在具体项目开发中，最好的方式是，在开发模式下带上propTypes，而在上线的时候可以去掉这些代码，可以用babel-react-optimize工具自动去除propTypes，这样部署到产品环境的代码就会更优。</p>\n<h4 id=\"React中的state\"><a href=\"#React中的state\" class=\"headerlink\" title=\"React中的state\"></a>React中的state</h4><p>state代表组件内部状态，常常用来定义组件内部初始值。组件内部的state必须是一个对象，不能是string或者number这样简单的数据类型。基本使用如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      text: <span class=\"number\">1</span>, <span class=\"comment\">// 使用state定义自己内部状态数据</span></div><div class=\"line\">      num:props.num || <span class=\"number\">1</span> <span class=\"comment\">// 接受父组件传来的参数</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure><br>在当前组件对象内部通过this.state来访问内部定义的变量，如果要改变状态千万不要直接通过this.state赋值改变，使用react提供的setState这个方法来改变状态，这样改变能够直接触发组件重新render使得界面绑定的相应的状态更新。</p>\n<h4 id=\"prop和state的对比\"><a href=\"#prop和state的对比\" class=\"headerlink\" title=\"prop和state的对比\"></a>prop和state的对比</h4><ul>\n<li>prop用于定义外部接口，state用于定义内部状态；</li>\n<li>prop的赋值在外部世界使用组件时，state的赋值在组件内部；</li>\n<li>组件不应该改变prop的值，而state存在的目的就是让组件来改变的；</li>\n</ul>\n<p>一个子组件去修改props中的值，就是违背react的设计初衷，如果必须修改，建议使用组件内部状态先保存props，然后通过改变组件内部状态变相改变了props。</p>\n<h3 id=\"使用prop建立组件间的通信\"><a href=\"#使用prop建立组件间的通信\" class=\"headerlink\" title=\"使用prop建立组件间的通信\"></a>使用prop建立组件间的通信</h3><p>应用示例如下：</p>\n<p><img width=\"600\" src=\"/2017-06-12/01.jpeg\" title=\"应用示例\"></p>\n<p>使用prop建立组件间的通信原理就是在子组件内部定义改变内部状态的方法并且触发父组件改变父组件的方法，并且在自组件自定一个空函数作为父子组件通信的桥接。</p>\n<p>具体实现代码如下，我们现在Counter子组件中定义需要改变状态的方法，除了触发改变内部状态的updateCount方法，同时也会触发父组件的this.props.onUpdate方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">onClickIncrementButton() &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.updateCount(<span class=\"literal\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">onClickDecrementButton() &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.updateCount(<span class=\"literal\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">updateCount(isIncrement) &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> previousValue = <span class=\"keyword\">this</span>.state.count;</div><div class=\"line\">  <span class=\"keyword\">const</span> newValue = isIncrement ? previousValue + <span class=\"number\">1</span> : previousValue - <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">count</span>: newValue&#125;)</div><div class=\"line\">  <span class=\"keyword\">this</span>.props.onUpdate(newValue, previousValue)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来我们定义一个默认的空函数，来桥接父子组件通信，代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Counter.propTypes = &#123;</div><div class=\"line\">  caption: PropTypes.string.isRequired,</div><div class=\"line\">  initValue: PropTypes.number,</div><div class=\"line\">  onUpdate: PropTypes.func</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Counter.defaultProps = &#123;</div><div class=\"line\">  initValue: <span class=\"number\">0</span>,</div><div class=\"line\">  onUpdate: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f <span class=\"comment\">//什么都不做的函数</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>并且在父组件中建立相应的更新方法，并且在render将onCounterUpdate方法以onUpdate名字传递给子组件中，自组件定义onUpdate来接受父组件传递下来的方法，从而解决了父子组件的通信，代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">onCounterUpdate(newValue, previousValue) &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> valueChange = newValue - previousValue;</div><div class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">sum</span>: <span class=\"keyword\">this</span>.state.sum + valueChange&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">render() &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;div style=&#123;style&#125;&gt;</div><div class=\"line\">      &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"First\"</span> /&gt;</div><div class=\"line\">      &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"Second\"</span> initValue=&#123;<span class=\"keyword\">this</span>.initValues[<span class=\"number\">1</span>]&#125; /&gt;</div><div class=\"line\">      &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"Third\"</span> initValue=&#123;<span class=\"keyword\">this</span>.initValues[<span class=\"number\">2</span>]&#125; /&gt;</div><div class=\"line\">      &lt;hr/&gt;</div><div class=\"line\">      &lt;div&gt;Total Count: &#123;<span class=\"keyword\">this</span>.state.sum&#125;&lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"使用prop传递参数的局限\"><a href=\"#使用prop传递参数的局限\" class=\"headerlink\" title=\"使用prop传递参数的局限\"></a>使用prop传递参数的局限</h3><p>从上面的示例不难看出，子组件和父组件都各自维护一套属于自己的状态，并且通过update来相互通信，如果update内部内部逻辑出现bug，这个时候，计数器的结果到底是子组件的对还是父组件的对呢，这个时候就需要共享状态的概念出现，通过一个全局状态来同步各个子组件内部的状态，开发者也只要关注共享全局状态走向就行。</p>\n<p>组件状态不统一：<br><img width=\"300\" src=\"/2017-06-12/02.jpeg\" title=\"组件状态不统一\"><br>全局状态同步状态：<br><img width=\"300\" src=\"/2017-06-12/03.jpeg\" title=\"全局状态同步状态\"></p>\n<p>如果一个系统中，存在多层嵌套组件，如果按照prop规则传递参数，岂不是非常麻烦，所以必须引入全局状态Redux，将在下节中为大家介绍基本的Redux思想及原理。</p>\n<h3 id=\"react生命周期介绍\"><a href=\"#react生命周期介绍\" class=\"headerlink\" title=\"react生命周期介绍\"></a>react生命周期介绍</h3><p>生命周期基本分成三个主要阶段：</p>\n<ul>\n<li>装载过程，组件第一次渲染过程</li>\n<li>更新过程，当组件重新渲染过程</li>\n<li>卸载过程，组件从DOM中删除过程</li>\n</ul>\n<h4 id=\"装载过程\"><a href=\"#装载过程\" class=\"headerlink\" title=\"装载过程\"></a>装载过程</h4><p>依次调用一下生命周期函数方法(按照es6最新语法介绍)：</p>\n<ul>\n<li>constructor</li>\n<li>defaultProps</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n<h5 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h5><p>这是es6中构造函数的写法，如果是无状态的React组件无需定义构造函数，因此定义构造函数基本的作用是：</p>\n<ul>\n<li>初始化state，在组件定义个函数中需要访问state状态。</li>\n<li>绑定函数的this上下文。</li>\n</ul>\n<p>代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.onClickIncrementButton = <span class=\"keyword\">this</span>.onClickIncrementButton.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.onClickDecrementButton = <span class=\"keyword\">this</span>.onClickDecrementButton.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"defaultProps\"><a href=\"#defaultProps\" class=\"headerlink\" title=\"defaultProps\"></a>defaultProps</h5><p>主要作用是给props定义初始值，基本写法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Counter.defaultProps = &#123;</div><div class=\"line\">  initValue: <span class=\"number\">0</span>,</div><div class=\"line\">  onUpdate: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f <span class=\"comment\">//什么都不做的函数</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h5 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h5><p>主要作用返回一个JSX描述的结构，最终再交付给React来操作渲染，组件在有些情况下如果不需要返回JSX结构，可以通过返回null或者false来告诉React不渲染任何DOM元素。</p>\n<blockquote>\n<p>注意：在render中不要操作对状态的改变，应该在自定义函数中改变</p>\n</blockquote>\n<h5 id=\"componentWillMount和componentDidMount\"><a href=\"#componentWillMount和componentDidMount\" class=\"headerlink\" title=\"componentWillMount和componentDidMount\"></a>componentWillMount和componentDidMount</h5><p>componentWillMount在render函数之前调用，也就是DOM还没有挂载，这个时候如果调用this.setState修改状态也不会发生重新渲染，其实我们可以在创建构造函数中就做好在componentWillMount应该做的事情。此函数既可以在服务端被调用，也可以在浏览器端被调用。</p>\n<p>componentDidMount在render之后调用，也就是挂载DOM的操作，如果一个父组件嵌套多个子组件，这个时候挂载DOM的顺序是等到子组件全部调用render函数之后再开始挂载相应子组件的DOM。该函数只能在浏览器端被调用。如果需要对DOM操作的话，建议可以在componentDidMount中定义函数进行操作。DOM挂载顺序结果如下：</p>\n<p><img width=\"700\" src=\"/2017-06-12/04.jpeg\" title=\"DOM挂载顺序\"></p>\n<h4 id=\"更新过程\"><a href=\"#更新过程\" class=\"headerlink\" title=\"更新过程\"></a>更新过程</h4><ul>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ul>\n<h5 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h5><p>这个函数是根据新的props的值来计算出是不是要更新组件内部state状态。同同时，只要父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发componentWillReceiveProps函数运行。</p>\n<p>在Counter组件中增加函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">componentWillReceiveProps(nextProps) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'enter componentWillReceiveProps '</span> + <span class=\"keyword\">this</span>.props.caption)</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>在ControlPanel函数中定义强制更新函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">render() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'enter ControlPanel render'</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div style=&#123;style&#125;&gt;</div><div class=\"line\">        &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"First\"</span> /&gt;</div><div class=\"line\">        &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"Second\"</span> initValue=&#123;<span class=\"keyword\">this</span>.initValues[<span class=\"number\">1</span>]&#125; /&gt;</div><div class=\"line\">        &lt;Counter onUpdate=&#123;<span class=\"keyword\">this</span>.onCounterUpdate&#125; caption=<span class=\"string\">\"Third\"</span> initValue=&#123;<span class=\"keyword\">this</span>.initValues[<span class=\"number\">2</span>]&#125; /&gt;</div><div class=\"line\">        &lt;button onClick=&#123; () =&gt; <span class=\"keyword\">this</span>.forceUpdate() &#125;&gt;</div><div class=\"line\">          Click me to re-render!</div><div class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;hr/</span>&gt;</div><div class=\"line\">        &lt;div&gt;Total Count: &#123;<span class=\"keyword\">this</span>.state.sum&#125;&lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div></pre></td></tr></table></figure><br>ControlPanel组件中触发了render函数，子组件中的componentWillReceiveProps都被触发了，但是并没有改变props的值，运行结果截图如下：<br><img width=\"700\" src=\"/2017-06-12/05.jpeg\" title=\"更新过程\"></p>\n<p>这个函数会接受nextProps参数，一般会用nextProps（这一次渲染传入的值）与this.props（上一次渲染传入的值）进行比较，只有两者有变化的时候才会调用this.setState更新内部状态。</p>\n<h5 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h5><p>主要作用根据nextProps, nextState接收的两个参数来判断组件是否需要执行render函数，react中这个函数如果不做任何设置，默认都是返回true，所以再做性能优化的时候，这个函数起到了至关重要的作用。<br>在Counter组件中增加函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (nextProps.caption !== <span class=\"keyword\">this</span>.props.caption) ||</div><div class=\"line\">           (nextState.count !== <span class=\"keyword\">this</span>.state.count);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure><br>改变任何一个值，只会触发当前这个组件调用render函数，运行结构如下：<br><img width=\"700\" src=\"/2017-06-12/05.jpeg\" title=\"性能优化过程\"></p>\n<h5 id=\"componentWillUpdate和componentDidUpdate\"><a href=\"#componentWillUpdate和componentDidUpdate\" class=\"headerlink\" title=\"componentWillUpdate和componentDidUpdate\"></a>componentWillUpdate和componentDidUpdate</h5><p>只要shouldComponentUpdate函数返回为true，就会以此调用componentWillUpdate、render、componentDidUpdate这三个函数，同样这两个函数即可以在服务端调用也可以在浏览器端调用。</p>\n<h4 id=\"卸载过程\"><a href=\"#卸载过程\" class=\"headerlink\" title=\"卸载过程\"></a>卸载过程</h4><p>这个过程主要是卸载不使用的组件DOM元素，或者使用非React方式创建的DOM元素，还是非常有作用的，例如，如果在componentDidMount中可以使用了js原生创建了DOM元素，但是在组件卸载过程中没有清楚，这个时候会造成内存泄露，所以在使用卸载组件的函数，必须确定相关的DOM都清除。</p>\n<p>本篇简要的React组件的通信和基本的生命周期运行流程，在使用prop通信会有一定的局限，下节会引入Redux共享状态概念，来解决prop传递的局限，本篇涉及到的源码可以访问<a href=\"https://github.com/wqzwh/react-redux-demo/tree/master/src/demo/01\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/react-redux-demo/tree/master/src/demo/01</a> </p>"},{"title":"ajax如何截取302响应","comments":1,"date":"2017-04-02T12:09:11.000Z","_content":"在ajax请求中，如果服务器端的响应是302 Found，在ajax的回调函数中能够获取这个状态码吗？能够从Response Headers中得到Location的值进行重定向吗？让我们来一起看看实际情况。\n\n##### 使用jQuery的$.ajax()发起ajax请求的JavaScript代码如下：\n\n``` javascript\n$.ajax({\nurl: '/oauth/respond',\ntype: 'post',\ndata: data,\ncomplete: function(jqXHR){\n    console.log(jqXHR.status);\n},\nerror: function (xhr) {\n    console.log(xhr.status);\n}\n});\n```\n<!-- more -->\n\n##### 当服务器端返回302 Found的响应时，浏览器中的运行结果如下：\n![111](ajax/111.png)\n\n在ajax的complete()与error()回调函数中得到的状态码都是404，而不是302。 \n为什么呢？在stackoverflow上找到了答案：\n\n原来，当服务器将302响应发给浏览器时，浏览器并不是直接进行ajax回调处理，而是先执行302重定向——从Response Headers中读取Location信息，然后向Location中的Url发出请求，在收到这个请求的响应后才会进行ajax回调处理。大致流程如下：\n\najax -> browser -> server -> 302 -> browser(redirect) -> server -> browser -> ajax callback\n\n而在我们的测试程序中，由于302返回的重定向URL在服务器上没有相应的处理程序，所以在ajax回调函数中得到的是404状态码；如果存在对应的URL，得到的状态码就是200。\n\n所以，如果你想在ajax请求中根据302响应通过location.href进行重定向是不可行的。\n\n#### 如何解决？\n\n#### 【方法一】\n\n继续用ajax，修改服务器端代码，将原来的302响应改为json响应，比如下面的ASP.NET MVC示例代码：\n\n``` javascript\nreturn Json(new { status = 302, location = \"/oauth/respond\" });\n\najax代码稍作修改即可：\n\n$.ajax({\n    url: '/oauth/respond',\n    type: 'post',\n    data: data,\n    dataType: 'json',\n    success: function (data) {\n        if (data.status == 302) {\n            location.href = data.location;\n        }\n    }\n}); \n```\n#### 【方法二】\n\n不用ajax，改用form。\n\n``` javascript\n\n<form method=\"post\" action=\"/oauth/respond\"></form>\n\n```\n","source":"_posts/ajax.md","raw":"---\ntitle: ajax如何截取302响应\ncomments: true\ndate: 2017-04-02 20:09:11\ncategories: \"javascript\"\ntags: \n    - 'javascript'\n    - 'ajax'\n    - '302'\n---\n在ajax请求中，如果服务器端的响应是302 Found，在ajax的回调函数中能够获取这个状态码吗？能够从Response Headers中得到Location的值进行重定向吗？让我们来一起看看实际情况。\n\n##### 使用jQuery的$.ajax()发起ajax请求的JavaScript代码如下：\n\n``` javascript\n$.ajax({\nurl: '/oauth/respond',\ntype: 'post',\ndata: data,\ncomplete: function(jqXHR){\n    console.log(jqXHR.status);\n},\nerror: function (xhr) {\n    console.log(xhr.status);\n}\n});\n```\n<!-- more -->\n\n##### 当服务器端返回302 Found的响应时，浏览器中的运行结果如下：\n![111](ajax/111.png)\n\n在ajax的complete()与error()回调函数中得到的状态码都是404，而不是302。 \n为什么呢？在stackoverflow上找到了答案：\n\n原来，当服务器将302响应发给浏览器时，浏览器并不是直接进行ajax回调处理，而是先执行302重定向——从Response Headers中读取Location信息，然后向Location中的Url发出请求，在收到这个请求的响应后才会进行ajax回调处理。大致流程如下：\n\najax -> browser -> server -> 302 -> browser(redirect) -> server -> browser -> ajax callback\n\n而在我们的测试程序中，由于302返回的重定向URL在服务器上没有相应的处理程序，所以在ajax回调函数中得到的是404状态码；如果存在对应的URL，得到的状态码就是200。\n\n所以，如果你想在ajax请求中根据302响应通过location.href进行重定向是不可行的。\n\n#### 如何解决？\n\n#### 【方法一】\n\n继续用ajax，修改服务器端代码，将原来的302响应改为json响应，比如下面的ASP.NET MVC示例代码：\n\n``` javascript\nreturn Json(new { status = 302, location = \"/oauth/respond\" });\n\najax代码稍作修改即可：\n\n$.ajax({\n    url: '/oauth/respond',\n    type: 'post',\n    data: data,\n    dataType: 'json',\n    success: function (data) {\n        if (data.status == 302) {\n            location.href = data.location;\n        }\n    }\n}); \n```\n#### 【方法二】\n\n不用ajax，改用form。\n\n``` javascript\n\n<form method=\"post\" action=\"/oauth/respond\"></form>\n\n```\n","slug":"ajax","published":1,"updated":"2017-08-26T12:58:33.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36re000elmld6w27wkeu","content":"<p>在ajax请求中，如果服务器端的响应是302 Found，在ajax的回调函数中能够获取这个状态码吗？能够从Response Headers中得到Location的值进行重定向吗？让我们来一起看看实际情况。</p>\n<h5 id=\"使用jQuery的-ajax-发起ajax请求的JavaScript代码如下：\"><a href=\"#使用jQuery的-ajax-发起ajax请求的JavaScript代码如下：\" class=\"headerlink\" title=\"使用jQuery的$.ajax()发起ajax请求的JavaScript代码如下：\"></a>使用jQuery的$.ajax()发起ajax请求的JavaScript代码如下：</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">url: <span class=\"string\">'/oauth/respond'</span>,</div><div class=\"line\">type: <span class=\"string\">'post'</span>,</div><div class=\"line\">data: data,</div><div class=\"line\">complete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(jqXHR.status);</div><div class=\"line\">&#125;,</div><div class=\"line\">error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">xhr</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(xhr.status);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h5 id=\"当服务器端返回302-Found的响应时，浏览器中的运行结果如下：\"><a href=\"#当服务器端返回302-Found的响应时，浏览器中的运行结果如下：\" class=\"headerlink\" title=\"当服务器端返回302 Found的响应时，浏览器中的运行结果如下：\"></a>当服务器端返回302 Found的响应时，浏览器中的运行结果如下：</h5><p><img src=\"/ajax/111.png\" alt=\"111\"></p>\n<p>在ajax的complete()与error()回调函数中得到的状态码都是404，而不是302。<br>为什么呢？在stackoverflow上找到了答案：</p>\n<p>原来，当服务器将302响应发给浏览器时，浏览器并不是直接进行ajax回调处理，而是先执行302重定向——从Response Headers中读取Location信息，然后向Location中的Url发出请求，在收到这个请求的响应后才会进行ajax回调处理。大致流程如下：</p>\n<p>ajax -&gt; browser -&gt; server -&gt; 302 -&gt; browser(redirect) -&gt; server -&gt; browser -&gt; ajax callback</p>\n<p>而在我们的测试程序中，由于302返回的重定向URL在服务器上没有相应的处理程序，所以在ajax回调函数中得到的是404状态码；如果存在对应的URL，得到的状态码就是200。</p>\n<p>所以，如果你想在ajax请求中根据302响应通过location.href进行重定向是不可行的。</p>\n<h4 id=\"如何解决？\"><a href=\"#如何解决？\" class=\"headerlink\" title=\"如何解决？\"></a>如何解决？</h4><h4 id=\"【方法一】\"><a href=\"#【方法一】\" class=\"headerlink\" title=\"【方法一】\"></a>【方法一】</h4><p>继续用ajax，修改服务器端代码，将原来的302响应改为json响应，比如下面的ASP.NET MVC示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> Json(<span class=\"keyword\">new</span> &#123; status = <span class=\"number\">302</span>, location = <span class=\"string\">\"/oauth/respond\"</span> &#125;);</div><div class=\"line\"></div><div class=\"line\">ajax代码稍作修改即可：</div><div class=\"line\"></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">    url: <span class=\"string\">'/oauth/respond'</span>,</div><div class=\"line\">    type: <span class=\"string\">'post'</span>,</div><div class=\"line\">    data: data,</div><div class=\"line\">    dataType: <span class=\"string\">'json'</span>,</div><div class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (data.status == <span class=\"number\">302</span>) &#123;</div><div class=\"line\">            location.href = data.location;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"【方法二】\"><a href=\"#【方法二】\" class=\"headerlink\" title=\"【方法二】\"></a>【方法二】</h4><p>不用ajax，改用form。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&lt;form method=<span class=\"string\">\"post\"</span> action=<span class=\"string\">\"/oauth/respond\"</span>&gt;&lt;/form&gt;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>在ajax请求中，如果服务器端的响应是302 Found，在ajax的回调函数中能够获取这个状态码吗？能够从Response Headers中得到Location的值进行重定向吗？让我们来一起看看实际情况。</p>\n<h5 id=\"使用jQuery的-ajax-发起ajax请求的JavaScript代码如下：\"><a href=\"#使用jQuery的-ajax-发起ajax请求的JavaScript代码如下：\" class=\"headerlink\" title=\"使用jQuery的$.ajax()发起ajax请求的JavaScript代码如下：\"></a>使用jQuery的$.ajax()发起ajax请求的JavaScript代码如下：</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">url: <span class=\"string\">'/oauth/respond'</span>,</div><div class=\"line\">type: <span class=\"string\">'post'</span>,</div><div class=\"line\">data: data,</div><div class=\"line\">complete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(jqXHR.status);</div><div class=\"line\">&#125;,</div><div class=\"line\">error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">xhr</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(xhr.status);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>","more":"<h5 id=\"当服务器端返回302-Found的响应时，浏览器中的运行结果如下：\"><a href=\"#当服务器端返回302-Found的响应时，浏览器中的运行结果如下：\" class=\"headerlink\" title=\"当服务器端返回302 Found的响应时，浏览器中的运行结果如下：\"></a>当服务器端返回302 Found的响应时，浏览器中的运行结果如下：</h5><p><img src=\"/ajax/111.png\" alt=\"111\"></p>\n<p>在ajax的complete()与error()回调函数中得到的状态码都是404，而不是302。<br>为什么呢？在stackoverflow上找到了答案：</p>\n<p>原来，当服务器将302响应发给浏览器时，浏览器并不是直接进行ajax回调处理，而是先执行302重定向——从Response Headers中读取Location信息，然后向Location中的Url发出请求，在收到这个请求的响应后才会进行ajax回调处理。大致流程如下：</p>\n<p>ajax -&gt; browser -&gt; server -&gt; 302 -&gt; browser(redirect) -&gt; server -&gt; browser -&gt; ajax callback</p>\n<p>而在我们的测试程序中，由于302返回的重定向URL在服务器上没有相应的处理程序，所以在ajax回调函数中得到的是404状态码；如果存在对应的URL，得到的状态码就是200。</p>\n<p>所以，如果你想在ajax请求中根据302响应通过location.href进行重定向是不可行的。</p>\n<h4 id=\"如何解决？\"><a href=\"#如何解决？\" class=\"headerlink\" title=\"如何解决？\"></a>如何解决？</h4><h4 id=\"【方法一】\"><a href=\"#【方法一】\" class=\"headerlink\" title=\"【方法一】\"></a>【方法一】</h4><p>继续用ajax，修改服务器端代码，将原来的302响应改为json响应，比如下面的ASP.NET MVC示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> Json(<span class=\"keyword\">new</span> &#123; status = <span class=\"number\">302</span>, location = <span class=\"string\">\"/oauth/respond\"</span> &#125;);</div><div class=\"line\"></div><div class=\"line\">ajax代码稍作修改即可：</div><div class=\"line\"></div><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">    url: <span class=\"string\">'/oauth/respond'</span>,</div><div class=\"line\">    type: <span class=\"string\">'post'</span>,</div><div class=\"line\">    data: data,</div><div class=\"line\">    dataType: <span class=\"string\">'json'</span>,</div><div class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (data.status == <span class=\"number\">302</span>) &#123;</div><div class=\"line\">            location.href = data.location;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"【方法二】\"><a href=\"#【方法二】\" class=\"headerlink\" title=\"【方法二】\"></a>【方法二】</h4><p>不用ajax，改用form。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&lt;form method=<span class=\"string\">\"post\"</span> action=<span class=\"string\">\"/oauth/respond\"</span>&gt;&lt;/form&gt;</div></pre></td></tr></table></figure>"},{"title":"如何使用vue-ssr做服务端渲染初体验(-)","comments":1,"date":"2017-06-01T13:09:11.000Z","_content":"\n### 1、前言\n\n服务端渲染实现原理机制：在服务端拿数据进行解析渲染，直接生成html片段返回给前端。然后前端可以通过解析后端返回的html片段到前端页面，大致有以下两种形式：\n\n1、服务器通过模版引擎直接渲染整个页面，例如java后端的vm模版引擎，php后端的smarty模版引擎。\n2、服务渲染生成html代码块, 前端通过AJAX获取然后使用js动态添加。\n\t\n<!-- more -->\t\n\t\n\n### 2、服务端渲染的优劣\n\n服务端渲染能够解决两大问题：\n\n1、seo问题，有利于搜索引擎蜘蛛抓取网站内容，利于网站的收录和排名。\n2、首屏加载过慢问题，例如现在成熟的SPA项目中，打开首页需要加载很多资源，通过服务端渲染可以加速首屏渲染。\n\t\n同样服务端渲染也会有弊端，主要是根据自己的业务场景来选择适合方式，由于服务端渲染前端页面，必将会给服务器增加压力。\n\n\n### 3、SSR的实现原理\n\n客户端请求服务器，服务器根据请求地址获得匹配的组件，在调用匹配到的组件返回 Promise (官方是preFetch方法)来将需要的数据拿到。最后再通过\n\n{% codeblock lang:javascript %}\n<script>window.__initial_state=data</script>\n{% endcodeblock %} \n\n将其写入网页，最后将服务端渲染好的网页返回回去。\n\n接下来客户端会将vuex将写入的 __initial_state__ 替换为当前的全局状态树，再用这个状态树去检查服务端渲染好的数据有没有问题。遇到没被服务端渲染的组件，再去发异步请求拿数据。说白了就是一个类似React的 shouldComponentUpdate 的Diff操作。\n\nVue2使用的是单向数据流，用了它，就可以通过 SSR 返回唯一一个全局状态， 并确认某个组件是否已经SSR过了。\n\n### 4、vue后端渲染主要插件：vue-server-renderer\n\n由于virtual dom的引入，使得vue的服务端渲染成为了可能，下面是官方 vue-server-renderer提供的渲染流程图:\n\n![官方流程图](vue-ssr/11.png)\n\n可以看出vue的后端渲染分三个部分组成：页面的源码（source），node层的渲染部分和浏览器端的渲染部分。\n\nsource分为两种entry point,一个是前端页面的入口client entry,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口server entry,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象（经过测试，直接返回Vue对象也是可以的）;\n\n前面的source部分就是业务开发的代码，开发完成之后通过 webpack 进行构建，生成对应的bundle，这里不再赘述client bundle,就是一个可在浏览器端执行的打包文件；这里说下server bundle, vue2提供 vue-server-renderer模块，模块可以提供两种render: rendererer/bundleRenderer ,下面分别介绍下这两种render。\n\nrenderer接收一个vue对象 ，然后进行渲染，这种对于简单的vue对象,可以这么去做，但是对于复杂的项目，如果使用这种直接require一个vue对象，这个对于服务端代码的结构和逻辑都不太友好，首先模块的状态会一直延续在每个请求渲染请求，我们需要去管理和避免这次渲染请求的状态影响到后面的请求,因此vue-server-renderer提供了另外一种渲染模式，通过一个 bundleRenderer去做渲染。\n\nbundleRenderer是较为复杂项目进行服务端渲染官方推荐的方式，通过webpack以server entry按照一定的要求打包生成一个 server-bundle,它相当于一个可以给服务端用的app的打包压缩文件，每一次调用都会重新初始化 vue对象，保证了每次请求都是独立的，对于开发者来说，只需要专注于当前业务就可以，不用为服务端渲染开发更多的逻辑代码。\nrenderer生成完成之后，都存在两个接口，分别是renderToString和renderToStream，一个是一次性将页面渲染成字符串文件，另外一个是流式渲染，适用于支持流的web服务器，可以是请求服务的速度更快。\n\n### 5、项目基本结构如下\n\n![项目结构图](vue-ssr/22.jpeg)\n\n> 如何从零开始搭建适合自己的vue后端渲染框架？","source":"_posts/vue-ssr.md","raw":"---\ntitle: 如何使用vue-ssr做服务端渲染初体验(-)\ncomments: true\ndate: 2017-06-01 21:09:11\ntags: \n    - 'javascript'\n    - 'vue'\n---\n\n### 1、前言\n\n服务端渲染实现原理机制：在服务端拿数据进行解析渲染，直接生成html片段返回给前端。然后前端可以通过解析后端返回的html片段到前端页面，大致有以下两种形式：\n\n1、服务器通过模版引擎直接渲染整个页面，例如java后端的vm模版引擎，php后端的smarty模版引擎。\n2、服务渲染生成html代码块, 前端通过AJAX获取然后使用js动态添加。\n\t\n<!-- more -->\t\n\t\n\n### 2、服务端渲染的优劣\n\n服务端渲染能够解决两大问题：\n\n1、seo问题，有利于搜索引擎蜘蛛抓取网站内容，利于网站的收录和排名。\n2、首屏加载过慢问题，例如现在成熟的SPA项目中，打开首页需要加载很多资源，通过服务端渲染可以加速首屏渲染。\n\t\n同样服务端渲染也会有弊端，主要是根据自己的业务场景来选择适合方式，由于服务端渲染前端页面，必将会给服务器增加压力。\n\n\n### 3、SSR的实现原理\n\n客户端请求服务器，服务器根据请求地址获得匹配的组件，在调用匹配到的组件返回 Promise (官方是preFetch方法)来将需要的数据拿到。最后再通过\n\n{% codeblock lang:javascript %}\n<script>window.__initial_state=data</script>\n{% endcodeblock %} \n\n将其写入网页，最后将服务端渲染好的网页返回回去。\n\n接下来客户端会将vuex将写入的 __initial_state__ 替换为当前的全局状态树，再用这个状态树去检查服务端渲染好的数据有没有问题。遇到没被服务端渲染的组件，再去发异步请求拿数据。说白了就是一个类似React的 shouldComponentUpdate 的Diff操作。\n\nVue2使用的是单向数据流，用了它，就可以通过 SSR 返回唯一一个全局状态， 并确认某个组件是否已经SSR过了。\n\n### 4、vue后端渲染主要插件：vue-server-renderer\n\n由于virtual dom的引入，使得vue的服务端渲染成为了可能，下面是官方 vue-server-renderer提供的渲染流程图:\n\n![官方流程图](vue-ssr/11.png)\n\n可以看出vue的后端渲染分三个部分组成：页面的源码（source），node层的渲染部分和浏览器端的渲染部分。\n\nsource分为两种entry point,一个是前端页面的入口client entry,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口server entry,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象（经过测试，直接返回Vue对象也是可以的）;\n\n前面的source部分就是业务开发的代码，开发完成之后通过 webpack 进行构建，生成对应的bundle，这里不再赘述client bundle,就是一个可在浏览器端执行的打包文件；这里说下server bundle, vue2提供 vue-server-renderer模块，模块可以提供两种render: rendererer/bundleRenderer ,下面分别介绍下这两种render。\n\nrenderer接收一个vue对象 ，然后进行渲染，这种对于简单的vue对象,可以这么去做，但是对于复杂的项目，如果使用这种直接require一个vue对象，这个对于服务端代码的结构和逻辑都不太友好，首先模块的状态会一直延续在每个请求渲染请求，我们需要去管理和避免这次渲染请求的状态影响到后面的请求,因此vue-server-renderer提供了另外一种渲染模式，通过一个 bundleRenderer去做渲染。\n\nbundleRenderer是较为复杂项目进行服务端渲染官方推荐的方式，通过webpack以server entry按照一定的要求打包生成一个 server-bundle,它相当于一个可以给服务端用的app的打包压缩文件，每一次调用都会重新初始化 vue对象，保证了每次请求都是独立的，对于开发者来说，只需要专注于当前业务就可以，不用为服务端渲染开发更多的逻辑代码。\nrenderer生成完成之后，都存在两个接口，分别是renderToString和renderToStream，一个是一次性将页面渲染成字符串文件，另外一个是流式渲染，适用于支持流的web服务器，可以是请求服务的速度更快。\n\n### 5、项目基本结构如下\n\n![项目结构图](vue-ssr/22.jpeg)\n\n> 如何从零开始搭建适合自己的vue后端渲染框架？","slug":"vue-ssr","published":1,"updated":"2017-08-26T12:58:33.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36rh000hlmldry0a1u14","content":"<h3 id=\"1、前言\"><a href=\"#1、前言\" class=\"headerlink\" title=\"1、前言\"></a>1、前言</h3><p>服务端渲染实现原理机制：在服务端拿数据进行解析渲染，直接生成html片段返回给前端。然后前端可以通过解析后端返回的html片段到前端页面，大致有以下两种形式：</p>\n<p>1、服务器通过模版引擎直接渲染整个页面，例如java后端的vm模版引擎，php后端的smarty模版引擎。<br>2、服务渲染生成html代码块, 前端通过AJAX获取然后使用js动态添加。</p>\n<a id=\"more\"></a>    \n<h3 id=\"2、服务端渲染的优劣\"><a href=\"#2、服务端渲染的优劣\" class=\"headerlink\" title=\"2、服务端渲染的优劣\"></a>2、服务端渲染的优劣</h3><p>服务端渲染能够解决两大问题：</p>\n<p>1、seo问题，有利于搜索引擎蜘蛛抓取网站内容，利于网站的收录和排名。<br>2、首屏加载过慢问题，例如现在成熟的SPA项目中，打开首页需要加载很多资源，通过服务端渲染可以加速首屏渲染。</p>\n<p>同样服务端渲染也会有弊端，主要是根据自己的业务场景来选择适合方式，由于服务端渲染前端页面，必将会给服务器增加压力。</p>\n<h3 id=\"3、SSR的实现原理\"><a href=\"#3、SSR的实现原理\" class=\"headerlink\" title=\"3、SSR的实现原理\"></a>3、SSR的实现原理</h3><p>客户端请求服务器，服务器根据请求地址获得匹配的组件，在调用匹配到的组件返回 Promise (官方是preFetch方法)来将需要的数据拿到。最后再通过</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;<span class=\"built_in\">window</span>.__initial_state=data&lt;<span class=\"regexp\">/script&gt;</span></div></pre></td></tr></table></figure> \n<p>将其写入网页，最后将服务端渲染好的网页返回回去。</p>\n<p>接下来客户端会将vuex将写入的 <strong>initial_state</strong> 替换为当前的全局状态树，再用这个状态树去检查服务端渲染好的数据有没有问题。遇到没被服务端渲染的组件，再去发异步请求拿数据。说白了就是一个类似React的 shouldComponentUpdate 的Diff操作。</p>\n<p>Vue2使用的是单向数据流，用了它，就可以通过 SSR 返回唯一一个全局状态， 并确认某个组件是否已经SSR过了。</p>\n<h3 id=\"4、vue后端渲染主要插件：vue-server-renderer\"><a href=\"#4、vue后端渲染主要插件：vue-server-renderer\" class=\"headerlink\" title=\"4、vue后端渲染主要插件：vue-server-renderer\"></a>4、vue后端渲染主要插件：vue-server-renderer</h3><p>由于virtual dom的引入，使得vue的服务端渲染成为了可能，下面是官方 vue-server-renderer提供的渲染流程图:</p>\n<p><img src=\"/vue-ssr/11.png\" alt=\"官方流程图\"></p>\n<p>可以看出vue的后端渲染分三个部分组成：页面的源码（source），node层的渲染部分和浏览器端的渲染部分。</p>\n<p>source分为两种entry point,一个是前端页面的入口client entry,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口server entry,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象（经过测试，直接返回Vue对象也是可以的）;</p>\n<p>前面的source部分就是业务开发的代码，开发完成之后通过 webpack 进行构建，生成对应的bundle，这里不再赘述client bundle,就是一个可在浏览器端执行的打包文件；这里说下server bundle, vue2提供 vue-server-renderer模块，模块可以提供两种render: rendererer/bundleRenderer ,下面分别介绍下这两种render。</p>\n<p>renderer接收一个vue对象 ，然后进行渲染，这种对于简单的vue对象,可以这么去做，但是对于复杂的项目，如果使用这种直接require一个vue对象，这个对于服务端代码的结构和逻辑都不太友好，首先模块的状态会一直延续在每个请求渲染请求，我们需要去管理和避免这次渲染请求的状态影响到后面的请求,因此vue-server-renderer提供了另外一种渲染模式，通过一个 bundleRenderer去做渲染。</p>\n<p>bundleRenderer是较为复杂项目进行服务端渲染官方推荐的方式，通过webpack以server entry按照一定的要求打包生成一个 server-bundle,它相当于一个可以给服务端用的app的打包压缩文件，每一次调用都会重新初始化 vue对象，保证了每次请求都是独立的，对于开发者来说，只需要专注于当前业务就可以，不用为服务端渲染开发更多的逻辑代码。<br>renderer生成完成之后，都存在两个接口，分别是renderToString和renderToStream，一个是一次性将页面渲染成字符串文件，另外一个是流式渲染，适用于支持流的web服务器，可以是请求服务的速度更快。</p>\n<h3 id=\"5、项目基本结构如下\"><a href=\"#5、项目基本结构如下\" class=\"headerlink\" title=\"5、项目基本结构如下\"></a>5、项目基本结构如下</h3><p><img src=\"/vue-ssr/22.jpeg\" alt=\"项目结构图\"></p>\n<blockquote>\n<p>如何从零开始搭建适合自己的vue后端渲染框架？</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"1、前言\"><a href=\"#1、前言\" class=\"headerlink\" title=\"1、前言\"></a>1、前言</h3><p>服务端渲染实现原理机制：在服务端拿数据进行解析渲染，直接生成html片段返回给前端。然后前端可以通过解析后端返回的html片段到前端页面，大致有以下两种形式：</p>\n<p>1、服务器通过模版引擎直接渲染整个页面，例如java后端的vm模版引擎，php后端的smarty模版引擎。<br>2、服务渲染生成html代码块, 前端通过AJAX获取然后使用js动态添加。</p>","more":"<h3 id=\"2、服务端渲染的优劣\"><a href=\"#2、服务端渲染的优劣\" class=\"headerlink\" title=\"2、服务端渲染的优劣\"></a>2、服务端渲染的优劣</h3><p>服务端渲染能够解决两大问题：</p>\n<p>1、seo问题，有利于搜索引擎蜘蛛抓取网站内容，利于网站的收录和排名。<br>2、首屏加载过慢问题，例如现在成熟的SPA项目中，打开首页需要加载很多资源，通过服务端渲染可以加速首屏渲染。</p>\n<p>同样服务端渲染也会有弊端，主要是根据自己的业务场景来选择适合方式，由于服务端渲染前端页面，必将会给服务器增加压力。</p>\n<h3 id=\"3、SSR的实现原理\"><a href=\"#3、SSR的实现原理\" class=\"headerlink\" title=\"3、SSR的实现原理\"></a>3、SSR的实现原理</h3><p>客户端请求服务器，服务器根据请求地址获得匹配的组件，在调用匹配到的组件返回 Promise (官方是preFetch方法)来将需要的数据拿到。最后再通过</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;<span class=\"built_in\">window</span>.__initial_state=data&lt;<span class=\"regexp\">/script&gt;</span></div></pre></td></tr></table></figure> \n<p>将其写入网页，最后将服务端渲染好的网页返回回去。</p>\n<p>接下来客户端会将vuex将写入的 <strong>initial_state</strong> 替换为当前的全局状态树，再用这个状态树去检查服务端渲染好的数据有没有问题。遇到没被服务端渲染的组件，再去发异步请求拿数据。说白了就是一个类似React的 shouldComponentUpdate 的Diff操作。</p>\n<p>Vue2使用的是单向数据流，用了它，就可以通过 SSR 返回唯一一个全局状态， 并确认某个组件是否已经SSR过了。</p>\n<h3 id=\"4、vue后端渲染主要插件：vue-server-renderer\"><a href=\"#4、vue后端渲染主要插件：vue-server-renderer\" class=\"headerlink\" title=\"4、vue后端渲染主要插件：vue-server-renderer\"></a>4、vue后端渲染主要插件：vue-server-renderer</h3><p>由于virtual dom的引入，使得vue的服务端渲染成为了可能，下面是官方 vue-server-renderer提供的渲染流程图:</p>\n<p><img src=\"/vue-ssr/11.png\" alt=\"官方流程图\"></p>\n<p>可以看出vue的后端渲染分三个部分组成：页面的源码（source），node层的渲染部分和浏览器端的渲染部分。</p>\n<p>source分为两种entry point,一个是前端页面的入口client entry,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口server entry,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象（经过测试，直接返回Vue对象也是可以的）;</p>\n<p>前面的source部分就是业务开发的代码，开发完成之后通过 webpack 进行构建，生成对应的bundle，这里不再赘述client bundle,就是一个可在浏览器端执行的打包文件；这里说下server bundle, vue2提供 vue-server-renderer模块，模块可以提供两种render: rendererer/bundleRenderer ,下面分别介绍下这两种render。</p>\n<p>renderer接收一个vue对象 ，然后进行渲染，这种对于简单的vue对象,可以这么去做，但是对于复杂的项目，如果使用这种直接require一个vue对象，这个对于服务端代码的结构和逻辑都不太友好，首先模块的状态会一直延续在每个请求渲染请求，我们需要去管理和避免这次渲染请求的状态影响到后面的请求,因此vue-server-renderer提供了另外一种渲染模式，通过一个 bundleRenderer去做渲染。</p>\n<p>bundleRenderer是较为复杂项目进行服务端渲染官方推荐的方式，通过webpack以server entry按照一定的要求打包生成一个 server-bundle,它相当于一个可以给服务端用的app的打包压缩文件，每一次调用都会重新初始化 vue对象，保证了每次请求都是独立的，对于开发者来说，只需要专注于当前业务就可以，不用为服务端渲染开发更多的逻辑代码。<br>renderer生成完成之后，都存在两个接口，分别是renderToString和renderToStream，一个是一次性将页面渲染成字符串文件，另外一个是流式渲染，适用于支持流的web服务器，可以是请求服务的速度更快。</p>\n<h3 id=\"5、项目基本结构如下\"><a href=\"#5、项目基本结构如下\" class=\"headerlink\" title=\"5、项目基本结构如下\"></a>5、项目基本结构如下</h3><p><img src=\"/vue-ssr/22.jpeg\" alt=\"项目结构图\"></p>\n<blockquote>\n<p>如何从零开始搭建适合自己的vue后端渲染框架？</p>\n</blockquote>"},{"title":"如何使用vue-ssr做服务端渲染初体验(二)","comments":1,"date":"2017-06-02T12:09:11.000Z","_content":"\n### 1、前言\n\n上一节我们大致讲了为什么需要使用vue后端渲染，以及vue后端渲染的基本原理，这节内容我们将从零开始搭建属于自己的vue后端渲染脚手架，当然不能不参考官方页面响应的实例<font color=\"#0078d8\">vue-hackernews-2.0</font>，从零开始搭建项目,源码在将在下节与大家共享。\n\n### 2、前期准备\n\n基本环境要求：node版本6.10.1以上，npm版本3.10.10以上，本机环境是这样的，建议升级到官方最新版本。\n\n使用的技术栈：\n\n<!-- more -->\n\n1、vue 2.4.2\n2、vuex 2.3.1\n3、vue-router 2.7.0\n4、vue-server-renderer 2.4.2\n5、express 4.15.4\n6、axios 0.16.2\n7、q https://github.com/kriskowal/q.git\n8、webpack 3.5.0\n9、mockjs 1.0.1-beta3\n10、babel \n\n以上是主要是用的技术栈，在构建过程中会是用相应的插件依赖包来配合进行压缩打包，以下是npm init后package.json文件所要添加的依赖包。\n\n![文件依赖](vue-ssr2/1.jpeg)\t\n\n### 3、项目主目录搭建\n\n基本目录结构如下：\n\n![项目主目录结构](vue-ssr2/2.jpeg)\n\n> 文件目录基本介绍：\n\t\ncomponents 主要存放组件代码，里面可以根据业务场景再次细分模块组件等。\nlib 主要存放第三方库文件，方便用户直接引入使用\npublic 主要存放公共组件代码和项目使用的公共文件代码，例如后期我们将axios封装成公共的api库文件等等。\nrouter 主要存放前端路由配置文件，写法规范按照vue-router官方例子即可。\nstore 主要是存放共享状态文件，里面包含action.js,getter.js,mutationtype.js,state.js等，后期会根据模块再细分这些。\napp.js 是项目入口文件\nApp.vue 是项目入口文件\nentry-client和entry-server分别是客户端入口文件和服务端的入口文件\nindex.template.html是整个项目的模版文件\n\n#### 开始编写app.js项目入口代码\n\n使用vue开发项目入口文件一般都会如下写法：\n{% codeblock lang:javascript %}\nimport Vue from 'vue';\nimport App from './index.vue';\nimport router from './router'\nimport store from './store';\n\nnew Vue({\n\tel: '#app',\n\tstore,\n\trouter,\n\trender: (h) => h(App)\n});\n{% endcodeblock %} \n\n这种写法是程序共享一个vue实例，但是在后端渲染中很容易导致交叉请求状态污染，导致数据流被污染了。\n\n> 所以，避免状态单例,我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例，同样router和store入口文件也需要重新创建一个实例。\n\n为了配合webpack动态加载路由配置，这里会改写常规路由引入写法，这样可以根据路由路径来判断加载相应的组件代码：\n\n{% codeblock lang:javascript %}\nimport Home from '../components/Home.vue'\n// 改写成\ncomponent: () => ('../components/Home.vue')\n{% endcodeblock %} \n\n\n以下是路由的基本写法router，对外会抛出一个createRouter方法来创建一个新的路由实例：\n\n{% codeblock lang:javascript %}\nimport Vue from 'vue'\nimport Router from 'vue-router';\nVue.use(Router)\nexport function createRouter() {\n    return new Router({\n        mode: 'history',\n        routes: [{\n            name:'home',\n            path: '/',\n            component: () =>\n                import ('../components/Home.vue')\n        }]\n    })\n}\n{% endcodeblock %} \n\n以下是store状态管理的基本写法，对外暴露了一个createStore方法，方便每次访问创建一个新的实例：\n\n{% codeblock lang:javascript %}\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport actions from './actions'\nimport getters from './getters'\n// 按照组件的复杂度是否使用modules\nimport Home from './modules/Home'\nVue.use(Vuex)\nexport function createStore() {\n  return new Vuex.Store({\n    actions,\n    getters,\n    modules:{\n      Home\n    },\n  })\n}\n{% endcodeblock %} \n\n\n\n结合写好的router和store入口文件代码来编写整个项目的入口文件app.js代码内容，同样最终也会对外暴露一个createApp方法，在每次创建app的时候保证router，store，app都是新创建的实例，这里还引入了一个vue路由插件vuex-router-sync，主要作用是同步路由状态(route state)到 store，以下是app.js完整代码：\n\n{% codeblock lang:javascript %}\nimport Vue from 'vue'\nimport App from './App.vue'\nimport { createRouter } from './router'\nimport { createStore } from './store'\nimport { sync } from 'vuex-router-sync'\nexport function createApp () {\n  // 创建 router 和 store 实例\n  const router = createRouter()\n  const store = createStore()\n  // 同步路由状态(route state)到 store\n  sync(store, router)\n  // 创建应用程序实例，将 router 和 store 注入\n  const app = new Vue({\n    router,\n    store,\n    render: h => h(App)\n  })\n  // 暴露 app, router 和 store。\n  return { app, router, store }\n}\n{% endcodeblock %} \n\n#### entry-client.js代码编写：\n\n首页引入从app文件中暴露出来的createApp方法，在每次调用客户端的时候，重新创建一个新的app，router，store，部分代码如下：\n\n{% codeblock lang:javascript %}\nimport { createApp } from './app'\nconst { app, router, store } = createApp()\n{% endcodeblock %}\n\n这里我们会使用到onReady方法，此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染的时候，例子代码如下：\n\n{% codeblock lang:javascript %}\nimport { createApp } from './app'\nconst { app, router, store } = createApp()\nrouter.onReady(() => {\n  app.$mount('#app')\n})\n{% endcodeblock %}\n\n\n我们会调用一个新方法beforeResolve，只有在router2.5.0以上的版本才会有的方法，注册一个类似于全局路由保护router.beforeEach()，除了在导航确认之后，在所有其他保护和异步组件已解决之后调用。基本写法如下：\n\n{% codeblock lang:javascript %}\nrouter.beforeResolve((to, from, next) => {\n\t// to 和 from 都是 路由信息对象\n\t// 返回目标位置或是当前路由匹配的组件数组（是数组的定义/构造类，不是实例）。通常在服务端渲染的数据预加载时时候。\n\tconst matched = router.getMatchedComponents(to)\n    const prevMatched = router.getMatchedComponents(from)\n})\n{% endcodeblock %}\n\n服务端把要给客户端的 state 放在了 window.__INITIAL_STATE__ 这个全局变量上面。前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（__INITIAL_STATE__），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。基本代码如下：\n{% codeblock lang:javascript %}\n// 将服务端渲染时候的状态写入vuex中\nif (window.__INITIAL_STATE__) {\n  store.replaceState(window.__INITIAL_STATE__)\n}\n{% endcodeblock %}\n\n接下来贴出来完整的客户端代码，这里的Q也可以不用引入，直接使用babel就能编译es6自带的Promise，因为本人使用习惯了，这里可以根据自身的需求是否安装：\n{% codeblock lang:javascript %}\nimport { createApp } from './app'\nimport Q from 'q';\nconst { app, router, store } = createApp()\nrouter.onReady(() => {\n  router.beforeResolve((to, from, next) => {\n      const matched = router.getMatchedComponents(to)\n      const prevMatched = router.getMatchedComponents(from)\n      // 我们只关心之前没有渲染的组件\n      // 所以我们对比它们，找出两个匹配列表的差异组件\n      let diffed = false\n      const activated = matched.filter((c, i) => {\n        return diffed || (diffed = (prevMatched[i] !== c))\n      })\n      if (!activated.length) {\n        return next()\n      }\n      // 这里如果有加载指示器(loading indicator)，就触发\n      Q.all(activated.map(c => {\n        if (c.asyncData) {\n          return c.asyncData({ store, route: to })\n        }\n      })).then(() => {\n        // 停止加载指示器(loading indicator)\n        next()\n      }).catch(next)\n    })\n    app.$mount('#app')\n})\n// 将服务端渲染时候的状态写入vuex中\nif (window.__INITIAL_STATE__) {\n  store.replaceState(window.__INITIAL_STATE__)\n}\n{% endcodeblock %}\n\n#### entry-server.js代码编写：\n\n基本编写和客户端的差不多，因为这是服务端渲染，涉及到与后端数据交互定义的问题，我们需要在这里定义好各组件与后端交互使用的方法名称，这样方便在组件内部直接使用，这里根我们常规在组件直接使用ajax获取数据有些不一样，代码片段如下：\n{% codeblock lang:javascript %}\n//直接定义组件内部asyncData方法来触发相应的ajax获取数据\nif (Component.asyncData) {\n  return Component.asyncData({\n    store,\n    route: router.currentRoute\n  })\n}\n{% endcodeblock %}\n\n以下是完整的服务端代码：\n{% codeblock lang:javascript %}\nimport { createApp } from './app'\nimport Q from 'q'\nexport default context => {\n  return new Q.Promise((resolve, reject) => {\n    const { app, router, store } = createApp()\n    router.push(context.url)\n    router.onReady(() => {\n      const matchedComponents = router.getMatchedComponents()\n      if (!matchedComponents.length) {\n        return reject({ code: 404 })\n      }\n      // 对所有匹配的路由组件调用 `asyncData()`\n      Q.all(matchedComponents.map(Component => {\n        if (Component.asyncData) {\n          return Component.asyncData({\n            store,\n            route: router.currentRoute\n          })\n        }\n      })).then(() => {\n        // 在所有预取钩子(preFetch hook) resolve 后，\n        // 我们的 store 现在已经填充入渲染应用程序所需的状态。\n        // 当我们将状态附加到上下文，\n        // 并且 `template` 选项用于 renderer 时，\n        // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。\n        context.state = store.state\n        resolve(app)\n      }).catch(reject)\n    }, reject)\n  })\n}\n{% endcodeblock %}\n\n### 4、脚手架其他目录介绍：\n\n到这里src下面主要的几个文件代码已经编写完成，接下里介绍下整个项目的目录结构如下：\n\n![整个目录结构](vue-ssr2/3.jpeg)\n\n主要几个文件介绍如下：\nbuild 主要存放webpack打包配置文件\ndist webpack打包后生成的目录\nlog 使用pm2监控进程存放的日志文件目录\nserver.js node服务器启动文件\npmlog.json pm2配置文件\n\n#### server.js入口文件编写\n\n我们还需要编写在服务端启动服务的代码server.js，我们会使用到部分node原生提供的api，片段代码如下：\n{% codeblock lang:javascript %}\nconst Vue = require('vue')\nconst express = require('express')\nconst path = require('path')\nconst LRU = require('lru-cache')\nconst { createBundleRenderer } = require('vue-server-renderer')\nconst fs = require('fs')\nconst net = require('net')\n{% endcodeblock %}\n\n大致思路是，引入前端模版页面index.template.html，使用express启动服务，引入webpack打包项目代码的dist文件，引入缓存模块（这里不做深入介绍，后期会单独详细介绍），判断端口是否被占用，自动启动其他接口服务。\n\n引入前端模版文件并且设置环境变量为production，片段代码如下：\n{% codeblock lang:javascript %}\nconst template = fs.readFileSync('./src/index.template.html', 'utf-8')\nconst isProd = process.env.NODE_ENV === 'production'\n{% endcodeblock %}\n\nvue-server-renderer插件的具体使用，通过读取dist文件夹下的目录文件，来创建createBundleRenderer函数，并且使用LRU来设置缓存的时间，通过判断是生产环境还是开发环境，调用不同的方法，代码片段如下：\n{% codeblock lang:javascript %}\nconst resolve = file => path.resolve(__dirname, file)\nfunction createRenderer (bundle, options) {\n  return createBundleRenderer(bundle, Object.assign(options, {\n    template,\n    cache: LRU({\n      max: 1000,\n      maxAge: 1000 * 60 * 15\n    }),\n    basedir: resolve('./dist'),\n    runInNewContext: false\n  }))\n}\nlet renderer;\nlet readyPromise\nif (isProd) {\n  const bundle = require('./dist/vue-ssr-server-bundle.json')\n  const clientManifest = require('./dist/vue-ssr-client-manifest.json')\n  renderer = createRenderer(bundle, {\n    clientManifest\n  })\n} else {\n  readyPromise = require('./build/setup-dev-server')(server, (bundle, options) => {\n    renderer = createRenderer(bundle, options)\n  })\n}\n{% endcodeblock %}\n\n使用express启动服务，代码片段如下：\n{% codeblock lang:javascript %}\nconst server = express()；\n\n//定义在启动服务钱先判断中间件中的缓存是否过期，是否直接调用dist文件。\nconst serve = (path, cache) => express.static(resolve(path), {\n  maxAge: cache && isProd ? 1000 * 60 * 60 * 24 * 30 : 0\n})\nserver.use('/dist', serve('./dist', true))\nserver.get('*', (req, res) => {\n  const context = {\n    title: 'hello',\n    url: req.url\n  }\n  renderer.renderToString(context, (err, html) => {\n    if (err) {\n      res.status(500).end('Internal Server Error')\n      return\n    }\n    res.end(html)\n  })\n})\n{% endcodeblock %}\n\n判断端口是否被占用，片段代码如下：\n{% codeblock lang:javascript %}\nfunction probe(port, callback) {\n\n    var servers = net.createServer().listen(port)\n\n    var calledOnce = false\n\n    var timeoutRef = setTimeout(function() {\n        calledOnce = true\n        callback(false, port)\n    }, 2000)\n\n    timeoutRef.unref()\n\n    var connected = false\n\n    servers.on('listening', function() {\n        clearTimeout(timeoutRef)\n\n        if (servers)\n            servers.close()\n\n        if (!calledOnce) {\n            calledOnce = true\n            callback(true, port)\n        }\n    })\n\n    servers.on('error', function(err) {\n        clearTimeout(timeoutRef)\n\n        var result = true\n        if (err.code === 'EADDRINUSE')\n            result = false\n\n        if (!calledOnce) {\n            calledOnce = true\n            callback(result, port)\n        }\n    })\n}\nvar checkPortPromise = new Promise((resolve) => {\n    (function serverport(_port) {\n        var pt = _port || 8080;\n        probe(pt, function(bl, _pt) {\n            // 端口被占用 bl 返回false\n            // _pt：传入的端口号\n            if (bl === true) {\n                // console.log(\"\\n  Static file server running at\" + \"\\n\\n=> http://localhost:\" + _pt + '\\n');\n                resolve(_pt);\n            } else {\n                serverport(_pt + 1)\n            }\n        })\n    })()\n\n})\ncheckPortPromise.then(data => {\n    uri = 'http://localhost:' + data;\n    console.log('启动服务路径'+uri)\n    server.listen(data);\n});\n{% endcodeblock %}\n\n到这里，基本的代码已经编写完成，webpack打包配置文件基本和官方保持不变，接下来可以尝试启动本地的项目服务，查看基本的demo展示。\n![demo](vue-ssr2/4.jpeg)\n\n>下节，我将介绍下mockjs，axios怎么封装成公共函数便于使用\n\t\n","source":"_posts/vue-ssr2.md","raw":"---\ntitle: 如何使用vue-ssr做服务端渲染初体验(二)\ncomments: true\ndate: 2017-06-02 20:09:11\ntags: \n    - 'javascript'\n    - 'vue'\n---\n\n### 1、前言\n\n上一节我们大致讲了为什么需要使用vue后端渲染，以及vue后端渲染的基本原理，这节内容我们将从零开始搭建属于自己的vue后端渲染脚手架，当然不能不参考官方页面响应的实例<font color=\"#0078d8\">vue-hackernews-2.0</font>，从零开始搭建项目,源码在将在下节与大家共享。\n\n### 2、前期准备\n\n基本环境要求：node版本6.10.1以上，npm版本3.10.10以上，本机环境是这样的，建议升级到官方最新版本。\n\n使用的技术栈：\n\n<!-- more -->\n\n1、vue 2.4.2\n2、vuex 2.3.1\n3、vue-router 2.7.0\n4、vue-server-renderer 2.4.2\n5、express 4.15.4\n6、axios 0.16.2\n7、q https://github.com/kriskowal/q.git\n8、webpack 3.5.0\n9、mockjs 1.0.1-beta3\n10、babel \n\n以上是主要是用的技术栈，在构建过程中会是用相应的插件依赖包来配合进行压缩打包，以下是npm init后package.json文件所要添加的依赖包。\n\n![文件依赖](vue-ssr2/1.jpeg)\t\n\n### 3、项目主目录搭建\n\n基本目录结构如下：\n\n![项目主目录结构](vue-ssr2/2.jpeg)\n\n> 文件目录基本介绍：\n\t\ncomponents 主要存放组件代码，里面可以根据业务场景再次细分模块组件等。\nlib 主要存放第三方库文件，方便用户直接引入使用\npublic 主要存放公共组件代码和项目使用的公共文件代码，例如后期我们将axios封装成公共的api库文件等等。\nrouter 主要存放前端路由配置文件，写法规范按照vue-router官方例子即可。\nstore 主要是存放共享状态文件，里面包含action.js,getter.js,mutationtype.js,state.js等，后期会根据模块再细分这些。\napp.js 是项目入口文件\nApp.vue 是项目入口文件\nentry-client和entry-server分别是客户端入口文件和服务端的入口文件\nindex.template.html是整个项目的模版文件\n\n#### 开始编写app.js项目入口代码\n\n使用vue开发项目入口文件一般都会如下写法：\n{% codeblock lang:javascript %}\nimport Vue from 'vue';\nimport App from './index.vue';\nimport router from './router'\nimport store from './store';\n\nnew Vue({\n\tel: '#app',\n\tstore,\n\trouter,\n\trender: (h) => h(App)\n});\n{% endcodeblock %} \n\n这种写法是程序共享一个vue实例，但是在后端渲染中很容易导致交叉请求状态污染，导致数据流被污染了。\n\n> 所以，避免状态单例,我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例，同样router和store入口文件也需要重新创建一个实例。\n\n为了配合webpack动态加载路由配置，这里会改写常规路由引入写法，这样可以根据路由路径来判断加载相应的组件代码：\n\n{% codeblock lang:javascript %}\nimport Home from '../components/Home.vue'\n// 改写成\ncomponent: () => ('../components/Home.vue')\n{% endcodeblock %} \n\n\n以下是路由的基本写法router，对外会抛出一个createRouter方法来创建一个新的路由实例：\n\n{% codeblock lang:javascript %}\nimport Vue from 'vue'\nimport Router from 'vue-router';\nVue.use(Router)\nexport function createRouter() {\n    return new Router({\n        mode: 'history',\n        routes: [{\n            name:'home',\n            path: '/',\n            component: () =>\n                import ('../components/Home.vue')\n        }]\n    })\n}\n{% endcodeblock %} \n\n以下是store状态管理的基本写法，对外暴露了一个createStore方法，方便每次访问创建一个新的实例：\n\n{% codeblock lang:javascript %}\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport actions from './actions'\nimport getters from './getters'\n// 按照组件的复杂度是否使用modules\nimport Home from './modules/Home'\nVue.use(Vuex)\nexport function createStore() {\n  return new Vuex.Store({\n    actions,\n    getters,\n    modules:{\n      Home\n    },\n  })\n}\n{% endcodeblock %} \n\n\n\n结合写好的router和store入口文件代码来编写整个项目的入口文件app.js代码内容，同样最终也会对外暴露一个createApp方法，在每次创建app的时候保证router，store，app都是新创建的实例，这里还引入了一个vue路由插件vuex-router-sync，主要作用是同步路由状态(route state)到 store，以下是app.js完整代码：\n\n{% codeblock lang:javascript %}\nimport Vue from 'vue'\nimport App from './App.vue'\nimport { createRouter } from './router'\nimport { createStore } from './store'\nimport { sync } from 'vuex-router-sync'\nexport function createApp () {\n  // 创建 router 和 store 实例\n  const router = createRouter()\n  const store = createStore()\n  // 同步路由状态(route state)到 store\n  sync(store, router)\n  // 创建应用程序实例，将 router 和 store 注入\n  const app = new Vue({\n    router,\n    store,\n    render: h => h(App)\n  })\n  // 暴露 app, router 和 store。\n  return { app, router, store }\n}\n{% endcodeblock %} \n\n#### entry-client.js代码编写：\n\n首页引入从app文件中暴露出来的createApp方法，在每次调用客户端的时候，重新创建一个新的app，router，store，部分代码如下：\n\n{% codeblock lang:javascript %}\nimport { createApp } from './app'\nconst { app, router, store } = createApp()\n{% endcodeblock %}\n\n这里我们会使用到onReady方法，此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染的时候，例子代码如下：\n\n{% codeblock lang:javascript %}\nimport { createApp } from './app'\nconst { app, router, store } = createApp()\nrouter.onReady(() => {\n  app.$mount('#app')\n})\n{% endcodeblock %}\n\n\n我们会调用一个新方法beforeResolve，只有在router2.5.0以上的版本才会有的方法，注册一个类似于全局路由保护router.beforeEach()，除了在导航确认之后，在所有其他保护和异步组件已解决之后调用。基本写法如下：\n\n{% codeblock lang:javascript %}\nrouter.beforeResolve((to, from, next) => {\n\t// to 和 from 都是 路由信息对象\n\t// 返回目标位置或是当前路由匹配的组件数组（是数组的定义/构造类，不是实例）。通常在服务端渲染的数据预加载时时候。\n\tconst matched = router.getMatchedComponents(to)\n    const prevMatched = router.getMatchedComponents(from)\n})\n{% endcodeblock %}\n\n服务端把要给客户端的 state 放在了 window.__INITIAL_STATE__ 这个全局变量上面。前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（__INITIAL_STATE__），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。基本代码如下：\n{% codeblock lang:javascript %}\n// 将服务端渲染时候的状态写入vuex中\nif (window.__INITIAL_STATE__) {\n  store.replaceState(window.__INITIAL_STATE__)\n}\n{% endcodeblock %}\n\n接下来贴出来完整的客户端代码，这里的Q也可以不用引入，直接使用babel就能编译es6自带的Promise，因为本人使用习惯了，这里可以根据自身的需求是否安装：\n{% codeblock lang:javascript %}\nimport { createApp } from './app'\nimport Q from 'q';\nconst { app, router, store } = createApp()\nrouter.onReady(() => {\n  router.beforeResolve((to, from, next) => {\n      const matched = router.getMatchedComponents(to)\n      const prevMatched = router.getMatchedComponents(from)\n      // 我们只关心之前没有渲染的组件\n      // 所以我们对比它们，找出两个匹配列表的差异组件\n      let diffed = false\n      const activated = matched.filter((c, i) => {\n        return diffed || (diffed = (prevMatched[i] !== c))\n      })\n      if (!activated.length) {\n        return next()\n      }\n      // 这里如果有加载指示器(loading indicator)，就触发\n      Q.all(activated.map(c => {\n        if (c.asyncData) {\n          return c.asyncData({ store, route: to })\n        }\n      })).then(() => {\n        // 停止加载指示器(loading indicator)\n        next()\n      }).catch(next)\n    })\n    app.$mount('#app')\n})\n// 将服务端渲染时候的状态写入vuex中\nif (window.__INITIAL_STATE__) {\n  store.replaceState(window.__INITIAL_STATE__)\n}\n{% endcodeblock %}\n\n#### entry-server.js代码编写：\n\n基本编写和客户端的差不多，因为这是服务端渲染，涉及到与后端数据交互定义的问题，我们需要在这里定义好各组件与后端交互使用的方法名称，这样方便在组件内部直接使用，这里根我们常规在组件直接使用ajax获取数据有些不一样，代码片段如下：\n{% codeblock lang:javascript %}\n//直接定义组件内部asyncData方法来触发相应的ajax获取数据\nif (Component.asyncData) {\n  return Component.asyncData({\n    store,\n    route: router.currentRoute\n  })\n}\n{% endcodeblock %}\n\n以下是完整的服务端代码：\n{% codeblock lang:javascript %}\nimport { createApp } from './app'\nimport Q from 'q'\nexport default context => {\n  return new Q.Promise((resolve, reject) => {\n    const { app, router, store } = createApp()\n    router.push(context.url)\n    router.onReady(() => {\n      const matchedComponents = router.getMatchedComponents()\n      if (!matchedComponents.length) {\n        return reject({ code: 404 })\n      }\n      // 对所有匹配的路由组件调用 `asyncData()`\n      Q.all(matchedComponents.map(Component => {\n        if (Component.asyncData) {\n          return Component.asyncData({\n            store,\n            route: router.currentRoute\n          })\n        }\n      })).then(() => {\n        // 在所有预取钩子(preFetch hook) resolve 后，\n        // 我们的 store 现在已经填充入渲染应用程序所需的状态。\n        // 当我们将状态附加到上下文，\n        // 并且 `template` 选项用于 renderer 时，\n        // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。\n        context.state = store.state\n        resolve(app)\n      }).catch(reject)\n    }, reject)\n  })\n}\n{% endcodeblock %}\n\n### 4、脚手架其他目录介绍：\n\n到这里src下面主要的几个文件代码已经编写完成，接下里介绍下整个项目的目录结构如下：\n\n![整个目录结构](vue-ssr2/3.jpeg)\n\n主要几个文件介绍如下：\nbuild 主要存放webpack打包配置文件\ndist webpack打包后生成的目录\nlog 使用pm2监控进程存放的日志文件目录\nserver.js node服务器启动文件\npmlog.json pm2配置文件\n\n#### server.js入口文件编写\n\n我们还需要编写在服务端启动服务的代码server.js，我们会使用到部分node原生提供的api，片段代码如下：\n{% codeblock lang:javascript %}\nconst Vue = require('vue')\nconst express = require('express')\nconst path = require('path')\nconst LRU = require('lru-cache')\nconst { createBundleRenderer } = require('vue-server-renderer')\nconst fs = require('fs')\nconst net = require('net')\n{% endcodeblock %}\n\n大致思路是，引入前端模版页面index.template.html，使用express启动服务，引入webpack打包项目代码的dist文件，引入缓存模块（这里不做深入介绍，后期会单独详细介绍），判断端口是否被占用，自动启动其他接口服务。\n\n引入前端模版文件并且设置环境变量为production，片段代码如下：\n{% codeblock lang:javascript %}\nconst template = fs.readFileSync('./src/index.template.html', 'utf-8')\nconst isProd = process.env.NODE_ENV === 'production'\n{% endcodeblock %}\n\nvue-server-renderer插件的具体使用，通过读取dist文件夹下的目录文件，来创建createBundleRenderer函数，并且使用LRU来设置缓存的时间，通过判断是生产环境还是开发环境，调用不同的方法，代码片段如下：\n{% codeblock lang:javascript %}\nconst resolve = file => path.resolve(__dirname, file)\nfunction createRenderer (bundle, options) {\n  return createBundleRenderer(bundle, Object.assign(options, {\n    template,\n    cache: LRU({\n      max: 1000,\n      maxAge: 1000 * 60 * 15\n    }),\n    basedir: resolve('./dist'),\n    runInNewContext: false\n  }))\n}\nlet renderer;\nlet readyPromise\nif (isProd) {\n  const bundle = require('./dist/vue-ssr-server-bundle.json')\n  const clientManifest = require('./dist/vue-ssr-client-manifest.json')\n  renderer = createRenderer(bundle, {\n    clientManifest\n  })\n} else {\n  readyPromise = require('./build/setup-dev-server')(server, (bundle, options) => {\n    renderer = createRenderer(bundle, options)\n  })\n}\n{% endcodeblock %}\n\n使用express启动服务，代码片段如下：\n{% codeblock lang:javascript %}\nconst server = express()；\n\n//定义在启动服务钱先判断中间件中的缓存是否过期，是否直接调用dist文件。\nconst serve = (path, cache) => express.static(resolve(path), {\n  maxAge: cache && isProd ? 1000 * 60 * 60 * 24 * 30 : 0\n})\nserver.use('/dist', serve('./dist', true))\nserver.get('*', (req, res) => {\n  const context = {\n    title: 'hello',\n    url: req.url\n  }\n  renderer.renderToString(context, (err, html) => {\n    if (err) {\n      res.status(500).end('Internal Server Error')\n      return\n    }\n    res.end(html)\n  })\n})\n{% endcodeblock %}\n\n判断端口是否被占用，片段代码如下：\n{% codeblock lang:javascript %}\nfunction probe(port, callback) {\n\n    var servers = net.createServer().listen(port)\n\n    var calledOnce = false\n\n    var timeoutRef = setTimeout(function() {\n        calledOnce = true\n        callback(false, port)\n    }, 2000)\n\n    timeoutRef.unref()\n\n    var connected = false\n\n    servers.on('listening', function() {\n        clearTimeout(timeoutRef)\n\n        if (servers)\n            servers.close()\n\n        if (!calledOnce) {\n            calledOnce = true\n            callback(true, port)\n        }\n    })\n\n    servers.on('error', function(err) {\n        clearTimeout(timeoutRef)\n\n        var result = true\n        if (err.code === 'EADDRINUSE')\n            result = false\n\n        if (!calledOnce) {\n            calledOnce = true\n            callback(result, port)\n        }\n    })\n}\nvar checkPortPromise = new Promise((resolve) => {\n    (function serverport(_port) {\n        var pt = _port || 8080;\n        probe(pt, function(bl, _pt) {\n            // 端口被占用 bl 返回false\n            // _pt：传入的端口号\n            if (bl === true) {\n                // console.log(\"\\n  Static file server running at\" + \"\\n\\n=> http://localhost:\" + _pt + '\\n');\n                resolve(_pt);\n            } else {\n                serverport(_pt + 1)\n            }\n        })\n    })()\n\n})\ncheckPortPromise.then(data => {\n    uri = 'http://localhost:' + data;\n    console.log('启动服务路径'+uri)\n    server.listen(data);\n});\n{% endcodeblock %}\n\n到这里，基本的代码已经编写完成，webpack打包配置文件基本和官方保持不变，接下来可以尝试启动本地的项目服务，查看基本的demo展示。\n![demo](vue-ssr2/4.jpeg)\n\n>下节，我将介绍下mockjs，axios怎么封装成公共函数便于使用\n\t\n","slug":"vue-ssr2","published":1,"updated":"2017-08-26T12:58:33.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36rk000jlmldndw7q4dw","content":"<h3 id=\"1、前言\"><a href=\"#1、前言\" class=\"headerlink\" title=\"1、前言\"></a>1、前言</h3><p>上一节我们大致讲了为什么需要使用vue后端渲染，以及vue后端渲染的基本原理，这节内容我们将从零开始搭建属于自己的vue后端渲染脚手架，当然不能不参考官方页面响应的实例<font color=\"#0078d8\">vue-hackernews-2.0</font>，从零开始搭建项目,源码在将在下节与大家共享。</p>\n<h3 id=\"2、前期准备\"><a href=\"#2、前期准备\" class=\"headerlink\" title=\"2、前期准备\"></a>2、前期准备</h3><p>基本环境要求：node版本6.10.1以上，npm版本3.10.10以上，本机环境是这样的，建议升级到官方最新版本。</p>\n<p>使用的技术栈：</p>\n<a id=\"more\"></a>\n<p>1、vue 2.4.2<br>2、vuex 2.3.1<br>3、vue-router 2.7.0<br>4、vue-server-renderer 2.4.2<br>5、express 4.15.4<br>6、axios 0.16.2<br>7、q <a href=\"https://github.com/kriskowal/q.git\" target=\"_blank\" rel=\"external\">https://github.com/kriskowal/q.git</a><br>8、webpack 3.5.0<br>9、mockjs 1.0.1-beta3<br>10、babel </p>\n<p>以上是主要是用的技术栈，在构建过程中会是用相应的插件依赖包来配合进行压缩打包，以下是npm init后package.json文件所要添加的依赖包。</p>\n<p><img src=\"/vue-ssr2/1.jpeg\" alt=\"文件依赖\">    </p>\n<h3 id=\"3、项目主目录搭建\"><a href=\"#3、项目主目录搭建\" class=\"headerlink\" title=\"3、项目主目录搭建\"></a>3、项目主目录搭建</h3><p>基本目录结构如下：</p>\n<p><img src=\"/vue-ssr2/2.jpeg\" alt=\"项目主目录结构\"></p>\n<blockquote>\n<p>文件目录基本介绍：</p>\n</blockquote>\n<p>components 主要存放组件代码，里面可以根据业务场景再次细分模块组件等。<br>lib 主要存放第三方库文件，方便用户直接引入使用<br>public 主要存放公共组件代码和项目使用的公共文件代码，例如后期我们将axios封装成公共的api库文件等等。<br>router 主要存放前端路由配置文件，写法规范按照vue-router官方例子即可。<br>store 主要是存放共享状态文件，里面包含action.js,getter.js,mutationtype.js,state.js等，后期会根据模块再细分这些。<br>app.js 是项目入口文件<br>App.vue 是项目入口文件<br>entry-client和entry-server分别是客户端入口文件和服务端的入口文件<br>index.template.html是整个项目的模版文件</p>\n<h4 id=\"开始编写app-js项目入口代码\"><a href=\"#开始编写app-js项目入口代码\" class=\"headerlink\" title=\"开始编写app.js项目入口代码\"></a>开始编写app.js项目入口代码</h4><p>使用vue开发项目入口文件一般都会如下写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./index.vue'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">\tel: <span class=\"string\">'#app'</span>,</div><div class=\"line\">\tstore,</div><div class=\"line\">\trouter,</div><div class=\"line\">\trender: <span class=\"function\">(<span class=\"params\">h</span>) =&gt;</span> h(App)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure> </p>\n<p>这种写法是程序共享一个vue实例，但是在后端渲染中很容易导致交叉请求状态污染，导致数据流被污染了。</p>\n<blockquote>\n<p>所以，避免状态单例,我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例，同样router和store入口文件也需要重新创建一个实例。</p>\n</blockquote>\n<p>为了配合webpack动态加载路由配置，这里会改写常规路由引入写法，这样可以根据路由路径来判断加载相应的组件代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Home <span class=\"keyword\">from</span> <span class=\"string\">'../components/Home.vue'</span></div><div class=\"line\"><span class=\"comment\">// 改写成</span></div><div class=\"line\">component: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (<span class=\"string\">'../components/Home.vue'</span>)</div></pre></td></tr></table></figure> \n<p>以下是路由的基本写法router，对外会抛出一个createRouter方法来创建一个新的路由实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span>;</div><div class=\"line\">Vue.use(Router)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createRouter</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Router(&#123;</div><div class=\"line\">        mode: <span class=\"string\">'history'</span>,</div><div class=\"line\">        routes: [&#123;</div><div class=\"line\">            name:<span class=\"string\">'home'</span>,</div><div class=\"line\">            path: <span class=\"string\">'/'</span>,</div><div class=\"line\">            component: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></div><div class=\"line\">                <span class=\"keyword\">import</span> (<span class=\"string\">'../components/Home.vue'</span>)</div><div class=\"line\">        &#125;]</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure> \n<p>以下是store状态管理的基本写法，对外暴露了一个createStore方法，方便每次访问创建一个新的实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"><span class=\"keyword\">import</span> actions <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></div><div class=\"line\"><span class=\"keyword\">import</span> getters <span class=\"keyword\">from</span> <span class=\"string\">'./getters'</span></div><div class=\"line\"><span class=\"comment\">// 按照组件的复杂度是否使用modules</span></div><div class=\"line\"><span class=\"keyword\">import</span> Home <span class=\"keyword\">from</span> <span class=\"string\">'./modules/Home'</span></div><div class=\"line\">Vue.use(Vuex)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</div><div class=\"line\">    actions,</div><div class=\"line\">    getters,</div><div class=\"line\">    modules:&#123;</div><div class=\"line\">      Home</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure> \n<p>结合写好的router和store入口文件代码来编写整个项目的入口文件app.js代码内容，同样最终也会对外暴露一个createApp方法，在每次创建app的时候保证router，store，app都是新创建的实例，这里还引入了一个vue路由插件vuex-router-sync，主要作用是同步路由状态(route state)到 store，以下是app.js完整代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App.vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; createRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./store'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; sync &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex-router-sync'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createApp</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 创建 router 和 store 实例</span></div><div class=\"line\">  <span class=\"keyword\">const</span> router = createRouter()</div><div class=\"line\">  <span class=\"keyword\">const</span> store = createStore()</div><div class=\"line\">  <span class=\"comment\">// 同步路由状态(route state)到 store</span></div><div class=\"line\">  sync(store, router)</div><div class=\"line\">  <span class=\"comment\">// 创建应用程序实例，将 router 和 store 注入</span></div><div class=\"line\">  <span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    router,</div><div class=\"line\">    store,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(App)</div><div class=\"line\">  &#125;)</div><div class=\"line\">  <span class=\"comment\">// 暴露 app, router 和 store。</span></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; app, router, store &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure> \n<h4 id=\"entry-client-js代码编写：\"><a href=\"#entry-client-js代码编写：\" class=\"headerlink\" title=\"entry-client.js代码编写：\"></a>entry-client.js代码编写：</h4><p>首页引入从app文件中暴露出来的createApp方法，在每次调用客户端的时候，重新创建一个新的app，router，store，部分代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; createApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app'</span></div><div class=\"line\"><span class=\"keyword\">const</span> &#123; app, router, store &#125; = createApp()</div></pre></td></tr></table></figure>\n<p>这里我们会使用到onReady方法，此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染的时候，例子代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; createApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app'</span></div><div class=\"line\"><span class=\"keyword\">const</span> &#123; app, router, store &#125; = createApp()</div><div class=\"line\">router.onReady(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  app.$mount(<span class=\"string\">'#app'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们会调用一个新方法beforeResolve，只有在router2.5.0以上的版本才会有的方法，注册一个类似于全局路由保护router.beforeEach()，除了在导航确认之后，在所有其他保护和异步组件已解决之后调用。基本写法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.beforeResolve(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</div><div class=\"line\">\t<span class=\"comment\">// to 和 from 都是 路由信息对象</span></div><div class=\"line\">\t<span class=\"comment\">// 返回目标位置或是当前路由匹配的组件数组（是数组的定义/构造类，不是实例）。通常在服务端渲染的数据预加载时时候。</span></div><div class=\"line\">\t<span class=\"keyword\">const</span> matched = router.getMatchedComponents(to)</div><div class=\"line\">    <span class=\"keyword\">const</span> prevMatched = router.getMatchedComponents(<span class=\"keyword\">from</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>服务端把要给客户端的 state 放在了 window.<strong>INITIAL_STATE</strong> 这个全局变量上面。前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（<strong>INITIAL_STATE</strong>），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将服务端渲染时候的状态写入vuex中</span></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.__INITIAL_STATE__) &#123;</div><div class=\"line\">  store.replaceState(<span class=\"built_in\">window</span>.__INITIAL_STATE__)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来贴出来完整的客户端代码，这里的Q也可以不用引入，直接使用babel就能编译es6自带的Promise，因为本人使用习惯了，这里可以根据自身的需求是否安装：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; createApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Q <span class=\"keyword\">from</span> <span class=\"string\">'q'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> &#123; app, router, store &#125; = createApp()</div><div class=\"line\">router.onReady(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  router.beforeResolve(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> matched = router.getMatchedComponents(to)</div><div class=\"line\">      <span class=\"keyword\">const</span> prevMatched = router.getMatchedComponents(<span class=\"keyword\">from</span>)</div><div class=\"line\">      <span class=\"comment\">// 我们只关心之前没有渲染的组件</span></div><div class=\"line\">      <span class=\"comment\">// 所以我们对比它们，找出两个匹配列表的差异组件</span></div><div class=\"line\">      <span class=\"keyword\">let</span> diffed = <span class=\"literal\">false</span></div><div class=\"line\">      <span class=\"keyword\">const</span> activated = matched.filter(<span class=\"function\">(<span class=\"params\">c, i</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> diffed || (diffed = (prevMatched[i] !== c))</div><div class=\"line\">      &#125;)</div><div class=\"line\">      <span class=\"keyword\">if</span> (!activated.length) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> next()</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 这里如果有加载指示器(loading indicator)，就触发</span></div><div class=\"line\">      Q.all(activated.map(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (c.asyncData) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> c.asyncData(&#123; store, <span class=\"attr\">route</span>: to &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;)).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 停止加载指示器(loading indicator)</span></div><div class=\"line\">        next()</div><div class=\"line\">      &#125;).catch(next)</div><div class=\"line\">    &#125;)</div><div class=\"line\">    app.$mount(<span class=\"string\">'#app'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// 将服务端渲染时候的状态写入vuex中</span></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.__INITIAL_STATE__) &#123;</div><div class=\"line\">  store.replaceState(<span class=\"built_in\">window</span>.__INITIAL_STATE__)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"entry-server-js代码编写：\"><a href=\"#entry-server-js代码编写：\" class=\"headerlink\" title=\"entry-server.js代码编写：\"></a>entry-server.js代码编写：</h4><p>基本编写和客户端的差不多，因为这是服务端渲染，涉及到与后端数据交互定义的问题，我们需要在这里定义好各组件与后端交互使用的方法名称，这样方便在组件内部直接使用，这里根我们常规在组件直接使用ajax获取数据有些不一样，代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//直接定义组件内部asyncData方法来触发相应的ajax获取数据</span></div><div class=\"line\"><span class=\"keyword\">if</span> (Component.asyncData) &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> Component.asyncData(&#123;</div><div class=\"line\">    store,</div><div class=\"line\">    route: router.currentRoute</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以下是完整的服务端代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; createApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Q <span class=\"keyword\">from</span> <span class=\"string\">'q'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> context =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> &#123; app, router, store &#125; = createApp()</div><div class=\"line\">    router.push(context.url)</div><div class=\"line\">    router.onReady(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> matchedComponents = router.getMatchedComponents()</div><div class=\"line\">      <span class=\"keyword\">if</span> (!matchedComponents.length) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> reject(&#123; <span class=\"attr\">code</span>: <span class=\"number\">404</span> &#125;)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 对所有匹配的路由组件调用 `asyncData()`</span></div><div class=\"line\">      Q.all(matchedComponents.map(<span class=\"function\"><span class=\"params\">Component</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (Component.asyncData) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> Component.asyncData(&#123;</div><div class=\"line\">            store,</div><div class=\"line\">            route: router.currentRoute</div><div class=\"line\">          &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;)).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 在所有预取钩子(preFetch hook) resolve 后，</span></div><div class=\"line\">        <span class=\"comment\">// 我们的 store 现在已经填充入渲染应用程序所需的状态。</span></div><div class=\"line\">        <span class=\"comment\">// 当我们将状态附加到上下文，</span></div><div class=\"line\">        <span class=\"comment\">// 并且 `template` 选项用于 renderer 时，</span></div><div class=\"line\">        <span class=\"comment\">// 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。</span></div><div class=\"line\">        context.state = store.state</div><div class=\"line\">        resolve(app)</div><div class=\"line\">      &#125;).catch(reject)</div><div class=\"line\">    &#125;, reject)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4、脚手架其他目录介绍：\"><a href=\"#4、脚手架其他目录介绍：\" class=\"headerlink\" title=\"4、脚手架其他目录介绍：\"></a>4、脚手架其他目录介绍：</h3><p>到这里src下面主要的几个文件代码已经编写完成，接下里介绍下整个项目的目录结构如下：</p>\n<p><img src=\"/vue-ssr2/3.jpeg\" alt=\"整个目录结构\"></p>\n<p>主要几个文件介绍如下：<br>build 主要存放webpack打包配置文件<br>dist webpack打包后生成的目录<br>log 使用pm2监控进程存放的日志文件目录<br>server.js node服务器启动文件<br>pmlog.json pm2配置文件</p>\n<h4 id=\"server-js入口文件编写\"><a href=\"#server-js入口文件编写\" class=\"headerlink\" title=\"server.js入口文件编写\"></a>server.js入口文件编写</h4><p>我们还需要编写在服务端启动服务的代码server.js，我们会使用到部分node原生提供的api，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Vue = <span class=\"built_in\">require</span>(<span class=\"string\">'vue'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> LRU = <span class=\"built_in\">require</span>(<span class=\"string\">'lru-cache'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> &#123; createBundleRenderer &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'vue-server-renderer'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">'net'</span>)</div></pre></td></tr></table></figure></p>\n<p>大致思路是，引入前端模版页面index.template.html，使用express启动服务，引入webpack打包项目代码的dist文件，引入缓存模块（这里不做深入介绍，后期会单独详细介绍），判断端口是否被占用，自动启动其他接口服务。</p>\n<p>引入前端模版文件并且设置环境变量为production，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> template = fs.readFileSync(<span class=\"string\">'./src/index.template.html'</span>, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"string\">'production'</span></div></pre></td></tr></table></figure></p>\n<p>vue-server-renderer插件的具体使用，通过读取dist文件夹下的目录文件，来创建createBundleRenderer函数，并且使用LRU来设置缓存的时间，通过判断是生产环境还是开发环境，调用不同的方法，代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> resolve = <span class=\"function\"><span class=\"params\">file</span> =&gt;</span> path.resolve(__dirname, file)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createRenderer</span> (<span class=\"params\">bundle, options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> createBundleRenderer(bundle, <span class=\"built_in\">Object</span>.assign(options, &#123;</div><div class=\"line\">    template,</div><div class=\"line\">    cache: LRU(&#123;</div><div class=\"line\">      max: <span class=\"number\">1000</span>,</div><div class=\"line\">      maxAge: <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">15</span></div><div class=\"line\">    &#125;),</div><div class=\"line\">    basedir: resolve(<span class=\"string\">'./dist'</span>),</div><div class=\"line\">    runInNewContext: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;))</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> renderer;</div><div class=\"line\"><span class=\"keyword\">let</span> readyPromise</div><div class=\"line\"><span class=\"keyword\">if</span> (isProd) &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> bundle = <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/vue-ssr-server-bundle.json'</span>)</div><div class=\"line\">  <span class=\"keyword\">const</span> clientManifest = <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/vue-ssr-client-manifest.json'</span>)</div><div class=\"line\">  renderer = createRenderer(bundle, &#123;</div><div class=\"line\">    clientManifest</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  readyPromise = <span class=\"built_in\">require</span>(<span class=\"string\">'./build/setup-dev-server'</span>)(server, (bundle, options) =&gt; &#123;</div><div class=\"line\">    renderer = createRenderer(bundle, options)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用express启动服务，代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> server = express()；</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//定义在启动服务钱先判断中间件中的缓存是否过期，是否直接调用dist文件。</span></div><div class=\"line\"><span class=\"keyword\">const</span> serve = <span class=\"function\">(<span class=\"params\">path, cache</span>) =&gt;</span> express.static(resolve(path), &#123;</div><div class=\"line\">  maxAge: cache &amp;&amp; isProd ? <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span> * <span class=\"number\">30</span> : <span class=\"number\">0</span></div><div class=\"line\">&#125;)</div><div class=\"line\">server.use(<span class=\"string\">'/dist'</span>, serve(<span class=\"string\">'./dist'</span>, <span class=\"literal\">true</span>))</div><div class=\"line\">server.get(<span class=\"string\">'*'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> context = &#123;</div><div class=\"line\">    title: <span class=\"string\">'hello'</span>,</div><div class=\"line\">    url: req.url</div><div class=\"line\">  &#125;</div><div class=\"line\">  renderer.renderToString(context, (err, html) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">      res.status(<span class=\"number\">500</span>).end(<span class=\"string\">'Internal Server Error'</span>)</div><div class=\"line\">      <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    res.end(html)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>判断端口是否被占用，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">probe</span>(<span class=\"params\">port, callback</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> servers = net.createServer().listen(port)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> calledOnce = <span class=\"literal\">false</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> timeoutRef = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        calledOnce = <span class=\"literal\">true</span></div><div class=\"line\">        callback(<span class=\"literal\">false</span>, port)</div><div class=\"line\">    &#125;, <span class=\"number\">2000</span>)</div><div class=\"line\"></div><div class=\"line\">    timeoutRef.unref()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> connected = <span class=\"literal\">false</span></div><div class=\"line\"></div><div class=\"line\">    servers.on(<span class=\"string\">'listening'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        clearTimeout(timeoutRef)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (servers)</div><div class=\"line\">            servers.close()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!calledOnce) &#123;</div><div class=\"line\">            calledOnce = <span class=\"literal\">true</span></div><div class=\"line\">            callback(<span class=\"literal\">true</span>, port)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    servers.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">        clearTimeout(timeoutRef)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> result = <span class=\"literal\">true</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (err.code === <span class=\"string\">'EADDRINUSE'</span>)</div><div class=\"line\">            result = <span class=\"literal\">false</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!calledOnce) &#123;</div><div class=\"line\">            calledOnce = <span class=\"literal\">true</span></div><div class=\"line\">            callback(result, port)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> checkPortPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</div><div class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">serverport</span>(<span class=\"params\">_port</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> pt = _port || <span class=\"number\">8080</span>;</div><div class=\"line\">        probe(pt, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bl, _pt</span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 端口被占用 bl 返回false</span></div><div class=\"line\">            <span class=\"comment\">// _pt：传入的端口号</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (bl === <span class=\"literal\">true</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// console.log(\"\\n  Static file server running at\" + \"\\n\\n=&gt; http://localhost:\" + _pt + '\\n');</span></div><div class=\"line\">                resolve(_pt);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                serverport(_pt + <span class=\"number\">1</span>)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)()</div><div class=\"line\"></div><div class=\"line\">&#125;)</div><div class=\"line\">checkPortPromise.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</div><div class=\"line\">    uri = <span class=\"string\">'http://localhost:'</span> + data;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'启动服务路径'</span>+uri)</div><div class=\"line\">    server.listen(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>到这里，基本的代码已经编写完成，webpack打包配置文件基本和官方保持不变，接下来可以尝试启动本地的项目服务，查看基本的demo展示。<br><img src=\"/vue-ssr2/4.jpeg\" alt=\"demo\"></p>\n<blockquote>\n<p>下节，我将介绍下mockjs，axios怎么封装成公共函数便于使用</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"1、前言\"><a href=\"#1、前言\" class=\"headerlink\" title=\"1、前言\"></a>1、前言</h3><p>上一节我们大致讲了为什么需要使用vue后端渲染，以及vue后端渲染的基本原理，这节内容我们将从零开始搭建属于自己的vue后端渲染脚手架，当然不能不参考官方页面响应的实例<font color=\"#0078d8\">vue-hackernews-2.0</font>，从零开始搭建项目,源码在将在下节与大家共享。</p>\n<h3 id=\"2、前期准备\"><a href=\"#2、前期准备\" class=\"headerlink\" title=\"2、前期准备\"></a>2、前期准备</h3><p>基本环境要求：node版本6.10.1以上，npm版本3.10.10以上，本机环境是这样的，建议升级到官方最新版本。</p>\n<p>使用的技术栈：</p>","more":"<p>1、vue 2.4.2<br>2、vuex 2.3.1<br>3、vue-router 2.7.0<br>4、vue-server-renderer 2.4.2<br>5、express 4.15.4<br>6、axios 0.16.2<br>7、q <a href=\"https://github.com/kriskowal/q.git\" target=\"_blank\" rel=\"external\">https://github.com/kriskowal/q.git</a><br>8、webpack 3.5.0<br>9、mockjs 1.0.1-beta3<br>10、babel </p>\n<p>以上是主要是用的技术栈，在构建过程中会是用相应的插件依赖包来配合进行压缩打包，以下是npm init后package.json文件所要添加的依赖包。</p>\n<p><img src=\"/vue-ssr2/1.jpeg\" alt=\"文件依赖\">    </p>\n<h3 id=\"3、项目主目录搭建\"><a href=\"#3、项目主目录搭建\" class=\"headerlink\" title=\"3、项目主目录搭建\"></a>3、项目主目录搭建</h3><p>基本目录结构如下：</p>\n<p><img src=\"/vue-ssr2/2.jpeg\" alt=\"项目主目录结构\"></p>\n<blockquote>\n<p>文件目录基本介绍：</p>\n</blockquote>\n<p>components 主要存放组件代码，里面可以根据业务场景再次细分模块组件等。<br>lib 主要存放第三方库文件，方便用户直接引入使用<br>public 主要存放公共组件代码和项目使用的公共文件代码，例如后期我们将axios封装成公共的api库文件等等。<br>router 主要存放前端路由配置文件，写法规范按照vue-router官方例子即可。<br>store 主要是存放共享状态文件，里面包含action.js,getter.js,mutationtype.js,state.js等，后期会根据模块再细分这些。<br>app.js 是项目入口文件<br>App.vue 是项目入口文件<br>entry-client和entry-server分别是客户端入口文件和服务端的入口文件<br>index.template.html是整个项目的模版文件</p>\n<h4 id=\"开始编写app-js项目入口代码\"><a href=\"#开始编写app-js项目入口代码\" class=\"headerlink\" title=\"开始编写app.js项目入口代码\"></a>开始编写app.js项目入口代码</h4><p>使用vue开发项目入口文件一般都会如下写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./index.vue'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">\tel: <span class=\"string\">'#app'</span>,</div><div class=\"line\">\tstore,</div><div class=\"line\">\trouter,</div><div class=\"line\">\trender: <span class=\"function\">(<span class=\"params\">h</span>) =&gt;</span> h(App)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure> </p>\n<p>这种写法是程序共享一个vue实例，但是在后端渲染中很容易导致交叉请求状态污染，导致数据流被污染了。</p>\n<blockquote>\n<p>所以，避免状态单例,我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例，同样router和store入口文件也需要重新创建一个实例。</p>\n</blockquote>\n<p>为了配合webpack动态加载路由配置，这里会改写常规路由引入写法，这样可以根据路由路径来判断加载相应的组件代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Home <span class=\"keyword\">from</span> <span class=\"string\">'../components/Home.vue'</span></div><div class=\"line\"><span class=\"comment\">// 改写成</span></div><div class=\"line\">component: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (<span class=\"string\">'../components/Home.vue'</span>)</div></pre></td></tr></table></figure> \n<p>以下是路由的基本写法router，对外会抛出一个createRouter方法来创建一个新的路由实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span>;</div><div class=\"line\">Vue.use(Router)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createRouter</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Router(&#123;</div><div class=\"line\">        mode: <span class=\"string\">'history'</span>,</div><div class=\"line\">        routes: [&#123;</div><div class=\"line\">            name:<span class=\"string\">'home'</span>,</div><div class=\"line\">            path: <span class=\"string\">'/'</span>,</div><div class=\"line\">            component: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></div><div class=\"line\">                <span class=\"keyword\">import</span> (<span class=\"string\">'../components/Home.vue'</span>)</div><div class=\"line\">        &#125;]</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure> \n<p>以下是store状态管理的基本写法，对外暴露了一个createStore方法，方便每次访问创建一个新的实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"><span class=\"keyword\">import</span> actions <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></div><div class=\"line\"><span class=\"keyword\">import</span> getters <span class=\"keyword\">from</span> <span class=\"string\">'./getters'</span></div><div class=\"line\"><span class=\"comment\">// 按照组件的复杂度是否使用modules</span></div><div class=\"line\"><span class=\"keyword\">import</span> Home <span class=\"keyword\">from</span> <span class=\"string\">'./modules/Home'</span></div><div class=\"line\">Vue.use(Vuex)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</div><div class=\"line\">    actions,</div><div class=\"line\">    getters,</div><div class=\"line\">    modules:&#123;</div><div class=\"line\">      Home</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure> \n<p>结合写好的router和store入口文件代码来编写整个项目的入口文件app.js代码内容，同样最终也会对外暴露一个createApp方法，在每次创建app的时候保证router，store，app都是新创建的实例，这里还引入了一个vue路由插件vuex-router-sync，主要作用是同步路由状态(route state)到 store，以下是app.js完整代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App.vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; createRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./store'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; sync &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex-router-sync'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createApp</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 创建 router 和 store 实例</span></div><div class=\"line\">  <span class=\"keyword\">const</span> router = createRouter()</div><div class=\"line\">  <span class=\"keyword\">const</span> store = createStore()</div><div class=\"line\">  <span class=\"comment\">// 同步路由状态(route state)到 store</span></div><div class=\"line\">  sync(store, router)</div><div class=\"line\">  <span class=\"comment\">// 创建应用程序实例，将 router 和 store 注入</span></div><div class=\"line\">  <span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    router,</div><div class=\"line\">    store,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(App)</div><div class=\"line\">  &#125;)</div><div class=\"line\">  <span class=\"comment\">// 暴露 app, router 和 store。</span></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; app, router, store &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure> \n<h4 id=\"entry-client-js代码编写：\"><a href=\"#entry-client-js代码编写：\" class=\"headerlink\" title=\"entry-client.js代码编写：\"></a>entry-client.js代码编写：</h4><p>首页引入从app文件中暴露出来的createApp方法，在每次调用客户端的时候，重新创建一个新的app，router，store，部分代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; createApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app'</span></div><div class=\"line\"><span class=\"keyword\">const</span> &#123; app, router, store &#125; = createApp()</div></pre></td></tr></table></figure>\n<p>这里我们会使用到onReady方法，此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染的时候，例子代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; createApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app'</span></div><div class=\"line\"><span class=\"keyword\">const</span> &#123; app, router, store &#125; = createApp()</div><div class=\"line\">router.onReady(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  app.$mount(<span class=\"string\">'#app'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们会调用一个新方法beforeResolve，只有在router2.5.0以上的版本才会有的方法，注册一个类似于全局路由保护router.beforeEach()，除了在导航确认之后，在所有其他保护和异步组件已解决之后调用。基本写法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.beforeResolve(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</div><div class=\"line\">\t<span class=\"comment\">// to 和 from 都是 路由信息对象</span></div><div class=\"line\">\t<span class=\"comment\">// 返回目标位置或是当前路由匹配的组件数组（是数组的定义/构造类，不是实例）。通常在服务端渲染的数据预加载时时候。</span></div><div class=\"line\">\t<span class=\"keyword\">const</span> matched = router.getMatchedComponents(to)</div><div class=\"line\">    <span class=\"keyword\">const</span> prevMatched = router.getMatchedComponents(<span class=\"keyword\">from</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>服务端把要给客户端的 state 放在了 window.<strong>INITIAL_STATE</strong> 这个全局变量上面。前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（<strong>INITIAL_STATE</strong>），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将服务端渲染时候的状态写入vuex中</span></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.__INITIAL_STATE__) &#123;</div><div class=\"line\">  store.replaceState(<span class=\"built_in\">window</span>.__INITIAL_STATE__)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来贴出来完整的客户端代码，这里的Q也可以不用引入，直接使用babel就能编译es6自带的Promise，因为本人使用习惯了，这里可以根据自身的需求是否安装：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; createApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Q <span class=\"keyword\">from</span> <span class=\"string\">'q'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> &#123; app, router, store &#125; = createApp()</div><div class=\"line\">router.onReady(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  router.beforeResolve(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> matched = router.getMatchedComponents(to)</div><div class=\"line\">      <span class=\"keyword\">const</span> prevMatched = router.getMatchedComponents(<span class=\"keyword\">from</span>)</div><div class=\"line\">      <span class=\"comment\">// 我们只关心之前没有渲染的组件</span></div><div class=\"line\">      <span class=\"comment\">// 所以我们对比它们，找出两个匹配列表的差异组件</span></div><div class=\"line\">      <span class=\"keyword\">let</span> diffed = <span class=\"literal\">false</span></div><div class=\"line\">      <span class=\"keyword\">const</span> activated = matched.filter(<span class=\"function\">(<span class=\"params\">c, i</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> diffed || (diffed = (prevMatched[i] !== c))</div><div class=\"line\">      &#125;)</div><div class=\"line\">      <span class=\"keyword\">if</span> (!activated.length) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> next()</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 这里如果有加载指示器(loading indicator)，就触发</span></div><div class=\"line\">      Q.all(activated.map(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (c.asyncData) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> c.asyncData(&#123; store, <span class=\"attr\">route</span>: to &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;)).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 停止加载指示器(loading indicator)</span></div><div class=\"line\">        next()</div><div class=\"line\">      &#125;).catch(next)</div><div class=\"line\">    &#125;)</div><div class=\"line\">    app.$mount(<span class=\"string\">'#app'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// 将服务端渲染时候的状态写入vuex中</span></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.__INITIAL_STATE__) &#123;</div><div class=\"line\">  store.replaceState(<span class=\"built_in\">window</span>.__INITIAL_STATE__)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"entry-server-js代码编写：\"><a href=\"#entry-server-js代码编写：\" class=\"headerlink\" title=\"entry-server.js代码编写：\"></a>entry-server.js代码编写：</h4><p>基本编写和客户端的差不多，因为这是服务端渲染，涉及到与后端数据交互定义的问题，我们需要在这里定义好各组件与后端交互使用的方法名称，这样方便在组件内部直接使用，这里根我们常规在组件直接使用ajax获取数据有些不一样，代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//直接定义组件内部asyncData方法来触发相应的ajax获取数据</span></div><div class=\"line\"><span class=\"keyword\">if</span> (Component.asyncData) &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> Component.asyncData(&#123;</div><div class=\"line\">    store,</div><div class=\"line\">    route: router.currentRoute</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以下是完整的服务端代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; createApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Q <span class=\"keyword\">from</span> <span class=\"string\">'q'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> context =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> &#123; app, router, store &#125; = createApp()</div><div class=\"line\">    router.push(context.url)</div><div class=\"line\">    router.onReady(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> matchedComponents = router.getMatchedComponents()</div><div class=\"line\">      <span class=\"keyword\">if</span> (!matchedComponents.length) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> reject(&#123; <span class=\"attr\">code</span>: <span class=\"number\">404</span> &#125;)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 对所有匹配的路由组件调用 `asyncData()`</span></div><div class=\"line\">      Q.all(matchedComponents.map(<span class=\"function\"><span class=\"params\">Component</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (Component.asyncData) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> Component.asyncData(&#123;</div><div class=\"line\">            store,</div><div class=\"line\">            route: router.currentRoute</div><div class=\"line\">          &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;)).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 在所有预取钩子(preFetch hook) resolve 后，</span></div><div class=\"line\">        <span class=\"comment\">// 我们的 store 现在已经填充入渲染应用程序所需的状态。</span></div><div class=\"line\">        <span class=\"comment\">// 当我们将状态附加到上下文，</span></div><div class=\"line\">        <span class=\"comment\">// 并且 `template` 选项用于 renderer 时，</span></div><div class=\"line\">        <span class=\"comment\">// 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。</span></div><div class=\"line\">        context.state = store.state</div><div class=\"line\">        resolve(app)</div><div class=\"line\">      &#125;).catch(reject)</div><div class=\"line\">    &#125;, reject)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4、脚手架其他目录介绍：\"><a href=\"#4、脚手架其他目录介绍：\" class=\"headerlink\" title=\"4、脚手架其他目录介绍：\"></a>4、脚手架其他目录介绍：</h3><p>到这里src下面主要的几个文件代码已经编写完成，接下里介绍下整个项目的目录结构如下：</p>\n<p><img src=\"/vue-ssr2/3.jpeg\" alt=\"整个目录结构\"></p>\n<p>主要几个文件介绍如下：<br>build 主要存放webpack打包配置文件<br>dist webpack打包后生成的目录<br>log 使用pm2监控进程存放的日志文件目录<br>server.js node服务器启动文件<br>pmlog.json pm2配置文件</p>\n<h4 id=\"server-js入口文件编写\"><a href=\"#server-js入口文件编写\" class=\"headerlink\" title=\"server.js入口文件编写\"></a>server.js入口文件编写</h4><p>我们还需要编写在服务端启动服务的代码server.js，我们会使用到部分node原生提供的api，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Vue = <span class=\"built_in\">require</span>(<span class=\"string\">'vue'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> LRU = <span class=\"built_in\">require</span>(<span class=\"string\">'lru-cache'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> &#123; createBundleRenderer &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'vue-server-renderer'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">'net'</span>)</div></pre></td></tr></table></figure></p>\n<p>大致思路是，引入前端模版页面index.template.html，使用express启动服务，引入webpack打包项目代码的dist文件，引入缓存模块（这里不做深入介绍，后期会单独详细介绍），判断端口是否被占用，自动启动其他接口服务。</p>\n<p>引入前端模版文件并且设置环境变量为production，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> template = fs.readFileSync(<span class=\"string\">'./src/index.template.html'</span>, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"string\">'production'</span></div></pre></td></tr></table></figure></p>\n<p>vue-server-renderer插件的具体使用，通过读取dist文件夹下的目录文件，来创建createBundleRenderer函数，并且使用LRU来设置缓存的时间，通过判断是生产环境还是开发环境，调用不同的方法，代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> resolve = <span class=\"function\"><span class=\"params\">file</span> =&gt;</span> path.resolve(__dirname, file)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createRenderer</span> (<span class=\"params\">bundle, options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> createBundleRenderer(bundle, <span class=\"built_in\">Object</span>.assign(options, &#123;</div><div class=\"line\">    template,</div><div class=\"line\">    cache: LRU(&#123;</div><div class=\"line\">      max: <span class=\"number\">1000</span>,</div><div class=\"line\">      maxAge: <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">15</span></div><div class=\"line\">    &#125;),</div><div class=\"line\">    basedir: resolve(<span class=\"string\">'./dist'</span>),</div><div class=\"line\">    runInNewContext: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;))</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> renderer;</div><div class=\"line\"><span class=\"keyword\">let</span> readyPromise</div><div class=\"line\"><span class=\"keyword\">if</span> (isProd) &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> bundle = <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/vue-ssr-server-bundle.json'</span>)</div><div class=\"line\">  <span class=\"keyword\">const</span> clientManifest = <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/vue-ssr-client-manifest.json'</span>)</div><div class=\"line\">  renderer = createRenderer(bundle, &#123;</div><div class=\"line\">    clientManifest</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  readyPromise = <span class=\"built_in\">require</span>(<span class=\"string\">'./build/setup-dev-server'</span>)(server, (bundle, options) =&gt; &#123;</div><div class=\"line\">    renderer = createRenderer(bundle, options)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用express启动服务，代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> server = express()；</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//定义在启动服务钱先判断中间件中的缓存是否过期，是否直接调用dist文件。</span></div><div class=\"line\"><span class=\"keyword\">const</span> serve = <span class=\"function\">(<span class=\"params\">path, cache</span>) =&gt;</span> express.static(resolve(path), &#123;</div><div class=\"line\">  maxAge: cache &amp;&amp; isProd ? <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span> * <span class=\"number\">30</span> : <span class=\"number\">0</span></div><div class=\"line\">&#125;)</div><div class=\"line\">server.use(<span class=\"string\">'/dist'</span>, serve(<span class=\"string\">'./dist'</span>, <span class=\"literal\">true</span>))</div><div class=\"line\">server.get(<span class=\"string\">'*'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> context = &#123;</div><div class=\"line\">    title: <span class=\"string\">'hello'</span>,</div><div class=\"line\">    url: req.url</div><div class=\"line\">  &#125;</div><div class=\"line\">  renderer.renderToString(context, (err, html) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">      res.status(<span class=\"number\">500</span>).end(<span class=\"string\">'Internal Server Error'</span>)</div><div class=\"line\">      <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    res.end(html)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>判断端口是否被占用，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">probe</span>(<span class=\"params\">port, callback</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> servers = net.createServer().listen(port)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> calledOnce = <span class=\"literal\">false</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> timeoutRef = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        calledOnce = <span class=\"literal\">true</span></div><div class=\"line\">        callback(<span class=\"literal\">false</span>, port)</div><div class=\"line\">    &#125;, <span class=\"number\">2000</span>)</div><div class=\"line\"></div><div class=\"line\">    timeoutRef.unref()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> connected = <span class=\"literal\">false</span></div><div class=\"line\"></div><div class=\"line\">    servers.on(<span class=\"string\">'listening'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        clearTimeout(timeoutRef)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (servers)</div><div class=\"line\">            servers.close()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!calledOnce) &#123;</div><div class=\"line\">            calledOnce = <span class=\"literal\">true</span></div><div class=\"line\">            callback(<span class=\"literal\">true</span>, port)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    servers.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">        clearTimeout(timeoutRef)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> result = <span class=\"literal\">true</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (err.code === <span class=\"string\">'EADDRINUSE'</span>)</div><div class=\"line\">            result = <span class=\"literal\">false</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!calledOnce) &#123;</div><div class=\"line\">            calledOnce = <span class=\"literal\">true</span></div><div class=\"line\">            callback(result, port)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> checkPortPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</div><div class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">serverport</span>(<span class=\"params\">_port</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> pt = _port || <span class=\"number\">8080</span>;</div><div class=\"line\">        probe(pt, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bl, _pt</span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 端口被占用 bl 返回false</span></div><div class=\"line\">            <span class=\"comment\">// _pt：传入的端口号</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (bl === <span class=\"literal\">true</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// console.log(\"\\n  Static file server running at\" + \"\\n\\n=&gt; http://localhost:\" + _pt + '\\n');</span></div><div class=\"line\">                resolve(_pt);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                serverport(_pt + <span class=\"number\">1</span>)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)()</div><div class=\"line\"></div><div class=\"line\">&#125;)</div><div class=\"line\">checkPortPromise.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</div><div class=\"line\">    uri = <span class=\"string\">'http://localhost:'</span> + data;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'启动服务路径'</span>+uri)</div><div class=\"line\">    server.listen(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>到这里，基本的代码已经编写完成，webpack打包配置文件基本和官方保持不变，接下来可以尝试启动本地的项目服务，查看基本的demo展示。<br><img src=\"/vue-ssr2/4.jpeg\" alt=\"demo\"></p>\n<blockquote>\n<p>下节，我将介绍下mockjs，axios怎么封装成公共函数便于使用</p>\n</blockquote>"},{"title":"如何使用vue-ssr做服务端渲染初体验(三)","comments":1,"date":"2017-06-05T12:09:11.000Z","_content":"\n### 1、前言\n\n上一节大致介绍了服务端和客户端入口文件代码内容，现在已经可以正常运行你的后端渲染脚手架了，这一节，跟大家分享下如何使用axios做ajax请求，如何使用mockjs做本地假数据，跑通本地基本逻辑，为以后前后端连调做准备。\n\n### 2、前期准备\n\n需要用npm安装axios，mockjs依赖包,由于mockjs只是代码开发的辅助工具，所以安装的时候我会加--save-dev来区分，具体可以根据自己的需求来定，当然，如果有mock服务平台的话，可以直接走mock平台造假数据，本地直接访问mock平台的接口，例如可以使用阿里的Rap平台管理工具生成。\n\n{% codeblock lang:javascript %}\nnpm install axios --save\nnpm install mockjs --save-dev\n{% endcodeblock %} \n\n<!-- more -->\n\n### 3、简要介绍axios\n\n>其他请求方式，代码示例如下：\n\n{% codeblock lang:javascript %}\naxios.request(config);\naxios.get(url[,config]);\naxios.delete(url[,config]);\naxios.head(url[,config]);\naxios.post(url[,data[,config]]);\naxios.put(url[,data[,config]])\naxios.patch(url[,data[,config]])\n{% endcodeblock %} \n\n>具体详细可以点击查看<a href=\"/2017-05-02/\" target=\"_blank\" >axios基本使用介绍</a>\n\napi.js完整代码如下：\n\n{% codeblock lang:javascript %}\nfunction ajax(url, type, options) {\n    return Q.Promise((resolve, reject) => {\n        axios({\n            method : type,\n            url : url,\n            // responseType:'stream',\n            data : options\n        })\n        .then((result) => {\n            if (result && result.status === 401) {\n                location.href = '/views/401.html'\n            }\n            if (result && result.status === 200) {\n                resolve(result.data);\n            } else {\n                reject({\n                    errno: result.errno,\n                    msg: result.msg\n                });\n            }\n        })\n        .catch(function(error) {\n            console.log(error,url);\n        });\n    })\n}\n\nconst config = {\n    get(url, options) {\n        const _self = this;\n        return Q.Promise((resolve, reject) => {\n            ajax(url, 'get', options)\n            .then((data) => {\n                resolve(data);\n            }, (error) => {\n                reject(error);\n            });\n        })\n    },\n\n    post(url, options) {\n        const _self = this;\n        return Q.Promise((resolve, reject) => {\n            ajax(url, 'post', options)\n            .then((data) => {\n                resolve(data);\n            }, (error) => {\n                reject(error);\n            });\n        })\n    },\n\n    put(url, options) {\n        const _self = this;\n        return Q.Promise((resolve, reject) => {\n            ajax(url, 'put', options)\n            .then((data) => {\n                resolve(data);\n            }, (error) => {\n                reject(error);\n            });\n        })\n    },\n\n    delete(url, options) {\n        const _self = this;\n        return Q.Promise((resolve, reject) => {\n            ajax(url, 'delete', options)\n            .then((data) => {\n                resolve(data);\n            }, (error) => {\n                reject(error);\n            });\n        })\n    },\n\n    jsonp(url, options) {\n        const _self = this;\n        return Q.Promise((resolve, reject) => {\n            ajax(url, 'jsonp', options)\n            .then((data) => {\n                resolve(data);\n            }, (error) => {\n                reject(error);\n            });\n        })\n    }\n};\n\nexport default config;\n{% endcodeblock %}\n\n>mockjs项目基本配置如下：\n\n\n1、在public下新建conf.js全局定义请求url地址，代码如下：\n{% codeblock lang:javascript %}\nmodule.exports = {\n    HOST: \"http://www.xxx.com\",\n    DEBUGMOCK: true\n};\n{% endcodeblock %}\n\n2、在component根目录下新建conf.js，定义组件mock的请求路径，并且定义是否开始单个组件使用mock数据还是线上接口数据，代码如下：\n{% codeblock lang:javascript %}\nconst PUBCONF = require('../public/conf.js');\n\nexport const DEMO = {\n  DEBUGMOCK : PUBCONF.DEBUGMOCK,\n\n  INDEX_URL : PUBCONF.HOST + '/demo',\n  INDEX_URL_MOCK : true && PUBCONF.DEBUGMOCK\n}\n\nexport const ANOTHER_DEMO = {\n\n}\nexport default {\n    DEMO,\n    ANOTHER_DEMO\n}\n{% endcodeblock %}\n\n3、在组件内部定义conf.js文件，主要编写单个组件的基本配置信息，请求路径，mock数据对应的url地址，代码如下：\n{% codeblock lang:javascript %}\nimport {DEMO} from '../conf.js';\nconst MODULECONF = {\n  'demo': {\n    NAME: 'demo',\n    ICON: '',\n    MOCK: DEMO.INDEX_URL_MOCK,\n    API: {\n      GET: DEMO.INDEX_URL,\n    }\n  },\n};\nexport default MODULECONF;\n{% endcodeblock %}\n\n4、在组件内部定义mockjs来编写mock假数据，代码如下：\n{% codeblock lang:javascript %}\nimport Mock from 'mockjs';\nexport default Mock.mock('http://www.xxx.com/demo', {\n    errno: 0,\n    msg: \"成功\",\n    data: [{\n        'name': '@name',\n        'age|1-100': 100,\n        'color': '@color'\n    }]\n});\n{% endcodeblock %}\n\n>查看数据返回效果，数据在控制台打印出来\n\n![查看数据返回](vue-ssr3/11.jpeg)\n\n以上就是基本的流程，如果有更好更灵活的使用方案，希望能够参与沟通并且分享，这里会有个问题，就是目前mockjs未能跟业务代码隔离，webpack如果单纯加上externals配置，项目打包后,直接本地运行会报错，找不到mockjs，不知道是不是自己配置的原因，但是基本的思想就是最终上线代码不要把工具类的函数打包进去。项目脚手架已经在github上分享，<a href=\"https://github.com/wqzwh/wq-vue-ssr\" target=\"_blank\">点击查看详情</a>\n","source":"_posts/vue-ssr3.md","raw":"---\ntitle: 如何使用vue-ssr做服务端渲染初体验(三)\ncomments: true\ndate: 2017-06-05 20:09:11\ntags: \n    - 'javascript'\n    - 'vue'\n---\n\n### 1、前言\n\n上一节大致介绍了服务端和客户端入口文件代码内容，现在已经可以正常运行你的后端渲染脚手架了，这一节，跟大家分享下如何使用axios做ajax请求，如何使用mockjs做本地假数据，跑通本地基本逻辑，为以后前后端连调做准备。\n\n### 2、前期准备\n\n需要用npm安装axios，mockjs依赖包,由于mockjs只是代码开发的辅助工具，所以安装的时候我会加--save-dev来区分，具体可以根据自己的需求来定，当然，如果有mock服务平台的话，可以直接走mock平台造假数据，本地直接访问mock平台的接口，例如可以使用阿里的Rap平台管理工具生成。\n\n{% codeblock lang:javascript %}\nnpm install axios --save\nnpm install mockjs --save-dev\n{% endcodeblock %} \n\n<!-- more -->\n\n### 3、简要介绍axios\n\n>其他请求方式，代码示例如下：\n\n{% codeblock lang:javascript %}\naxios.request(config);\naxios.get(url[,config]);\naxios.delete(url[,config]);\naxios.head(url[,config]);\naxios.post(url[,data[,config]]);\naxios.put(url[,data[,config]])\naxios.patch(url[,data[,config]])\n{% endcodeblock %} \n\n>具体详细可以点击查看<a href=\"/2017-05-02/\" target=\"_blank\" >axios基本使用介绍</a>\n\napi.js完整代码如下：\n\n{% codeblock lang:javascript %}\nfunction ajax(url, type, options) {\n    return Q.Promise((resolve, reject) => {\n        axios({\n            method : type,\n            url : url,\n            // responseType:'stream',\n            data : options\n        })\n        .then((result) => {\n            if (result && result.status === 401) {\n                location.href = '/views/401.html'\n            }\n            if (result && result.status === 200) {\n                resolve(result.data);\n            } else {\n                reject({\n                    errno: result.errno,\n                    msg: result.msg\n                });\n            }\n        })\n        .catch(function(error) {\n            console.log(error,url);\n        });\n    })\n}\n\nconst config = {\n    get(url, options) {\n        const _self = this;\n        return Q.Promise((resolve, reject) => {\n            ajax(url, 'get', options)\n            .then((data) => {\n                resolve(data);\n            }, (error) => {\n                reject(error);\n            });\n        })\n    },\n\n    post(url, options) {\n        const _self = this;\n        return Q.Promise((resolve, reject) => {\n            ajax(url, 'post', options)\n            .then((data) => {\n                resolve(data);\n            }, (error) => {\n                reject(error);\n            });\n        })\n    },\n\n    put(url, options) {\n        const _self = this;\n        return Q.Promise((resolve, reject) => {\n            ajax(url, 'put', options)\n            .then((data) => {\n                resolve(data);\n            }, (error) => {\n                reject(error);\n            });\n        })\n    },\n\n    delete(url, options) {\n        const _self = this;\n        return Q.Promise((resolve, reject) => {\n            ajax(url, 'delete', options)\n            .then((data) => {\n                resolve(data);\n            }, (error) => {\n                reject(error);\n            });\n        })\n    },\n\n    jsonp(url, options) {\n        const _self = this;\n        return Q.Promise((resolve, reject) => {\n            ajax(url, 'jsonp', options)\n            .then((data) => {\n                resolve(data);\n            }, (error) => {\n                reject(error);\n            });\n        })\n    }\n};\n\nexport default config;\n{% endcodeblock %}\n\n>mockjs项目基本配置如下：\n\n\n1、在public下新建conf.js全局定义请求url地址，代码如下：\n{% codeblock lang:javascript %}\nmodule.exports = {\n    HOST: \"http://www.xxx.com\",\n    DEBUGMOCK: true\n};\n{% endcodeblock %}\n\n2、在component根目录下新建conf.js，定义组件mock的请求路径，并且定义是否开始单个组件使用mock数据还是线上接口数据，代码如下：\n{% codeblock lang:javascript %}\nconst PUBCONF = require('../public/conf.js');\n\nexport const DEMO = {\n  DEBUGMOCK : PUBCONF.DEBUGMOCK,\n\n  INDEX_URL : PUBCONF.HOST + '/demo',\n  INDEX_URL_MOCK : true && PUBCONF.DEBUGMOCK\n}\n\nexport const ANOTHER_DEMO = {\n\n}\nexport default {\n    DEMO,\n    ANOTHER_DEMO\n}\n{% endcodeblock %}\n\n3、在组件内部定义conf.js文件，主要编写单个组件的基本配置信息，请求路径，mock数据对应的url地址，代码如下：\n{% codeblock lang:javascript %}\nimport {DEMO} from '../conf.js';\nconst MODULECONF = {\n  'demo': {\n    NAME: 'demo',\n    ICON: '',\n    MOCK: DEMO.INDEX_URL_MOCK,\n    API: {\n      GET: DEMO.INDEX_URL,\n    }\n  },\n};\nexport default MODULECONF;\n{% endcodeblock %}\n\n4、在组件内部定义mockjs来编写mock假数据，代码如下：\n{% codeblock lang:javascript %}\nimport Mock from 'mockjs';\nexport default Mock.mock('http://www.xxx.com/demo', {\n    errno: 0,\n    msg: \"成功\",\n    data: [{\n        'name': '@name',\n        'age|1-100': 100,\n        'color': '@color'\n    }]\n});\n{% endcodeblock %}\n\n>查看数据返回效果，数据在控制台打印出来\n\n![查看数据返回](vue-ssr3/11.jpeg)\n\n以上就是基本的流程，如果有更好更灵活的使用方案，希望能够参与沟通并且分享，这里会有个问题，就是目前mockjs未能跟业务代码隔离，webpack如果单纯加上externals配置，项目打包后,直接本地运行会报错，找不到mockjs，不知道是不是自己配置的原因，但是基本的思想就是最终上线代码不要把工具类的函数打包进去。项目脚手架已经在github上分享，<a href=\"https://github.com/wqzwh/wq-vue-ssr\" target=\"_blank\">点击查看详情</a>\n","slug":"vue-ssr3","published":1,"updated":"2017-08-26T12:58:33.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36rn000llmldesyz1z8e","content":"<h3 id=\"1、前言\"><a href=\"#1、前言\" class=\"headerlink\" title=\"1、前言\"></a>1、前言</h3><p>上一节大致介绍了服务端和客户端入口文件代码内容，现在已经可以正常运行你的后端渲染脚手架了，这一节，跟大家分享下如何使用axios做ajax请求，如何使用mockjs做本地假数据，跑通本地基本逻辑，为以后前后端连调做准备。</p>\n<h3 id=\"2、前期准备\"><a href=\"#2、前期准备\" class=\"headerlink\" title=\"2、前期准备\"></a>2、前期准备</h3><p>需要用npm安装axios，mockjs依赖包,由于mockjs只是代码开发的辅助工具，所以安装的时候我会加–save-dev来区分，具体可以根据自己的需求来定，当然，如果有mock服务平台的话，可以直接走mock平台造假数据，本地直接访问mock平台的接口，例如可以使用阿里的Rap平台管理工具生成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install axios --save</div><div class=\"line\">npm install mockjs --save-dev</div></pre></td></tr></table></figure> \n<a id=\"more\"></a>\n<h3 id=\"3、简要介绍axios\"><a href=\"#3、简要介绍axios\" class=\"headerlink\" title=\"3、简要介绍axios\"></a>3、简要介绍axios</h3><blockquote>\n<p>其他请求方式，代码示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios.request(config);</div><div class=\"line\">axios.get(url[,config]);</div><div class=\"line\">axios.delete(url[,config]);</div><div class=\"line\">axios.head(url[,config]);</div><div class=\"line\">axios.post(url[,data[,config]]);</div><div class=\"line\">axios.put(url[,data[,config]])</div><div class=\"line\">axios.patch(url[,data[,config]])</div></pre></td></tr></table></figure> \n<blockquote>\n<p>具体详细可以点击查看<a href=\"/2017-05-02/\" target=\"_blank\">axios基本使用介绍</a></p>\n</blockquote>\n<p>api.js完整代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url, type, options</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">        axios(&#123;</div><div class=\"line\">            method : type,</div><div class=\"line\">            url : url,</div><div class=\"line\">            <span class=\"comment\">// responseType:'stream',</span></div><div class=\"line\">            data : options</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (result &amp;&amp; result.status === <span class=\"number\">401</span>) &#123;</div><div class=\"line\">                location.href = <span class=\"string\">'/views/401.html'</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (result &amp;&amp; result.status === <span class=\"number\">200</span>) &#123;</div><div class=\"line\">                resolve(result.data);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                reject(&#123;</div><div class=\"line\">                    errno: result.errno,</div><div class=\"line\">                    msg: result.msg</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(error,url);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> config = &#123;</div><div class=\"line\">    get(url, options) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">            ajax(url, <span class=\"string\">'get'</span>, options)</div><div class=\"line\">            .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                resolve(data);</div><div class=\"line\">            &#125;, (error) =&gt; &#123;</div><div class=\"line\">                reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    post(url, options) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">            ajax(url, <span class=\"string\">'post'</span>, options)</div><div class=\"line\">            .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                resolve(data);</div><div class=\"line\">            &#125;, (error) =&gt; &#123;</div><div class=\"line\">                reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    put(url, options) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">            ajax(url, <span class=\"string\">'put'</span>, options)</div><div class=\"line\">            .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                resolve(data);</div><div class=\"line\">            &#125;, (error) =&gt; &#123;</div><div class=\"line\">                reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">delete</span>(url, options) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">            ajax(url, <span class=\"string\">'delete'</span>, options)</div><div class=\"line\">            .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                resolve(data);</div><div class=\"line\">            &#125;, (error) =&gt; &#123;</div><div class=\"line\">                reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    jsonp(url, options) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">            ajax(url, <span class=\"string\">'jsonp'</span>, options)</div><div class=\"line\">            .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                resolve(data);</div><div class=\"line\">            &#125;, (error) =&gt; &#123;</div><div class=\"line\">                reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> config;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>mockjs项目基本配置如下：</p>\n</blockquote>\n<p>1、在public下新建conf.js全局定义请求url地址，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    HOST: <span class=\"string\">\"http://www.xxx.com\"</span>,</div><div class=\"line\">    DEBUGMOCK: <span class=\"literal\">true</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>2、在component根目录下新建conf.js，定义组件mock的请求路径，并且定义是否开始单个组件使用mock数据还是线上接口数据，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> PUBCONF = <span class=\"built_in\">require</span>(<span class=\"string\">'../public/conf.js'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DEMO = &#123;</div><div class=\"line\">  DEBUGMOCK : PUBCONF.DEBUGMOCK,</div><div class=\"line\"></div><div class=\"line\">  INDEX_URL : PUBCONF.HOST + <span class=\"string\">'/demo'</span>,</div><div class=\"line\">  INDEX_URL_MOCK : <span class=\"literal\">true</span> &amp;&amp; PUBCONF.DEBUGMOCK</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ANOTHER_DEMO = &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    DEMO,</div><div class=\"line\">    ANOTHER_DEMO</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>3、在组件内部定义conf.js文件，主要编写单个组件的基本配置信息，请求路径，mock数据对应的url地址，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;DEMO&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../conf.js'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> MODULECONF = &#123;</div><div class=\"line\">  <span class=\"string\">'demo'</span>: &#123;</div><div class=\"line\">    NAME: <span class=\"string\">'demo'</span>,</div><div class=\"line\">    ICON: <span class=\"string\">''</span>,</div><div class=\"line\">    MOCK: DEMO.INDEX_URL_MOCK,</div><div class=\"line\">    API: &#123;</div><div class=\"line\">      GET: DEMO.INDEX_URL,</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MODULECONF;</div></pre></td></tr></table></figure></p>\n<p>4、在组件内部定义mockjs来编写mock假数据，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Mock <span class=\"keyword\">from</span> <span class=\"string\">'mockjs'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Mock.mock(<span class=\"string\">'http://www.xxx.com/demo'</span>, &#123;</div><div class=\"line\">    errno: <span class=\"number\">0</span>,</div><div class=\"line\">    msg: <span class=\"string\">\"成功\"</span>,</div><div class=\"line\">    data: [&#123;</div><div class=\"line\">        <span class=\"string\">'name'</span>: <span class=\"string\">'@name'</span>,</div><div class=\"line\">        <span class=\"string\">'age|1-100'</span>: <span class=\"number\">100</span>,</div><div class=\"line\">        <span class=\"string\">'color'</span>: <span class=\"string\">'@color'</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>查看数据返回效果，数据在控制台打印出来</p>\n</blockquote>\n<p><img src=\"/vue-ssr3/11.jpeg\" alt=\"查看数据返回\"></p>\n<p>以上就是基本的流程，如果有更好更灵活的使用方案，希望能够参与沟通并且分享，这里会有个问题，就是目前mockjs未能跟业务代码隔离，webpack如果单纯加上externals配置，项目打包后,直接本地运行会报错，找不到mockjs，不知道是不是自己配置的原因，但是基本的思想就是最终上线代码不要把工具类的函数打包进去。项目脚手架已经在github上分享，<a href=\"https://github.com/wqzwh/wq-vue-ssr\" target=\"_blank\">点击查看详情</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1、前言\"><a href=\"#1、前言\" class=\"headerlink\" title=\"1、前言\"></a>1、前言</h3><p>上一节大致介绍了服务端和客户端入口文件代码内容，现在已经可以正常运行你的后端渲染脚手架了，这一节，跟大家分享下如何使用axios做ajax请求，如何使用mockjs做本地假数据，跑通本地基本逻辑，为以后前后端连调做准备。</p>\n<h3 id=\"2、前期准备\"><a href=\"#2、前期准备\" class=\"headerlink\" title=\"2、前期准备\"></a>2、前期准备</h3><p>需要用npm安装axios，mockjs依赖包,由于mockjs只是代码开发的辅助工具，所以安装的时候我会加–save-dev来区分，具体可以根据自己的需求来定，当然，如果有mock服务平台的话，可以直接走mock平台造假数据，本地直接访问mock平台的接口，例如可以使用阿里的Rap平台管理工具生成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install axios --save</div><div class=\"line\">npm install mockjs --save-dev</div></pre></td></tr></table></figure>","more":"<h3 id=\"3、简要介绍axios\"><a href=\"#3、简要介绍axios\" class=\"headerlink\" title=\"3、简要介绍axios\"></a>3、简要介绍axios</h3><blockquote>\n<p>其他请求方式，代码示例如下：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">axios.request(config);</div><div class=\"line\">axios.get(url[,config]);</div><div class=\"line\">axios.delete(url[,config]);</div><div class=\"line\">axios.head(url[,config]);</div><div class=\"line\">axios.post(url[,data[,config]]);</div><div class=\"line\">axios.put(url[,data[,config]])</div><div class=\"line\">axios.patch(url[,data[,config]])</div></pre></td></tr></table></figure> \n<blockquote>\n<p>具体详细可以点击查看<a href=\"/2017-05-02/\" target=\"_blank\">axios基本使用介绍</a></p>\n</blockquote>\n<p>api.js完整代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url, type, options</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">        axios(&#123;</div><div class=\"line\">            method : type,</div><div class=\"line\">            url : url,</div><div class=\"line\">            <span class=\"comment\">// responseType:'stream',</span></div><div class=\"line\">            data : options</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (result &amp;&amp; result.status === <span class=\"number\">401</span>) &#123;</div><div class=\"line\">                location.href = <span class=\"string\">'/views/401.html'</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (result &amp;&amp; result.status === <span class=\"number\">200</span>) &#123;</div><div class=\"line\">                resolve(result.data);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                reject(&#123;</div><div class=\"line\">                    errno: result.errno,</div><div class=\"line\">                    msg: result.msg</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(error,url);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> config = &#123;</div><div class=\"line\">    get(url, options) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">            ajax(url, <span class=\"string\">'get'</span>, options)</div><div class=\"line\">            .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                resolve(data);</div><div class=\"line\">            &#125;, (error) =&gt; &#123;</div><div class=\"line\">                reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    post(url, options) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">            ajax(url, <span class=\"string\">'post'</span>, options)</div><div class=\"line\">            .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                resolve(data);</div><div class=\"line\">            &#125;, (error) =&gt; &#123;</div><div class=\"line\">                reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    put(url, options) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">            ajax(url, <span class=\"string\">'put'</span>, options)</div><div class=\"line\">            .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                resolve(data);</div><div class=\"line\">            &#125;, (error) =&gt; &#123;</div><div class=\"line\">                reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">delete</span>(url, options) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">            ajax(url, <span class=\"string\">'delete'</span>, options)</div><div class=\"line\">            .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                resolve(data);</div><div class=\"line\">            &#125;, (error) =&gt; &#123;</div><div class=\"line\">                reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    jsonp(url, options) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> Q.Promise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">            ajax(url, <span class=\"string\">'jsonp'</span>, options)</div><div class=\"line\">            .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                resolve(data);</div><div class=\"line\">            &#125;, (error) =&gt; &#123;</div><div class=\"line\">                reject(error);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> config;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>mockjs项目基本配置如下：</p>\n</blockquote>\n<p>1、在public下新建conf.js全局定义请求url地址，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    HOST: <span class=\"string\">\"http://www.xxx.com\"</span>,</div><div class=\"line\">    DEBUGMOCK: <span class=\"literal\">true</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>2、在component根目录下新建conf.js，定义组件mock的请求路径，并且定义是否开始单个组件使用mock数据还是线上接口数据，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> PUBCONF = <span class=\"built_in\">require</span>(<span class=\"string\">'../public/conf.js'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DEMO = &#123;</div><div class=\"line\">  DEBUGMOCK : PUBCONF.DEBUGMOCK,</div><div class=\"line\"></div><div class=\"line\">  INDEX_URL : PUBCONF.HOST + <span class=\"string\">'/demo'</span>,</div><div class=\"line\">  INDEX_URL_MOCK : <span class=\"literal\">true</span> &amp;&amp; PUBCONF.DEBUGMOCK</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ANOTHER_DEMO = &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    DEMO,</div><div class=\"line\">    ANOTHER_DEMO</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>3、在组件内部定义conf.js文件，主要编写单个组件的基本配置信息，请求路径，mock数据对应的url地址，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;DEMO&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../conf.js'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> MODULECONF = &#123;</div><div class=\"line\">  <span class=\"string\">'demo'</span>: &#123;</div><div class=\"line\">    NAME: <span class=\"string\">'demo'</span>,</div><div class=\"line\">    ICON: <span class=\"string\">''</span>,</div><div class=\"line\">    MOCK: DEMO.INDEX_URL_MOCK,</div><div class=\"line\">    API: &#123;</div><div class=\"line\">      GET: DEMO.INDEX_URL,</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MODULECONF;</div></pre></td></tr></table></figure></p>\n<p>4、在组件内部定义mockjs来编写mock假数据，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Mock <span class=\"keyword\">from</span> <span class=\"string\">'mockjs'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Mock.mock(<span class=\"string\">'http://www.xxx.com/demo'</span>, &#123;</div><div class=\"line\">    errno: <span class=\"number\">0</span>,</div><div class=\"line\">    msg: <span class=\"string\">\"成功\"</span>,</div><div class=\"line\">    data: [&#123;</div><div class=\"line\">        <span class=\"string\">'name'</span>: <span class=\"string\">'@name'</span>,</div><div class=\"line\">        <span class=\"string\">'age|1-100'</span>: <span class=\"number\">100</span>,</div><div class=\"line\">        <span class=\"string\">'color'</span>: <span class=\"string\">'@color'</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>查看数据返回效果，数据在控制台打印出来</p>\n</blockquote>\n<p><img src=\"/vue-ssr3/11.jpeg\" alt=\"查看数据返回\"></p>\n<p>以上就是基本的流程，如果有更好更灵活的使用方案，希望能够参与沟通并且分享，这里会有个问题，就是目前mockjs未能跟业务代码隔离，webpack如果单纯加上externals配置，项目打包后,直接本地运行会报错，找不到mockjs，不知道是不是自己配置的原因，但是基本的思想就是最终上线代码不要把工具类的函数打包进去。项目脚手架已经在github上分享，<a href=\"https://github.com/wqzwh/wq-vue-ssr\" target=\"_blank\">点击查看详情</a></p>"},{"title":"WebGL系列教程--3D图形学入门","comments":1,"toc":true,"date":"2017-07-01T13:09:11.000Z","_content":"\n### 3D的基本元素\n\n2D坐标系由x轴和y轴构成。其中，笛卡尔坐标系是最常见的2D坐标系。原点为（0.0），每个系统的坐标系不一样，有的系统y轴是正方向，有的是y轴的负方向为正方向。\n\n<img width=\"300\" src=\"webgl-2017-07-01/01.jpeg\" title=\"2D笛卡尔坐标系\"/>\n\n<!-- more -->\n\nHTML5 canvas2D坐标系,canvas坐标原点在左上角，从x为右是正方向，向下为y轴的正方向\n\n<img width=\"300\" src=\"webgl-2017-07-01/02.jpeg\" title=\"canvas坐标原点\"/>\n\n示例代码片段：\n{% codeblock lang:html %}\n<style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n    </style>\n<canvas id=\"canvas\"></canvas>\n<script>\n  var cxt = canvas.getContext('2d');\n\n  // 设置正方体左上角坐标（x，y）\n  var x = 50;\n  var y = 50;\n\n  // 绘制正方形\n  cxt.fillRect(x,y,50,50);\n</script>  \n{% endcodeblock %}\n\n效果如下：\n\n<img width=\"300\" src=\"webgl-2017-07-01/03.jpeg\"/>\n修改x和y轴后展示效果如下：\n{% codeblock lang:javascript %}\n  // 设置正方体左上角坐标（x，y）\n  var x = 0;\n  var y = 0;\n{% endcodeblock %}\n<img width=\"300\" src=\"webgl-2017-07-01/04.jpeg\"/>\n\n3D坐标系增加了表示深度的z轴，即3D物体离屏幕的深度。\n\n<img width=\"300\" src=\"webgl-2017-07-01/05.jpeg\"/>\n\nWebGL坐标系的方向，向上为y轴的正方向，向右为x轴的正方向，从原点向外为z轴的正方向。绘图的可视范围是+1到-1之间\n\n<img width=\"300\" src=\"webgl-2017-07-01/06.jpeg\"/>\n\n基本示例代码如下：\n{% codeblock lang:javascript %}\n  const VSHADER_SOURCE =\n    `void main() {\n    gl_Position = vec4(1.0,0.0,0.0,1.0);\n    gl_PointSize = 30.0;\n}`\n{% endcodeblock %}\n\nwebgl规定1.0为可视区域的最外层，不是像素值的意义。\n\n<img width=\"300\" src=\"webgl-2017-07-01/07.jpeg\"/>\n\n三角形是基础图形，所有的图形都能根据三角形进行拼凑而成，也就是3D图形是由一个或者多个三角形组成；网格是由一个或者多个图形组成。\n\n<b>法线</b>:始终垂直于某平面的虚线，在几何中，法线是指平面上垂直于曲线在某点切线的直线。法线和切线的交点称作切点，法线在3D绘图当中尤其在切图当中起到很大作用，通常的切图会失真，用法线切图方式算法的切图效果相对比较逼真。\n\n<img width=\"300\" src=\"webgl-2017-07-01/08.jpeg\"/>\n\n### 3D的变换概念\n\n<b>变换</b>：变换的原理是对顶点的改变，变换的方式有三种，分别是缩放、平移、旋转。\n    <img width=\"200\" src=\"webgl-2017-07-01/09.jpeg\"/><img width=\"200\" src=\"webgl-2017-07-01/10.jpeg\"/><img width=\"200\" src=\"webgl-2017-07-01/11.jpeg\"/><img width=\"200\" src=\"webgl-2017-07-01/12.jpeg\"/>\n\n旋转规定Z轴不变，定义初始旋转角度变量，示例代码我们先用着色器来计算顶点坐标位置，性能会比较低，在实际开发中，会定义矩阵来计算复杂的位置，示例代码片段如下：    \n{% codeblock lang:javascript %}\n// 定义旋转角度\nvar ANGLE = 30.0;\nconst VSHADER_SOURCE =\n  ` attribute vec4 a_Position;\n    uniform float u_CosB,u_SinB;\n    attribute float a_PointSize;\n    void main() {\n       gl_Position.x = a_Position.x * u_CosB -  a_Position.y * u_SinB;\n       gl_Position.y = a_Position.x * u_SinB -  a_Position.y * u_CosB;\n       gl_Position.z = a_Position.z;\n       gl_Position.w = 1.0;\n     }`\n// 片元着色器程序\nconst FSHADER_SOURCE =\n  ` precision mediump float;\n    uniform vec4 u_FragColor;\n    void main() {\n      gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n    }`\n{% endcodeblock %}\n\n<b>矩阵</b>：解决的复杂是针对着色器的，在实际开发中，应保证着色器的简单，因为着色器越复杂性能就越低。在webgl中矩阵可以理解为是一种数据类型，专门处理复杂的计算，可以进行乘法和加法的运算。代码片段如下：\n{% codeblock lang:javascript %}\n// 定义矩阵的方式来处理变换效果\n// 定义旋转角度\nvar ANGLE = 30.0;\nconst VSHADER_SOURCE =\n  ` attribute vec4 a_Position;\n    uniform mat4 u_xformMatrix; //定义矩阵来变化\n    void main() {\n       gl_Position = u_xformMatrix * a_Position;\n     }`\n// 片元着色器程序\nconst FSHADER_SOURCE =\n  ` void main() {\n      gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n    }`\n{% endcodeblock %}\n\n### 网格表面\n\n<b>纹理与材质</b>：纹理可以定义网格表面的外观，例如在模型上贴一张图片；材质是网格表面的特性，也就是光滑度、透明度等等。\n<b>光照原理</b>：光线方向决定物体的明暗度与阴影,在着色过程中，需要考虑光源类型与反射类型。\n<b>光照类型</b>：平行光（从一个方向平行的打在一个物体上，有方向感的）、点光源光（由中心光源散发出来的光线，越往四周光线越弱）、环境光（在任何一个地方，光线的强弱都是一样的）\n\n<img width=\"500\" src=\"webgl-2017-07-01/13.jpeg\"/>\n\n<b>反射类型</b>：漫反射光色由入射光色、表面漆色和入射角决定，环境反射由入射光色和表面漆色决定。\n\n<img width=\"300\" src=\"webgl-2017-07-01/14.jpeg\"/>\n\n### 着色器\n\n代替传统的固定渲染管线，固定的渲染管线是不可变的；着色器具有可编程性的；着色器分为，顶点着色器和片元着色器。\n\n<b>顶点着色器</b>：顶点着色器用来描述顶点的位置、颜色的程序，写法类似c语言，会定义一个主函数main，同时有系统变量，这个变量是不可以变的，变量对应的值是强类型，片段代码如下：\n\n{% codeblock lang:javascript %}\nvoid main() {\n    gl_Position = vec4(0.0,0.0,0.0,1.0);\n    gl_PointSize = 20.0;\n}\n{% endcodeblock %}\n\n<b>片元着色器</b>：对网格表面像素的处理程序，例如网格表面的贴图就需要用到片元着色器，系统变量对应的值是不能超过1.0的，片段代码如下：\n\n{% codeblock lang:javascript %}\nvoid main(){\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n}\n{% endcodeblock %}\n\n### 3D世界\n\n<b>相机、视口、投影</b>：相机角度的不同，观察物力的景象就是不同的，远近决定观察看到物体的大小不同，图片中绿色的区域表示视口，也就是canvas决定的，它的大小决定了可视化的范围，红色部分表示场景显示最远能够到哪里，两者之间的可视化锥体，就代表可视化的范围，最终的影像会在视口中呈现出来，大小是由相机决定的。投影的概念就是物体投影在前方视口最终形成的影像。\n\n<img width=\"400\" src=\"webgl-2017-07-01/15.jpeg\"/>\n\n这一节简要的介绍了以上几个概念的基本知识，下一节将介绍WebGL的基本概念。后期所有的例子都会提供源码供大家下载。","source":"_posts/webgl-2017-07-01.md","raw":"---\ntitle: WebGL系列教程--3D图形学入门\ncomments: true\ntoc: true\ndate: 2017-07-01 21:09:11\ntags: \n    - 'javascript'\n    - 'webgl'\n---\n\n### 3D的基本元素\n\n2D坐标系由x轴和y轴构成。其中，笛卡尔坐标系是最常见的2D坐标系。原点为（0.0），每个系统的坐标系不一样，有的系统y轴是正方向，有的是y轴的负方向为正方向。\n\n<img width=\"300\" src=\"webgl-2017-07-01/01.jpeg\" title=\"2D笛卡尔坐标系\"/>\n\n<!-- more -->\n\nHTML5 canvas2D坐标系,canvas坐标原点在左上角，从x为右是正方向，向下为y轴的正方向\n\n<img width=\"300\" src=\"webgl-2017-07-01/02.jpeg\" title=\"canvas坐标原点\"/>\n\n示例代码片段：\n{% codeblock lang:html %}\n<style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n    </style>\n<canvas id=\"canvas\"></canvas>\n<script>\n  var cxt = canvas.getContext('2d');\n\n  // 设置正方体左上角坐标（x，y）\n  var x = 50;\n  var y = 50;\n\n  // 绘制正方形\n  cxt.fillRect(x,y,50,50);\n</script>  \n{% endcodeblock %}\n\n效果如下：\n\n<img width=\"300\" src=\"webgl-2017-07-01/03.jpeg\"/>\n修改x和y轴后展示效果如下：\n{% codeblock lang:javascript %}\n  // 设置正方体左上角坐标（x，y）\n  var x = 0;\n  var y = 0;\n{% endcodeblock %}\n<img width=\"300\" src=\"webgl-2017-07-01/04.jpeg\"/>\n\n3D坐标系增加了表示深度的z轴，即3D物体离屏幕的深度。\n\n<img width=\"300\" src=\"webgl-2017-07-01/05.jpeg\"/>\n\nWebGL坐标系的方向，向上为y轴的正方向，向右为x轴的正方向，从原点向外为z轴的正方向。绘图的可视范围是+1到-1之间\n\n<img width=\"300\" src=\"webgl-2017-07-01/06.jpeg\"/>\n\n基本示例代码如下：\n{% codeblock lang:javascript %}\n  const VSHADER_SOURCE =\n    `void main() {\n    gl_Position = vec4(1.0,0.0,0.0,1.0);\n    gl_PointSize = 30.0;\n}`\n{% endcodeblock %}\n\nwebgl规定1.0为可视区域的最外层，不是像素值的意义。\n\n<img width=\"300\" src=\"webgl-2017-07-01/07.jpeg\"/>\n\n三角形是基础图形，所有的图形都能根据三角形进行拼凑而成，也就是3D图形是由一个或者多个三角形组成；网格是由一个或者多个图形组成。\n\n<b>法线</b>:始终垂直于某平面的虚线，在几何中，法线是指平面上垂直于曲线在某点切线的直线。法线和切线的交点称作切点，法线在3D绘图当中尤其在切图当中起到很大作用，通常的切图会失真，用法线切图方式算法的切图效果相对比较逼真。\n\n<img width=\"300\" src=\"webgl-2017-07-01/08.jpeg\"/>\n\n### 3D的变换概念\n\n<b>变换</b>：变换的原理是对顶点的改变，变换的方式有三种，分别是缩放、平移、旋转。\n    <img width=\"200\" src=\"webgl-2017-07-01/09.jpeg\"/><img width=\"200\" src=\"webgl-2017-07-01/10.jpeg\"/><img width=\"200\" src=\"webgl-2017-07-01/11.jpeg\"/><img width=\"200\" src=\"webgl-2017-07-01/12.jpeg\"/>\n\n旋转规定Z轴不变，定义初始旋转角度变量，示例代码我们先用着色器来计算顶点坐标位置，性能会比较低，在实际开发中，会定义矩阵来计算复杂的位置，示例代码片段如下：    \n{% codeblock lang:javascript %}\n// 定义旋转角度\nvar ANGLE = 30.0;\nconst VSHADER_SOURCE =\n  ` attribute vec4 a_Position;\n    uniform float u_CosB,u_SinB;\n    attribute float a_PointSize;\n    void main() {\n       gl_Position.x = a_Position.x * u_CosB -  a_Position.y * u_SinB;\n       gl_Position.y = a_Position.x * u_SinB -  a_Position.y * u_CosB;\n       gl_Position.z = a_Position.z;\n       gl_Position.w = 1.0;\n     }`\n// 片元着色器程序\nconst FSHADER_SOURCE =\n  ` precision mediump float;\n    uniform vec4 u_FragColor;\n    void main() {\n      gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n    }`\n{% endcodeblock %}\n\n<b>矩阵</b>：解决的复杂是针对着色器的，在实际开发中，应保证着色器的简单，因为着色器越复杂性能就越低。在webgl中矩阵可以理解为是一种数据类型，专门处理复杂的计算，可以进行乘法和加法的运算。代码片段如下：\n{% codeblock lang:javascript %}\n// 定义矩阵的方式来处理变换效果\n// 定义旋转角度\nvar ANGLE = 30.0;\nconst VSHADER_SOURCE =\n  ` attribute vec4 a_Position;\n    uniform mat4 u_xformMatrix; //定义矩阵来变化\n    void main() {\n       gl_Position = u_xformMatrix * a_Position;\n     }`\n// 片元着色器程序\nconst FSHADER_SOURCE =\n  ` void main() {\n      gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n    }`\n{% endcodeblock %}\n\n### 网格表面\n\n<b>纹理与材质</b>：纹理可以定义网格表面的外观，例如在模型上贴一张图片；材质是网格表面的特性，也就是光滑度、透明度等等。\n<b>光照原理</b>：光线方向决定物体的明暗度与阴影,在着色过程中，需要考虑光源类型与反射类型。\n<b>光照类型</b>：平行光（从一个方向平行的打在一个物体上，有方向感的）、点光源光（由中心光源散发出来的光线，越往四周光线越弱）、环境光（在任何一个地方，光线的强弱都是一样的）\n\n<img width=\"500\" src=\"webgl-2017-07-01/13.jpeg\"/>\n\n<b>反射类型</b>：漫反射光色由入射光色、表面漆色和入射角决定，环境反射由入射光色和表面漆色决定。\n\n<img width=\"300\" src=\"webgl-2017-07-01/14.jpeg\"/>\n\n### 着色器\n\n代替传统的固定渲染管线，固定的渲染管线是不可变的；着色器具有可编程性的；着色器分为，顶点着色器和片元着色器。\n\n<b>顶点着色器</b>：顶点着色器用来描述顶点的位置、颜色的程序，写法类似c语言，会定义一个主函数main，同时有系统变量，这个变量是不可以变的，变量对应的值是强类型，片段代码如下：\n\n{% codeblock lang:javascript %}\nvoid main() {\n    gl_Position = vec4(0.0,0.0,0.0,1.0);\n    gl_PointSize = 20.0;\n}\n{% endcodeblock %}\n\n<b>片元着色器</b>：对网格表面像素的处理程序，例如网格表面的贴图就需要用到片元着色器，系统变量对应的值是不能超过1.0的，片段代码如下：\n\n{% codeblock lang:javascript %}\nvoid main(){\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n}\n{% endcodeblock %}\n\n### 3D世界\n\n<b>相机、视口、投影</b>：相机角度的不同，观察物力的景象就是不同的，远近决定观察看到物体的大小不同，图片中绿色的区域表示视口，也就是canvas决定的，它的大小决定了可视化的范围，红色部分表示场景显示最远能够到哪里，两者之间的可视化锥体，就代表可视化的范围，最终的影像会在视口中呈现出来，大小是由相机决定的。投影的概念就是物体投影在前方视口最终形成的影像。\n\n<img width=\"400\" src=\"webgl-2017-07-01/15.jpeg\"/>\n\n这一节简要的介绍了以上几个概念的基本知识，下一节将介绍WebGL的基本概念。后期所有的例子都会提供源码供大家下载。","slug":"webgl-2017-07-01","published":1,"updated":"2017-09-03T04:15:58.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36rp000nlmld1b0wh3hc","content":"<h3 id=\"3D的基本元素\"><a href=\"#3D的基本元素\" class=\"headerlink\" title=\"3D的基本元素\"></a>3D的基本元素</h3><p>2D坐标系由x轴和y轴构成。其中，笛卡尔坐标系是最常见的2D坐标系。原点为（0.0），每个系统的坐标系不一样，有的系统y轴是正方向，有的是y轴的负方向为正方向。</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/01.jpeg\" title=\"2D笛卡尔坐标系\"></p>\n<a id=\"more\"></a>\n<p>HTML5 canvas2D坐标系,canvas坐标原点在左上角，从x为右是正方向，向下为y轴的正方向</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/02.jpeg\" title=\"canvas坐标原点\"></p>\n<p>示例代码片段：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"undefined\">        * &#123;</span></div><div class=\"line\"><span class=\"undefined\">            margin: 0;</span></div><div class=\"line\"><span class=\"undefined\">            padding: 0;</span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"canvas\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> cxt = canvas.getContext(<span class=\"string\">'2d'</span>);</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// 设置正方体左上角坐标（x，y）</span></span></div><div class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> x = <span class=\"number\">50</span>;</span></div><div class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> y = <span class=\"number\">50</span>;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// 绘制正方形</span></span></div><div class=\"line\"><span class=\"undefined\">  cxt.fillRect(x,y,50,50);</span></div><div class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>  </div></pre></td></tr></table></figure></p>\n<p>效果如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/03.jpeg\"><br>修改x和y轴后展示效果如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 设置正方体左上角坐标（x，y）</span></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">0</span>;</div></pre></td></tr></table></figure><br><img width=\"300\" src=\"/webgl-2017-07-01/04.jpeg\"></p>\n<p>3D坐标系增加了表示深度的z轴，即3D物体离屏幕的深度。</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/05.jpeg\"></p>\n<p>WebGL坐标系的方向，向上为y轴的正方向，向右为x轴的正方向，从原点向外为z轴的正方向。绘图的可视范围是+1到-1之间</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/06.jpeg\"></p>\n<p>基本示例代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"keyword\">const</span> VSHADER_SOURCE =</div><div class=\"line\">    <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">    gl_Position = vec4(1.0,0.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">    gl_PointSize = 30.0;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>\n<p>webgl规定1.0为可视区域的最外层，不是像素值的意义。</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/07.jpeg\"></p>\n<p>三角形是基础图形，所有的图形都能根据三角形进行拼凑而成，也就是3D图形是由一个或者多个三角形组成；网格是由一个或者多个图形组成。</p>\n<p><b>法线</b>:始终垂直于某平面的虚线，在几何中，法线是指平面上垂直于曲线在某点切线的直线。法线和切线的交点称作切点，法线在3D绘图当中尤其在切图当中起到很大作用，通常的切图会失真，用法线切图方式算法的切图效果相对比较逼真。</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/08.jpeg\"></p>\n<h3 id=\"3D的变换概念\"><a href=\"#3D的变换概念\" class=\"headerlink\" title=\"3D的变换概念\"></a>3D的变换概念</h3><p><b>变换</b>：变换的原理是对顶点的改变，变换的方式有三种，分别是缩放、平移、旋转。<br>    <img width=\"200\" src=\"/webgl-2017-07-01/09.jpeg\"><img width=\"200\" src=\"/webgl-2017-07-01/10.jpeg\"><img width=\"200\" src=\"/webgl-2017-07-01/11.jpeg\"><img width=\"200\" src=\"/webgl-2017-07-01/12.jpeg\"></p>\n<p>旋转规定Z轴不变，定义初始旋转角度变量，示例代码我们先用着色器来计算顶点坐标位置，性能会比较低，在实际开发中，会定义矩阵来计算复杂的位置，示例代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义旋转角度</span></div><div class=\"line\"><span class=\"keyword\">var</span> ANGLE = <span class=\"number\">30.0</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> VSHADER_SOURCE =</div><div class=\"line\">  <span class=\"string\">` attribute vec4 a_Position;</span></div><div class=\"line\"><span class=\"string\">    uniform float u_CosB,u_SinB;</span></div><div class=\"line\"><span class=\"string\">    attribute float a_PointSize;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">       gl_Position.x = a_Position.x * u_CosB -  a_Position.y * u_SinB;</span></div><div class=\"line\"><span class=\"string\">       gl_Position.y = a_Position.x * u_SinB -  a_Position.y * u_CosB;</span></div><div class=\"line\"><span class=\"string\">       gl_Position.z = a_Position.z;</span></div><div class=\"line\"><span class=\"string\">       gl_Position.w = 1.0;</span></div><div class=\"line\"><span class=\"string\">     &#125;`</span></div><div class=\"line\"><span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\"><span class=\"keyword\">const</span> FSHADER_SOURCE =</div><div class=\"line\">  <span class=\"string\">` precision mediump float;</span></div><div class=\"line\"><span class=\"string\">    uniform vec4 u_FragColor;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,1.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">    &#125;`</span></div></pre></td></tr></table></figure></p>\n<p><b>矩阵</b>：解决的复杂是针对着色器的，在实际开发中，应保证着色器的简单，因为着色器越复杂性能就越低。在webgl中矩阵可以理解为是一种数据类型，专门处理复杂的计算，可以进行乘法和加法的运算。代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义矩阵的方式来处理变换效果</span></div><div class=\"line\"><span class=\"comment\">// 定义旋转角度</span></div><div class=\"line\"><span class=\"keyword\">var</span> ANGLE = <span class=\"number\">30.0</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> VSHADER_SOURCE =</div><div class=\"line\">  <span class=\"string\">` attribute vec4 a_Position;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 u_xformMatrix; //定义矩阵来变化</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">       gl_Position = u_xformMatrix * a_Position;</span></div><div class=\"line\"><span class=\"string\">     &#125;`</span></div><div class=\"line\"><span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\"><span class=\"keyword\">const</span> FSHADER_SOURCE =</div><div class=\"line\">  <span class=\"string\">` void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,1.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">    &#125;`</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"网格表面\"><a href=\"#网格表面\" class=\"headerlink\" title=\"网格表面\"></a>网格表面</h3><p><b>纹理与材质</b>：纹理可以定义网格表面的外观，例如在模型上贴一张图片；材质是网格表面的特性，也就是光滑度、透明度等等。<br><b>光照原理</b>：光线方向决定物体的明暗度与阴影,在着色过程中，需要考虑光源类型与反射类型。<br><b>光照类型</b>：平行光（从一个方向平行的打在一个物体上，有方向感的）、点光源光（由中心光源散发出来的光线，越往四周光线越弱）、环境光（在任何一个地方，光线的强弱都是一样的）</p>\n<p><img width=\"500\" src=\"/webgl-2017-07-01/13.jpeg\"></p>\n<p><b>反射类型</b>：漫反射光色由入射光色、表面漆色和入射角决定，环境反射由入射光色和表面漆色决定。</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/14.jpeg\"></p>\n<h3 id=\"着色器\"><a href=\"#着色器\" class=\"headerlink\" title=\"着色器\"></a>着色器</h3><p>代替传统的固定渲染管线，固定的渲染管线是不可变的；着色器具有可编程性的；着色器分为，顶点着色器和片元着色器。</p>\n<p><b>顶点着色器</b>：顶点着色器用来描述顶点的位置、颜色的程序，写法类似c语言，会定义一个主函数main，同时有系统变量，这个变量是不可以变的，变量对应的值是强类型，片段代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> main() &#123;</div><div class=\"line\">    gl_Position = vec4(<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">    gl_PointSize = <span class=\"number\">20.0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><b>片元着色器</b>：对网格表面像素的处理程序，例如网格表面的贴图就需要用到片元着色器，系统变量对应的值是不能超过1.0的，片段代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> main()&#123;</div><div class=\"line\">    gl_FragColor = vec4(<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3D世界\"><a href=\"#3D世界\" class=\"headerlink\" title=\"3D世界\"></a>3D世界</h3><p><b>相机、视口、投影</b>：相机角度的不同，观察物力的景象就是不同的，远近决定观察看到物体的大小不同，图片中绿色的区域表示视口，也就是canvas决定的，它的大小决定了可视化的范围，红色部分表示场景显示最远能够到哪里，两者之间的可视化锥体，就代表可视化的范围，最终的影像会在视口中呈现出来，大小是由相机决定的。投影的概念就是物体投影在前方视口最终形成的影像。</p>\n<p><img width=\"400\" src=\"/webgl-2017-07-01/15.jpeg\"></p>\n<p>这一节简要的介绍了以上几个概念的基本知识，下一节将介绍WebGL的基本概念。后期所有的例子都会提供源码供大家下载。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"3D的基本元素\"><a href=\"#3D的基本元素\" class=\"headerlink\" title=\"3D的基本元素\"></a>3D的基本元素</h3><p>2D坐标系由x轴和y轴构成。其中，笛卡尔坐标系是最常见的2D坐标系。原点为（0.0），每个系统的坐标系不一样，有的系统y轴是正方向，有的是y轴的负方向为正方向。</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/01.jpeg\" title=\"2D笛卡尔坐标系\"></p>","more":"<p>HTML5 canvas2D坐标系,canvas坐标原点在左上角，从x为右是正方向，向下为y轴的正方向</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/02.jpeg\" title=\"canvas坐标原点\"></p>\n<p>示例代码片段：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"undefined\">        * &#123;</span></div><div class=\"line\"><span class=\"undefined\">            margin: 0;</span></div><div class=\"line\"><span class=\"undefined\">            padding: 0;</span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"canvas\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> cxt = canvas.getContext(<span class=\"string\">'2d'</span>);</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// 设置正方体左上角坐标（x，y）</span></span></div><div class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> x = <span class=\"number\">50</span>;</span></div><div class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> y = <span class=\"number\">50</span>;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// 绘制正方形</span></span></div><div class=\"line\"><span class=\"undefined\">  cxt.fillRect(x,y,50,50);</span></div><div class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>  </div></pre></td></tr></table></figure></p>\n<p>效果如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/03.jpeg\"><br>修改x和y轴后展示效果如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 设置正方体左上角坐标（x，y）</span></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">0</span>;</div></pre></td></tr></table></figure><br><img width=\"300\" src=\"/webgl-2017-07-01/04.jpeg\"></p>\n<p>3D坐标系增加了表示深度的z轴，即3D物体离屏幕的深度。</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/05.jpeg\"></p>\n<p>WebGL坐标系的方向，向上为y轴的正方向，向右为x轴的正方向，从原点向外为z轴的正方向。绘图的可视范围是+1到-1之间</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/06.jpeg\"></p>\n<p>基本示例代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"keyword\">const</span> VSHADER_SOURCE =</div><div class=\"line\">    <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">    gl_Position = vec4(1.0,0.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">    gl_PointSize = 30.0;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>\n<p>webgl规定1.0为可视区域的最外层，不是像素值的意义。</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/07.jpeg\"></p>\n<p>三角形是基础图形，所有的图形都能根据三角形进行拼凑而成，也就是3D图形是由一个或者多个三角形组成；网格是由一个或者多个图形组成。</p>\n<p><b>法线</b>:始终垂直于某平面的虚线，在几何中，法线是指平面上垂直于曲线在某点切线的直线。法线和切线的交点称作切点，法线在3D绘图当中尤其在切图当中起到很大作用，通常的切图会失真，用法线切图方式算法的切图效果相对比较逼真。</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/08.jpeg\"></p>\n<h3 id=\"3D的变换概念\"><a href=\"#3D的变换概念\" class=\"headerlink\" title=\"3D的变换概念\"></a>3D的变换概念</h3><p><b>变换</b>：变换的原理是对顶点的改变，变换的方式有三种，分别是缩放、平移、旋转。<br>    <img width=\"200\" src=\"/webgl-2017-07-01/09.jpeg\"><img width=\"200\" src=\"/webgl-2017-07-01/10.jpeg\"><img width=\"200\" src=\"/webgl-2017-07-01/11.jpeg\"><img width=\"200\" src=\"/webgl-2017-07-01/12.jpeg\"></p>\n<p>旋转规定Z轴不变，定义初始旋转角度变量，示例代码我们先用着色器来计算顶点坐标位置，性能会比较低，在实际开发中，会定义矩阵来计算复杂的位置，示例代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义旋转角度</span></div><div class=\"line\"><span class=\"keyword\">var</span> ANGLE = <span class=\"number\">30.0</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> VSHADER_SOURCE =</div><div class=\"line\">  <span class=\"string\">` attribute vec4 a_Position;</span></div><div class=\"line\"><span class=\"string\">    uniform float u_CosB,u_SinB;</span></div><div class=\"line\"><span class=\"string\">    attribute float a_PointSize;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">       gl_Position.x = a_Position.x * u_CosB -  a_Position.y * u_SinB;</span></div><div class=\"line\"><span class=\"string\">       gl_Position.y = a_Position.x * u_SinB -  a_Position.y * u_CosB;</span></div><div class=\"line\"><span class=\"string\">       gl_Position.z = a_Position.z;</span></div><div class=\"line\"><span class=\"string\">       gl_Position.w = 1.0;</span></div><div class=\"line\"><span class=\"string\">     &#125;`</span></div><div class=\"line\"><span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\"><span class=\"keyword\">const</span> FSHADER_SOURCE =</div><div class=\"line\">  <span class=\"string\">` precision mediump float;</span></div><div class=\"line\"><span class=\"string\">    uniform vec4 u_FragColor;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,1.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">    &#125;`</span></div></pre></td></tr></table></figure></p>\n<p><b>矩阵</b>：解决的复杂是针对着色器的，在实际开发中，应保证着色器的简单，因为着色器越复杂性能就越低。在webgl中矩阵可以理解为是一种数据类型，专门处理复杂的计算，可以进行乘法和加法的运算。代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义矩阵的方式来处理变换效果</span></div><div class=\"line\"><span class=\"comment\">// 定义旋转角度</span></div><div class=\"line\"><span class=\"keyword\">var</span> ANGLE = <span class=\"number\">30.0</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> VSHADER_SOURCE =</div><div class=\"line\">  <span class=\"string\">` attribute vec4 a_Position;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 u_xformMatrix; //定义矩阵来变化</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">       gl_Position = u_xformMatrix * a_Position;</span></div><div class=\"line\"><span class=\"string\">     &#125;`</span></div><div class=\"line\"><span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\"><span class=\"keyword\">const</span> FSHADER_SOURCE =</div><div class=\"line\">  <span class=\"string\">` void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,1.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">    &#125;`</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"网格表面\"><a href=\"#网格表面\" class=\"headerlink\" title=\"网格表面\"></a>网格表面</h3><p><b>纹理与材质</b>：纹理可以定义网格表面的外观，例如在模型上贴一张图片；材质是网格表面的特性，也就是光滑度、透明度等等。<br><b>光照原理</b>：光线方向决定物体的明暗度与阴影,在着色过程中，需要考虑光源类型与反射类型。<br><b>光照类型</b>：平行光（从一个方向平行的打在一个物体上，有方向感的）、点光源光（由中心光源散发出来的光线，越往四周光线越弱）、环境光（在任何一个地方，光线的强弱都是一样的）</p>\n<p><img width=\"500\" src=\"/webgl-2017-07-01/13.jpeg\"></p>\n<p><b>反射类型</b>：漫反射光色由入射光色、表面漆色和入射角决定，环境反射由入射光色和表面漆色决定。</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-01/14.jpeg\"></p>\n<h3 id=\"着色器\"><a href=\"#着色器\" class=\"headerlink\" title=\"着色器\"></a>着色器</h3><p>代替传统的固定渲染管线，固定的渲染管线是不可变的；着色器具有可编程性的；着色器分为，顶点着色器和片元着色器。</p>\n<p><b>顶点着色器</b>：顶点着色器用来描述顶点的位置、颜色的程序，写法类似c语言，会定义一个主函数main，同时有系统变量，这个变量是不可以变的，变量对应的值是强类型，片段代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> main() &#123;</div><div class=\"line\">    gl_Position = vec4(<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">    gl_PointSize = <span class=\"number\">20.0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><b>片元着色器</b>：对网格表面像素的处理程序，例如网格表面的贴图就需要用到片元着色器，系统变量对应的值是不能超过1.0的，片段代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> main()&#123;</div><div class=\"line\">    gl_FragColor = vec4(<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3D世界\"><a href=\"#3D世界\" class=\"headerlink\" title=\"3D世界\"></a>3D世界</h3><p><b>相机、视口、投影</b>：相机角度的不同，观察物力的景象就是不同的，远近决定观察看到物体的大小不同，图片中绿色的区域表示视口，也就是canvas决定的，它的大小决定了可视化的范围，红色部分表示场景显示最远能够到哪里，两者之间的可视化锥体，就代表可视化的范围，最终的影像会在视口中呈现出来，大小是由相机决定的。投影的概念就是物体投影在前方视口最终形成的影像。</p>\n<p><img width=\"400\" src=\"/webgl-2017-07-01/15.jpeg\"></p>\n<p>这一节简要的介绍了以上几个概念的基本知识，下一节将介绍WebGL的基本概念。后期所有的例子都会提供源码供大家下载。</p>"},{"title":"WebGL系列教程--基本概述","comments":1,"toc":true,"date":"2017-07-02T13:09:11.000Z","_content":"\n### WebGL是什么\n在浏览器绘制3D图形的的一门技术，是内嵌在浏览器中，目前支持高版本浏览器，因此不需要安装任何插件，同样也支持多平台运行，它是基于OpenGL ES 2.0技术。\n\n#### 优势\n\n* 快速传播\n* 维护简单\n* 跨平台性\n* 开放的标准\n* 硬件加速\n* 无需安装插件\n* 充分利用浏览器功能\n\n<!-- more -->\n\n#### 图形API模式\n\n即时模式，每一帧的场景不管是否发生了变化，都需要重新绘制，提供API的图形库并没有保存需要绘图场景的内部模型，但是应用程序需要在内存中用自己的方式表示场景，这种设计模式大大提高了应用程序的灵活性和控制的能力，但是需要应用程序执行更多的操作，如跟踪场景的模型，应用初始化等等，包括清除操作。webGL采用的是即时模式，非常灵活，但是相对而言手工代码会多一点。\n\n保留模式，它的API保留了所有图形库的模型和场景，但应用程序调用保留模式API时需要更新内部的模型，图形库决定在什么时候执行实际的绘制方法，这意味着不需要为每一帧场景重新绘制命令，因此保留模式API似乎更容易使用。\n\n### 图像硬件介绍\n\n<img width=\"600\" src=\"webgl-2017-07-02/01.jpeg\"/>\n\n### WebGL程序执行原理\n\n#### 图形流水线\n\n<img width=\"600\" src=\"webgl-2017-07-02/02.jpeg\"/>\n\n通过顶点来确定图形，具备形状之后内部时空的，通过光栅化进行“面积”的填充，然后进入片元着色器，进入“绘图”过程，类似上色过程，再次进逐片元操作\n\n#### 定点着色器\n\n* 顶点着色器源代码，javascript字符串形式表示出来\n* 内置变量，名字不可辨，区分大小写\n* 自定义 Attribute 变量，表示每一个点的数据，可以定义多个\n* 自定义 Uniform 变量，表示一个常量，是个恒定的，所有点的数据都是一样的\n* 自定义 Varying 变量，定点着色器和片着色器传导数据用的\n                                                                \n#### 片元着色器\n\n* 片元着色器源代码，javascript字符串形式表示出来\n* 内置变量，名字不可辨，区分大小写\n* Uniform 和 Samplers，Samplers用来储存纹理\n* 自定义 Varying 变量，定点着色器和片着色器传导数据用的\n\n### WebGL和HTML5及Javascript的关系\n\n* 需要 HTML5 Canvas 元素，webgl和canvas画图都需要canvas这个api\n* 用 Javascript 处理逻辑\n* 可利用支持 HTML5 浏览器的一切功能\n* 用 Javascript 字符串形式编写着色器源代码\n\n基本示例代码如下：\n{% codeblock lang:html %}\n<body onload=\"main()\">\n    <canvas id=\"webgl\" width=\"500\" height=\"400\"></canvas>\n    <script src=\"../lib/webgl-utils.js\"></script>\n    <script src=\"../lib/webgl-debug.js\"></script>\n    <script src=\"../lib/cuon-utils.js\"></script>\n\n    <script>\n        // 顶点着色器程序\n        const VSHADER_SOURCE =\n            `void main() {\n          gl_Position = vec4(1.0,0.0,0.0,1.0);\n          gl_PointSize = 30.0;\n        }`\n        \n        // 片元着色器程序\n        const FSHADER_SOURCE =\n            `void main() {\n          gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n          }`\n\n        function main() {\n            // 获取canvan元素\n            var canvas = document.getElementById(\"webgl\");\n\n            // 获取webgl绘图上下文\n            var gl = getWebGLContext(canvas, true);\n            if (!gl) {\n                console.log('error');\n                return;\n            }\n\n            // 初始化着色器\n            if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {\n                console.log('error');\n                return;\n            }\n\n\n            // 制定清空canvas的颜色\n            gl.clearColor(0.0, 0.0, 0.0, 1.0);\n            // 清空canvas\n            gl.clear(gl.COLOR_BUFFER_BIT);\n\n            // 绘制一个点\n            gl.drawArrays(gl.POINTS, 0, 1);\n        }\n    </script>\n</body>\n{% endcodeblock %}\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/02","source":"_posts/webgl-2017-07-02.md","raw":"---\ntitle: WebGL系列教程--基本概述\ncomments: true\ntoc: true\ndate: 2017-07-02 21:09:11\ntags: \n    - 'javascript'\n    - 'webgl'\n---\n\n### WebGL是什么\n在浏览器绘制3D图形的的一门技术，是内嵌在浏览器中，目前支持高版本浏览器，因此不需要安装任何插件，同样也支持多平台运行，它是基于OpenGL ES 2.0技术。\n\n#### 优势\n\n* 快速传播\n* 维护简单\n* 跨平台性\n* 开放的标准\n* 硬件加速\n* 无需安装插件\n* 充分利用浏览器功能\n\n<!-- more -->\n\n#### 图形API模式\n\n即时模式，每一帧的场景不管是否发生了变化，都需要重新绘制，提供API的图形库并没有保存需要绘图场景的内部模型，但是应用程序需要在内存中用自己的方式表示场景，这种设计模式大大提高了应用程序的灵活性和控制的能力，但是需要应用程序执行更多的操作，如跟踪场景的模型，应用初始化等等，包括清除操作。webGL采用的是即时模式，非常灵活，但是相对而言手工代码会多一点。\n\n保留模式，它的API保留了所有图形库的模型和场景，但应用程序调用保留模式API时需要更新内部的模型，图形库决定在什么时候执行实际的绘制方法，这意味着不需要为每一帧场景重新绘制命令，因此保留模式API似乎更容易使用。\n\n### 图像硬件介绍\n\n<img width=\"600\" src=\"webgl-2017-07-02/01.jpeg\"/>\n\n### WebGL程序执行原理\n\n#### 图形流水线\n\n<img width=\"600\" src=\"webgl-2017-07-02/02.jpeg\"/>\n\n通过顶点来确定图形，具备形状之后内部时空的，通过光栅化进行“面积”的填充，然后进入片元着色器，进入“绘图”过程，类似上色过程，再次进逐片元操作\n\n#### 定点着色器\n\n* 顶点着色器源代码，javascript字符串形式表示出来\n* 内置变量，名字不可辨，区分大小写\n* 自定义 Attribute 变量，表示每一个点的数据，可以定义多个\n* 自定义 Uniform 变量，表示一个常量，是个恒定的，所有点的数据都是一样的\n* 自定义 Varying 变量，定点着色器和片着色器传导数据用的\n                                                                \n#### 片元着色器\n\n* 片元着色器源代码，javascript字符串形式表示出来\n* 内置变量，名字不可辨，区分大小写\n* Uniform 和 Samplers，Samplers用来储存纹理\n* 自定义 Varying 变量，定点着色器和片着色器传导数据用的\n\n### WebGL和HTML5及Javascript的关系\n\n* 需要 HTML5 Canvas 元素，webgl和canvas画图都需要canvas这个api\n* 用 Javascript 处理逻辑\n* 可利用支持 HTML5 浏览器的一切功能\n* 用 Javascript 字符串形式编写着色器源代码\n\n基本示例代码如下：\n{% codeblock lang:html %}\n<body onload=\"main()\">\n    <canvas id=\"webgl\" width=\"500\" height=\"400\"></canvas>\n    <script src=\"../lib/webgl-utils.js\"></script>\n    <script src=\"../lib/webgl-debug.js\"></script>\n    <script src=\"../lib/cuon-utils.js\"></script>\n\n    <script>\n        // 顶点着色器程序\n        const VSHADER_SOURCE =\n            `void main() {\n          gl_Position = vec4(1.0,0.0,0.0,1.0);\n          gl_PointSize = 30.0;\n        }`\n        \n        // 片元着色器程序\n        const FSHADER_SOURCE =\n            `void main() {\n          gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n          }`\n\n        function main() {\n            // 获取canvan元素\n            var canvas = document.getElementById(\"webgl\");\n\n            // 获取webgl绘图上下文\n            var gl = getWebGLContext(canvas, true);\n            if (!gl) {\n                console.log('error');\n                return;\n            }\n\n            // 初始化着色器\n            if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {\n                console.log('error');\n                return;\n            }\n\n\n            // 制定清空canvas的颜色\n            gl.clearColor(0.0, 0.0, 0.0, 1.0);\n            // 清空canvas\n            gl.clear(gl.COLOR_BUFFER_BIT);\n\n            // 绘制一个点\n            gl.drawArrays(gl.POINTS, 0, 1);\n        }\n    </script>\n</body>\n{% endcodeblock %}\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/02","slug":"webgl-2017-07-02","published":1,"updated":"2017-09-04T04:33:36.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36rs000qlmldb2s9xha9","content":"<h3 id=\"WebGL是什么\"><a href=\"#WebGL是什么\" class=\"headerlink\" title=\"WebGL是什么\"></a>WebGL是什么</h3><p>在浏览器绘制3D图形的的一门技术，是内嵌在浏览器中，目前支持高版本浏览器，因此不需要安装任何插件，同样也支持多平台运行，它是基于OpenGL ES 2.0技术。</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>快速传播</li>\n<li>维护简单</li>\n<li>跨平台性</li>\n<li>开放的标准</li>\n<li>硬件加速</li>\n<li>无需安装插件</li>\n<li>充分利用浏览器功能</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"图形API模式\"><a href=\"#图形API模式\" class=\"headerlink\" title=\"图形API模式\"></a>图形API模式</h4><p>即时模式，每一帧的场景不管是否发生了变化，都需要重新绘制，提供API的图形库并没有保存需要绘图场景的内部模型，但是应用程序需要在内存中用自己的方式表示场景，这种设计模式大大提高了应用程序的灵活性和控制的能力，但是需要应用程序执行更多的操作，如跟踪场景的模型，应用初始化等等，包括清除操作。webGL采用的是即时模式，非常灵活，但是相对而言手工代码会多一点。</p>\n<p>保留模式，它的API保留了所有图形库的模型和场景，但应用程序调用保留模式API时需要更新内部的模型，图形库决定在什么时候执行实际的绘制方法，这意味着不需要为每一帧场景重新绘制命令，因此保留模式API似乎更容易使用。</p>\n<h3 id=\"图像硬件介绍\"><a href=\"#图像硬件介绍\" class=\"headerlink\" title=\"图像硬件介绍\"></a>图像硬件介绍</h3><p><img width=\"600\" src=\"/webgl-2017-07-02/01.jpeg\"></p>\n<h3 id=\"WebGL程序执行原理\"><a href=\"#WebGL程序执行原理\" class=\"headerlink\" title=\"WebGL程序执行原理\"></a>WebGL程序执行原理</h3><h4 id=\"图形流水线\"><a href=\"#图形流水线\" class=\"headerlink\" title=\"图形流水线\"></a>图形流水线</h4><p><img width=\"600\" src=\"/webgl-2017-07-02/02.jpeg\"></p>\n<p>通过顶点来确定图形，具备形状之后内部时空的，通过光栅化进行“面积”的填充，然后进入片元着色器，进入“绘图”过程，类似上色过程，再次进逐片元操作</p>\n<h4 id=\"定点着色器\"><a href=\"#定点着色器\" class=\"headerlink\" title=\"定点着色器\"></a>定点着色器</h4><ul>\n<li>顶点着色器源代码，javascript字符串形式表示出来</li>\n<li>内置变量，名字不可辨，区分大小写</li>\n<li>自定义 Attribute 变量，表示每一个点的数据，可以定义多个</li>\n<li>自定义 Uniform 变量，表示一个常量，是个恒定的，所有点的数据都是一样的</li>\n<li>自定义 Varying 变量，定点着色器和片着色器传导数据用的</li>\n</ul>\n<h4 id=\"片元着色器\"><a href=\"#片元着色器\" class=\"headerlink\" title=\"片元着色器\"></a>片元着色器</h4><ul>\n<li>片元着色器源代码，javascript字符串形式表示出来</li>\n<li>内置变量，名字不可辨，区分大小写</li>\n<li>Uniform 和 Samplers，Samplers用来储存纹理</li>\n<li>自定义 Varying 变量，定点着色器和片着色器传导数据用的</li>\n</ul>\n<h3 id=\"WebGL和HTML5及Javascript的关系\"><a href=\"#WebGL和HTML5及Javascript的关系\" class=\"headerlink\" title=\"WebGL和HTML5及Javascript的关系\"></a>WebGL和HTML5及Javascript的关系</h3><ul>\n<li>需要 HTML5 Canvas 元素，webgl和canvas画图都需要canvas这个api</li>\n<li>用 Javascript 处理逻辑</li>\n<li>可利用支持 HTML5 浏览器的一切功能</li>\n<li>用 Javascript 字符串形式编写着色器源代码</li>\n</ul>\n<p>基本示例代码如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"main()\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"webgl\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"500\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"400\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../lib/webgl-utils.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../lib/webgl-debug.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../lib/cuon-utils.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 顶点着色器程序</span></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">const</span> VSHADER_SOURCE =</span></div><div class=\"line\"><span class=\"undefined\">            `void main() &#123;</span></div><div class=\"line\"><span class=\"undefined\">          gl_Position = vec4(1.0,0.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"undefined\">          gl_PointSize = 30.0;</span></div><div class=\"line\"><span class=\"undefined\">        &#125;`</span></div><div class=\"line\"><span class=\"undefined\">        </span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 片元着色器程序</span></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">const</span> FSHADER_SOURCE =</span></div><div class=\"line\"><span class=\"undefined\">            `void main() &#123;</span></div><div class=\"line\"><span class=\"undefined\">          gl_FragColor = vec4(1.0,1.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"undefined\">          &#125;`</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 获取canvan元素</span></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"webgl\"</span>);</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 获取webgl绘图上下文</span></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> gl = getWebGLContext(canvas, <span class=\"literal\">true</span>);</span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (!gl) &#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'error'</span>);</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">return</span>;</span></div><div class=\"line\"><span class=\"undefined\">            &#125;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 初始化着色器</span></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) &#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'error'</span>);</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">return</span>;</span></div><div class=\"line\"><span class=\"undefined\">            &#125;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 制定清空canvas的颜色</span></span></div><div class=\"line\"><span class=\"undefined\">            gl.clearColor(0.0, 0.0, 0.0, 1.0);</span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 清空canvas</span></span></div><div class=\"line\"><span class=\"undefined\">            gl.clear(gl.COLOR_BUFFER_BIT);</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 绘制一个点</span></span></div><div class=\"line\"><span class=\"undefined\">            gl.drawArrays(gl.POINTS, 0, 1);</span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/02\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/02</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"WebGL是什么\"><a href=\"#WebGL是什么\" class=\"headerlink\" title=\"WebGL是什么\"></a>WebGL是什么</h3><p>在浏览器绘制3D图形的的一门技术，是内嵌在浏览器中，目前支持高版本浏览器，因此不需要安装任何插件，同样也支持多平台运行，它是基于OpenGL ES 2.0技术。</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>快速传播</li>\n<li>维护简单</li>\n<li>跨平台性</li>\n<li>开放的标准</li>\n<li>硬件加速</li>\n<li>无需安装插件</li>\n<li>充分利用浏览器功能</li>\n</ul>","more":"<h4 id=\"图形API模式\"><a href=\"#图形API模式\" class=\"headerlink\" title=\"图形API模式\"></a>图形API模式</h4><p>即时模式，每一帧的场景不管是否发生了变化，都需要重新绘制，提供API的图形库并没有保存需要绘图场景的内部模型，但是应用程序需要在内存中用自己的方式表示场景，这种设计模式大大提高了应用程序的灵活性和控制的能力，但是需要应用程序执行更多的操作，如跟踪场景的模型，应用初始化等等，包括清除操作。webGL采用的是即时模式，非常灵活，但是相对而言手工代码会多一点。</p>\n<p>保留模式，它的API保留了所有图形库的模型和场景，但应用程序调用保留模式API时需要更新内部的模型，图形库决定在什么时候执行实际的绘制方法，这意味着不需要为每一帧场景重新绘制命令，因此保留模式API似乎更容易使用。</p>\n<h3 id=\"图像硬件介绍\"><a href=\"#图像硬件介绍\" class=\"headerlink\" title=\"图像硬件介绍\"></a>图像硬件介绍</h3><p><img width=\"600\" src=\"/webgl-2017-07-02/01.jpeg\"></p>\n<h3 id=\"WebGL程序执行原理\"><a href=\"#WebGL程序执行原理\" class=\"headerlink\" title=\"WebGL程序执行原理\"></a>WebGL程序执行原理</h3><h4 id=\"图形流水线\"><a href=\"#图形流水线\" class=\"headerlink\" title=\"图形流水线\"></a>图形流水线</h4><p><img width=\"600\" src=\"/webgl-2017-07-02/02.jpeg\"></p>\n<p>通过顶点来确定图形，具备形状之后内部时空的，通过光栅化进行“面积”的填充，然后进入片元着色器，进入“绘图”过程，类似上色过程，再次进逐片元操作</p>\n<h4 id=\"定点着色器\"><a href=\"#定点着色器\" class=\"headerlink\" title=\"定点着色器\"></a>定点着色器</h4><ul>\n<li>顶点着色器源代码，javascript字符串形式表示出来</li>\n<li>内置变量，名字不可辨，区分大小写</li>\n<li>自定义 Attribute 变量，表示每一个点的数据，可以定义多个</li>\n<li>自定义 Uniform 变量，表示一个常量，是个恒定的，所有点的数据都是一样的</li>\n<li>自定义 Varying 变量，定点着色器和片着色器传导数据用的</li>\n</ul>\n<h4 id=\"片元着色器\"><a href=\"#片元着色器\" class=\"headerlink\" title=\"片元着色器\"></a>片元着色器</h4><ul>\n<li>片元着色器源代码，javascript字符串形式表示出来</li>\n<li>内置变量，名字不可辨，区分大小写</li>\n<li>Uniform 和 Samplers，Samplers用来储存纹理</li>\n<li>自定义 Varying 变量，定点着色器和片着色器传导数据用的</li>\n</ul>\n<h3 id=\"WebGL和HTML5及Javascript的关系\"><a href=\"#WebGL和HTML5及Javascript的关系\" class=\"headerlink\" title=\"WebGL和HTML5及Javascript的关系\"></a>WebGL和HTML5及Javascript的关系</h3><ul>\n<li>需要 HTML5 Canvas 元素，webgl和canvas画图都需要canvas这个api</li>\n<li>用 Javascript 处理逻辑</li>\n<li>可利用支持 HTML5 浏览器的一切功能</li>\n<li>用 Javascript 字符串形式编写着色器源代码</li>\n</ul>\n<p>基本示例代码如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"main()\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"webgl\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"500\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"400\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../lib/webgl-utils.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../lib/webgl-debug.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../lib/cuon-utils.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 顶点着色器程序</span></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">const</span> VSHADER_SOURCE =</span></div><div class=\"line\"><span class=\"undefined\">            `void main() &#123;</span></div><div class=\"line\"><span class=\"undefined\">          gl_Position = vec4(1.0,0.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"undefined\">          gl_PointSize = 30.0;</span></div><div class=\"line\"><span class=\"undefined\">        &#125;`</span></div><div class=\"line\"><span class=\"undefined\">        </span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 片元着色器程序</span></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">const</span> FSHADER_SOURCE =</span></div><div class=\"line\"><span class=\"undefined\">            `void main() &#123;</span></div><div class=\"line\"><span class=\"undefined\">          gl_FragColor = vec4(1.0,1.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"undefined\">          &#125;`</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 获取canvan元素</span></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"webgl\"</span>);</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 获取webgl绘图上下文</span></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> gl = getWebGLContext(canvas, <span class=\"literal\">true</span>);</span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (!gl) &#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'error'</span>);</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">return</span>;</span></div><div class=\"line\"><span class=\"undefined\">            &#125;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 初始化着色器</span></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) &#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'error'</span>);</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">return</span>;</span></div><div class=\"line\"><span class=\"undefined\">            &#125;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 制定清空canvas的颜色</span></span></div><div class=\"line\"><span class=\"undefined\">            gl.clearColor(0.0, 0.0, 0.0, 1.0);</span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 清空canvas</span></span></div><div class=\"line\"><span class=\"undefined\">            gl.clear(gl.COLOR_BUFFER_BIT);</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 绘制一个点</span></span></div><div class=\"line\"><span class=\"undefined\">            gl.drawArrays(gl.POINTS, 0, 1);</span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/02\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/02</a></p>"},{"title":"WebGL系列教程--缓冲区对象","comments":1,"toc":true,"date":"2017-07-03T13:09:11.000Z","_content":"\n### attribute 变量的使用\n\n主要职能是在顶点着色器当中使用的，只能被申明为全局变量，用来表示顶点的信息，比如一个图形中包含多个顶点，顶点着色器是针对逐顶点进行运算的，都会传导到attribute变量中，然而，两个顶点之间的部分是不会被传导到顶点着色器中的。\n\n这个变量只能支持矢量和矩阵两种类型，attribute变量的个数限制和设备有关系，最小支持8个attribute变量。\n\n<img width=\"600\" src=\"webgl-2017-07-03/01.jpeg\"/>\n\n* 在顶点着色器中，声明 attribute 变量\n* 将 attribute 变量赋值给 gl_Position 变量\n* 向 attribute 变量传递数据\n\n<!-- more -->\n\n首先创建顶点着色器的基本代码：\n\n{% codeblock lang:javascript %}\n// 顶点着色器程序\nconst vertexShaderSource =\n    `attribute vec4 apos;\n    void main() {\n  gl_Position = apos;\n  gl_PointSize = 10.0;\n}`\n{% endcodeblock %}\n\n书写基本的片元着色器的代码：\n{% codeblock lang:javascript %}\n// 片元着色器程序\nconst fragmentShaderSource =\n    `void main() {\n  gl_FragColor = vec4(1.0,0.5,0.0,1.0);\n  }`\n{% endcodeblock %}\n\n获取webgl上下文代码：\n{% codeblock lang:javascript %}\nvar cxt = canvas.getContext('webgl');\n{% endcodeblock %}\n\n获得顶点着色器和片元着色器对象,并且把源代码写入到顶点着色器及片元着色器中去，然后进行编译，片段代码如下：\n{% codeblock lang:javascript %}\n    var vertexShader = cxt.createShader(cxt.VERTEX_SHADER);\n    var fragmentShader = cxt.createShader(cxt.FRAGMENT_SHADER);\n    cxt.shaderSource(vertexShader,vertexShaderSource);\n    cxt.shaderSource(fragmentShader,fragmentShaderSource);\n    cxt.compileShader(vertexShader);\n    cxt.compileShader(fragmentShader);\n{% endcodeblock %}\n\n创建program，并且将顶点着色器和片元着色器附着在program上，代码如下\n{% codeblock lang:javascript %}\n    var program = cxt.createProgram();\n    cxt.attachShader(program,vertexShader);\n    cxt.attachShader(program,fragmentShader);\n    cxt.linkProgram(program);\n    cxt.useProgram(program);\n{% endcodeblock %}\n\n得到顶点着色器中的变量apos，片段代码如下：\n{% codeblock lang:javascript %}\n    var aposLocation = cxt.getAttribLocation(program,'apos');\n{% endcodeblock %}\n\n清屏处理，代码如下：\n{% codeblock lang:javascript %}\n    cxt.clearColor(0.2,0.2,0.2,1.0);\n    cxt.clear(cxt.COLOR_BUFFER_BIT);\n{% endcodeblock %}\n\n通过for循环来绘制多个点，代码如下：\n{% codeblock lang:javascript %}\nfor(var i= 0,num = points.length;i<num;i++){\n    cxt.vertexAttrib4f(aposLocation,points[i].x,points[i].y,1.0,1.0);\n    cxt.drawArrays(cxt.POINTS,0,1);\n}\n{% endcodeblock %}\n\n### 缓冲区对象的创建、绑定、写入数据\n\n#### 缓冲区对象是什么\n\n* 绘制面所必需的技术\n* 一次性写入多个顶点数据\n* 一块内存区域   \n\n#### 创建缓冲区对象\n\n* 创建缓冲区的方法  var buffer = gl.createBuffer()\n* 根据返回值判断是否创建成功\n* 绑定缓冲区方法 gl.bindBuffer(gl.ARRAY_BUFFER , buffer)\n\n<img width=\"600\" src=\"webgl-2017-07-03/02.jpeg\"/>\n\n#### 写入数据\n* gl.bufferData(gl.ARRAY_BUFFER , data , gl.STATIC_DRAW)\n* data 是类型化数组\n* gl.STATIC_DRAW，一次写入多次绘制\n* gl.STREAM_DRAW，一次写入多次绘制，比第一次调用的少\n* gl.DYNAMIC_DRAW，多次写入多次绘制\n\n<img width=\"600\" src=\"webgl-2017-07-03/03.jpeg\"/>\n\n#### 类型化数组\n接口都是通过类型化数组来进行通信\n* Int8Array   Uint8Array   \n* Int16Array   Uint16Array\n* Int32Array   Uint32Array \n* Float32Array \n* Float64Array\n\n#### 缓冲区数据导入 attribute 变量\n* vertexAttribPointer(location , size , type , normalized , stride , offset ) \n* 错误信息  INVALID_OPERATION，表示没有可用的program对象\n* 错误信息  INVALID_VALUE，表示attribute的最大值已经超出的范围\n* enableVertexAttribArray(location)，激活localtion\n* 错误信息  INVALID_OPERATION，表示没有可用的program对象\n\n<img width=\"600\" src=\"webgl-2017-07-03/04.jpeg\"/>\n\n### 代码分析\n\n创建类型化数组对象\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n    -1.0,1.0,\n    1.0,1.0,\n    -1.0,-1.0,\n    1.0,-1.0,\n    0.0,0.0\n]);\n{% endcodeblock %}\n\n创建buffer和绑定baffer片段代码如下：\n{% codeblock lang:javascript %}\nvar buf = cxt.createBuffer();\ncxt.bindBuffer(cxt.ARRAY_BUFFER,buf);\n{% endcodeblock %}\n\n将类型化数组绑定到缓冲区中：\n{% codeblock lang:javascript %}\ncxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW);\n{% endcodeblock %}\n\n将缓冲区数据导入attribute变量中：\n{% codeblock lang:javascript %}\ncxt.vertexAttribPointer(aposLocation,2,cxt.FLOAT,false,0,0);\ncxt.enableVertexAttribArray(aposLocation);\n{% endcodeblock %}\n\n开始绘制，代码如下：\n{% codeblock lang:javascript %}\ncxt.clearColor(0.0,0.5,0.5,1.0);\ncxt.clear(cxt.COLOR_BUFFER_BIT);\ncxt.drawArrays(cxt.POINTS,0,5);\n{% endcodeblock %}\n\n完整代码如下：\n{% codeblock lang:html %}\n<canvas id=\"e03\" width=\"500\" height=\"500\"></canvas>\n<script src=\"../lib.js\"></script>\n<script>\n    var canvas = document.getElementById('e03');\n    var cxt = canvas.getContext('webgl');\n    // 顶点着色器程序\n    const vertexShaderSource =\n        `attribute vec4 apos;\n        void main() {\n    gl_Position = apos;\n    gl_PointSize = 10.0;\n    }`\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `void main() {\n    gl_FragColor = vec4(1.0,0.5,0.0,1.0);\n    }`\n    var program  = initShader(cxt,vertexShaderSource,fragmentShaderSource);\n    var aposLocation = cxt.getAttribLocation(program,'apos');\n    var buffer = cxt.createBuffer();\n    cxt.bindBuffer(cxt.ARRAY_BUFFER,buffer);\n    var data = new Float32Array([\n            -1.0,1.0,\n            1.0,1.0,\n            -1.0,-1.0,\n            1.0,-1.0,\n            0.0,0.0\n    ]);\n    cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW);\n    cxt.vertexAttribPointer(aposLocation,2,cxt.FLOAT,false,0,0);\n    cxt.enableVertexAttribArray(aposLocation);\n    cxt.clearColor(0.0,0.5,0.5,1.0);\n    cxt.clear(cxt.COLOR_BUFFER_BIT);\n    cxt.drawArrays(cxt.POINTS,0,5);\n</script>\n{% endcodeblock %}\n\n运行效果图如下：\n\n<img width=\"600\" src=\"webgl-2017-07-03/05.jpeg\"/>\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/03\n\n","source":"_posts/webgl-2017-07-03.md","raw":"---\ntitle: WebGL系列教程--缓冲区对象\ncomments: true\ntoc: true\ndate: 2017-07-03 21:09:11\ntags: \n    - 'javascript'\n    - 'webgl'\n---\n\n### attribute 变量的使用\n\n主要职能是在顶点着色器当中使用的，只能被申明为全局变量，用来表示顶点的信息，比如一个图形中包含多个顶点，顶点着色器是针对逐顶点进行运算的，都会传导到attribute变量中，然而，两个顶点之间的部分是不会被传导到顶点着色器中的。\n\n这个变量只能支持矢量和矩阵两种类型，attribute变量的个数限制和设备有关系，最小支持8个attribute变量。\n\n<img width=\"600\" src=\"webgl-2017-07-03/01.jpeg\"/>\n\n* 在顶点着色器中，声明 attribute 变量\n* 将 attribute 变量赋值给 gl_Position 变量\n* 向 attribute 变量传递数据\n\n<!-- more -->\n\n首先创建顶点着色器的基本代码：\n\n{% codeblock lang:javascript %}\n// 顶点着色器程序\nconst vertexShaderSource =\n    `attribute vec4 apos;\n    void main() {\n  gl_Position = apos;\n  gl_PointSize = 10.0;\n}`\n{% endcodeblock %}\n\n书写基本的片元着色器的代码：\n{% codeblock lang:javascript %}\n// 片元着色器程序\nconst fragmentShaderSource =\n    `void main() {\n  gl_FragColor = vec4(1.0,0.5,0.0,1.0);\n  }`\n{% endcodeblock %}\n\n获取webgl上下文代码：\n{% codeblock lang:javascript %}\nvar cxt = canvas.getContext('webgl');\n{% endcodeblock %}\n\n获得顶点着色器和片元着色器对象,并且把源代码写入到顶点着色器及片元着色器中去，然后进行编译，片段代码如下：\n{% codeblock lang:javascript %}\n    var vertexShader = cxt.createShader(cxt.VERTEX_SHADER);\n    var fragmentShader = cxt.createShader(cxt.FRAGMENT_SHADER);\n    cxt.shaderSource(vertexShader,vertexShaderSource);\n    cxt.shaderSource(fragmentShader,fragmentShaderSource);\n    cxt.compileShader(vertexShader);\n    cxt.compileShader(fragmentShader);\n{% endcodeblock %}\n\n创建program，并且将顶点着色器和片元着色器附着在program上，代码如下\n{% codeblock lang:javascript %}\n    var program = cxt.createProgram();\n    cxt.attachShader(program,vertexShader);\n    cxt.attachShader(program,fragmentShader);\n    cxt.linkProgram(program);\n    cxt.useProgram(program);\n{% endcodeblock %}\n\n得到顶点着色器中的变量apos，片段代码如下：\n{% codeblock lang:javascript %}\n    var aposLocation = cxt.getAttribLocation(program,'apos');\n{% endcodeblock %}\n\n清屏处理，代码如下：\n{% codeblock lang:javascript %}\n    cxt.clearColor(0.2,0.2,0.2,1.0);\n    cxt.clear(cxt.COLOR_BUFFER_BIT);\n{% endcodeblock %}\n\n通过for循环来绘制多个点，代码如下：\n{% codeblock lang:javascript %}\nfor(var i= 0,num = points.length;i<num;i++){\n    cxt.vertexAttrib4f(aposLocation,points[i].x,points[i].y,1.0,1.0);\n    cxt.drawArrays(cxt.POINTS,0,1);\n}\n{% endcodeblock %}\n\n### 缓冲区对象的创建、绑定、写入数据\n\n#### 缓冲区对象是什么\n\n* 绘制面所必需的技术\n* 一次性写入多个顶点数据\n* 一块内存区域   \n\n#### 创建缓冲区对象\n\n* 创建缓冲区的方法  var buffer = gl.createBuffer()\n* 根据返回值判断是否创建成功\n* 绑定缓冲区方法 gl.bindBuffer(gl.ARRAY_BUFFER , buffer)\n\n<img width=\"600\" src=\"webgl-2017-07-03/02.jpeg\"/>\n\n#### 写入数据\n* gl.bufferData(gl.ARRAY_BUFFER , data , gl.STATIC_DRAW)\n* data 是类型化数组\n* gl.STATIC_DRAW，一次写入多次绘制\n* gl.STREAM_DRAW，一次写入多次绘制，比第一次调用的少\n* gl.DYNAMIC_DRAW，多次写入多次绘制\n\n<img width=\"600\" src=\"webgl-2017-07-03/03.jpeg\"/>\n\n#### 类型化数组\n接口都是通过类型化数组来进行通信\n* Int8Array   Uint8Array   \n* Int16Array   Uint16Array\n* Int32Array   Uint32Array \n* Float32Array \n* Float64Array\n\n#### 缓冲区数据导入 attribute 变量\n* vertexAttribPointer(location , size , type , normalized , stride , offset ) \n* 错误信息  INVALID_OPERATION，表示没有可用的program对象\n* 错误信息  INVALID_VALUE，表示attribute的最大值已经超出的范围\n* enableVertexAttribArray(location)，激活localtion\n* 错误信息  INVALID_OPERATION，表示没有可用的program对象\n\n<img width=\"600\" src=\"webgl-2017-07-03/04.jpeg\"/>\n\n### 代码分析\n\n创建类型化数组对象\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n    -1.0,1.0,\n    1.0,1.0,\n    -1.0,-1.0,\n    1.0,-1.0,\n    0.0,0.0\n]);\n{% endcodeblock %}\n\n创建buffer和绑定baffer片段代码如下：\n{% codeblock lang:javascript %}\nvar buf = cxt.createBuffer();\ncxt.bindBuffer(cxt.ARRAY_BUFFER,buf);\n{% endcodeblock %}\n\n将类型化数组绑定到缓冲区中：\n{% codeblock lang:javascript %}\ncxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW);\n{% endcodeblock %}\n\n将缓冲区数据导入attribute变量中：\n{% codeblock lang:javascript %}\ncxt.vertexAttribPointer(aposLocation,2,cxt.FLOAT,false,0,0);\ncxt.enableVertexAttribArray(aposLocation);\n{% endcodeblock %}\n\n开始绘制，代码如下：\n{% codeblock lang:javascript %}\ncxt.clearColor(0.0,0.5,0.5,1.0);\ncxt.clear(cxt.COLOR_BUFFER_BIT);\ncxt.drawArrays(cxt.POINTS,0,5);\n{% endcodeblock %}\n\n完整代码如下：\n{% codeblock lang:html %}\n<canvas id=\"e03\" width=\"500\" height=\"500\"></canvas>\n<script src=\"../lib.js\"></script>\n<script>\n    var canvas = document.getElementById('e03');\n    var cxt = canvas.getContext('webgl');\n    // 顶点着色器程序\n    const vertexShaderSource =\n        `attribute vec4 apos;\n        void main() {\n    gl_Position = apos;\n    gl_PointSize = 10.0;\n    }`\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `void main() {\n    gl_FragColor = vec4(1.0,0.5,0.0,1.0);\n    }`\n    var program  = initShader(cxt,vertexShaderSource,fragmentShaderSource);\n    var aposLocation = cxt.getAttribLocation(program,'apos');\n    var buffer = cxt.createBuffer();\n    cxt.bindBuffer(cxt.ARRAY_BUFFER,buffer);\n    var data = new Float32Array([\n            -1.0,1.0,\n            1.0,1.0,\n            -1.0,-1.0,\n            1.0,-1.0,\n            0.0,0.0\n    ]);\n    cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW);\n    cxt.vertexAttribPointer(aposLocation,2,cxt.FLOAT,false,0,0);\n    cxt.enableVertexAttribArray(aposLocation);\n    cxt.clearColor(0.0,0.5,0.5,1.0);\n    cxt.clear(cxt.COLOR_BUFFER_BIT);\n    cxt.drawArrays(cxt.POINTS,0,5);\n</script>\n{% endcodeblock %}\n\n运行效果图如下：\n\n<img width=\"600\" src=\"webgl-2017-07-03/05.jpeg\"/>\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/03\n\n","slug":"webgl-2017-07-03","published":1,"updated":"2017-09-04T04:33:25.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36ru000tlmldbscwdhb8","content":"<h3 id=\"attribute-变量的使用\"><a href=\"#attribute-变量的使用\" class=\"headerlink\" title=\"attribute 变量的使用\"></a>attribute 变量的使用</h3><p>主要职能是在顶点着色器当中使用的，只能被申明为全局变量，用来表示顶点的信息，比如一个图形中包含多个顶点，顶点着色器是针对逐顶点进行运算的，都会传导到attribute变量中，然而，两个顶点之间的部分是不会被传导到顶点着色器中的。</p>\n<p>这个变量只能支持矢量和矩阵两种类型，attribute变量的个数限制和设备有关系，最小支持8个attribute变量。</p>\n<p><img width=\"600\" src=\"/webgl-2017-07-03/01.jpeg\"></p>\n<ul>\n<li>在顶点着色器中，声明 attribute 变量</li>\n<li>将 attribute 变量赋值给 gl_Position 变量</li>\n<li>向 attribute 变量传递数据</li>\n</ul>\n<a id=\"more\"></a>\n<p>首先创建顶点着色器的基本代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\"><span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">    <span class=\"string\">`attribute vec4 apos;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">  gl_Position = apos;</span></div><div class=\"line\"><span class=\"string\">  gl_PointSize = 10.0;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure>\n<p>书写基本的片元着色器的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\"><span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">    <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">  gl_FragColor = vec4(1.0,0.5,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>获取webgl上下文代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cxt = canvas.getContext(<span class=\"string\">'webgl'</span>);</div></pre></td></tr></table></figure></p>\n<p>获得顶点着色器和片元着色器对象,并且把源代码写入到顶点着色器及片元着色器中去，然后进行编译，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vertexShader = cxt.createShader(cxt.VERTEX_SHADER);</div><div class=\"line\"><span class=\"keyword\">var</span> fragmentShader = cxt.createShader(cxt.FRAGMENT_SHADER);</div><div class=\"line\">cxt.shaderSource(vertexShader,vertexShaderSource);</div><div class=\"line\">cxt.shaderSource(fragmentShader,fragmentShaderSource);</div><div class=\"line\">cxt.compileShader(vertexShader);</div><div class=\"line\">cxt.compileShader(fragmentShader);</div></pre></td></tr></table></figure></p>\n<p>创建program，并且将顶点着色器和片元着色器附着在program上，代码如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> program = cxt.createProgram();</div><div class=\"line\">cxt.attachShader(program,vertexShader);</div><div class=\"line\">cxt.attachShader(program,fragmentShader);</div><div class=\"line\">cxt.linkProgram(program);</div><div class=\"line\">cxt.useProgram(program);</div></pre></td></tr></table></figure></p>\n<p>得到顶点着色器中的变量apos，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aposLocation = cxt.getAttribLocation(program,<span class=\"string\">'apos'</span>);</div></pre></td></tr></table></figure></p>\n<p>清屏处理，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.clearColor(<span class=\"number\">0.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">cxt.clear(cxt.COLOR_BUFFER_BIT);</div></pre></td></tr></table></figure></p>\n<p>通过for循环来绘制多个点，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i= <span class=\"number\">0</span>,num = points.length;i&lt;num;i++)&#123;</div><div class=\"line\">    cxt.vertexAttrib4f(aposLocation,points[i].x,points[i].y,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">    cxt.drawArrays(cxt.POINTS,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"缓冲区对象的创建、绑定、写入数据\"><a href=\"#缓冲区对象的创建、绑定、写入数据\" class=\"headerlink\" title=\"缓冲区对象的创建、绑定、写入数据\"></a>缓冲区对象的创建、绑定、写入数据</h3><h4 id=\"缓冲区对象是什么\"><a href=\"#缓冲区对象是什么\" class=\"headerlink\" title=\"缓冲区对象是什么\"></a>缓冲区对象是什么</h4><ul>\n<li>绘制面所必需的技术</li>\n<li>一次性写入多个顶点数据</li>\n<li>一块内存区域   </li>\n</ul>\n<h4 id=\"创建缓冲区对象\"><a href=\"#创建缓冲区对象\" class=\"headerlink\" title=\"创建缓冲区对象\"></a>创建缓冲区对象</h4><ul>\n<li>创建缓冲区的方法  var buffer = gl.createBuffer()</li>\n<li>根据返回值判断是否创建成功</li>\n<li>绑定缓冲区方法 gl.bindBuffer(gl.ARRAY_BUFFER , buffer)</li>\n</ul>\n<p><img width=\"600\" src=\"/webgl-2017-07-03/02.jpeg\"></p>\n<h4 id=\"写入数据\"><a href=\"#写入数据\" class=\"headerlink\" title=\"写入数据\"></a>写入数据</h4><ul>\n<li>gl.bufferData(gl.ARRAY_BUFFER , data , gl.STATIC_DRAW)</li>\n<li>data 是类型化数组</li>\n<li>gl.STATIC_DRAW，一次写入多次绘制</li>\n<li>gl.STREAM_DRAW，一次写入多次绘制，比第一次调用的少</li>\n<li>gl.DYNAMIC_DRAW，多次写入多次绘制</li>\n</ul>\n<p><img width=\"600\" src=\"/webgl-2017-07-03/03.jpeg\"></p>\n<h4 id=\"类型化数组\"><a href=\"#类型化数组\" class=\"headerlink\" title=\"类型化数组\"></a>类型化数组</h4><p>接口都是通过类型化数组来进行通信</p>\n<ul>\n<li>Int8Array   Uint8Array   </li>\n<li>Int16Array   Uint16Array</li>\n<li>Int32Array   Uint32Array </li>\n<li>Float32Array </li>\n<li>Float64Array</li>\n</ul>\n<h4 id=\"缓冲区数据导入-attribute-变量\"><a href=\"#缓冲区数据导入-attribute-变量\" class=\"headerlink\" title=\"缓冲区数据导入 attribute 变量\"></a>缓冲区数据导入 attribute 变量</h4><ul>\n<li>vertexAttribPointer(location , size , type , normalized , stride , offset ) </li>\n<li>错误信息  INVALID_OPERATION，表示没有可用的program对象</li>\n<li>错误信息  INVALID_VALUE，表示attribute的最大值已经超出的范围</li>\n<li>enableVertexAttribArray(location)，激活localtion</li>\n<li>错误信息  INVALID_OPERATION，表示没有可用的program对象</li>\n</ul>\n<p><img width=\"600\" src=\"/webgl-2017-07-03/04.jpeg\"></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>创建类型化数组对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">-1.0</span>,<span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">-1.0</span>,<span class=\"number\">-1.0</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>,<span class=\"number\">-1.0</span>,</div><div class=\"line\">    <span class=\"number\">0.0</span>,<span class=\"number\">0.0</span></div><div class=\"line\">]);</div></pre></td></tr></table></figure></p>\n<p>创建buffer和绑定baffer片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> buf = cxt.createBuffer();</div><div class=\"line\">cxt.bindBuffer(cxt.ARRAY_BUFFER,buf);</div></pre></td></tr></table></figure></p>\n<p>将类型化数组绑定到缓冲区中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW);</div></pre></td></tr></table></figure></p>\n<p>将缓冲区数据导入attribute变量中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.vertexAttribPointer(aposLocation,<span class=\"number\">2</span>,cxt.FLOAT,<span class=\"literal\">false</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</div><div class=\"line\">cxt.enableVertexAttribArray(aposLocation);</div></pre></td></tr></table></figure></p>\n<p>开始绘制，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.clearColor(<span class=\"number\">0.0</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.5</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\">cxt.drawArrays(cxt.POINTS,<span class=\"number\">0</span>,<span class=\"number\">5</span>);</div></pre></td></tr></table></figure></p>\n<p>完整代码如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"e03\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"500\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../lib.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'e03'</span>);</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> cxt = canvas.getContext(<span class=\"string\">'webgl'</span>);</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 顶点着色器程序</span></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">const</span> vertexShaderSource =</span></div><div class=\"line\"><span class=\"undefined\">        `attribute vec4 apos;</span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">void</span> main() &#123;</span></div><div class=\"line\"><span class=\"undefined\">    gl_Position = apos;</span></div><div class=\"line\"><span class=\"undefined\">    gl_PointSize = 10.0;</span></div><div class=\"line\"><span class=\"undefined\">    &#125;`</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 片元着色器程序</span></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">const</span> fragmentShaderSource =</span></div><div class=\"line\"><span class=\"undefined\">        `void main() &#123;</span></div><div class=\"line\"><span class=\"undefined\">    gl_FragColor = vec4(1.0,0.5,0.0,1.0);</span></div><div class=\"line\"><span class=\"undefined\">    &#125;`</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> program  = initShader(cxt,vertexShaderSource,fragmentShaderSource);</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> aposLocation = cxt.getAttribLocation(program,<span class=\"string\">'apos'</span>);</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> buffer = cxt.createBuffer();</span></div><div class=\"line\"><span class=\"undefined\">    cxt.bindBuffer(cxt.ARRAY_BUFFER,buffer);</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</span></div><div class=\"line\"><span class=\"undefined\">            -1.0,1.0,</span></div><div class=\"line\"><span class=\"undefined\">            1.0,1.0,</span></div><div class=\"line\"><span class=\"undefined\">            -1.0,-1.0,</span></div><div class=\"line\"><span class=\"undefined\">            1.0,-1.0,</span></div><div class=\"line\"><span class=\"undefined\">            0.0,0.0</span></div><div class=\"line\"><span class=\"undefined\">    ]);</span></div><div class=\"line\"><span class=\"undefined\">    cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW);</span></div><div class=\"line\"><span class=\"javascript\">    cxt.vertexAttribPointer(aposLocation,<span class=\"number\">2</span>,cxt.FLOAT,<span class=\"literal\">false</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span></div><div class=\"line\"><span class=\"undefined\">    cxt.enableVertexAttribArray(aposLocation);</span></div><div class=\"line\"><span class=\"undefined\">    cxt.clearColor(0.0,0.5,0.5,1.0);</span></div><div class=\"line\"><span class=\"undefined\">    cxt.clear(cxt.COLOR_BUFFER_BIT);</span></div><div class=\"line\"><span class=\"undefined\">    cxt.drawArrays(cxt.POINTS,0,5);</span></div><div class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>运行效果图如下：</p>\n<p><img width=\"600\" src=\"/webgl-2017-07-03/05.jpeg\"></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/03\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/03</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"attribute-变量的使用\"><a href=\"#attribute-变量的使用\" class=\"headerlink\" title=\"attribute 变量的使用\"></a>attribute 变量的使用</h3><p>主要职能是在顶点着色器当中使用的，只能被申明为全局变量，用来表示顶点的信息，比如一个图形中包含多个顶点，顶点着色器是针对逐顶点进行运算的，都会传导到attribute变量中，然而，两个顶点之间的部分是不会被传导到顶点着色器中的。</p>\n<p>这个变量只能支持矢量和矩阵两种类型，attribute变量的个数限制和设备有关系，最小支持8个attribute变量。</p>\n<p><img width=\"600\" src=\"/webgl-2017-07-03/01.jpeg\"></p>\n<ul>\n<li>在顶点着色器中，声明 attribute 变量</li>\n<li>将 attribute 变量赋值给 gl_Position 变量</li>\n<li>向 attribute 变量传递数据</li>\n</ul>","more":"<p>首先创建顶点着色器的基本代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\"><span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">    <span class=\"string\">`attribute vec4 apos;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">  gl_Position = apos;</span></div><div class=\"line\"><span class=\"string\">  gl_PointSize = 10.0;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure>\n<p>书写基本的片元着色器的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\"><span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">    <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">  gl_FragColor = vec4(1.0,0.5,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>获取webgl上下文代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cxt = canvas.getContext(<span class=\"string\">'webgl'</span>);</div></pre></td></tr></table></figure></p>\n<p>获得顶点着色器和片元着色器对象,并且把源代码写入到顶点着色器及片元着色器中去，然后进行编译，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vertexShader = cxt.createShader(cxt.VERTEX_SHADER);</div><div class=\"line\"><span class=\"keyword\">var</span> fragmentShader = cxt.createShader(cxt.FRAGMENT_SHADER);</div><div class=\"line\">cxt.shaderSource(vertexShader,vertexShaderSource);</div><div class=\"line\">cxt.shaderSource(fragmentShader,fragmentShaderSource);</div><div class=\"line\">cxt.compileShader(vertexShader);</div><div class=\"line\">cxt.compileShader(fragmentShader);</div></pre></td></tr></table></figure></p>\n<p>创建program，并且将顶点着色器和片元着色器附着在program上，代码如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> program = cxt.createProgram();</div><div class=\"line\">cxt.attachShader(program,vertexShader);</div><div class=\"line\">cxt.attachShader(program,fragmentShader);</div><div class=\"line\">cxt.linkProgram(program);</div><div class=\"line\">cxt.useProgram(program);</div></pre></td></tr></table></figure></p>\n<p>得到顶点着色器中的变量apos，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aposLocation = cxt.getAttribLocation(program,<span class=\"string\">'apos'</span>);</div></pre></td></tr></table></figure></p>\n<p>清屏处理，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.clearColor(<span class=\"number\">0.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">cxt.clear(cxt.COLOR_BUFFER_BIT);</div></pre></td></tr></table></figure></p>\n<p>通过for循环来绘制多个点，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i= <span class=\"number\">0</span>,num = points.length;i&lt;num;i++)&#123;</div><div class=\"line\">    cxt.vertexAttrib4f(aposLocation,points[i].x,points[i].y,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">    cxt.drawArrays(cxt.POINTS,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"缓冲区对象的创建、绑定、写入数据\"><a href=\"#缓冲区对象的创建、绑定、写入数据\" class=\"headerlink\" title=\"缓冲区对象的创建、绑定、写入数据\"></a>缓冲区对象的创建、绑定、写入数据</h3><h4 id=\"缓冲区对象是什么\"><a href=\"#缓冲区对象是什么\" class=\"headerlink\" title=\"缓冲区对象是什么\"></a>缓冲区对象是什么</h4><ul>\n<li>绘制面所必需的技术</li>\n<li>一次性写入多个顶点数据</li>\n<li>一块内存区域   </li>\n</ul>\n<h4 id=\"创建缓冲区对象\"><a href=\"#创建缓冲区对象\" class=\"headerlink\" title=\"创建缓冲区对象\"></a>创建缓冲区对象</h4><ul>\n<li>创建缓冲区的方法  var buffer = gl.createBuffer()</li>\n<li>根据返回值判断是否创建成功</li>\n<li>绑定缓冲区方法 gl.bindBuffer(gl.ARRAY_BUFFER , buffer)</li>\n</ul>\n<p><img width=\"600\" src=\"/webgl-2017-07-03/02.jpeg\"></p>\n<h4 id=\"写入数据\"><a href=\"#写入数据\" class=\"headerlink\" title=\"写入数据\"></a>写入数据</h4><ul>\n<li>gl.bufferData(gl.ARRAY_BUFFER , data , gl.STATIC_DRAW)</li>\n<li>data 是类型化数组</li>\n<li>gl.STATIC_DRAW，一次写入多次绘制</li>\n<li>gl.STREAM_DRAW，一次写入多次绘制，比第一次调用的少</li>\n<li>gl.DYNAMIC_DRAW，多次写入多次绘制</li>\n</ul>\n<p><img width=\"600\" src=\"/webgl-2017-07-03/03.jpeg\"></p>\n<h4 id=\"类型化数组\"><a href=\"#类型化数组\" class=\"headerlink\" title=\"类型化数组\"></a>类型化数组</h4><p>接口都是通过类型化数组来进行通信</p>\n<ul>\n<li>Int8Array   Uint8Array   </li>\n<li>Int16Array   Uint16Array</li>\n<li>Int32Array   Uint32Array </li>\n<li>Float32Array </li>\n<li>Float64Array</li>\n</ul>\n<h4 id=\"缓冲区数据导入-attribute-变量\"><a href=\"#缓冲区数据导入-attribute-变量\" class=\"headerlink\" title=\"缓冲区数据导入 attribute 变量\"></a>缓冲区数据导入 attribute 变量</h4><ul>\n<li>vertexAttribPointer(location , size , type , normalized , stride , offset ) </li>\n<li>错误信息  INVALID_OPERATION，表示没有可用的program对象</li>\n<li>错误信息  INVALID_VALUE，表示attribute的最大值已经超出的范围</li>\n<li>enableVertexAttribArray(location)，激活localtion</li>\n<li>错误信息  INVALID_OPERATION，表示没有可用的program对象</li>\n</ul>\n<p><img width=\"600\" src=\"/webgl-2017-07-03/04.jpeg\"></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>创建类型化数组对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">-1.0</span>,<span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">-1.0</span>,<span class=\"number\">-1.0</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>,<span class=\"number\">-1.0</span>,</div><div class=\"line\">    <span class=\"number\">0.0</span>,<span class=\"number\">0.0</span></div><div class=\"line\">]);</div></pre></td></tr></table></figure></p>\n<p>创建buffer和绑定baffer片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> buf = cxt.createBuffer();</div><div class=\"line\">cxt.bindBuffer(cxt.ARRAY_BUFFER,buf);</div></pre></td></tr></table></figure></p>\n<p>将类型化数组绑定到缓冲区中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW);</div></pre></td></tr></table></figure></p>\n<p>将缓冲区数据导入attribute变量中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.vertexAttribPointer(aposLocation,<span class=\"number\">2</span>,cxt.FLOAT,<span class=\"literal\">false</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</div><div class=\"line\">cxt.enableVertexAttribArray(aposLocation);</div></pre></td></tr></table></figure></p>\n<p>开始绘制，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.clearColor(<span class=\"number\">0.0</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.5</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\">cxt.drawArrays(cxt.POINTS,<span class=\"number\">0</span>,<span class=\"number\">5</span>);</div></pre></td></tr></table></figure></p>\n<p>完整代码如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"e03\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"500\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../lib.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'e03'</span>);</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> cxt = canvas.getContext(<span class=\"string\">'webgl'</span>);</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 顶点着色器程序</span></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">const</span> vertexShaderSource =</span></div><div class=\"line\"><span class=\"undefined\">        `attribute vec4 apos;</span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">void</span> main() &#123;</span></div><div class=\"line\"><span class=\"undefined\">    gl_Position = apos;</span></div><div class=\"line\"><span class=\"undefined\">    gl_PointSize = 10.0;</span></div><div class=\"line\"><span class=\"undefined\">    &#125;`</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 片元着色器程序</span></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">const</span> fragmentShaderSource =</span></div><div class=\"line\"><span class=\"undefined\">        `void main() &#123;</span></div><div class=\"line\"><span class=\"undefined\">    gl_FragColor = vec4(1.0,0.5,0.0,1.0);</span></div><div class=\"line\"><span class=\"undefined\">    &#125;`</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> program  = initShader(cxt,vertexShaderSource,fragmentShaderSource);</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> aposLocation = cxt.getAttribLocation(program,<span class=\"string\">'apos'</span>);</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> buffer = cxt.createBuffer();</span></div><div class=\"line\"><span class=\"undefined\">    cxt.bindBuffer(cxt.ARRAY_BUFFER,buffer);</span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</span></div><div class=\"line\"><span class=\"undefined\">            -1.0,1.0,</span></div><div class=\"line\"><span class=\"undefined\">            1.0,1.0,</span></div><div class=\"line\"><span class=\"undefined\">            -1.0,-1.0,</span></div><div class=\"line\"><span class=\"undefined\">            1.0,-1.0,</span></div><div class=\"line\"><span class=\"undefined\">            0.0,0.0</span></div><div class=\"line\"><span class=\"undefined\">    ]);</span></div><div class=\"line\"><span class=\"undefined\">    cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW);</span></div><div class=\"line\"><span class=\"javascript\">    cxt.vertexAttribPointer(aposLocation,<span class=\"number\">2</span>,cxt.FLOAT,<span class=\"literal\">false</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span></div><div class=\"line\"><span class=\"undefined\">    cxt.enableVertexAttribArray(aposLocation);</span></div><div class=\"line\"><span class=\"undefined\">    cxt.clearColor(0.0,0.5,0.5,1.0);</span></div><div class=\"line\"><span class=\"undefined\">    cxt.clear(cxt.COLOR_BUFFER_BIT);</span></div><div class=\"line\"><span class=\"undefined\">    cxt.drawArrays(cxt.POINTS,0,5);</span></div><div class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>运行效果图如下：</p>\n<p><img width=\"600\" src=\"/webgl-2017-07-03/05.jpeg\"></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/03\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/03</a></p>"},{"title":"WebGL系列教程--基本图形绘制","comments":1,"toc":true,"date":"2017-07-04T13:09:11.000Z","_content":"\n### 点的绘制\n\n#### 单点绘制\n\n* gl.drawArrays( gl.POINTS, start , count )\n* gl.POINTS，标示绘制点的\n* start 起始位置\n* count 绘制数量，绘制点的个数不能超过在buffer中存在点的个数\n\n#### 多点绘制\n\n* 采用 javascript 循环，实现多点绘制\n* 采用 WebGL 缓冲区对象，实现多点绘制\n\n上一节代码示例中分别采用了循环绘制点和使用缓冲区对象绘制点，详细请查看上一节内容。\n\n<!-- more -->\n\n### 线段绘制\n\n#### 绘制单线段\n\n* gl.drawArray( gl.LINES , start , count )\n* gl.LINES，可以绘制一条线，也可以绘制多条线\n* 绘制一条线\n* 绘制多条线\n\n最重要的画线代码如下：\n\n{% codeblock lang:javascript %}\ncxt.drawArrays(cxt.LINES,0,4);\n{% endcodeblock %}\n\n####  绘制多线段\n\n* gl.drawArray( gl.LINE_STRIP , start , count )\n* gl.LINE_STRIP 绘制线段带\n* 例如绘制一个矩形框需要定义五个点才能绘制出来，线段带是没有绘路的概念\n\n\n绘制一个矩形重要的相关代码如下：\n\n{% codeblock lang:javascript %}\n//类型化数组定义五个点\nvar data = new Float32Array([\n    -.5,.5,\n    .5,.5 ,\n    .5, -.5,\n    -.5, -.5,\n    -.5,.5\n]);\n\n// 最终绘制也是绘制5个点\ncxt.drawArrays(cxt.LINE_STRIP,0,5);\n{% endcodeblock %}\n\n#### 绘制回路线段\n\n* gl.drawArray( gl.LINE_LOOP , start , count )\n* gl.LINE_LOOP 自动闭合线段，例如绘制矩形只需要4个点即可，默认会将最后一个点和第一个开始的点连接起来\n\n绘制一个矩形重要的相关代码如下：\n\n{% codeblock lang:javascript %}\n//类型化数组定义4个点\nvar data = new Float32Array([\n    -.5,.5,\n    .5,.5 ,\n    .5, -.5,\n    -.5, -.5,\n    -.5,.5\n]);\n\n// 最终绘制也是绘制5个点\ncxt.drawArrays(cxt.LINE_LOOP,0,4);\n{% endcodeblock %}\n\n使用gl.LINE_LOOP绘制一个领结形状的图形，其实只是利用了LINE_LOOP自动闭合线段绘制出来的，核心片段代码如下：\n{% codeblock lang:javascript %}\n//类型化数组定义4个点\nvar data = new Float32Array([\n    -.5, .5,\n    .5, .5,\n    -.5, -.5,\n    .5, -.5\n]);\n\n// 最终绘制也是绘制5个点\ncxt.drawArrays(cxt.LINE_LOOP,0,4);\n{% endcodeblock %}\n\n运行效果图如下：\n\n<img width=\"300\" src=\"webgl-2017-07-04/01.jpeg\"/>\n\n### 多边形绘制\n\n#### 绘制三角形\n\n* gl.drawArray( gl.TRIANGLES , start , count )\n* gl. TRIANGLES\n\n核心代码片段如下：\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n    0,0,\n    -.5,-.5 ,\n    .5, -.5\n]);\n\ncxt.drawArrays(cxt.TRIANGLES,0,3);\n{% endcodeblock %}\n\n运行效果图如下：\n\n<img width=\"300\" src=\"webgl-2017-07-04/02.jpeg\"/>\n\n#### 绘制三角带\n\n* gl.drawArray( gl.TRIANGLE_STRIP , start , count )\n* gl.TRIANGLE_STRIP\n\n绘制一个平行四边形的核心代码如下：\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n        -.3,.3,\n        .5,.3,\n    -.5, -.3,\n        .3, -.3\n    ]);\n\ncxt.drawArrays(cxt.TRIANGLE_STRIP,0,4);\n{% endcodeblock %}\n\n运行效果图如下：\n\n<img width=\"300\" src=\"webgl-2017-07-04/03.jpeg\"/>\n\n#### 绘制三角扇\n\n* gl.drawArray( gl.TRIANGLE_FAN , start , count )\n* gl.TRIANGLE_FAN\n\n绘制一个六边形的核心代码如下：\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n      .0,0,\n      -.3,.5,\n      -.6,.3,\n      -.3, -.3,\n      .3, -.3,\n      .6, .3,\n          .4,.5,\n      -.3,.5\n    ]);\n\ncxt.drawArrays(cxt.TRIANGLE_FAN,0,8);\n{% endcodeblock %}\n\n运行效果图如下：\n\n<img width=\"300\" src=\"webgl-2017-07-04/04.jpeg\"/>\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/04\n","source":"_posts/webgl-2017-07-04.md","raw":"---\ntitle: WebGL系列教程--基本图形绘制\ncomments: true\ntoc: true\ndate: 2017-07-04 21:09:11\ntags: \n    - 'javascript'\n    - 'webgl'\n---\n\n### 点的绘制\n\n#### 单点绘制\n\n* gl.drawArrays( gl.POINTS, start , count )\n* gl.POINTS，标示绘制点的\n* start 起始位置\n* count 绘制数量，绘制点的个数不能超过在buffer中存在点的个数\n\n#### 多点绘制\n\n* 采用 javascript 循环，实现多点绘制\n* 采用 WebGL 缓冲区对象，实现多点绘制\n\n上一节代码示例中分别采用了循环绘制点和使用缓冲区对象绘制点，详细请查看上一节内容。\n\n<!-- more -->\n\n### 线段绘制\n\n#### 绘制单线段\n\n* gl.drawArray( gl.LINES , start , count )\n* gl.LINES，可以绘制一条线，也可以绘制多条线\n* 绘制一条线\n* 绘制多条线\n\n最重要的画线代码如下：\n\n{% codeblock lang:javascript %}\ncxt.drawArrays(cxt.LINES,0,4);\n{% endcodeblock %}\n\n####  绘制多线段\n\n* gl.drawArray( gl.LINE_STRIP , start , count )\n* gl.LINE_STRIP 绘制线段带\n* 例如绘制一个矩形框需要定义五个点才能绘制出来，线段带是没有绘路的概念\n\n\n绘制一个矩形重要的相关代码如下：\n\n{% codeblock lang:javascript %}\n//类型化数组定义五个点\nvar data = new Float32Array([\n    -.5,.5,\n    .5,.5 ,\n    .5, -.5,\n    -.5, -.5,\n    -.5,.5\n]);\n\n// 最终绘制也是绘制5个点\ncxt.drawArrays(cxt.LINE_STRIP,0,5);\n{% endcodeblock %}\n\n#### 绘制回路线段\n\n* gl.drawArray( gl.LINE_LOOP , start , count )\n* gl.LINE_LOOP 自动闭合线段，例如绘制矩形只需要4个点即可，默认会将最后一个点和第一个开始的点连接起来\n\n绘制一个矩形重要的相关代码如下：\n\n{% codeblock lang:javascript %}\n//类型化数组定义4个点\nvar data = new Float32Array([\n    -.5,.5,\n    .5,.5 ,\n    .5, -.5,\n    -.5, -.5,\n    -.5,.5\n]);\n\n// 最终绘制也是绘制5个点\ncxt.drawArrays(cxt.LINE_LOOP,0,4);\n{% endcodeblock %}\n\n使用gl.LINE_LOOP绘制一个领结形状的图形，其实只是利用了LINE_LOOP自动闭合线段绘制出来的，核心片段代码如下：\n{% codeblock lang:javascript %}\n//类型化数组定义4个点\nvar data = new Float32Array([\n    -.5, .5,\n    .5, .5,\n    -.5, -.5,\n    .5, -.5\n]);\n\n// 最终绘制也是绘制5个点\ncxt.drawArrays(cxt.LINE_LOOP,0,4);\n{% endcodeblock %}\n\n运行效果图如下：\n\n<img width=\"300\" src=\"webgl-2017-07-04/01.jpeg\"/>\n\n### 多边形绘制\n\n#### 绘制三角形\n\n* gl.drawArray( gl.TRIANGLES , start , count )\n* gl. TRIANGLES\n\n核心代码片段如下：\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n    0,0,\n    -.5,-.5 ,\n    .5, -.5\n]);\n\ncxt.drawArrays(cxt.TRIANGLES,0,3);\n{% endcodeblock %}\n\n运行效果图如下：\n\n<img width=\"300\" src=\"webgl-2017-07-04/02.jpeg\"/>\n\n#### 绘制三角带\n\n* gl.drawArray( gl.TRIANGLE_STRIP , start , count )\n* gl.TRIANGLE_STRIP\n\n绘制一个平行四边形的核心代码如下：\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n        -.3,.3,\n        .5,.3,\n    -.5, -.3,\n        .3, -.3\n    ]);\n\ncxt.drawArrays(cxt.TRIANGLE_STRIP,0,4);\n{% endcodeblock %}\n\n运行效果图如下：\n\n<img width=\"300\" src=\"webgl-2017-07-04/03.jpeg\"/>\n\n#### 绘制三角扇\n\n* gl.drawArray( gl.TRIANGLE_FAN , start , count )\n* gl.TRIANGLE_FAN\n\n绘制一个六边形的核心代码如下：\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n      .0,0,\n      -.3,.5,\n      -.6,.3,\n      -.3, -.3,\n      .3, -.3,\n      .6, .3,\n          .4,.5,\n      -.3,.5\n    ]);\n\ncxt.drawArrays(cxt.TRIANGLE_FAN,0,8);\n{% endcodeblock %}\n\n运行效果图如下：\n\n<img width=\"300\" src=\"webgl-2017-07-04/04.jpeg\"/>\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/04\n","slug":"webgl-2017-07-04","published":1,"updated":"2017-09-05T13:47:51.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36rx000vlmldis4kh05b","content":"<h3 id=\"点的绘制\"><a href=\"#点的绘制\" class=\"headerlink\" title=\"点的绘制\"></a>点的绘制</h3><h4 id=\"单点绘制\"><a href=\"#单点绘制\" class=\"headerlink\" title=\"单点绘制\"></a>单点绘制</h4><ul>\n<li>gl.drawArrays( gl.POINTS, start , count )</li>\n<li>gl.POINTS，标示绘制点的</li>\n<li>start 起始位置</li>\n<li>count 绘制数量，绘制点的个数不能超过在buffer中存在点的个数</li>\n</ul>\n<h4 id=\"多点绘制\"><a href=\"#多点绘制\" class=\"headerlink\" title=\"多点绘制\"></a>多点绘制</h4><ul>\n<li>采用 javascript 循环，实现多点绘制</li>\n<li>采用 WebGL 缓冲区对象，实现多点绘制</li>\n</ul>\n<p>上一节代码示例中分别采用了循环绘制点和使用缓冲区对象绘制点，详细请查看上一节内容。</p>\n<a id=\"more\"></a>\n<h3 id=\"线段绘制\"><a href=\"#线段绘制\" class=\"headerlink\" title=\"线段绘制\"></a>线段绘制</h3><h4 id=\"绘制单线段\"><a href=\"#绘制单线段\" class=\"headerlink\" title=\"绘制单线段\"></a>绘制单线段</h4><ul>\n<li>gl.drawArray( gl.LINES , start , count )</li>\n<li>gl.LINES，可以绘制一条线，也可以绘制多条线</li>\n<li>绘制一条线</li>\n<li>绘制多条线</li>\n</ul>\n<p>最重要的画线代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.drawArrays(cxt.LINES,<span class=\"number\">0</span>,<span class=\"number\">4</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"绘制多线段\"><a href=\"#绘制多线段\" class=\"headerlink\" title=\"绘制多线段\"></a>绘制多线段</h4><ul>\n<li>gl.drawArray( gl.LINE_STRIP , start , count )</li>\n<li>gl.LINE_STRIP 绘制线段带</li>\n<li>例如绘制一个矩形框需要定义五个点才能绘制出来，线段带是没有绘路的概念</li>\n</ul>\n<p>绘制一个矩形重要的相关代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//类型化数组定义五个点</span></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">-.5</span>,<span class=\"number\">.5</span>,</div><div class=\"line\">    <span class=\"number\">.5</span>,<span class=\"number\">.5</span> ,</div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">-.5</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">-.5</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>,<span class=\"number\">.5</span></div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 最终绘制也是绘制5个点</span></div><div class=\"line\">cxt.drawArrays(cxt.LINE_STRIP,<span class=\"number\">0</span>,<span class=\"number\">5</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"绘制回路线段\"><a href=\"#绘制回路线段\" class=\"headerlink\" title=\"绘制回路线段\"></a>绘制回路线段</h4><ul>\n<li>gl.drawArray( gl.LINE_LOOP , start , count )</li>\n<li>gl.LINE_LOOP 自动闭合线段，例如绘制矩形只需要4个点即可，默认会将最后一个点和第一个开始的点连接起来</li>\n</ul>\n<p>绘制一个矩形重要的相关代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//类型化数组定义4个点</span></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">-.5</span>,<span class=\"number\">.5</span>,</div><div class=\"line\">    <span class=\"number\">.5</span>,<span class=\"number\">.5</span> ,</div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">-.5</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">-.5</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>,<span class=\"number\">.5</span></div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 最终绘制也是绘制5个点</span></div><div class=\"line\">cxt.drawArrays(cxt.LINE_LOOP,<span class=\"number\">0</span>,<span class=\"number\">4</span>);</div></pre></td></tr></table></figure>\n<p>使用gl.LINE_LOOP绘制一个领结形状的图形，其实只是利用了LINE_LOOP自动闭合线段绘制出来的，核心片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//类型化数组定义4个点</span></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">.5</span>,</div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">.5</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">-.5</span>,</div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">-.5</span></div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 最终绘制也是绘制5个点</span></div><div class=\"line\">cxt.drawArrays(cxt.LINE_LOOP,<span class=\"number\">0</span>,<span class=\"number\">4</span>);</div></pre></td></tr></table></figure></p>\n<p>运行效果图如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-04/01.jpeg\"></p>\n<h3 id=\"多边形绘制\"><a href=\"#多边形绘制\" class=\"headerlink\" title=\"多边形绘制\"></a>多边形绘制</h3><h4 id=\"绘制三角形\"><a href=\"#绘制三角形\" class=\"headerlink\" title=\"绘制三角形\"></a>绘制三角形</h4><ul>\n<li>gl.drawArray( gl.TRIANGLES , start , count )</li>\n<li>gl. TRIANGLES</li>\n</ul>\n<p>核心代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">0</span>,<span class=\"number\">0</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>,<span class=\"number\">-.5</span> ,</div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">-.5</span></div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\">cxt.drawArrays(cxt.TRIANGLES,<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<p>运行效果图如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-04/02.jpeg\"></p>\n<h4 id=\"绘制三角带\"><a href=\"#绘制三角带\" class=\"headerlink\" title=\"绘制三角带\"></a>绘制三角带</h4><ul>\n<li>gl.drawArray( gl.TRIANGLE_STRIP , start , count )</li>\n<li>gl.TRIANGLE_STRIP</li>\n</ul>\n<p>绘制一个平行四边形的核心代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">-.3</span>,<span class=\"number\">.3</span>,</div><div class=\"line\">        <span class=\"number\">.5</span>,<span class=\"number\">.3</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">-.3</span>,</div><div class=\"line\">        <span class=\"number\">.3</span>, <span class=\"number\">-.3</span></div><div class=\"line\">    ]);</div><div class=\"line\"></div><div class=\"line\">cxt.drawArrays(cxt.TRIANGLE_STRIP,<span class=\"number\">0</span>,<span class=\"number\">4</span>);</div></pre></td></tr></table></figure></p>\n<p>运行效果图如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-04/03.jpeg\"></p>\n<h4 id=\"绘制三角扇\"><a href=\"#绘制三角扇\" class=\"headerlink\" title=\"绘制三角扇\"></a>绘制三角扇</h4><ul>\n<li>gl.drawArray( gl.TRIANGLE_FAN , start , count )</li>\n<li>gl.TRIANGLE_FAN</li>\n</ul>\n<p>绘制一个六边形的核心代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">      <span class=\"number\">.0</span>,<span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"number\">-.3</span>,<span class=\"number\">.5</span>,</div><div class=\"line\">      <span class=\"number\">-.6</span>,<span class=\"number\">.3</span>,</div><div class=\"line\">      <span class=\"number\">-.3</span>, <span class=\"number\">-.3</span>,</div><div class=\"line\">      <span class=\"number\">.3</span>, <span class=\"number\">-.3</span>,</div><div class=\"line\">      <span class=\"number\">.6</span>, <span class=\"number\">.3</span>,</div><div class=\"line\">          <span class=\"number\">.4</span>,<span class=\"number\">.5</span>,</div><div class=\"line\">      <span class=\"number\">-.3</span>,<span class=\"number\">.5</span></div><div class=\"line\">    ]);</div><div class=\"line\"></div><div class=\"line\">cxt.drawArrays(cxt.TRIANGLE_FAN,<span class=\"number\">0</span>,<span class=\"number\">8</span>);</div></pre></td></tr></table></figure></p>\n<p>运行效果图如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-04/04.jpeg\"></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/04\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/04</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"点的绘制\"><a href=\"#点的绘制\" class=\"headerlink\" title=\"点的绘制\"></a>点的绘制</h3><h4 id=\"单点绘制\"><a href=\"#单点绘制\" class=\"headerlink\" title=\"单点绘制\"></a>单点绘制</h4><ul>\n<li>gl.drawArrays( gl.POINTS, start , count )</li>\n<li>gl.POINTS，标示绘制点的</li>\n<li>start 起始位置</li>\n<li>count 绘制数量，绘制点的个数不能超过在buffer中存在点的个数</li>\n</ul>\n<h4 id=\"多点绘制\"><a href=\"#多点绘制\" class=\"headerlink\" title=\"多点绘制\"></a>多点绘制</h4><ul>\n<li>采用 javascript 循环，实现多点绘制</li>\n<li>采用 WebGL 缓冲区对象，实现多点绘制</li>\n</ul>\n<p>上一节代码示例中分别采用了循环绘制点和使用缓冲区对象绘制点，详细请查看上一节内容。</p>","more":"<h3 id=\"线段绘制\"><a href=\"#线段绘制\" class=\"headerlink\" title=\"线段绘制\"></a>线段绘制</h3><h4 id=\"绘制单线段\"><a href=\"#绘制单线段\" class=\"headerlink\" title=\"绘制单线段\"></a>绘制单线段</h4><ul>\n<li>gl.drawArray( gl.LINES , start , count )</li>\n<li>gl.LINES，可以绘制一条线，也可以绘制多条线</li>\n<li>绘制一条线</li>\n<li>绘制多条线</li>\n</ul>\n<p>最重要的画线代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.drawArrays(cxt.LINES,<span class=\"number\">0</span>,<span class=\"number\">4</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"绘制多线段\"><a href=\"#绘制多线段\" class=\"headerlink\" title=\"绘制多线段\"></a>绘制多线段</h4><ul>\n<li>gl.drawArray( gl.LINE_STRIP , start , count )</li>\n<li>gl.LINE_STRIP 绘制线段带</li>\n<li>例如绘制一个矩形框需要定义五个点才能绘制出来，线段带是没有绘路的概念</li>\n</ul>\n<p>绘制一个矩形重要的相关代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//类型化数组定义五个点</span></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">-.5</span>,<span class=\"number\">.5</span>,</div><div class=\"line\">    <span class=\"number\">.5</span>,<span class=\"number\">.5</span> ,</div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">-.5</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">-.5</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>,<span class=\"number\">.5</span></div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 最终绘制也是绘制5个点</span></div><div class=\"line\">cxt.drawArrays(cxt.LINE_STRIP,<span class=\"number\">0</span>,<span class=\"number\">5</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"绘制回路线段\"><a href=\"#绘制回路线段\" class=\"headerlink\" title=\"绘制回路线段\"></a>绘制回路线段</h4><ul>\n<li>gl.drawArray( gl.LINE_LOOP , start , count )</li>\n<li>gl.LINE_LOOP 自动闭合线段，例如绘制矩形只需要4个点即可，默认会将最后一个点和第一个开始的点连接起来</li>\n</ul>\n<p>绘制一个矩形重要的相关代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//类型化数组定义4个点</span></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">-.5</span>,<span class=\"number\">.5</span>,</div><div class=\"line\">    <span class=\"number\">.5</span>,<span class=\"number\">.5</span> ,</div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">-.5</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">-.5</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>,<span class=\"number\">.5</span></div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 最终绘制也是绘制5个点</span></div><div class=\"line\">cxt.drawArrays(cxt.LINE_LOOP,<span class=\"number\">0</span>,<span class=\"number\">4</span>);</div></pre></td></tr></table></figure>\n<p>使用gl.LINE_LOOP绘制一个领结形状的图形，其实只是利用了LINE_LOOP自动闭合线段绘制出来的，核心片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//类型化数组定义4个点</span></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">.5</span>,</div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">.5</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">-.5</span>,</div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">-.5</span></div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 最终绘制也是绘制5个点</span></div><div class=\"line\">cxt.drawArrays(cxt.LINE_LOOP,<span class=\"number\">0</span>,<span class=\"number\">4</span>);</div></pre></td></tr></table></figure></p>\n<p>运行效果图如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-04/01.jpeg\"></p>\n<h3 id=\"多边形绘制\"><a href=\"#多边形绘制\" class=\"headerlink\" title=\"多边形绘制\"></a>多边形绘制</h3><h4 id=\"绘制三角形\"><a href=\"#绘制三角形\" class=\"headerlink\" title=\"绘制三角形\"></a>绘制三角形</h4><ul>\n<li>gl.drawArray( gl.TRIANGLES , start , count )</li>\n<li>gl. TRIANGLES</li>\n</ul>\n<p>核心代码片段如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">0</span>,<span class=\"number\">0</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>,<span class=\"number\">-.5</span> ,</div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">-.5</span></div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\">cxt.drawArrays(cxt.TRIANGLES,<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<p>运行效果图如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-04/02.jpeg\"></p>\n<h4 id=\"绘制三角带\"><a href=\"#绘制三角带\" class=\"headerlink\" title=\"绘制三角带\"></a>绘制三角带</h4><ul>\n<li>gl.drawArray( gl.TRIANGLE_STRIP , start , count )</li>\n<li>gl.TRIANGLE_STRIP</li>\n</ul>\n<p>绘制一个平行四边形的核心代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">-.3</span>,<span class=\"number\">.3</span>,</div><div class=\"line\">        <span class=\"number\">.5</span>,<span class=\"number\">.3</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">-.3</span>,</div><div class=\"line\">        <span class=\"number\">.3</span>, <span class=\"number\">-.3</span></div><div class=\"line\">    ]);</div><div class=\"line\"></div><div class=\"line\">cxt.drawArrays(cxt.TRIANGLE_STRIP,<span class=\"number\">0</span>,<span class=\"number\">4</span>);</div></pre></td></tr></table></figure></p>\n<p>运行效果图如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-04/03.jpeg\"></p>\n<h4 id=\"绘制三角扇\"><a href=\"#绘制三角扇\" class=\"headerlink\" title=\"绘制三角扇\"></a>绘制三角扇</h4><ul>\n<li>gl.drawArray( gl.TRIANGLE_FAN , start , count )</li>\n<li>gl.TRIANGLE_FAN</li>\n</ul>\n<p>绘制一个六边形的核心代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">      <span class=\"number\">.0</span>,<span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"number\">-.3</span>,<span class=\"number\">.5</span>,</div><div class=\"line\">      <span class=\"number\">-.6</span>,<span class=\"number\">.3</span>,</div><div class=\"line\">      <span class=\"number\">-.3</span>, <span class=\"number\">-.3</span>,</div><div class=\"line\">      <span class=\"number\">.3</span>, <span class=\"number\">-.3</span>,</div><div class=\"line\">      <span class=\"number\">.6</span>, <span class=\"number\">.3</span>,</div><div class=\"line\">          <span class=\"number\">.4</span>,<span class=\"number\">.5</span>,</div><div class=\"line\">      <span class=\"number\">-.3</span>,<span class=\"number\">.5</span></div><div class=\"line\">    ]);</div><div class=\"line\"></div><div class=\"line\">cxt.drawArrays(cxt.TRIANGLE_FAN,<span class=\"number\">0</span>,<span class=\"number\">8</span>);</div></pre></td></tr></table></figure></p>\n<p>运行效果图如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-04/04.jpeg\"></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/04\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/04</a></p>"},{"title":"WebGL系列教程--图形的变换","comments":1,"toc":true,"date":"2017-07-06T13:09:11.000Z","_content":"\n### 图形的移动\n\n#### 原理\n\n* 图形的移动，实际上就是定量改变顶点的位置。\n* 在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。\n\n可以使用setTimeout定时执行画点的方法，来逐一改变点的位置实现图形的移动。\n\n<!-- more -->\n\n先编写顶点着色器，需要单独定义a，b来分别改变点的x方向和y方向，基本代码如下：\n{% codeblock lang:javascript %}\nconst vertexShaderSource =\n    `\n    attribute vec4 pos;\n    uniform float a;\n    uniform float b;\n    void main() {\n      gl_Position.x = pos.x + a;\n      gl_Position.y = pos.y + b;\n      gl_Position.z = .0;\n      gl_PointSize = 10.0;\n}`\n{% endcodeblock %}\n\n片元着色器代码和之前写法基本一致，基本代码如下：\n{% codeblock lang:javascript %}\nconst fragmentShaderSource =\n    `void main() {\n      gl_FragColor = vec4(1.0,0.5,0.0,1.0);\n  }`\n{% endcodeblock %}\n\n给顶点着色器中的变量定义响应的location，基本代码如下：\n{% codeblock lang:javascript %}\nvar posLocation = cxt.getAttribLocation(program, 'pos');\nvar aLocation = cxt.getUniformLocation(program, 'a');\nvar bLocation = cxt.getUniformLocation(program, 'b');\n{% endcodeblock %}\n\n使用setTimeOut函数定义简单的平移效果，基本代码如下：\n{% codeblock lang:javascript %}\nrun();\n    function run() {\n        cxt.uniform1f(aLocation, a);\n        cxt.uniform1f(bLocation, b);\n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n\n        a += .05;\n        b += .05;\n\n        setTimeout(run, 500)\n    }\n{% endcodeblock %}\n\n\n### 图形的缩放\n\n#### 原理\n\n* 基于原点，基于定义的某一个点进行缩小和放大(其实还做了平移操作)\n* 在着色器中，逐顶点乘以缩放的倍数，对x轴和y轴同时进行缩放\n\n 编写顶点着色器,定义一个cj变量，通过x轴和y轴同时乘以cj这个变量，来实现逐顶点缩放，基本代码如下：\n {% codeblock lang:javascript %}\n const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform float cj;\n    void main() {\n      gl_Position.x = pos.x * cj;\n      gl_Position.y = pos.y * cj;\n      gl_Position.z = .0;\n      gl_Position.w = 1.0;\n      gl_PointSize = 10.0;\n}`\n{% endcodeblock %}\n\n定义cjLocation，代码如下：\n{% codeblock lang:javascript %}\nvar cjLocation = cxt.getUniformLocation(program, 'cj');\n{% endcodeblock %}\n\n定义基本渲染函数render，再单独定义放大缩小函数，基本代码如下：\n{% codeblock lang:javascript %}\nvar cj = 1.0;\t\n    render();\n    function render() {\n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n        cxt.uniform1f(cjLocation, cj);\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n    }\n    function fangda() {\n        cj += .05;\n        render()\n    }\n\n    function suoxiao() {\n        cj -= .05;\n        render()\n    }\n{% endcodeblock %}\n\n#### 利用w快速缩放\n\n修改着色器代码，将vec4改成vec2，基本意思就是pos存在x和y两个点，基本修改后如下：\n {% codeblock lang:javascript %}\n const vertexShaderSource =\n        `\n    attribute vec2 pos;\n    uniform float w;\n    void main() {\n      gl_Position = vec4(pos,0.0,w);\n}`\n{% endcodeblock %}\n\n该方法实现效果刚好和vec4的时候相反，基本原因是vec4(x/w,y/w,z/w,w),所以w越大，其实x和y轴会越小，所以最终放大效果和之前是相反的。\n\n\n### 图形的旋转\n\n#### 原理\n\n* 基于原点，以一定的角度旋转\n* 在顶点着色器中，更改gl.Position.x和gl.Position.y的值\n\n#### 旋转方程\n\n* x = r.cos(a)\n* y = r.sin(a)\n* x1 = r.cos(a+b)\n* y1 = r.sin(a+b)\n* x1 = x.cos(b) - y.sin(b)\n* y1 = x.sin(b) + y.cos(b)\n* z1 = z = 0.0\n\n顶点着色器代码基本写法如下：\n {% codeblock lang:javascript %}\nconst vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform float cosB;\n    uniform float sinB;\n    void main() {\n      gl_Position.x = pos.x * cosB - pos.y * sinB;\n      gl_Position.y = pos.x * sinB + pos.y * cosB;\n      gl_Position.z = .0;\n      gl_Position.w = 1.0;\n}`\n{% endcodeblock %}\n\n实现简单动画基本如下：\n {% codeblock lang:javascript %}\nvar angle = 10.0;\n    function render() {\n        var t = Math.PI * angle / 180;\n        var cosB = Math.sin(t);\n        var sinB = Math.cos(t);\n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n        cxt.uniform1f(cosBLocation, cosB);\n        cxt.uniform1f(sinBLocation, sinB);\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n    }\n\n    setInterval(() => {\n        angle += 1.0;\n        render();\n    }, 1000)\n{% endcodeblock %}\n\n### 矩阵变换实现图形的移动\n\n#### 原理\n\n* 图形的移动，实际上就是定量改变顶点的位置。\n* 在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。\n\n只要改变Tx,Ty,就能分别改变图形的x方向和y方向\n\n<img width=\"300\" src=\"webgl-2017-07-06/1.jpeg\"/>\n\n在顶点着色器中定义一个xf举证变量，基本代码如下：\n {% codeblock lang:javascript %}\nconst vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform mat4 xf;\n    void main() {\n      gl_Position = xf * pos;\n}`\n{% endcodeblock %}\n\n定义一个矩阵代码：\n {% codeblock lang:javascript %}\nvar xf = new Float32Array([\n                    1.0, 0.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0, 0.0,\n                    0.0, 0.0, 1.0, 0.0,\n                    Tx, Ty, 0.0, 1.0\n                ]);\n{% endcodeblock %}\n\n只需要通过改变Tx，Ty就能实现改变图形的移动，并不需要改变着色器代码，这样效率会很高，render函数基本如下：\n{% codeblock lang:javascript %}\nvar Tx = 1.0, Ty = 0.0;\n\n    function render() {\n      var xf = new Float32Array([\n                    1.0, 0.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0, 0.0,\n                    0.0, 0.0, 1.0, 0.0,\n                    Tx, Ty, 0.0, 1.0\n                ]);\n        \n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n        cxt.uniformMatrix4fv(xfLocation,false,xf);\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n    }\n    render()\n{% endcodeblock %}\n\n### 矩阵变换实现图形的缩放\n\n#### 原理\n\n* 基于原点。\n* 在着色器中，逐顶点乘以缩放倍数\n\nSx,Sy改变就会使得图形成比例的缩放\n<img width=\"300\" src=\"webgl-2017-07-06/2.jpeg\"/>\n\n主要是矩阵函数不一样，其他基本一样，代码基本如下：\n{% codeblock lang:javascript %}\nvar sx = 1.0,\n        sy = 1.0;\n\n    function render() {\n        var xf = new Float32Array([\n            sx, 0.0, 0.0, 0.0,\n            0.0, sy, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        ]);\n\n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n        cxt.uniformMatrix4fv(xfLocation, false, xf);\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n    }\n\n    render()\n{% endcodeblock %}\n\n### 矩阵变换实现图形的旋转\n\n#### 原理\n\n* 基于原点，以一定的角度旋转。\n* 在顶点着色器中，更改 gl_Position.x 和 gl_Position.y 值。\n\n<img width=\"300\" src=\"webgl-2017-07-06/3.jpeg\"/>\n\n实现一个时钟指针的旋转，并且控制其速度和开关。\n\n定义一个顶点着色器和片元着色器，基本代码如下：\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform mat4 xf;\n    void main() {\n      gl_Position = xf * pos;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `void main() {\n      gl_FragColor = vec4(1.0,.0,.0,1.0);\n  }`\n{% endcodeblock %}\n\n最终render函数基本如下：\n{% codeblock lang:javascript %}\nvar time;\n\n    function render() {\n        angle += zl;\n\n        t = Math.PI * angle / 180;\n        sinB = Math.sin(t);\n        cosB = Math.cos(t);\n        var xf = new Float32Array([\n            cosB, sinB, 0.0, 0.0, -sinB, cosB, 0.0, .0,\n            0.0, .0, 1.0, .0,\n            0.0, .0, .0, 1.0\n        ]);\n        cxt.uniformMatrix4fv(xfLocation, false, xf);\n\n        cxt.clearColor(.5, .5, .5, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n\n        cxt.drawArrays(cxt.LINES, 0, 2);\n        time = setTimeout(render, 500);\n\n        if (!isOpen) {\n            clearTimeout(time);\n        }\n    }\n\n    render()\n{% endcodeblock %}\n\n最终效果如下图：\n<img width=\"600\" src=\"webgl-2017-07-06/4.jpeg\"/>\n\n### WebGL动画原理\n\n#### 原理\n\n* 通过 setTimeout 定时渲染\n* 每次渲染都用背景色刷屏\n* 每次渲染都修改变换参数\n* 变换矩阵A * 变换矩阵B * 原始顶点坐标矢量 ＝ 最终顶点坐标矢量\n\n#### 基本步骤\n\n* 编写着色器代码\n* 编写基础代码\n* 编写平移和缩放代码\n* 开发平移且缩放小动画\n\n编写着色器代码，示例如下：\n\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform mat4 xz;\n    uniform mat4 py;\n    void main() {\n      gl_Position = pos * xz * py;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `void main() {\n      gl_FragColor = vec4(1.0,.0,.0,1.0);\n  }`\n{% endcodeblock %}\n\n编写基础代码，上下文确定，buffer编写以及buffer数据加载等等，基本代码如下：\n{% codeblock lang:javascript %}\nvar cxt = document.getElementById('example08').getContext('webgl');\n\n    var buffer = cxt.createBuffer();\n    cxt.bindBuffer(cxt.ARRAY_BUFFER, buffer);\n    var data = new Float32Array([\n        0.0, 0.2, -.2, -.2,\n        .2, -.2,\n    ]);\n\n    cxt.bufferData(cxt.ARRAY_BUFFER, data, cxt.STATIC_DRAW);\n\n    var program = initShader(cxt, vertexShaderSource, fragmentShaderSource);\n\n    var posLocation = cxt.getAttribLocation(program, 'pos');\n    var xzLocation = cxt.getUniformLocation(program, 'xz');\n    var pyLocation = cxt.getUniformLocation(program, 'py');\n\n\n    cxt.vertexAttribPointer(posLocation, 2, cxt.FLOAT, false, 0, 0);\n    cxt.enableVertexAttribArray(posLocation);\n{% endcodeblock %}\n\n定义平移矩阵和缩放矩阵代码：\n{% codeblock lang:javascript %}\nvar xz = new Float32Array([\n            cosB, sinB, 0.0, 0.0, \n            -sinB, cosB, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        ]);\n var py = new Float32Array([\n            1.0, 0.0, 0.0, 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            tx, ty, 0.0, 1.0\n        ]);\n\n        cxt.uniformMatrix4fv(xzLocation,false, xz);\n        cxt.uniformMatrix4fv(pyLocation,false, py);       \n{% endcodeblock %}\n\n最终加入setTimeOut函数的run方法代码如下：\n\n{% codeblock lang:javascript %}\nfunction run() {\n        var t = Math.PI * ANGLE / 180;\n        sinB = Math.sin(t);\n        cosB = Math.cos(t);\n\n        var xz = new Float32Array([\n            cosB, sinB, 0.0, 0.0, \n            -sinB, cosB, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        ]);\n\n        tx += .005;\n        ty += .005;\n\n        ANGLE += 1;\n\n        var py = new Float32Array([\n            1.0, 0.0, 0.0, 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            tx, ty, 0.0, 1.0\n        ]);\n\n        cxt.uniformMatrix4fv(xzLocation,false, xz);\n        cxt.uniformMatrix4fv(pyLocation,false, py);\n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n\n\n        setTimeout(run, 500)\n    }\n\n    run();     \n{% endcodeblock %}\n\n\n### 矩阵复合变换\n\n* 复合变换是多种变换同时进行，通过4 * 4 矩阵相乘得出来的结果，可以使用上面的示例，简化着色器中定义的矩阵变量。\n\n开发一个矩阵运算方法，基本原理如下图：\n\n<img width=\"300\" src=\"webgl-2017-07-08/5.jpeg\"/>\n\n完整方法代码如下：\n{% codeblock lang:javascript %}\nfunction mix(a, b) {\n        var result = new Float32Array(16);\n\n        for (var i = 0; i < 4; i++) {\n            result[i] = a[i] * b[0] + a[i + 4] * b[1] + a[i + 8] * b[2] + a[i + 12] * b[3];\n            result[i + 4] = a[i] * b[4] + a[i + 4] * b[5] + a[i + 8] * b[6] + a[i + 12] * b[7];\n            result[i + 8] = a[i] * b[8] + a[i + 4] * b[9] + a[i + 8] * b[10] + a[i + 12] * b[11];\n            result[i + 12] = a[i] * b[12] + a[i + 4] * b[13] + a[i + 8] * b[14] + a[i + 12] * b[15];\n        }\n\n        return result;\n    }\n\n{% endcodeblock %}\n\n简化着色器代码，基本如下：\n{% codeblock lang:javascript %}\nconst vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform mat4 xf;\n    void main() {\n      gl_Position = pos * xf;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `void main() {\n      gl_FragColor = vec4(1.0,.0,.0,1.0);\n  }`\n{% endcodeblock %}\n\n简化Location和矩阵数据导入的函数方法，剩余代码和前面的动画原理示例一样，片段代码如下：\n{% codeblock lang:javascript %}\nvar xfLocation = cxt.getUniformLocation(program, 'xf');\ncxt.uniformMatrix4fv(xfLocation, false, mix(xz,py));\n{% endcodeblock %}\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/05","source":"_posts/webgl-2017-07-06.md","raw":"---\ntitle: WebGL系列教程--图形的变换\ncomments: true\ntoc: true\ndate: 2017-07-06 21:09:11\ntags:\n    - 'javascript'\n    - 'webgl'\n---\n\n### 图形的移动\n\n#### 原理\n\n* 图形的移动，实际上就是定量改变顶点的位置。\n* 在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。\n\n可以使用setTimeout定时执行画点的方法，来逐一改变点的位置实现图形的移动。\n\n<!-- more -->\n\n先编写顶点着色器，需要单独定义a，b来分别改变点的x方向和y方向，基本代码如下：\n{% codeblock lang:javascript %}\nconst vertexShaderSource =\n    `\n    attribute vec4 pos;\n    uniform float a;\n    uniform float b;\n    void main() {\n      gl_Position.x = pos.x + a;\n      gl_Position.y = pos.y + b;\n      gl_Position.z = .0;\n      gl_PointSize = 10.0;\n}`\n{% endcodeblock %}\n\n片元着色器代码和之前写法基本一致，基本代码如下：\n{% codeblock lang:javascript %}\nconst fragmentShaderSource =\n    `void main() {\n      gl_FragColor = vec4(1.0,0.5,0.0,1.0);\n  }`\n{% endcodeblock %}\n\n给顶点着色器中的变量定义响应的location，基本代码如下：\n{% codeblock lang:javascript %}\nvar posLocation = cxt.getAttribLocation(program, 'pos');\nvar aLocation = cxt.getUniformLocation(program, 'a');\nvar bLocation = cxt.getUniformLocation(program, 'b');\n{% endcodeblock %}\n\n使用setTimeOut函数定义简单的平移效果，基本代码如下：\n{% codeblock lang:javascript %}\nrun();\n    function run() {\n        cxt.uniform1f(aLocation, a);\n        cxt.uniform1f(bLocation, b);\n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n\n        a += .05;\n        b += .05;\n\n        setTimeout(run, 500)\n    }\n{% endcodeblock %}\n\n\n### 图形的缩放\n\n#### 原理\n\n* 基于原点，基于定义的某一个点进行缩小和放大(其实还做了平移操作)\n* 在着色器中，逐顶点乘以缩放的倍数，对x轴和y轴同时进行缩放\n\n 编写顶点着色器,定义一个cj变量，通过x轴和y轴同时乘以cj这个变量，来实现逐顶点缩放，基本代码如下：\n {% codeblock lang:javascript %}\n const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform float cj;\n    void main() {\n      gl_Position.x = pos.x * cj;\n      gl_Position.y = pos.y * cj;\n      gl_Position.z = .0;\n      gl_Position.w = 1.0;\n      gl_PointSize = 10.0;\n}`\n{% endcodeblock %}\n\n定义cjLocation，代码如下：\n{% codeblock lang:javascript %}\nvar cjLocation = cxt.getUniformLocation(program, 'cj');\n{% endcodeblock %}\n\n定义基本渲染函数render，再单独定义放大缩小函数，基本代码如下：\n{% codeblock lang:javascript %}\nvar cj = 1.0;\t\n    render();\n    function render() {\n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n        cxt.uniform1f(cjLocation, cj);\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n    }\n    function fangda() {\n        cj += .05;\n        render()\n    }\n\n    function suoxiao() {\n        cj -= .05;\n        render()\n    }\n{% endcodeblock %}\n\n#### 利用w快速缩放\n\n修改着色器代码，将vec4改成vec2，基本意思就是pos存在x和y两个点，基本修改后如下：\n {% codeblock lang:javascript %}\n const vertexShaderSource =\n        `\n    attribute vec2 pos;\n    uniform float w;\n    void main() {\n      gl_Position = vec4(pos,0.0,w);\n}`\n{% endcodeblock %}\n\n该方法实现效果刚好和vec4的时候相反，基本原因是vec4(x/w,y/w,z/w,w),所以w越大，其实x和y轴会越小，所以最终放大效果和之前是相反的。\n\n\n### 图形的旋转\n\n#### 原理\n\n* 基于原点，以一定的角度旋转\n* 在顶点着色器中，更改gl.Position.x和gl.Position.y的值\n\n#### 旋转方程\n\n* x = r.cos(a)\n* y = r.sin(a)\n* x1 = r.cos(a+b)\n* y1 = r.sin(a+b)\n* x1 = x.cos(b) - y.sin(b)\n* y1 = x.sin(b) + y.cos(b)\n* z1 = z = 0.0\n\n顶点着色器代码基本写法如下：\n {% codeblock lang:javascript %}\nconst vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform float cosB;\n    uniform float sinB;\n    void main() {\n      gl_Position.x = pos.x * cosB - pos.y * sinB;\n      gl_Position.y = pos.x * sinB + pos.y * cosB;\n      gl_Position.z = .0;\n      gl_Position.w = 1.0;\n}`\n{% endcodeblock %}\n\n实现简单动画基本如下：\n {% codeblock lang:javascript %}\nvar angle = 10.0;\n    function render() {\n        var t = Math.PI * angle / 180;\n        var cosB = Math.sin(t);\n        var sinB = Math.cos(t);\n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n        cxt.uniform1f(cosBLocation, cosB);\n        cxt.uniform1f(sinBLocation, sinB);\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n    }\n\n    setInterval(() => {\n        angle += 1.0;\n        render();\n    }, 1000)\n{% endcodeblock %}\n\n### 矩阵变换实现图形的移动\n\n#### 原理\n\n* 图形的移动，实际上就是定量改变顶点的位置。\n* 在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。\n\n只要改变Tx,Ty,就能分别改变图形的x方向和y方向\n\n<img width=\"300\" src=\"webgl-2017-07-06/1.jpeg\"/>\n\n在顶点着色器中定义一个xf举证变量，基本代码如下：\n {% codeblock lang:javascript %}\nconst vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform mat4 xf;\n    void main() {\n      gl_Position = xf * pos;\n}`\n{% endcodeblock %}\n\n定义一个矩阵代码：\n {% codeblock lang:javascript %}\nvar xf = new Float32Array([\n                    1.0, 0.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0, 0.0,\n                    0.0, 0.0, 1.0, 0.0,\n                    Tx, Ty, 0.0, 1.0\n                ]);\n{% endcodeblock %}\n\n只需要通过改变Tx，Ty就能实现改变图形的移动，并不需要改变着色器代码，这样效率会很高，render函数基本如下：\n{% codeblock lang:javascript %}\nvar Tx = 1.0, Ty = 0.0;\n\n    function render() {\n      var xf = new Float32Array([\n                    1.0, 0.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0, 0.0,\n                    0.0, 0.0, 1.0, 0.0,\n                    Tx, Ty, 0.0, 1.0\n                ]);\n        \n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n        cxt.uniformMatrix4fv(xfLocation,false,xf);\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n    }\n    render()\n{% endcodeblock %}\n\n### 矩阵变换实现图形的缩放\n\n#### 原理\n\n* 基于原点。\n* 在着色器中，逐顶点乘以缩放倍数\n\nSx,Sy改变就会使得图形成比例的缩放\n<img width=\"300\" src=\"webgl-2017-07-06/2.jpeg\"/>\n\n主要是矩阵函数不一样，其他基本一样，代码基本如下：\n{% codeblock lang:javascript %}\nvar sx = 1.0,\n        sy = 1.0;\n\n    function render() {\n        var xf = new Float32Array([\n            sx, 0.0, 0.0, 0.0,\n            0.0, sy, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        ]);\n\n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n        cxt.uniformMatrix4fv(xfLocation, false, xf);\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n    }\n\n    render()\n{% endcodeblock %}\n\n### 矩阵变换实现图形的旋转\n\n#### 原理\n\n* 基于原点，以一定的角度旋转。\n* 在顶点着色器中，更改 gl_Position.x 和 gl_Position.y 值。\n\n<img width=\"300\" src=\"webgl-2017-07-06/3.jpeg\"/>\n\n实现一个时钟指针的旋转，并且控制其速度和开关。\n\n定义一个顶点着色器和片元着色器，基本代码如下：\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform mat4 xf;\n    void main() {\n      gl_Position = xf * pos;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `void main() {\n      gl_FragColor = vec4(1.0,.0,.0,1.0);\n  }`\n{% endcodeblock %}\n\n最终render函数基本如下：\n{% codeblock lang:javascript %}\nvar time;\n\n    function render() {\n        angle += zl;\n\n        t = Math.PI * angle / 180;\n        sinB = Math.sin(t);\n        cosB = Math.cos(t);\n        var xf = new Float32Array([\n            cosB, sinB, 0.0, 0.0, -sinB, cosB, 0.0, .0,\n            0.0, .0, 1.0, .0,\n            0.0, .0, .0, 1.0\n        ]);\n        cxt.uniformMatrix4fv(xfLocation, false, xf);\n\n        cxt.clearColor(.5, .5, .5, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n\n        cxt.drawArrays(cxt.LINES, 0, 2);\n        time = setTimeout(render, 500);\n\n        if (!isOpen) {\n            clearTimeout(time);\n        }\n    }\n\n    render()\n{% endcodeblock %}\n\n最终效果如下图：\n<img width=\"600\" src=\"webgl-2017-07-06/4.jpeg\"/>\n\n### WebGL动画原理\n\n#### 原理\n\n* 通过 setTimeout 定时渲染\n* 每次渲染都用背景色刷屏\n* 每次渲染都修改变换参数\n* 变换矩阵A * 变换矩阵B * 原始顶点坐标矢量 ＝ 最终顶点坐标矢量\n\n#### 基本步骤\n\n* 编写着色器代码\n* 编写基础代码\n* 编写平移和缩放代码\n* 开发平移且缩放小动画\n\n编写着色器代码，示例如下：\n\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform mat4 xz;\n    uniform mat4 py;\n    void main() {\n      gl_Position = pos * xz * py;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `void main() {\n      gl_FragColor = vec4(1.0,.0,.0,1.0);\n  }`\n{% endcodeblock %}\n\n编写基础代码，上下文确定，buffer编写以及buffer数据加载等等，基本代码如下：\n{% codeblock lang:javascript %}\nvar cxt = document.getElementById('example08').getContext('webgl');\n\n    var buffer = cxt.createBuffer();\n    cxt.bindBuffer(cxt.ARRAY_BUFFER, buffer);\n    var data = new Float32Array([\n        0.0, 0.2, -.2, -.2,\n        .2, -.2,\n    ]);\n\n    cxt.bufferData(cxt.ARRAY_BUFFER, data, cxt.STATIC_DRAW);\n\n    var program = initShader(cxt, vertexShaderSource, fragmentShaderSource);\n\n    var posLocation = cxt.getAttribLocation(program, 'pos');\n    var xzLocation = cxt.getUniformLocation(program, 'xz');\n    var pyLocation = cxt.getUniformLocation(program, 'py');\n\n\n    cxt.vertexAttribPointer(posLocation, 2, cxt.FLOAT, false, 0, 0);\n    cxt.enableVertexAttribArray(posLocation);\n{% endcodeblock %}\n\n定义平移矩阵和缩放矩阵代码：\n{% codeblock lang:javascript %}\nvar xz = new Float32Array([\n            cosB, sinB, 0.0, 0.0, \n            -sinB, cosB, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        ]);\n var py = new Float32Array([\n            1.0, 0.0, 0.0, 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            tx, ty, 0.0, 1.0\n        ]);\n\n        cxt.uniformMatrix4fv(xzLocation,false, xz);\n        cxt.uniformMatrix4fv(pyLocation,false, py);       \n{% endcodeblock %}\n\n最终加入setTimeOut函数的run方法代码如下：\n\n{% codeblock lang:javascript %}\nfunction run() {\n        var t = Math.PI * ANGLE / 180;\n        sinB = Math.sin(t);\n        cosB = Math.cos(t);\n\n        var xz = new Float32Array([\n            cosB, sinB, 0.0, 0.0, \n            -sinB, cosB, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        ]);\n\n        tx += .005;\n        ty += .005;\n\n        ANGLE += 1;\n\n        var py = new Float32Array([\n            1.0, 0.0, 0.0, 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            tx, ty, 0.0, 1.0\n        ]);\n\n        cxt.uniformMatrix4fv(xzLocation,false, xz);\n        cxt.uniformMatrix4fv(pyLocation,false, py);\n        cxt.clearColor(0.0, 0.0, 0.0, 1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n\n        cxt.drawArrays(cxt.TRIANGLES, 0, 3);\n\n\n        setTimeout(run, 500)\n    }\n\n    run();     \n{% endcodeblock %}\n\n\n### 矩阵复合变换\n\n* 复合变换是多种变换同时进行，通过4 * 4 矩阵相乘得出来的结果，可以使用上面的示例，简化着色器中定义的矩阵变量。\n\n开发一个矩阵运算方法，基本原理如下图：\n\n<img width=\"300\" src=\"webgl-2017-07-08/5.jpeg\"/>\n\n完整方法代码如下：\n{% codeblock lang:javascript %}\nfunction mix(a, b) {\n        var result = new Float32Array(16);\n\n        for (var i = 0; i < 4; i++) {\n            result[i] = a[i] * b[0] + a[i + 4] * b[1] + a[i + 8] * b[2] + a[i + 12] * b[3];\n            result[i + 4] = a[i] * b[4] + a[i + 4] * b[5] + a[i + 8] * b[6] + a[i + 12] * b[7];\n            result[i + 8] = a[i] * b[8] + a[i + 4] * b[9] + a[i + 8] * b[10] + a[i + 12] * b[11];\n            result[i + 12] = a[i] * b[12] + a[i + 4] * b[13] + a[i + 8] * b[14] + a[i + 12] * b[15];\n        }\n\n        return result;\n    }\n\n{% endcodeblock %}\n\n简化着色器代码，基本如下：\n{% codeblock lang:javascript %}\nconst vertexShaderSource =\n        `\n    attribute vec4 pos;\n    uniform mat4 xf;\n    void main() {\n      gl_Position = pos * xf;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `void main() {\n      gl_FragColor = vec4(1.0,.0,.0,1.0);\n  }`\n{% endcodeblock %}\n\n简化Location和矩阵数据导入的函数方法，剩余代码和前面的动画原理示例一样，片段代码如下：\n{% codeblock lang:javascript %}\nvar xfLocation = cxt.getUniformLocation(program, 'xf');\ncxt.uniformMatrix4fv(xfLocation, false, mix(xz,py));\n{% endcodeblock %}\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/05","slug":"webgl-2017-07-06","published":1,"updated":"2017-10-05T08:31:05.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36rz000xlmlduef0c4fo","content":"<h3 id=\"图形的移动\"><a href=\"#图形的移动\" class=\"headerlink\" title=\"图形的移动\"></a>图形的移动</h3><h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>图形的移动，实际上就是定量改变顶点的位置。</li>\n<li>在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。</li>\n</ul>\n<p>可以使用setTimeout定时执行画点的方法，来逐一改变点的位置实现图形的移动。</p>\n<a id=\"more\"></a>\n<p>先编写顶点着色器，需要单独定义a，b来分别改变点的x方向和y方向，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">    <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform float a;</span></div><div class=\"line\"><span class=\"string\">    uniform float b;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.x = pos.x + a;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.y = pos.y + b;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.z = .0;</span></div><div class=\"line\"><span class=\"string\">      gl_PointSize = 10.0;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>\n<p>片元着色器代码和之前写法基本一致，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">    <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,0.5,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>给顶点着色器中的变量定义响应的location，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> posLocation = cxt.getAttribLocation(program, <span class=\"string\">'pos'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> aLocation = cxt.getUniformLocation(program, <span class=\"string\">'a'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> bLocation = cxt.getUniformLocation(program, <span class=\"string\">'b'</span>);</div></pre></td></tr></table></figure></p>\n<p>使用setTimeOut函数定义简单的平移效果，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">run();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        cxt.uniform1f(aLocation, a);</div><div class=\"line\">        cxt.uniform1f(bLocation, b);</div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\"></div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\">        a += <span class=\"number\">.05</span>;</div><div class=\"line\">        b += <span class=\"number\">.05</span>;</div><div class=\"line\"></div><div class=\"line\">        setTimeout(run, <span class=\"number\">500</span>)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"图形的缩放\"><a href=\"#图形的缩放\" class=\"headerlink\" title=\"图形的缩放\"></a>图形的缩放</h3><h4 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>基于原点，基于定义的某一个点进行缩小和放大(其实还做了平移操作)</li>\n<li><p>在着色器中，逐顶点乘以缩放的倍数，对x轴和y轴同时进行缩放</p>\n<p>编写顶点着色器,定义一个cj变量，通过x轴和y轴同时乘以cj这个变量，来实现逐顶点缩放，基本代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform float cj;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.x = pos.x * cj;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.y = pos.y * cj;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.z = .0;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.w = 1.0;</span></div><div class=\"line\"><span class=\"string\">      gl_PointSize = 10.0;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>定义cjLocation，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cjLocation = cxt.getUniformLocation(program, <span class=\"string\">'cj'</span>);</div></pre></td></tr></table></figure></p>\n<p>定义基本渲染函数render，再单独定义放大缩小函数，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cj = <span class=\"number\">1.0</span>;\t</div><div class=\"line\">    render();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\">        cxt.uniform1f(cjLocation, cj);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fangda</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        cj += <span class=\"number\">.05</span>;</div><div class=\"line\">        render()</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">suoxiao</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        cj -= <span class=\"number\">.05</span>;</div><div class=\"line\">        render()</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"利用w快速缩放\"><a href=\"#利用w快速缩放\" class=\"headerlink\" title=\"利用w快速缩放\"></a>利用w快速缩放</h4><p>修改着色器代码，将vec4改成vec2，基本意思就是pos存在x和y两个点，基本修改后如下：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec2 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform float w;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = vec4(pos,0.0,w);</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>\n<p>该方法实现效果刚好和vec4的时候相反，基本原因是vec4(x/w,y/w,z/w,w),所以w越大，其实x和y轴会越小，所以最终放大效果和之前是相反的。</p>\n<h3 id=\"图形的旋转\"><a href=\"#图形的旋转\" class=\"headerlink\" title=\"图形的旋转\"></a>图形的旋转</h3><h4 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>基于原点，以一定的角度旋转</li>\n<li>在顶点着色器中，更改gl.Position.x和gl.Position.y的值</li>\n</ul>\n<h4 id=\"旋转方程\"><a href=\"#旋转方程\" class=\"headerlink\" title=\"旋转方程\"></a>旋转方程</h4><ul>\n<li>x = r.cos(a)</li>\n<li>y = r.sin(a)</li>\n<li>x1 = r.cos(a+b)</li>\n<li>y1 = r.sin(a+b)</li>\n<li>x1 = x.cos(b) - y.sin(b)</li>\n<li>y1 = x.sin(b) + y.cos(b)</li>\n<li>z1 = z = 0.0</li>\n</ul>\n<p>顶点着色器代码基本写法如下：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform float cosB;</span></div><div class=\"line\"><span class=\"string\">    uniform float sinB;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.x = pos.x * cosB - pos.y * sinB;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.y = pos.x * sinB + pos.y * cosB;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.z = .0;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.w = 1.0;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>\n<p>实现简单动画基本如下：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> angle = <span class=\"number\">10.0</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> t = <span class=\"built_in\">Math</span>.PI * angle / <span class=\"number\">180</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> cosB = <span class=\"built_in\">Math</span>.sin(t);</div><div class=\"line\">        <span class=\"keyword\">var</span> sinB = <span class=\"built_in\">Math</span>.cos(t);</div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\">        cxt.uniform1f(cosBLocation, cosB);</div><div class=\"line\">        cxt.uniform1f(sinBLocation, sinB);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        angle += <span class=\"number\">1.0</span>;</div><div class=\"line\">        render();</div><div class=\"line\">    &#125;, <span class=\"number\">1000</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"矩阵变换实现图形的移动\"><a href=\"#矩阵变换实现图形的移动\" class=\"headerlink\" title=\"矩阵变换实现图形的移动\"></a>矩阵变换实现图形的移动</h3><h4 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>图形的移动，实际上就是定量改变顶点的位置。</li>\n<li>在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。</li>\n</ul>\n<p>只要改变Tx,Ty,就能分别改变图形的x方向和y方向</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-06/1.jpeg\"></p>\n<p>在顶点着色器中定义一个xf举证变量，基本代码如下：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 xf;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = xf * pos;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>\n<p>定义一个矩阵代码：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xf = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">                    <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    Tx, Ty, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">                ]);</div></pre></td></tr></table></figure></p>\n<p>只需要通过改变Tx，Ty就能实现改变图形的移动，并不需要改变着色器代码，这样效率会很高，render函数基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Tx = <span class=\"number\">1.0</span>, Ty = <span class=\"number\">0.0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> xf = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">                    <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    Tx, Ty, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">                ]);</div><div class=\"line\">        </div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\">        cxt.uniformMatrix4fv(xfLocation,<span class=\"literal\">false</span>,xf);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    render()</div></pre></td></tr></table></figure></p>\n<h3 id=\"矩阵变换实现图形的缩放\"><a href=\"#矩阵变换实现图形的缩放\" class=\"headerlink\" title=\"矩阵变换实现图形的缩放\"></a>矩阵变换实现图形的缩放</h3><h4 id=\"原理-4\"><a href=\"#原理-4\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>基于原点。</li>\n<li>在着色器中，逐顶点乘以缩放倍数</li>\n</ul>\n<p>Sx,Sy改变就会使得图形成比例的缩放<br><img width=\"300\" src=\"/webgl-2017-07-06/2.jpeg\"></p>\n<p>主要是矩阵函数不一样，其他基本一样，代码基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> sx = <span class=\"number\">1.0</span>,</div><div class=\"line\">        sy = <span class=\"number\">1.0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> xf = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            sx, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, sy, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\"></div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\">        cxt.uniformMatrix4fv(xfLocation, <span class=\"literal\">false</span>, xf);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render()</div></pre></td></tr></table></figure></p>\n<h3 id=\"矩阵变换实现图形的旋转\"><a href=\"#矩阵变换实现图形的旋转\" class=\"headerlink\" title=\"矩阵变换实现图形的旋转\"></a>矩阵变换实现图形的旋转</h3><h4 id=\"原理-5\"><a href=\"#原理-5\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>基于原点，以一定的角度旋转。</li>\n<li>在顶点着色器中，更改 gl_Position.x 和 gl_Position.y 值。</li>\n</ul>\n<p><img width=\"300\" src=\"/webgl-2017-07-06/3.jpeg\"></p>\n<p>实现一个时钟指针的旋转，并且控制其速度和开关。</p>\n<p>定义一个顶点着色器和片元着色器，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 xf;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = xf * pos;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,.0,.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>最终render函数基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> time;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        angle += zl;</div><div class=\"line\"></div><div class=\"line\">        t = <span class=\"built_in\">Math</span>.PI * angle / <span class=\"number\">180</span>;</div><div class=\"line\">        sinB = <span class=\"built_in\">Math</span>.sin(t);</div><div class=\"line\">        cosB = <span class=\"built_in\">Math</span>.cos(t);</div><div class=\"line\">        <span class=\"keyword\">var</span> xf = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            cosB, sinB, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, -sinB, cosB, <span class=\"number\">0.0</span>, <span class=\"number\">.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">.0</span>, <span class=\"number\">.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\">        cxt.uniformMatrix4fv(xfLocation, <span class=\"literal\">false</span>, xf);</div><div class=\"line\"></div><div class=\"line\">        cxt.clearColor(<span class=\"number\">.5</span>, <span class=\"number\">.5</span>, <span class=\"number\">.5</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\"></div><div class=\"line\">        cxt.drawArrays(cxt.LINES, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</div><div class=\"line\">        time = setTimeout(render, <span class=\"number\">500</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!isOpen) &#123;</div><div class=\"line\">            clearTimeout(time);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render()</div></pre></td></tr></table></figure></p>\n<p>最终效果如下图：<br><img width=\"600\" src=\"/webgl-2017-07-06/4.jpeg\"></p>\n<h3 id=\"WebGL动画原理\"><a href=\"#WebGL动画原理\" class=\"headerlink\" title=\"WebGL动画原理\"></a>WebGL动画原理</h3><h4 id=\"原理-6\"><a href=\"#原理-6\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>通过 setTimeout 定时渲染</li>\n<li>每次渲染都用背景色刷屏</li>\n<li>每次渲染都修改变换参数</li>\n<li>变换矩阵A <em> 变换矩阵B </em> 原始顶点坐标矢量 ＝ 最终顶点坐标矢量</li>\n</ul>\n<h4 id=\"基本步骤\"><a href=\"#基本步骤\" class=\"headerlink\" title=\"基本步骤\"></a>基本步骤</h4><ul>\n<li>编写着色器代码</li>\n<li>编写基础代码</li>\n<li>编写平移和缩放代码</li>\n<li>开发平移且缩放小动画</li>\n</ul>\n<p>编写着色器代码，示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 xz;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 py;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = pos * xz * py;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,.0,.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure>\n<p>编写基础代码，上下文确定，buffer编写以及buffer数据加载等等，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cxt = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example08'</span>).getContext(<span class=\"string\">'webgl'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> buffer = cxt.createBuffer();</div><div class=\"line\">    cxt.bindBuffer(cxt.ARRAY_BUFFER, buffer);</div><div class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">0.2</span>, <span class=\"number\">-.2</span>, <span class=\"number\">-.2</span>,</div><div class=\"line\">        <span class=\"number\">.2</span>, <span class=\"number\">-.2</span>,</div><div class=\"line\">    ]);</div><div class=\"line\"></div><div class=\"line\">    cxt.bufferData(cxt.ARRAY_BUFFER, data, cxt.STATIC_DRAW);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> program = initShader(cxt, vertexShaderSource, fragmentShaderSource);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> posLocation = cxt.getAttribLocation(program, <span class=\"string\">'pos'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> xzLocation = cxt.getUniformLocation(program, <span class=\"string\">'xz'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> pyLocation = cxt.getUniformLocation(program, <span class=\"string\">'py'</span>);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    cxt.vertexAttribPointer(posLocation, <span class=\"number\">2</span>, cxt.FLOAT, <span class=\"literal\">false</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    cxt.enableVertexAttribArray(posLocation);</div></pre></td></tr></table></figure></p>\n<p>定义平移矩阵和缩放矩阵代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xz = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            cosB, sinB, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, </div><div class=\"line\">            -sinB, cosB, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\"> <span class=\"keyword\">var</span> py = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            tx, ty, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\"></div><div class=\"line\">        cxt.uniformMatrix4fv(xzLocation,<span class=\"literal\">false</span>, xz);</div><div class=\"line\">        cxt.uniformMatrix4fv(pyLocation,<span class=\"literal\">false</span>, py);       </div></pre></td></tr></table></figure></p>\n<p>最终加入setTimeOut函数的run方法代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> t = <span class=\"built_in\">Math</span>.PI * ANGLE / <span class=\"number\">180</span>;</div><div class=\"line\">        sinB = <span class=\"built_in\">Math</span>.sin(t);</div><div class=\"line\">        cosB = <span class=\"built_in\">Math</span>.cos(t);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> xz = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            cosB, sinB, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, </div><div class=\"line\">            -sinB, cosB, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\"></div><div class=\"line\">        tx += <span class=\"number\">.005</span>;</div><div class=\"line\">        ty += <span class=\"number\">.005</span>;</div><div class=\"line\"></div><div class=\"line\">        ANGLE += <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> py = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            tx, ty, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\"></div><div class=\"line\">        cxt.uniformMatrix4fv(xzLocation,<span class=\"literal\">false</span>, xz);</div><div class=\"line\">        cxt.uniformMatrix4fv(pyLocation,<span class=\"literal\">false</span>, py);</div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\"></div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        setTimeout(run, <span class=\"number\">500</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    run();     </div></pre></td></tr></table></figure>\n<h3 id=\"矩阵复合变换\"><a href=\"#矩阵复合变换\" class=\"headerlink\" title=\"矩阵复合变换\"></a>矩阵复合变换</h3><ul>\n<li>复合变换是多种变换同时进行，通过4 * 4 矩阵相乘得出来的结果，可以使用上面的示例，简化着色器中定义的矩阵变量。</li>\n</ul>\n<p>开发一个矩阵运算方法，基本原理如下图：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-06/5.jpeg\"></p>\n<p>完整方法代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mix</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>(<span class=\"number\">16</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</div><div class=\"line\">            result[i] = a[i] * b[<span class=\"number\">0</span>] + a[i + <span class=\"number\">4</span>] * b[<span class=\"number\">1</span>] + a[i + <span class=\"number\">8</span>] * b[<span class=\"number\">2</span>] + a[i + <span class=\"number\">12</span>] * b[<span class=\"number\">3</span>];</div><div class=\"line\">            result[i + <span class=\"number\">4</span>] = a[i] * b[<span class=\"number\">4</span>] + a[i + <span class=\"number\">4</span>] * b[<span class=\"number\">5</span>] + a[i + <span class=\"number\">8</span>] * b[<span class=\"number\">6</span>] + a[i + <span class=\"number\">12</span>] * b[<span class=\"number\">7</span>];</div><div class=\"line\">            result[i + <span class=\"number\">8</span>] = a[i] * b[<span class=\"number\">8</span>] + a[i + <span class=\"number\">4</span>] * b[<span class=\"number\">9</span>] + a[i + <span class=\"number\">8</span>] * b[<span class=\"number\">10</span>] + a[i + <span class=\"number\">12</span>] * b[<span class=\"number\">11</span>];</div><div class=\"line\">            result[i + <span class=\"number\">12</span>] = a[i] * b[<span class=\"number\">12</span>] + a[i + <span class=\"number\">4</span>] * b[<span class=\"number\">13</span>] + a[i + <span class=\"number\">8</span>] * b[<span class=\"number\">14</span>] + a[i + <span class=\"number\">12</span>] * b[<span class=\"number\">15</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p>简化着色器代码，基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 xf;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = pos * xf;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,.0,.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>简化Location和矩阵数据导入的函数方法，剩余代码和前面的动画原理示例一样，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xfLocation = cxt.getUniformLocation(program, <span class=\"string\">'xf'</span>);</div><div class=\"line\">cxt.uniformMatrix4fv(xfLocation, <span class=\"literal\">false</span>, mix(xz,py));</div></pre></td></tr></table></figure></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/05\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/05</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"图形的移动\"><a href=\"#图形的移动\" class=\"headerlink\" title=\"图形的移动\"></a>图形的移动</h3><h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>图形的移动，实际上就是定量改变顶点的位置。</li>\n<li>在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。</li>\n</ul>\n<p>可以使用setTimeout定时执行画点的方法，来逐一改变点的位置实现图形的移动。</p>","more":"<p>先编写顶点着色器，需要单独定义a，b来分别改变点的x方向和y方向，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">    <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform float a;</span></div><div class=\"line\"><span class=\"string\">    uniform float b;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.x = pos.x + a;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.y = pos.y + b;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.z = .0;</span></div><div class=\"line\"><span class=\"string\">      gl_PointSize = 10.0;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>\n<p>片元着色器代码和之前写法基本一致，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">    <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,0.5,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>给顶点着色器中的变量定义响应的location，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> posLocation = cxt.getAttribLocation(program, <span class=\"string\">'pos'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> aLocation = cxt.getUniformLocation(program, <span class=\"string\">'a'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> bLocation = cxt.getUniformLocation(program, <span class=\"string\">'b'</span>);</div></pre></td></tr></table></figure></p>\n<p>使用setTimeOut函数定义简单的平移效果，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">run();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        cxt.uniform1f(aLocation, a);</div><div class=\"line\">        cxt.uniform1f(bLocation, b);</div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\"></div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\">        a += <span class=\"number\">.05</span>;</div><div class=\"line\">        b += <span class=\"number\">.05</span>;</div><div class=\"line\"></div><div class=\"line\">        setTimeout(run, <span class=\"number\">500</span>)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"图形的缩放\"><a href=\"#图形的缩放\" class=\"headerlink\" title=\"图形的缩放\"></a>图形的缩放</h3><h4 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>基于原点，基于定义的某一个点进行缩小和放大(其实还做了平移操作)</li>\n<li><p>在着色器中，逐顶点乘以缩放的倍数，对x轴和y轴同时进行缩放</p>\n<p>编写顶点着色器,定义一个cj变量，通过x轴和y轴同时乘以cj这个变量，来实现逐顶点缩放，基本代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform float cj;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.x = pos.x * cj;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.y = pos.y * cj;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.z = .0;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.w = 1.0;</span></div><div class=\"line\"><span class=\"string\">      gl_PointSize = 10.0;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>定义cjLocation，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cjLocation = cxt.getUniformLocation(program, <span class=\"string\">'cj'</span>);</div></pre></td></tr></table></figure></p>\n<p>定义基本渲染函数render，再单独定义放大缩小函数，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cj = <span class=\"number\">1.0</span>;\t</div><div class=\"line\">    render();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\">        cxt.uniform1f(cjLocation, cj);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fangda</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        cj += <span class=\"number\">.05</span>;</div><div class=\"line\">        render()</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">suoxiao</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        cj -= <span class=\"number\">.05</span>;</div><div class=\"line\">        render()</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"利用w快速缩放\"><a href=\"#利用w快速缩放\" class=\"headerlink\" title=\"利用w快速缩放\"></a>利用w快速缩放</h4><p>修改着色器代码，将vec4改成vec2，基本意思就是pos存在x和y两个点，基本修改后如下：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec2 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform float w;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = vec4(pos,0.0,w);</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>\n<p>该方法实现效果刚好和vec4的时候相反，基本原因是vec4(x/w,y/w,z/w,w),所以w越大，其实x和y轴会越小，所以最终放大效果和之前是相反的。</p>\n<h3 id=\"图形的旋转\"><a href=\"#图形的旋转\" class=\"headerlink\" title=\"图形的旋转\"></a>图形的旋转</h3><h4 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>基于原点，以一定的角度旋转</li>\n<li>在顶点着色器中，更改gl.Position.x和gl.Position.y的值</li>\n</ul>\n<h4 id=\"旋转方程\"><a href=\"#旋转方程\" class=\"headerlink\" title=\"旋转方程\"></a>旋转方程</h4><ul>\n<li>x = r.cos(a)</li>\n<li>y = r.sin(a)</li>\n<li>x1 = r.cos(a+b)</li>\n<li>y1 = r.sin(a+b)</li>\n<li>x1 = x.cos(b) - y.sin(b)</li>\n<li>y1 = x.sin(b) + y.cos(b)</li>\n<li>z1 = z = 0.0</li>\n</ul>\n<p>顶点着色器代码基本写法如下：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform float cosB;</span></div><div class=\"line\"><span class=\"string\">    uniform float sinB;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.x = pos.x * cosB - pos.y * sinB;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.y = pos.x * sinB + pos.y * cosB;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.z = .0;</span></div><div class=\"line\"><span class=\"string\">      gl_Position.w = 1.0;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>\n<p>实现简单动画基本如下：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> angle = <span class=\"number\">10.0</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> t = <span class=\"built_in\">Math</span>.PI * angle / <span class=\"number\">180</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> cosB = <span class=\"built_in\">Math</span>.sin(t);</div><div class=\"line\">        <span class=\"keyword\">var</span> sinB = <span class=\"built_in\">Math</span>.cos(t);</div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\">        cxt.uniform1f(cosBLocation, cosB);</div><div class=\"line\">        cxt.uniform1f(sinBLocation, sinB);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        angle += <span class=\"number\">1.0</span>;</div><div class=\"line\">        render();</div><div class=\"line\">    &#125;, <span class=\"number\">1000</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"矩阵变换实现图形的移动\"><a href=\"#矩阵变换实现图形的移动\" class=\"headerlink\" title=\"矩阵变换实现图形的移动\"></a>矩阵变换实现图形的移动</h3><h4 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>图形的移动，实际上就是定量改变顶点的位置。</li>\n<li>在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。</li>\n</ul>\n<p>只要改变Tx,Ty,就能分别改变图形的x方向和y方向</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-06/1.jpeg\"></p>\n<p>在顶点着色器中定义一个xf举证变量，基本代码如下：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 xf;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = xf * pos;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>\n<p>定义一个矩阵代码：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xf = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">                    <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    Tx, Ty, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">                ]);</div></pre></td></tr></table></figure></p>\n<p>只需要通过改变Tx，Ty就能实现改变图形的移动，并不需要改变着色器代码，这样效率会很高，render函数基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Tx = <span class=\"number\">1.0</span>, Ty = <span class=\"number\">0.0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> xf = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">                    <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">                    Tx, Ty, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">                ]);</div><div class=\"line\">        </div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\">        cxt.uniformMatrix4fv(xfLocation,<span class=\"literal\">false</span>,xf);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    render()</div></pre></td></tr></table></figure></p>\n<h3 id=\"矩阵变换实现图形的缩放\"><a href=\"#矩阵变换实现图形的缩放\" class=\"headerlink\" title=\"矩阵变换实现图形的缩放\"></a>矩阵变换实现图形的缩放</h3><h4 id=\"原理-4\"><a href=\"#原理-4\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>基于原点。</li>\n<li>在着色器中，逐顶点乘以缩放倍数</li>\n</ul>\n<p>Sx,Sy改变就会使得图形成比例的缩放<br><img width=\"300\" src=\"/webgl-2017-07-06/2.jpeg\"></p>\n<p>主要是矩阵函数不一样，其他基本一样，代码基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> sx = <span class=\"number\">1.0</span>,</div><div class=\"line\">        sy = <span class=\"number\">1.0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> xf = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            sx, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, sy, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\"></div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\">        cxt.uniformMatrix4fv(xfLocation, <span class=\"literal\">false</span>, xf);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render()</div></pre></td></tr></table></figure></p>\n<h3 id=\"矩阵变换实现图形的旋转\"><a href=\"#矩阵变换实现图形的旋转\" class=\"headerlink\" title=\"矩阵变换实现图形的旋转\"></a>矩阵变换实现图形的旋转</h3><h4 id=\"原理-5\"><a href=\"#原理-5\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>基于原点，以一定的角度旋转。</li>\n<li>在顶点着色器中，更改 gl_Position.x 和 gl_Position.y 值。</li>\n</ul>\n<p><img width=\"300\" src=\"/webgl-2017-07-06/3.jpeg\"></p>\n<p>实现一个时钟指针的旋转，并且控制其速度和开关。</p>\n<p>定义一个顶点着色器和片元着色器，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 xf;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = xf * pos;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,.0,.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>最终render函数基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> time;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        angle += zl;</div><div class=\"line\"></div><div class=\"line\">        t = <span class=\"built_in\">Math</span>.PI * angle / <span class=\"number\">180</span>;</div><div class=\"line\">        sinB = <span class=\"built_in\">Math</span>.sin(t);</div><div class=\"line\">        cosB = <span class=\"built_in\">Math</span>.cos(t);</div><div class=\"line\">        <span class=\"keyword\">var</span> xf = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            cosB, sinB, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, -sinB, cosB, <span class=\"number\">0.0</span>, <span class=\"number\">.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">.0</span>, <span class=\"number\">.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\">        cxt.uniformMatrix4fv(xfLocation, <span class=\"literal\">false</span>, xf);</div><div class=\"line\"></div><div class=\"line\">        cxt.clearColor(<span class=\"number\">.5</span>, <span class=\"number\">.5</span>, <span class=\"number\">.5</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\"></div><div class=\"line\">        cxt.drawArrays(cxt.LINES, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</div><div class=\"line\">        time = setTimeout(render, <span class=\"number\">500</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!isOpen) &#123;</div><div class=\"line\">            clearTimeout(time);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render()</div></pre></td></tr></table></figure></p>\n<p>最终效果如下图：<br><img width=\"600\" src=\"/webgl-2017-07-06/4.jpeg\"></p>\n<h3 id=\"WebGL动画原理\"><a href=\"#WebGL动画原理\" class=\"headerlink\" title=\"WebGL动画原理\"></a>WebGL动画原理</h3><h4 id=\"原理-6\"><a href=\"#原理-6\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ul>\n<li>通过 setTimeout 定时渲染</li>\n<li>每次渲染都用背景色刷屏</li>\n<li>每次渲染都修改变换参数</li>\n<li>变换矩阵A <em> 变换矩阵B </em> 原始顶点坐标矢量 ＝ 最终顶点坐标矢量</li>\n</ul>\n<h4 id=\"基本步骤\"><a href=\"#基本步骤\" class=\"headerlink\" title=\"基本步骤\"></a>基本步骤</h4><ul>\n<li>编写着色器代码</li>\n<li>编写基础代码</li>\n<li>编写平移和缩放代码</li>\n<li>开发平移且缩放小动画</li>\n</ul>\n<p>编写着色器代码，示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 xz;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 py;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = pos * xz * py;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,.0,.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure>\n<p>编写基础代码，上下文确定，buffer编写以及buffer数据加载等等，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cxt = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example08'</span>).getContext(<span class=\"string\">'webgl'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> buffer = cxt.createBuffer();</div><div class=\"line\">    cxt.bindBuffer(cxt.ARRAY_BUFFER, buffer);</div><div class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">0.2</span>, <span class=\"number\">-.2</span>, <span class=\"number\">-.2</span>,</div><div class=\"line\">        <span class=\"number\">.2</span>, <span class=\"number\">-.2</span>,</div><div class=\"line\">    ]);</div><div class=\"line\"></div><div class=\"line\">    cxt.bufferData(cxt.ARRAY_BUFFER, data, cxt.STATIC_DRAW);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> program = initShader(cxt, vertexShaderSource, fragmentShaderSource);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> posLocation = cxt.getAttribLocation(program, <span class=\"string\">'pos'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> xzLocation = cxt.getUniformLocation(program, <span class=\"string\">'xz'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> pyLocation = cxt.getUniformLocation(program, <span class=\"string\">'py'</span>);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    cxt.vertexAttribPointer(posLocation, <span class=\"number\">2</span>, cxt.FLOAT, <span class=\"literal\">false</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    cxt.enableVertexAttribArray(posLocation);</div></pre></td></tr></table></figure></p>\n<p>定义平移矩阵和缩放矩阵代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xz = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            cosB, sinB, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, </div><div class=\"line\">            -sinB, cosB, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\"> <span class=\"keyword\">var</span> py = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            tx, ty, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\"></div><div class=\"line\">        cxt.uniformMatrix4fv(xzLocation,<span class=\"literal\">false</span>, xz);</div><div class=\"line\">        cxt.uniformMatrix4fv(pyLocation,<span class=\"literal\">false</span>, py);       </div></pre></td></tr></table></figure></p>\n<p>最终加入setTimeOut函数的run方法代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> t = <span class=\"built_in\">Math</span>.PI * ANGLE / <span class=\"number\">180</span>;</div><div class=\"line\">        sinB = <span class=\"built_in\">Math</span>.sin(t);</div><div class=\"line\">        cosB = <span class=\"built_in\">Math</span>.cos(t);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> xz = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            cosB, sinB, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, </div><div class=\"line\">            -sinB, cosB, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\"></div><div class=\"line\">        tx += <span class=\"number\">.005</span>;</div><div class=\"line\">        ty += <span class=\"number\">.005</span>;</div><div class=\"line\"></div><div class=\"line\">        ANGLE += <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> py = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">            tx, ty, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span></div><div class=\"line\">        ]);</div><div class=\"line\"></div><div class=\"line\">        cxt.uniformMatrix4fv(xzLocation,<span class=\"literal\">false</span>, xz);</div><div class=\"line\">        cxt.uniformMatrix4fv(pyLocation,<span class=\"literal\">false</span>, py);</div><div class=\"line\">        cxt.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\"></div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        setTimeout(run, <span class=\"number\">500</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    run();     </div></pre></td></tr></table></figure>\n<h3 id=\"矩阵复合变换\"><a href=\"#矩阵复合变换\" class=\"headerlink\" title=\"矩阵复合变换\"></a>矩阵复合变换</h3><ul>\n<li>复合变换是多种变换同时进行，通过4 * 4 矩阵相乘得出来的结果，可以使用上面的示例，简化着色器中定义的矩阵变量。</li>\n</ul>\n<p>开发一个矩阵运算方法，基本原理如下图：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-06/5.jpeg\"></p>\n<p>完整方法代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mix</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>(<span class=\"number\">16</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</div><div class=\"line\">            result[i] = a[i] * b[<span class=\"number\">0</span>] + a[i + <span class=\"number\">4</span>] * b[<span class=\"number\">1</span>] + a[i + <span class=\"number\">8</span>] * b[<span class=\"number\">2</span>] + a[i + <span class=\"number\">12</span>] * b[<span class=\"number\">3</span>];</div><div class=\"line\">            result[i + <span class=\"number\">4</span>] = a[i] * b[<span class=\"number\">4</span>] + a[i + <span class=\"number\">4</span>] * b[<span class=\"number\">5</span>] + a[i + <span class=\"number\">8</span>] * b[<span class=\"number\">6</span>] + a[i + <span class=\"number\">12</span>] * b[<span class=\"number\">7</span>];</div><div class=\"line\">            result[i + <span class=\"number\">8</span>] = a[i] * b[<span class=\"number\">8</span>] + a[i + <span class=\"number\">4</span>] * b[<span class=\"number\">9</span>] + a[i + <span class=\"number\">8</span>] * b[<span class=\"number\">10</span>] + a[i + <span class=\"number\">12</span>] * b[<span class=\"number\">11</span>];</div><div class=\"line\">            result[i + <span class=\"number\">12</span>] = a[i] * b[<span class=\"number\">12</span>] + a[i + <span class=\"number\">4</span>] * b[<span class=\"number\">13</span>] + a[i + <span class=\"number\">8</span>] * b[<span class=\"number\">14</span>] + a[i + <span class=\"number\">12</span>] * b[<span class=\"number\">15</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p>简化着色器代码，基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 xf;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = pos * xf;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,.0,.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>简化Location和矩阵数据导入的函数方法，剩余代码和前面的动画原理示例一样，片段代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xfLocation = cxt.getUniformLocation(program, <span class=\"string\">'xf'</span>);</div><div class=\"line\">cxt.uniformMatrix4fv(xfLocation, <span class=\"literal\">false</span>, mix(xz,py));</div></pre></td></tr></table></figure></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/05\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/05</a></p>"},{"title":"WebGL系列教程--着色器技术","comments":1,"toc":true,"date":"2017-07-08T13:09:11.000Z","_content":"\n### 数据传入顶点着色器\n\n#### 创建多个缓冲区\n\n<img width=\"300\" src=\"webgl-2017-07-08/1.jpeg\"/>\n\n例如上图显示的，创建点的坐标和创建点的大小两个缓冲区，就要在顶点着色器中创建两个attribute变量\n\n在顶点着色器中定义两个attribute变量，分别是点和点的大小，基本代码如下：\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    attribute float size;\n    void main() {\n      gl_Position = pos;\n      gl_PointSize = size;\n}`\n{% endcodeblock %}\n\n<!-- more -->\n创建program变量，代码基本如下：\n{% codeblock lang:javascript %}\nvar program = initShader(cxt, vertexShaderSource, fragmentShaderSource);\n{% endcodeblock %}\n\n使用lib库中的bindAttribute函数创建两个buffer相关代码，基本如下：\n{% codeblock lang:javascript %}\nbindAttribute(cxt, 'pos', new Float32Array([\n            0.0,0.0,\n            0.3,0.5,\n            0.2,1.0\n    ]), program, 2);\n    bindAttribute(cxt, 'size', new Float32Array([\n            10.0,20.0,30.0\n    ]), program, 1);\n{% endcodeblock %}\n\n最后调用drawArrays直接画点即可，代码如下：\n{% codeblock lang:javascript %}\ncxt.drawArrays(cxt.POINTS, 0, 3);\n{% endcodeblock %}\n\n### 偏移参数\n\n* 一个缓冲区多种用途\n* 通过偏移参数划分数据类别\n\n类数组定义方式有所变化，将点的位置和点的大小定义在一个数组中，前面两位代表点的位置，最后一位代表点的大小，基本代码如下：\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n        0.0, 0.0, 10.0,\n        0.5, 0.5, 30.0,\n        0.2, -.6, 50.0\n    ]);\n{% endcodeblock %}\n\nvertexAttribPointer函数的参数形式有所变化，data.BYTES_PER_ELEMENT代表偏移量单位，*3代表每一组数据有三个，所以*3，*2代表从偏移2两位开始计算，基本代码如下：\n{% codeblock lang:javascript %}\ncxt.vertexAttribPointer(posLocation, 2, cxt.FLOAT, false, data.BYTES_PER_ELEMENT * 3, 0);\n    cxt.vertexAttribPointer(sizeLocation, 1, cxt.FLOAT, false, data.BYTES_PER_ELEMENT * 3, data.BYTES_PER_ELEMENT * 2)\n{% endcodeblock %}\n\n\n### 顶点着色器和片元着色器通信\n\n* 通过 uniform 实现顶点和片元着色器共用数据，uniform是不可变的值\n* 通过 varying 传递数据\n\n\n着色器代码如下：\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    varying vec4 color;\n    void main() {\n      gl_Position = pos;\n      gl_PointSize = abs(pos.x) * 30.0;\n      color = pos;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `\n\t\tprecision lowp float;\n\t\tvarying vec4 color;\n        void main() {\n      gl_FragColor = color;\n  }`\n{% endcodeblock %}\n\n最终效果是根据坐标的大小和坐标的位置，显示不同的颜色，基本效果如下：\n<img width=\"300\" src=\"webgl-2017-07-08/2.jpeg\"/>\n\n编写一个渐变三角形的示例效果，使用一个buffer数据，分别定义坐标点和点的颜色值，着色器代码如下：\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    attribute vec4 vcolor;\n    varying vec4 color;\n    void main() {\n      gl_Position = pos;\n      color = vcolor;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `\n\t\tprecision lowp float;\n\t\tvarying vec4 color;\n        void main() {\n      gl_FragColor = color;\n  }`\n{% endcodeblock %}\n\nbuffer数据data代码如下：\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n        0.0, .3,  1.0 ,0.0,0.0,\n        -.5, -.5, 0.0, 1.0,0.0,\n        .5, -.5  , 0.0, 0.0,1.0\n\n    ]);\n{% endcodeblock %}\n\n最终效果效果如下：\n<img width=\"300\" src=\"webgl-2017-07-08/3.jpeg\"/>\n\n\n制作一个旋转四边形，并且四边形四个坐标系分别是不同的颜色，首先初步定义着色器代码，基本代码如下：\n\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n        uniform mat4 xf;\n    attribute vec4 pos;\n    varying vec4 vpos;\n    void main() {\n      gl_Position =  xf * pos;\n      vpos = gl_Position;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `\n\t\tprecision lowp float;\n        varying vec4 vpos;\n        void main() {\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }`\n{% endcodeblock %}\n\n获取上下文和program示例代码，利用lib库中的initShader函数，基本如下：\n\n{% codeblock lang:javascript %}\nvar cxt = document.getElementById('example06').getContext('webgl');\n\n    var program = initShader(cxt, vertexShaderSource, fragmentShaderSource);\n{% endcodeblock %}\n\n定义一个四边形相关的buffer数据内容，基本代码如下：\n\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n        -.3, .3,\n        -0.5, -.3,\n        .5, .3,\n        .3, -.3\n\n    ]);\n\n    bindAttribute(cxt,'pos',data,program);\n{% endcodeblock %}\n\n定义着色器中定义的xf变量相关代码，并且创建旋转矩阵，定义旋转角度等，基本如下：\n{% codeblock lang:javascript %}\nvar xfLocation = cxt.getUniformLocation(program,'xf');\nvar angle = 0;\nrun()\n    function run() {\n        angle++\n        var xzm = createXZMatrix(angle);\n        cxt.uniformMatrix4fv(xfLocation, false, xzm);\n        cxt.drawArrays(cxt.TRIANGLE_STRIP, 0, 4);\n        setTimeout(run, 100)\n    }\n{% endcodeblock %}\n\n此时的效果是四边形可以旋转，但是颜色还是之前定义的红色，基本效果如下：\n\n<img width=\"300\" src=\"webgl-2017-07-08/6.jpeg\"/>\n\n通过修改片元着色器中的代码实现不同象限中显示不同颜色，基本代码如下：\n{% codeblock lang:javascript %}\n// 片元着色器程序\n    const fragmentShaderSource =\n        `\n\t\tprecision lowp float;\n        varying vec4 vpos;\n        void main() {\n      if(vpos.x >= 0.0 && vpos.y >= 0.0){\n                   gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n               }else if(vpos.x >0.0 && vpos.y < 0.0){\n                   gl_FragColor = vec4(0.0,1.0,0.0,1.0);\n               }else if(vpos.x < 0.0 && vpos.y > 0.0){\n                   gl_FragColor = vec4(0.0,0.0,1.0,1.0);\n               }else{\n                   gl_FragColor = vec4(0.2,0.2,0.2,1.0);\n            }\n  }`\n\n{% endcodeblock %}\n\n修改完之后，最终效果如下：\n<img width=\"300\" src=\"webgl-2017-07-08/7.jpeg\"/>\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/06","source":"_posts/webgl-2017-07-08.md","raw":"---\ntitle: WebGL系列教程--着色器技术\ncomments: true\ntoc: true\ndate: 2017-07-08 21:09:11\ntags:\n    - 'javascript'\n    - 'webgl'\n---\n\n### 数据传入顶点着色器\n\n#### 创建多个缓冲区\n\n<img width=\"300\" src=\"webgl-2017-07-08/1.jpeg\"/>\n\n例如上图显示的，创建点的坐标和创建点的大小两个缓冲区，就要在顶点着色器中创建两个attribute变量\n\n在顶点着色器中定义两个attribute变量，分别是点和点的大小，基本代码如下：\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    attribute float size;\n    void main() {\n      gl_Position = pos;\n      gl_PointSize = size;\n}`\n{% endcodeblock %}\n\n<!-- more -->\n创建program变量，代码基本如下：\n{% codeblock lang:javascript %}\nvar program = initShader(cxt, vertexShaderSource, fragmentShaderSource);\n{% endcodeblock %}\n\n使用lib库中的bindAttribute函数创建两个buffer相关代码，基本如下：\n{% codeblock lang:javascript %}\nbindAttribute(cxt, 'pos', new Float32Array([\n            0.0,0.0,\n            0.3,0.5,\n            0.2,1.0\n    ]), program, 2);\n    bindAttribute(cxt, 'size', new Float32Array([\n            10.0,20.0,30.0\n    ]), program, 1);\n{% endcodeblock %}\n\n最后调用drawArrays直接画点即可，代码如下：\n{% codeblock lang:javascript %}\ncxt.drawArrays(cxt.POINTS, 0, 3);\n{% endcodeblock %}\n\n### 偏移参数\n\n* 一个缓冲区多种用途\n* 通过偏移参数划分数据类别\n\n类数组定义方式有所变化，将点的位置和点的大小定义在一个数组中，前面两位代表点的位置，最后一位代表点的大小，基本代码如下：\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n        0.0, 0.0, 10.0,\n        0.5, 0.5, 30.0,\n        0.2, -.6, 50.0\n    ]);\n{% endcodeblock %}\n\nvertexAttribPointer函数的参数形式有所变化，data.BYTES_PER_ELEMENT代表偏移量单位，*3代表每一组数据有三个，所以*3，*2代表从偏移2两位开始计算，基本代码如下：\n{% codeblock lang:javascript %}\ncxt.vertexAttribPointer(posLocation, 2, cxt.FLOAT, false, data.BYTES_PER_ELEMENT * 3, 0);\n    cxt.vertexAttribPointer(sizeLocation, 1, cxt.FLOAT, false, data.BYTES_PER_ELEMENT * 3, data.BYTES_PER_ELEMENT * 2)\n{% endcodeblock %}\n\n\n### 顶点着色器和片元着色器通信\n\n* 通过 uniform 实现顶点和片元着色器共用数据，uniform是不可变的值\n* 通过 varying 传递数据\n\n\n着色器代码如下：\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    varying vec4 color;\n    void main() {\n      gl_Position = pos;\n      gl_PointSize = abs(pos.x) * 30.0;\n      color = pos;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `\n\t\tprecision lowp float;\n\t\tvarying vec4 color;\n        void main() {\n      gl_FragColor = color;\n  }`\n{% endcodeblock %}\n\n最终效果是根据坐标的大小和坐标的位置，显示不同的颜色，基本效果如下：\n<img width=\"300\" src=\"webgl-2017-07-08/2.jpeg\"/>\n\n编写一个渐变三角形的示例效果，使用一个buffer数据，分别定义坐标点和点的颜色值，着色器代码如下：\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 pos;\n    attribute vec4 vcolor;\n    varying vec4 color;\n    void main() {\n      gl_Position = pos;\n      color = vcolor;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `\n\t\tprecision lowp float;\n\t\tvarying vec4 color;\n        void main() {\n      gl_FragColor = color;\n  }`\n{% endcodeblock %}\n\nbuffer数据data代码如下：\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n        0.0, .3,  1.0 ,0.0,0.0,\n        -.5, -.5, 0.0, 1.0,0.0,\n        .5, -.5  , 0.0, 0.0,1.0\n\n    ]);\n{% endcodeblock %}\n\n最终效果效果如下：\n<img width=\"300\" src=\"webgl-2017-07-08/3.jpeg\"/>\n\n\n制作一个旋转四边形，并且四边形四个坐标系分别是不同的颜色，首先初步定义着色器代码，基本代码如下：\n\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n        uniform mat4 xf;\n    attribute vec4 pos;\n    varying vec4 vpos;\n    void main() {\n      gl_Position =  xf * pos;\n      vpos = gl_Position;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `\n\t\tprecision lowp float;\n        varying vec4 vpos;\n        void main() {\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }`\n{% endcodeblock %}\n\n获取上下文和program示例代码，利用lib库中的initShader函数，基本如下：\n\n{% codeblock lang:javascript %}\nvar cxt = document.getElementById('example06').getContext('webgl');\n\n    var program = initShader(cxt, vertexShaderSource, fragmentShaderSource);\n{% endcodeblock %}\n\n定义一个四边形相关的buffer数据内容，基本代码如下：\n\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n        -.3, .3,\n        -0.5, -.3,\n        .5, .3,\n        .3, -.3\n\n    ]);\n\n    bindAttribute(cxt,'pos',data,program);\n{% endcodeblock %}\n\n定义着色器中定义的xf变量相关代码，并且创建旋转矩阵，定义旋转角度等，基本如下：\n{% codeblock lang:javascript %}\nvar xfLocation = cxt.getUniformLocation(program,'xf');\nvar angle = 0;\nrun()\n    function run() {\n        angle++\n        var xzm = createXZMatrix(angle);\n        cxt.uniformMatrix4fv(xfLocation, false, xzm);\n        cxt.drawArrays(cxt.TRIANGLE_STRIP, 0, 4);\n        setTimeout(run, 100)\n    }\n{% endcodeblock %}\n\n此时的效果是四边形可以旋转，但是颜色还是之前定义的红色，基本效果如下：\n\n<img width=\"300\" src=\"webgl-2017-07-08/6.jpeg\"/>\n\n通过修改片元着色器中的代码实现不同象限中显示不同颜色，基本代码如下：\n{% codeblock lang:javascript %}\n// 片元着色器程序\n    const fragmentShaderSource =\n        `\n\t\tprecision lowp float;\n        varying vec4 vpos;\n        void main() {\n      if(vpos.x >= 0.0 && vpos.y >= 0.0){\n                   gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n               }else if(vpos.x >0.0 && vpos.y < 0.0){\n                   gl_FragColor = vec4(0.0,1.0,0.0,1.0);\n               }else if(vpos.x < 0.0 && vpos.y > 0.0){\n                   gl_FragColor = vec4(0.0,0.0,1.0,1.0);\n               }else{\n                   gl_FragColor = vec4(0.2,0.2,0.2,1.0);\n            }\n  }`\n\n{% endcodeblock %}\n\n修改完之后，最终效果如下：\n<img width=\"300\" src=\"webgl-2017-07-08/7.jpeg\"/>\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/06","slug":"webgl-2017-07-08","published":1,"updated":"2017-10-06T11:47:22.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36s1000zlmlddith6oqk","content":"<h3 id=\"数据传入顶点着色器\"><a href=\"#数据传入顶点着色器\" class=\"headerlink\" title=\"数据传入顶点着色器\"></a>数据传入顶点着色器</h3><h4 id=\"创建多个缓冲区\"><a href=\"#创建多个缓冲区\" class=\"headerlink\" title=\"创建多个缓冲区\"></a>创建多个缓冲区</h4><p><img width=\"300\" src=\"/webgl-2017-07-08/1.jpeg\"></p>\n<p>例如上图显示的，创建点的坐标和创建点的大小两个缓冲区，就要在顶点着色器中创建两个attribute变量</p>\n<p>在顶点着色器中定义两个attribute变量，分别是点和点的大小，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    attribute float size;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = pos;</span></div><div class=\"line\"><span class=\"string\">      gl_PointSize = size;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>创建program变量，代码基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> program = initShader(cxt, vertexShaderSource, fragmentShaderSource);</div></pre></td></tr></table></figure></p>\n<p>使用lib库中的bindAttribute函数创建两个buffer相关代码，基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">bindAttribute(cxt, <span class=\"string\">'pos'</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            <span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.3</span>,<span class=\"number\">0.5</span>,</div><div class=\"line\">            <span class=\"number\">0.2</span>,<span class=\"number\">1.0</span></div><div class=\"line\">    ]), program, <span class=\"number\">2</span>);</div><div class=\"line\">    bindAttribute(cxt, <span class=\"string\">'size'</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            <span class=\"number\">10.0</span>,<span class=\"number\">20.0</span>,<span class=\"number\">30.0</span></div><div class=\"line\">    ]), program, <span class=\"number\">1</span>);</div></pre></td></tr></table></figure></p>\n<p>最后调用drawArrays直接画点即可，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.drawArrays(cxt.POINTS, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<h3 id=\"偏移参数\"><a href=\"#偏移参数\" class=\"headerlink\" title=\"偏移参数\"></a>偏移参数</h3><ul>\n<li>一个缓冲区多种用途</li>\n<li>通过偏移参数划分数据类别</li>\n</ul>\n<p>类数组定义方式有所变化，将点的位置和点的大小定义在一个数组中，前面两位代表点的位置，最后一位代表点的大小，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">10.0</span>,</div><div class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">30.0</span>,</div><div class=\"line\">        <span class=\"number\">0.2</span>, <span class=\"number\">-.6</span>, <span class=\"number\">50.0</span></div><div class=\"line\">    ]);</div></pre></td></tr></table></figure></p>\n<p>vertexAttribPointer函数的参数形式有所变化，data.BYTES_PER_ELEMENT代表偏移量单位，<em>3代表每一组数据有三个，所以</em>3，*2代表从偏移2两位开始计算，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.vertexAttribPointer(posLocation, <span class=\"number\">2</span>, cxt.FLOAT, <span class=\"literal\">false</span>, data.BYTES_PER_ELEMENT * <span class=\"number\">3</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    cxt.vertexAttribPointer(sizeLocation, <span class=\"number\">1</span>, cxt.FLOAT, <span class=\"literal\">false</span>, data.BYTES_PER_ELEMENT * <span class=\"number\">3</span>, data.BYTES_PER_ELEMENT * <span class=\"number\">2</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"顶点着色器和片元着色器通信\"><a href=\"#顶点着色器和片元着色器通信\" class=\"headerlink\" title=\"顶点着色器和片元着色器通信\"></a>顶点着色器和片元着色器通信</h3><ul>\n<li>通过 uniform 实现顶点和片元着色器共用数据，uniform是不可变的值</li>\n<li>通过 varying 传递数据</li>\n</ul>\n<p>着色器代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 color;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = pos;</span></div><div class=\"line\"><span class=\"string\">      gl_PointSize = abs(pos.x) * 30.0;</span></div><div class=\"line\"><span class=\"string\">      color = pos;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t\tprecision lowp float;</span></div><div class=\"line\"><span class=\"string\">\t\tvarying vec4 color;</span></div><div class=\"line\"><span class=\"string\">        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = color;</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>最终效果是根据坐标的大小和坐标的位置，显示不同的颜色，基本效果如下：<br><img width=\"300\" src=\"/webgl-2017-07-08/2.jpeg\"></p>\n<p>编写一个渐变三角形的示例效果，使用一个buffer数据，分别定义坐标点和点的颜色值，着色器代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 vcolor;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 color;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = pos;</span></div><div class=\"line\"><span class=\"string\">      color = vcolor;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t\tprecision lowp float;</span></div><div class=\"line\"><span class=\"string\">\t\tvarying vec4 color;</span></div><div class=\"line\"><span class=\"string\">        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = color;</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>buffer数据data代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">.3</span>,  <span class=\"number\">1.0</span> ,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,</div><div class=\"line\">        <span class=\"number\">-.5</span>, <span class=\"number\">-.5</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,</div><div class=\"line\">        <span class=\"number\">.5</span>, <span class=\"number\">-.5</span>  , <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,<span class=\"number\">1.0</span></div><div class=\"line\"></div><div class=\"line\">    ]);</div></pre></td></tr></table></figure></p>\n<p>最终效果效果如下：<br><img width=\"300\" src=\"/webgl-2017-07-08/3.jpeg\"></p>\n<p>制作一个旋转四边形，并且四边形四个坐标系分别是不同的颜色，首先初步定义着色器代码，基本代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">        uniform mat4 xf;</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 vpos;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position =  xf * pos;</span></div><div class=\"line\"><span class=\"string\">      vpos = gl_Position;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t\tprecision lowp float;</span></div><div class=\"line\"><span class=\"string\">        varying vec4 vpos;</span></div><div class=\"line\"><span class=\"string\">        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,0.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure>\n<p>获取上下文和program示例代码，利用lib库中的initShader函数，基本如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cxt = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example06'</span>).getContext(<span class=\"string\">'webgl'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> program = initShader(cxt, vertexShaderSource, fragmentShaderSource);</div></pre></td></tr></table></figure>\n<p>定义一个四边形相关的buffer数据内容，基本代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">-.3</span>, <span class=\"number\">.3</span>,</div><div class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">-.3</span>,</div><div class=\"line\">        <span class=\"number\">.5</span>, <span class=\"number\">.3</span>,</div><div class=\"line\">        <span class=\"number\">.3</span>, <span class=\"number\">-.3</span></div><div class=\"line\"></div><div class=\"line\">    ]);</div><div class=\"line\"></div><div class=\"line\">    bindAttribute(cxt,<span class=\"string\">'pos'</span>,data,program);</div></pre></td></tr></table></figure>\n<p>定义着色器中定义的xf变量相关代码，并且创建旋转矩阵，定义旋转角度等，基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xfLocation = cxt.getUniformLocation(program,<span class=\"string\">'xf'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> angle = <span class=\"number\">0</span>;</div><div class=\"line\">run()</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        angle++</div><div class=\"line\">        <span class=\"keyword\">var</span> xzm = createXZMatrix(angle);</div><div class=\"line\">        cxt.uniformMatrix4fv(xfLocation, <span class=\"literal\">false</span>, xzm);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLE_STRIP, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</div><div class=\"line\">        setTimeout(run, <span class=\"number\">100</span>)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>此时的效果是四边形可以旋转，但是颜色还是之前定义的红色，基本效果如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-08/6.jpeg\"></p>\n<p>通过修改片元着色器中的代码实现不同象限中显示不同颜色，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t\tprecision lowp float;</span></div><div class=\"line\"><span class=\"string\">        varying vec4 vpos;</span></div><div class=\"line\"><span class=\"string\">        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      if(vpos.x &gt;= 0.0 &amp;&amp; vpos.y &gt;= 0.0)&#123;</span></div><div class=\"line\"><span class=\"string\">                   gl_FragColor = vec4(1.0,0.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">               &#125;else if(vpos.x &gt;0.0 &amp;&amp; vpos.y &lt; 0.0)&#123;</span></div><div class=\"line\"><span class=\"string\">                   gl_FragColor = vec4(0.0,1.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">               &#125;else if(vpos.x &lt; 0.0 &amp;&amp; vpos.y &gt; 0.0)&#123;</span></div><div class=\"line\"><span class=\"string\">                   gl_FragColor = vec4(0.0,0.0,1.0,1.0);</span></div><div class=\"line\"><span class=\"string\">               &#125;else&#123;</span></div><div class=\"line\"><span class=\"string\">                   gl_FragColor = vec4(0.2,0.2,0.2,1.0);</span></div><div class=\"line\"><span class=\"string\">            &#125;</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p>修改完之后，最终效果如下：<br><img width=\"300\" src=\"/webgl-2017-07-08/7.jpeg\"></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/06\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/06</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"数据传入顶点着色器\"><a href=\"#数据传入顶点着色器\" class=\"headerlink\" title=\"数据传入顶点着色器\"></a>数据传入顶点着色器</h3><h4 id=\"创建多个缓冲区\"><a href=\"#创建多个缓冲区\" class=\"headerlink\" title=\"创建多个缓冲区\"></a>创建多个缓冲区</h4><p><img width=\"300\" src=\"/webgl-2017-07-08/1.jpeg\"></p>\n<p>例如上图显示的，创建点的坐标和创建点的大小两个缓冲区，就要在顶点着色器中创建两个attribute变量</p>\n<p>在顶点着色器中定义两个attribute变量，分别是点和点的大小，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    attribute float size;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = pos;</span></div><div class=\"line\"><span class=\"string\">      gl_PointSize = size;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div></pre></td></tr></table></figure></p>","more":"<p>创建program变量，代码基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> program = initShader(cxt, vertexShaderSource, fragmentShaderSource);</div></pre></td></tr></table></figure></p>\n<p>使用lib库中的bindAttribute函数创建两个buffer相关代码，基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">bindAttribute(cxt, <span class=\"string\">'pos'</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            <span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,</div><div class=\"line\">            <span class=\"number\">0.3</span>,<span class=\"number\">0.5</span>,</div><div class=\"line\">            <span class=\"number\">0.2</span>,<span class=\"number\">1.0</span></div><div class=\"line\">    ]), program, <span class=\"number\">2</span>);</div><div class=\"line\">    bindAttribute(cxt, <span class=\"string\">'size'</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">            <span class=\"number\">10.0</span>,<span class=\"number\">20.0</span>,<span class=\"number\">30.0</span></div><div class=\"line\">    ]), program, <span class=\"number\">1</span>);</div></pre></td></tr></table></figure></p>\n<p>最后调用drawArrays直接画点即可，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.drawArrays(cxt.POINTS, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<h3 id=\"偏移参数\"><a href=\"#偏移参数\" class=\"headerlink\" title=\"偏移参数\"></a>偏移参数</h3><ul>\n<li>一个缓冲区多种用途</li>\n<li>通过偏移参数划分数据类别</li>\n</ul>\n<p>类数组定义方式有所变化，将点的位置和点的大小定义在一个数组中，前面两位代表点的位置，最后一位代表点的大小，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">10.0</span>,</div><div class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">30.0</span>,</div><div class=\"line\">        <span class=\"number\">0.2</span>, <span class=\"number\">-.6</span>, <span class=\"number\">50.0</span></div><div class=\"line\">    ]);</div></pre></td></tr></table></figure></p>\n<p>vertexAttribPointer函数的参数形式有所变化，data.BYTES_PER_ELEMENT代表偏移量单位，<em>3代表每一组数据有三个，所以</em>3，*2代表从偏移2两位开始计算，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cxt.vertexAttribPointer(posLocation, <span class=\"number\">2</span>, cxt.FLOAT, <span class=\"literal\">false</span>, data.BYTES_PER_ELEMENT * <span class=\"number\">3</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    cxt.vertexAttribPointer(sizeLocation, <span class=\"number\">1</span>, cxt.FLOAT, <span class=\"literal\">false</span>, data.BYTES_PER_ELEMENT * <span class=\"number\">3</span>, data.BYTES_PER_ELEMENT * <span class=\"number\">2</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"顶点着色器和片元着色器通信\"><a href=\"#顶点着色器和片元着色器通信\" class=\"headerlink\" title=\"顶点着色器和片元着色器通信\"></a>顶点着色器和片元着色器通信</h3><ul>\n<li>通过 uniform 实现顶点和片元着色器共用数据，uniform是不可变的值</li>\n<li>通过 varying 传递数据</li>\n</ul>\n<p>着色器代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 color;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = pos;</span></div><div class=\"line\"><span class=\"string\">      gl_PointSize = abs(pos.x) * 30.0;</span></div><div class=\"line\"><span class=\"string\">      color = pos;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t\tprecision lowp float;</span></div><div class=\"line\"><span class=\"string\">\t\tvarying vec4 color;</span></div><div class=\"line\"><span class=\"string\">        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = color;</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>最终效果是根据坐标的大小和坐标的位置，显示不同的颜色，基本效果如下：<br><img width=\"300\" src=\"/webgl-2017-07-08/2.jpeg\"></p>\n<p>编写一个渐变三角形的示例效果，使用一个buffer数据，分别定义坐标点和点的颜色值，着色器代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 vcolor;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 color;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = pos;</span></div><div class=\"line\"><span class=\"string\">      color = vcolor;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t\tprecision lowp float;</span></div><div class=\"line\"><span class=\"string\">\t\tvarying vec4 color;</span></div><div class=\"line\"><span class=\"string\">        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = color;</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>buffer数据data代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">.3</span>,  <span class=\"number\">1.0</span> ,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,</div><div class=\"line\">        <span class=\"number\">-.5</span>, <span class=\"number\">-.5</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,</div><div class=\"line\">        <span class=\"number\">.5</span>, <span class=\"number\">-.5</span>  , <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,<span class=\"number\">1.0</span></div><div class=\"line\"></div><div class=\"line\">    ]);</div></pre></td></tr></table></figure></p>\n<p>最终效果效果如下：<br><img width=\"300\" src=\"/webgl-2017-07-08/3.jpeg\"></p>\n<p>制作一个旋转四边形，并且四边形四个坐标系分别是不同的颜色，首先初步定义着色器代码，基本代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">        uniform mat4 xf;</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 vpos;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position =  xf * pos;</span></div><div class=\"line\"><span class=\"string\">      vpos = gl_Position;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t\tprecision lowp float;</span></div><div class=\"line\"><span class=\"string\">        varying vec4 vpos;</span></div><div class=\"line\"><span class=\"string\">        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = vec4(1.0,0.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure>\n<p>获取上下文和program示例代码，利用lib库中的initShader函数，基本如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cxt = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example06'</span>).getContext(<span class=\"string\">'webgl'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> program = initShader(cxt, vertexShaderSource, fragmentShaderSource);</div></pre></td></tr></table></figure>\n<p>定义一个四边形相关的buffer数据内容，基本代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">-.3</span>, <span class=\"number\">.3</span>,</div><div class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">-.3</span>,</div><div class=\"line\">        <span class=\"number\">.5</span>, <span class=\"number\">.3</span>,</div><div class=\"line\">        <span class=\"number\">.3</span>, <span class=\"number\">-.3</span></div><div class=\"line\"></div><div class=\"line\">    ]);</div><div class=\"line\"></div><div class=\"line\">    bindAttribute(cxt,<span class=\"string\">'pos'</span>,data,program);</div></pre></td></tr></table></figure>\n<p>定义着色器中定义的xf变量相关代码，并且创建旋转矩阵，定义旋转角度等，基本如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xfLocation = cxt.getUniformLocation(program,<span class=\"string\">'xf'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> angle = <span class=\"number\">0</span>;</div><div class=\"line\">run()</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        angle++</div><div class=\"line\">        <span class=\"keyword\">var</span> xzm = createXZMatrix(angle);</div><div class=\"line\">        cxt.uniformMatrix4fv(xfLocation, <span class=\"literal\">false</span>, xzm);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLE_STRIP, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</div><div class=\"line\">        setTimeout(run, <span class=\"number\">100</span>)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>此时的效果是四边形可以旋转，但是颜色还是之前定义的红色，基本效果如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-08/6.jpeg\"></p>\n<p>通过修改片元着色器中的代码实现不同象限中显示不同颜色，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t\tprecision lowp float;</span></div><div class=\"line\"><span class=\"string\">        varying vec4 vpos;</span></div><div class=\"line\"><span class=\"string\">        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      if(vpos.x &gt;= 0.0 &amp;&amp; vpos.y &gt;= 0.0)&#123;</span></div><div class=\"line\"><span class=\"string\">                   gl_FragColor = vec4(1.0,0.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">               &#125;else if(vpos.x &gt;0.0 &amp;&amp; vpos.y &lt; 0.0)&#123;</span></div><div class=\"line\"><span class=\"string\">                   gl_FragColor = vec4(0.0,1.0,0.0,1.0);</span></div><div class=\"line\"><span class=\"string\">               &#125;else if(vpos.x &lt; 0.0 &amp;&amp; vpos.y &gt; 0.0)&#123;</span></div><div class=\"line\"><span class=\"string\">                   gl_FragColor = vec4(0.0,0.0,1.0,1.0);</span></div><div class=\"line\"><span class=\"string\">               &#125;else&#123;</span></div><div class=\"line\"><span class=\"string\">                   gl_FragColor = vec4(0.2,0.2,0.2,1.0);</span></div><div class=\"line\"><span class=\"string\">            &#125;</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p>修改完之后，最终效果如下：<br><img width=\"300\" src=\"/webgl-2017-07-08/7.jpeg\"></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/06\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/06</a></p>"},{"title":"WebGL系列教程--视点与视线","comments":1,"toc":true,"date":"2017-07-09T13:09:11.000Z","_content":"\n### 视点、目标点和上方向\n\n* 视点：观察者所在的三维世界中的位置。\n* 目标点：被观察的目标所在的位置。\n* 上方向：相机正上方的方向。\n\n#### 试图矩阵\n\n* 默认情况下，视点位于坐标系原点\n* lookAt(out, eye, center, up)\n* eye 指定视点\n* center  指定观察点\n* up  指定向上方向\n\n<!-- more -->\n\n定义顶点着色器和片元着色器代码，在定义着色器代码中，需要定义点的坐标，点的颜色，矩阵，和片元着色器通信的颜色变量\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 a_Position;\n    attribute vec4 a_Color;\n    uniform mat4 u_vmatrix;\n    varying vec4 v_Color;\n    void main() {\n      gl_Position = u_vmatrix * a_Position;\n      v_Color = a_Color;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `\n        precision lowp float;\n        varying vec4 v_Color;\n        void main() {\n      gl_FragColor = v_Color;\n  }`\n{% endcodeblock %}\n\n定义几个公共工具类函数，基本代码如下：\n{% codeblock lang:javascript %}\nfunction normalize(v){\n        var sum = 0;\n        for (var i=0;i< v.length;i++){\n            sum += v[i] * v[i];\n        }\n        var result = Math.sqrt(sum);\n        for(var j=0;j< v.length; j++){\n            v[i] = v[i] / result;\n        }\n    }\n\n    function cross(a,b){\n        var nX = a[1] * b[2] - a[2] * b[1];\n        var nY = a[2] * b[0] -a[0] * b[2];\n        var nZ = a[0] * b[1] - a[1] * b[0];\n\n        return new Float32Array([nX,nY,nZ]);\n    }\n\n    function dot(a,b){\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    }\n\n    function minus(a , b){\n        return new Float32Array([a[0] - b[0], a[1] - b[1] , a[2] - b[2]]);\n    }\n{% endcodeblock %}\n\n通过工具类函数创建一个新的视图矩阵，基本代码如下：\n{% codeblock lang:javascript %}\nfunction getVMatrix(){\n\n        var eye = new Float32Array([0.4,0.0,0.26]);\n        var lookat = new Float32Array([0.0,0.0,0.0]);\n        var up = new Float32Array([0,1,1]);\n\n        var zA = minus(eye , lookat);\n        normalize(zA);\n\n        normalize(up);\n        var xA = cross(up, zA);\n\n        var yA = cross(zA,xA);\n\n        return new Float32Array([\n                xA[0],yA[0],zA[0], 0,\n                xA[1],yA[1],zA[1], 0,\n                xA[2],yA[2],zA[2], 0,\n                - dot(xA,eye), -dot(yA,eye),-dot(zA,eye),1\n\n        ])\n\n    }\n{% endcodeblock %}\n\n创建三角形类型化数组，基本代码如下：\n{% codeblock lang:javascript %}\n\nvar data = new Float32Array([\n        0.0, 0.5, -0.4, 0.4, 1.0, 0.4,\n        -0.5, -0.5, -0.4, 0.4, 1.0, 0.4,\n        0.5, -0.5, -0.4, 1.0, 0.4, 0.4,\n\n        0.5, 0.4, -0.2, 1.0, 0.4, 0.4,\n        -0.5, 0.4, -0.2, 1.0, 1.0, 0.4,\n        0.0, -0.6, -0.2, 1.0, 1.0, 0.4\n    ]);\n{% endcodeblock %}\n\n视图矩阵数据添加，基本代码如下：\n{% codeblock lang:javascript %}\n\nvar u_vmatrixLocation = cxt.getUniformLocation(program,'u_vmatrix');\n\nvar mx = getVMatrix(); // 视图矩阵\n\ncxt.uniformMatrix4fv(u_vmatrixLocation,false,mx);\n{% endcodeblock %}\n\n最终效果如下：\n\n<img width=\"300\" src=\"webgl-2017-07-09/1.jpeg\"/>\n\n### 视点控制\n\n* 旋转后顶点坐标 ＝ 旋转矩阵 * 原始顶点坐标\n* （从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 * 旋转后顶点坐标\n* （从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 * 旋转矩阵 * 原始顶点坐标\n* 视图矩阵 * 模型矩阵 * 原始顶点坐标\n\n添加键盘控制视点位置，基本代码如下：\n{% codeblock lang:javascript %}\n\nvar eyeX = 0.25;\n\n    function draw(eyeX){\n\n        var mx = getVMatrix(eyeX); // 视图矩阵\n\n        cxt.uniformMatrix4fv(u_vmatrixLocation,false,mx);\n\n        cxt.clearColor(1.0,1.0,1.0,1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n\n        cxt.drawArrays(cxt.TRIANGLES,0,6);\n\n    }\n\n    document.addEventListener('keydown', function (event) {\n        switch (event.keyCode){\n            case 37:\n                eyeX += .01;\n                break;\n            case 39:\n                eyeX -= .01;\n                break;\n        }\n        draw(eyeX);\n\n    });\n\n    draw(eyeX);\n{% endcodeblock %}\n\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/09","source":"_posts/webgl-2017-07-09.md","raw":"---\ntitle: WebGL系列教程--视点与视线\ncomments: true\ntoc: true\ndate: 2017-07-09 21:09:11\ntags:\n    - 'javascript'\n    - 'webgl'\n---\n\n### 视点、目标点和上方向\n\n* 视点：观察者所在的三维世界中的位置。\n* 目标点：被观察的目标所在的位置。\n* 上方向：相机正上方的方向。\n\n#### 试图矩阵\n\n* 默认情况下，视点位于坐标系原点\n* lookAt(out, eye, center, up)\n* eye 指定视点\n* center  指定观察点\n* up  指定向上方向\n\n<!-- more -->\n\n定义顶点着色器和片元着色器代码，在定义着色器代码中，需要定义点的坐标，点的颜色，矩阵，和片元着色器通信的颜色变量\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n    attribute vec4 a_Position;\n    attribute vec4 a_Color;\n    uniform mat4 u_vmatrix;\n    varying vec4 v_Color;\n    void main() {\n      gl_Position = u_vmatrix * a_Position;\n      v_Color = a_Color;\n}`\n\n    // 片元着色器程序\n    const fragmentShaderSource =\n        `\n        precision lowp float;\n        varying vec4 v_Color;\n        void main() {\n      gl_FragColor = v_Color;\n  }`\n{% endcodeblock %}\n\n定义几个公共工具类函数，基本代码如下：\n{% codeblock lang:javascript %}\nfunction normalize(v){\n        var sum = 0;\n        for (var i=0;i< v.length;i++){\n            sum += v[i] * v[i];\n        }\n        var result = Math.sqrt(sum);\n        for(var j=0;j< v.length; j++){\n            v[i] = v[i] / result;\n        }\n    }\n\n    function cross(a,b){\n        var nX = a[1] * b[2] - a[2] * b[1];\n        var nY = a[2] * b[0] -a[0] * b[2];\n        var nZ = a[0] * b[1] - a[1] * b[0];\n\n        return new Float32Array([nX,nY,nZ]);\n    }\n\n    function dot(a,b){\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    }\n\n    function minus(a , b){\n        return new Float32Array([a[0] - b[0], a[1] - b[1] , a[2] - b[2]]);\n    }\n{% endcodeblock %}\n\n通过工具类函数创建一个新的视图矩阵，基本代码如下：\n{% codeblock lang:javascript %}\nfunction getVMatrix(){\n\n        var eye = new Float32Array([0.4,0.0,0.26]);\n        var lookat = new Float32Array([0.0,0.0,0.0]);\n        var up = new Float32Array([0,1,1]);\n\n        var zA = minus(eye , lookat);\n        normalize(zA);\n\n        normalize(up);\n        var xA = cross(up, zA);\n\n        var yA = cross(zA,xA);\n\n        return new Float32Array([\n                xA[0],yA[0],zA[0], 0,\n                xA[1],yA[1],zA[1], 0,\n                xA[2],yA[2],zA[2], 0,\n                - dot(xA,eye), -dot(yA,eye),-dot(zA,eye),1\n\n        ])\n\n    }\n{% endcodeblock %}\n\n创建三角形类型化数组，基本代码如下：\n{% codeblock lang:javascript %}\n\nvar data = new Float32Array([\n        0.0, 0.5, -0.4, 0.4, 1.0, 0.4,\n        -0.5, -0.5, -0.4, 0.4, 1.0, 0.4,\n        0.5, -0.5, -0.4, 1.0, 0.4, 0.4,\n\n        0.5, 0.4, -0.2, 1.0, 0.4, 0.4,\n        -0.5, 0.4, -0.2, 1.0, 1.0, 0.4,\n        0.0, -0.6, -0.2, 1.0, 1.0, 0.4\n    ]);\n{% endcodeblock %}\n\n视图矩阵数据添加，基本代码如下：\n{% codeblock lang:javascript %}\n\nvar u_vmatrixLocation = cxt.getUniformLocation(program,'u_vmatrix');\n\nvar mx = getVMatrix(); // 视图矩阵\n\ncxt.uniformMatrix4fv(u_vmatrixLocation,false,mx);\n{% endcodeblock %}\n\n最终效果如下：\n\n<img width=\"300\" src=\"webgl-2017-07-09/1.jpeg\"/>\n\n### 视点控制\n\n* 旋转后顶点坐标 ＝ 旋转矩阵 * 原始顶点坐标\n* （从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 * 旋转后顶点坐标\n* （从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 * 旋转矩阵 * 原始顶点坐标\n* 视图矩阵 * 模型矩阵 * 原始顶点坐标\n\n添加键盘控制视点位置，基本代码如下：\n{% codeblock lang:javascript %}\n\nvar eyeX = 0.25;\n\n    function draw(eyeX){\n\n        var mx = getVMatrix(eyeX); // 视图矩阵\n\n        cxt.uniformMatrix4fv(u_vmatrixLocation,false,mx);\n\n        cxt.clearColor(1.0,1.0,1.0,1.0);\n        cxt.clear(cxt.COLOR_BUFFER_BIT);\n\n        cxt.drawArrays(cxt.TRIANGLES,0,6);\n\n    }\n\n    document.addEventListener('keydown', function (event) {\n        switch (event.keyCode){\n            case 37:\n                eyeX += .01;\n                break;\n            case 39:\n                eyeX -= .01;\n                break;\n        }\n        draw(eyeX);\n\n    });\n\n    draw(eyeX);\n{% endcodeblock %}\n\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/09","slug":"webgl-2017-07-09","published":1,"updated":"2017-10-15T02:20:21.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36s30012lmld43a139rf","content":"<h3 id=\"视点、目标点和上方向\"><a href=\"#视点、目标点和上方向\" class=\"headerlink\" title=\"视点、目标点和上方向\"></a>视点、目标点和上方向</h3><ul>\n<li>视点：观察者所在的三维世界中的位置。</li>\n<li>目标点：被观察的目标所在的位置。</li>\n<li>上方向：相机正上方的方向。</li>\n</ul>\n<h4 id=\"试图矩阵\"><a href=\"#试图矩阵\" class=\"headerlink\" title=\"试图矩阵\"></a>试图矩阵</h4><ul>\n<li>默认情况下，视点位于坐标系原点</li>\n<li>lookAt(out, eye, center, up)</li>\n<li>eye 指定视点</li>\n<li>center  指定观察点</li>\n<li>up  指定向上方向</li>\n</ul>\n<a id=\"more\"></a>\n<p>定义顶点着色器和片元着色器代码，在定义着色器代码中，需要定义点的坐标，点的颜色，矩阵，和片元着色器通信的颜色变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 a_Position;</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 a_Color;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 u_vmatrix;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = u_vmatrix * a_Position;</span></div><div class=\"line\"><span class=\"string\">      v_Color = a_Color;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">        precision lowp float;</span></div><div class=\"line\"><span class=\"string\">        varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\">        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = v_Color;</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>定义几个公共工具类函数，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalize</span>(<span class=\"params\">v</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt; v.length;i++)&#123;</div><div class=\"line\">            sum += v[i] * v[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">var</span> result = <span class=\"built_in\">Math</span>.sqrt(sum);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j=<span class=\"number\">0</span>;j&lt; v.length; j++)&#123;</div><div class=\"line\">            v[i] = v[i] / result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cross</span>(<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> nX = a[<span class=\"number\">1</span>] * b[<span class=\"number\">2</span>] - a[<span class=\"number\">2</span>] * b[<span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"keyword\">var</span> nY = a[<span class=\"number\">2</span>] * b[<span class=\"number\">0</span>] -a[<span class=\"number\">0</span>] * b[<span class=\"number\">2</span>];</div><div class=\"line\">        <span class=\"keyword\">var</span> nZ = a[<span class=\"number\">0</span>] * b[<span class=\"number\">1</span>] - a[<span class=\"number\">1</span>] * b[<span class=\"number\">0</span>];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([nX,nY,nZ]);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dot</span>(<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] * b[<span class=\"number\">0</span>] + a[<span class=\"number\">1</span>] * b[<span class=\"number\">1</span>] + a[<span class=\"number\">2</span>] * b[<span class=\"number\">2</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minus</span>(<span class=\"params\">a , b</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([a[<span class=\"number\">0</span>] - b[<span class=\"number\">0</span>], a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>] , a[<span class=\"number\">2</span>] - b[<span class=\"number\">2</span>]]);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>通过工具类函数创建一个新的视图矩阵，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getVMatrix</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> eye = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([<span class=\"number\">0.4</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.26</span>]);</div><div class=\"line\">        <span class=\"keyword\">var</span> lookat = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>]);</div><div class=\"line\">        <span class=\"keyword\">var</span> up = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>]);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> zA = minus(eye , lookat);</div><div class=\"line\">        normalize(zA);</div><div class=\"line\"></div><div class=\"line\">        normalize(up);</div><div class=\"line\">        <span class=\"keyword\">var</span> xA = cross(up, zA);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> yA = cross(zA,xA);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">                xA[<span class=\"number\">0</span>],yA[<span class=\"number\">0</span>],zA[<span class=\"number\">0</span>], <span class=\"number\">0</span>,</div><div class=\"line\">                xA[<span class=\"number\">1</span>],yA[<span class=\"number\">1</span>],zA[<span class=\"number\">1</span>], <span class=\"number\">0</span>,</div><div class=\"line\">                xA[<span class=\"number\">2</span>],yA[<span class=\"number\">2</span>],zA[<span class=\"number\">2</span>], <span class=\"number\">0</span>,</div><div class=\"line\">                - dot(xA,eye), -dot(yA,eye),-dot(zA,eye),<span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\">        ])</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>创建三角形类型化数组，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">-0.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">-0.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">-0.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\"></div><div class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">0.4</span>, <span class=\"number\">-0.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">0.4</span>, <span class=\"number\">-0.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">-0.6</span>, <span class=\"number\">-0.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span></div><div class=\"line\">    ]);</div></pre></td></tr></table></figure></p>\n<p>视图矩阵数据添加，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> u_vmatrixLocation = cxt.getUniformLocation(program,<span class=\"string\">'u_vmatrix'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> mx = getVMatrix(); <span class=\"comment\">// 视图矩阵</span></div><div class=\"line\"></div><div class=\"line\">cxt.uniformMatrix4fv(u_vmatrixLocation,<span class=\"literal\">false</span>,mx);</div></pre></td></tr></table></figure></p>\n<p>最终效果如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-09/1.jpeg\"></p>\n<h3 id=\"视点控制\"><a href=\"#视点控制\" class=\"headerlink\" title=\"视点控制\"></a>视点控制</h3><ul>\n<li>旋转后顶点坐标 ＝ 旋转矩阵 * 原始顶点坐标</li>\n<li>（从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 * 旋转后顶点坐标</li>\n<li>（从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 <em> 旋转矩阵 </em> 原始顶点坐标</li>\n<li>视图矩阵 <em> 模型矩阵 </em> 原始顶点坐标</li>\n</ul>\n<p>添加键盘控制视点位置，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> eyeX = <span class=\"number\">0.25</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\">eyeX</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> mx = getVMatrix(eyeX); <span class=\"comment\">// 视图矩阵</span></div><div class=\"line\"></div><div class=\"line\">        cxt.uniformMatrix4fv(u_vmatrixLocation,<span class=\"literal\">false</span>,mx);</div><div class=\"line\"></div><div class=\"line\">        cxt.clearColor(<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\"></div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES,<span class=\"number\">0</span>,<span class=\"number\">6</span>);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'keydown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (event.keyCode)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">37</span>:</div><div class=\"line\">                eyeX += <span class=\"number\">.01</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">39</span>:</div><div class=\"line\">                eyeX -= <span class=\"number\">.01</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        draw(eyeX);</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    draw(eyeX);</div></pre></td></tr></table></figure></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/09\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/09</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"视点、目标点和上方向\"><a href=\"#视点、目标点和上方向\" class=\"headerlink\" title=\"视点、目标点和上方向\"></a>视点、目标点和上方向</h3><ul>\n<li>视点：观察者所在的三维世界中的位置。</li>\n<li>目标点：被观察的目标所在的位置。</li>\n<li>上方向：相机正上方的方向。</li>\n</ul>\n<h4 id=\"试图矩阵\"><a href=\"#试图矩阵\" class=\"headerlink\" title=\"试图矩阵\"></a>试图矩阵</h4><ul>\n<li>默认情况下，视点位于坐标系原点</li>\n<li>lookAt(out, eye, center, up)</li>\n<li>eye 指定视点</li>\n<li>center  指定观察点</li>\n<li>up  指定向上方向</li>\n</ul>","more":"<p>定义顶点着色器和片元着色器代码，在定义着色器代码中，需要定义点的坐标，点的颜色，矩阵，和片元着色器通信的颜色变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 a_Position;</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 a_Color;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 u_vmatrix;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\">    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_Position = u_vmatrix * a_Position;</span></div><div class=\"line\"><span class=\"string\">      v_Color = a_Color;</span></div><div class=\"line\"><span class=\"string\">&#125;`</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">        precision lowp float;</span></div><div class=\"line\"><span class=\"string\">        varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\">        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">      gl_FragColor = v_Color;</span></div><div class=\"line\"><span class=\"string\">  &#125;`</span></div></pre></td></tr></table></figure></p>\n<p>定义几个公共工具类函数，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalize</span>(<span class=\"params\">v</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt; v.length;i++)&#123;</div><div class=\"line\">            sum += v[i] * v[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">var</span> result = <span class=\"built_in\">Math</span>.sqrt(sum);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j=<span class=\"number\">0</span>;j&lt; v.length; j++)&#123;</div><div class=\"line\">            v[i] = v[i] / result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cross</span>(<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> nX = a[<span class=\"number\">1</span>] * b[<span class=\"number\">2</span>] - a[<span class=\"number\">2</span>] * b[<span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"keyword\">var</span> nY = a[<span class=\"number\">2</span>] * b[<span class=\"number\">0</span>] -a[<span class=\"number\">0</span>] * b[<span class=\"number\">2</span>];</div><div class=\"line\">        <span class=\"keyword\">var</span> nZ = a[<span class=\"number\">0</span>] * b[<span class=\"number\">1</span>] - a[<span class=\"number\">1</span>] * b[<span class=\"number\">0</span>];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([nX,nY,nZ]);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dot</span>(<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] * b[<span class=\"number\">0</span>] + a[<span class=\"number\">1</span>] * b[<span class=\"number\">1</span>] + a[<span class=\"number\">2</span>] * b[<span class=\"number\">2</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minus</span>(<span class=\"params\">a , b</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([a[<span class=\"number\">0</span>] - b[<span class=\"number\">0</span>], a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>] , a[<span class=\"number\">2</span>] - b[<span class=\"number\">2</span>]]);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>通过工具类函数创建一个新的视图矩阵，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getVMatrix</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> eye = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([<span class=\"number\">0.4</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.26</span>]);</div><div class=\"line\">        <span class=\"keyword\">var</span> lookat = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>]);</div><div class=\"line\">        <span class=\"keyword\">var</span> up = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>]);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> zA = minus(eye , lookat);</div><div class=\"line\">        normalize(zA);</div><div class=\"line\"></div><div class=\"line\">        normalize(up);</div><div class=\"line\">        <span class=\"keyword\">var</span> xA = cross(up, zA);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> yA = cross(zA,xA);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">                xA[<span class=\"number\">0</span>],yA[<span class=\"number\">0</span>],zA[<span class=\"number\">0</span>], <span class=\"number\">0</span>,</div><div class=\"line\">                xA[<span class=\"number\">1</span>],yA[<span class=\"number\">1</span>],zA[<span class=\"number\">1</span>], <span class=\"number\">0</span>,</div><div class=\"line\">                xA[<span class=\"number\">2</span>],yA[<span class=\"number\">2</span>],zA[<span class=\"number\">2</span>], <span class=\"number\">0</span>,</div><div class=\"line\">                - dot(xA,eye), -dot(yA,eye),-dot(zA,eye),<span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\">        ])</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>创建三角形类型化数组，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">-0.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">-0.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">-0.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\"></div><div class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">0.4</span>, <span class=\"number\">-0.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">0.4</span>, <span class=\"number\">-0.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">        <span class=\"number\">0.0</span>, <span class=\"number\">-0.6</span>, <span class=\"number\">-0.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span></div><div class=\"line\">    ]);</div></pre></td></tr></table></figure></p>\n<p>视图矩阵数据添加，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> u_vmatrixLocation = cxt.getUniformLocation(program,<span class=\"string\">'u_vmatrix'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> mx = getVMatrix(); <span class=\"comment\">// 视图矩阵</span></div><div class=\"line\"></div><div class=\"line\">cxt.uniformMatrix4fv(u_vmatrixLocation,<span class=\"literal\">false</span>,mx);</div></pre></td></tr></table></figure></p>\n<p>最终效果如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-09/1.jpeg\"></p>\n<h3 id=\"视点控制\"><a href=\"#视点控制\" class=\"headerlink\" title=\"视点控制\"></a>视点控制</h3><ul>\n<li>旋转后顶点坐标 ＝ 旋转矩阵 * 原始顶点坐标</li>\n<li>（从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 * 旋转后顶点坐标</li>\n<li>（从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 <em> 旋转矩阵 </em> 原始顶点坐标</li>\n<li>视图矩阵 <em> 模型矩阵 </em> 原始顶点坐标</li>\n</ul>\n<p>添加键盘控制视点位置，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> eyeX = <span class=\"number\">0.25</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\">eyeX</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> mx = getVMatrix(eyeX); <span class=\"comment\">// 视图矩阵</span></div><div class=\"line\"></div><div class=\"line\">        cxt.uniformMatrix4fv(u_vmatrixLocation,<span class=\"literal\">false</span>,mx);</div><div class=\"line\"></div><div class=\"line\">        cxt.clearColor(<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>);</div><div class=\"line\">        cxt.clear(cxt.COLOR_BUFFER_BIT);</div><div class=\"line\"></div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLES,<span class=\"number\">0</span>,<span class=\"number\">6</span>);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'keydown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (event.keyCode)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">37</span>:</div><div class=\"line\">                eyeX += <span class=\"number\">.01</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">39</span>:</div><div class=\"line\">                eyeX -= <span class=\"number\">.01</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        draw(eyeX);</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    draw(eyeX);</div></pre></td></tr></table></figure></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/09\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/09</a></p>"},{"title":"WebGL系列教程--可视范围","comments":1,"toc":true,"date":"2017-07-11T13:09:11.000Z","_content":"\n### 可视范围基础\n\n#### 盒状空间\n\n* 长方体可是空间，也叫盒状空间，是由正射投影产生。\n* 可视锥体空间，由透视投影产生。\n\n在透视投影下，产生的三维场景看上去更是有深度感，更加自然，因为我们平时观察真实世界用的也是透视投影。在大多数情况下，比如三维射击类游戏中，我们都应该采用透视投影。相比之下，正射投影的好处是用户可以方便的比较场景中物体的大小，这是因为物体看上去的大小与其所在的位置没有关系。在建筑平面图等技术绘图的相关场合，应当使用这种投影。\n\n<!-- more -->\n\n#### 盒状空间的工作原理\n\n盒状可视空间的由前后两个矩形表面确定，分别称近裁剪面和远裁剪面，前者的四个顶点为（right,top,-near）,(-left,top,-near),(-left,-bottom,-near),(right,-bottom,-near),而后者的四个顶点为(right,top,far),(-left,top,far),(-left,-bottom,far),(right,-bottom,far).\n\n<img width=\"300\" src=\"webgl-2017-07-11/01.jpeg\"/>\n\n<canvas>上显示的就是可视空间中物体在近裁剪面上的投。如果裁剪面的高宽比和<canvas>不一样，那么画面就会被按照<canvas>的高宽比进行压缩，物体会被扭曲。近裁剪面与远裁剪面之间的盒形空间就是可是空间，只有在此空间内的物体会被显示出来。如果某个物体一部分在可视空间内，一部分在其外，那就只显示可视空间内的部分。\n\n### 正射投影矩阵\n\n#### 函数\n\n* setOrtho(left , right , bottom , top , near , far)\n* left / right / bottom / top 参数含义：定位范围。\n* near  参数含义：近裁切面。\n* far  参数含义：远裁切面。\n\n基本方程式如下：\n\n<img width=\"300\" src=\"webgl-2017-07-11/2.jpeg\"/>\n\n写一个正射投影实例代码，核心代码如下：\n\n编写顶点着色器和片元着色器代码，定义一个uniform矩阵变量。\n{% codeblock lang:javascript %}\nvar vertexShaderSource = `\n    attribute vec4 pos;\n    uniform mat4 u_mx;\n    attribute vec4 a_Color;\n    varying vec4 v_Color;\n\n    void main(){\n        gl_Position = u_mx * pos;\n        v_Color = a_Color;\n    }\n`\n\nvar fragmentShaderSource = `\n    precision lowp float;\n    varying vec4 v_Color;\n    void main(){\n        gl_FragColor = v_Color;\n    }\n`  \n{% endcodeblock %}\n\n定义一个正射矩阵的方法\n{% codeblock lang:javascript %}\nfunction getOMX(left,right,bottom,top,near,far){\n\n    return new Float32Array([\n        2 / (right - left), 0, 0, 0,\n        0, 2 / (top - bottom), 0, 0,\n        0, 0, -2 / (far - near), 0,\n        -(right + left) / (right - left),\n        -(top + bottom) / (top - bottom),\n        -(far + near) / (far - near),\n        1\n    ]);\n\n}\nvar near = 0.0;\nvar far = .5;\n\nvar omx = getOMX(-.5,.5, -.5,.5, near , far);    \n{% endcodeblock %}\n\n\n定义数据data类型化数组\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n    0.0, 0.6, -.4, 0.4, 1.0, 0.4,\n    -.45, -.4, -.51, .4, 1.0, .4,\n    0.5, -.4, -.4, 1.0, .4, .4,\n\n    .5, .4, -.2, 1.0, .4, .4,\n    -.5, .4, -.2, 1.0, 1.0, .3,\n    .0, -.6, -.2, 1.0, 1.0, .4\n]);   \n{% endcodeblock %}\n\n由于定义的far为.5,而data类型化数组数据一个三角形的坐标为-.51，实际效果会产生一个缺角，可以根据改变三角形的顶点来看不同的效果，最终效果如下图：\n\n<img width=\"300\" src=\"webgl-2017-07-11/3.jpeg\"/>\n\n### 缺角的修补\n\n* 将远裁面移到距离视点更远的地方。\n* <正射投影矩阵> * <视图矩阵> * <顶点坐标>\n\n代码效果如下：\n\n<img width=\"300\" src=\"webgl-2017-07-11/4.jpeg\"/>\n\n### 透视投影\n\n#### 基础\n\n* 透视投影和正射投影基本一致，但存在一些参数差异。使得远处的物体看起来比较小，一般在游戏开发会用的比较多。\n* 可视空间顶面和底面的夹角必须大于0。\n* 指定近裁面的宽高比例。\n\n<img width=\"300\" src=\"webgl-2017-07-11/5.jpeg\"/>\n\n后面的三角形会根据与视点的距离做相应的缩放，并且做相应的平移。\n\n#### 透视投影矩阵\n\n### 矩阵公式\n\n<img width=\"500\" src=\"webgl-2017-07-11/6.jpeg\"/>\n\n通过一个示例来解释透视投影具体的效果。\n\n定义着色器代码：\n\n{% codeblock lang:javascript %}\nvar vertexShaderSource = `\n    attribute vec4 pos;\n    uniform mat4 u_mx;\n    attribute vec4 a_Color;\n    varying vec4 v_Color;\n\n    void main(){\n        gl_Position = u_mx * pos;\n        v_Color = a_Color;\n    }\n`\n\nvar fragmentShaderSource = `\n    precision lowp float;\n    varying vec4 v_Color;\n    void main(){\n        gl_FragColor = v_Color;\n    }\n`   \n{% endcodeblock %}\n\n创建program代码：\n\n{% codeblock lang:javascript %}\nvar gl = canvas.getContext('webgl');\n\nvar program = initShader(gl,vertexShaderSource,fragmentShaderSource); \n{% endcodeblock %}\n\n定义创建透视投影矩阵函数方法：\n\n{% codeblock lang:javascript %}\n/**\n * 创建透视投影矩阵\n * fov 指定垂直视角\n * aspect 宽度 ／ 高度\n * near  近裁切面\n * far  远裁切面\n */\nfunction getTS(fov,aspect,near,far){\n    fov = fov * Math.PI / 180; // 弧度\n    return new Float32Array([\n        1 / (aspect * Math.tan(fov / 2)), 0, 0, 0,\n        0, 1 / Math.tan(fov / 2), 0, 0,\n        0, 0, -(far + near) / (far - near), -1,\n        0, 0, -2 * (far * near) / (far - near), 0\n    ]);\n}\n{% endcodeblock %}\n\n创建ata，并且将data绑定到创建的buffer上：\n\n{% codeblock lang:javascript %}\n// 四个三角形\nvar buffer_data = new Float32Array([\n\n    0.75, 1.0, -.8, 1.0, 1.0, .4,\n    .25, -1.0, -.8, 1.0, 1.0, .4,\n    1.0, -1.0, -.8, 1.0, .4, .4,\n\n    .75, 1.0, 0.8, .4, .4, 1.0,\n    .25, -1.0, .8, .4, .4, 1.0,\n    1.0, -1.0, .8, 1.0, .4, .4,\n\n\n    // 第一个三角形\n    -.75, 1.0, -.8, 1.0, 1.0, .4,\n    -1.0, -1.0, -.8, 1.0, 1.0, 0.4,\n    -0.25, -1.0, -.8, 1.0, .4, .4,\n\n    -.75, 1.0, .8, .4, .4, 1.0,\n    -1.0, -1.0, .8, .4, .4, 1.0,\n    -.25, -1.0, .8, 1.0, .4, .4\n\n]);\n\nvar buffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\ngl.bufferData(gl.ARRAY_BUFFER, buffer_data, gl.STATIC_DRAW);\n{% endcodeblock %}\n\n得到Location，并且给其赋值：\n\n{% codeblock lang:javascript %}\nvar posLocation = gl.getAttribLocation(program, 'pos');\nvar aColorLocation = gl.getAttribLocation(program, 'a_Color');\nvar uMXLocation = gl.getUniformLocation(program, 'u_mx');\n\nvar BYTES_SIZE = buffer_data.BYTES_PER_ELEMENT;\n\ngl.vertexAttribPointer(posLocation, 3, gl.FLOAT, false, BYTES_SIZE * 6, 0);\ngl.vertexAttribPointer(aColorLocation, 3, gl.FLOAT, false, BYTES_SIZE * 6, BYTES_SIZE * 3);\ngl.enableVertexAttribArray(posLocation);\ngl.enableVertexAttribArray(aColorLocation);\n{% endcodeblock %}\n\n定义一个绘图函数方法，并且执行，其中getVMatrix和multiplyMatrix是lib库中的函数：\n\n{% codeblock lang:javascript %}\nfunction draw() {\n\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    var mx = getTS(30, canvas.width / canvas.height, 1, 100);\n    var vmx = getVMatrix(0,0,5,0,0,-100);\n    gl.uniformMatrix4fv(uMXLocation,false,multiplyMatrix(mx,vmx));\n\n    gl.drawArrays(gl.TRIANGLES, 0, 12);\n}\n\ndraw();\n{% endcodeblock %}\n\n最终运行结果如下：\n\n<img width=\"400\" src=\"webgl-2017-07-11/7.jpeg\"/>\n\n#### 物体前后关系\n\n* 默认情况下，WebGL 是按照顶点在缓冲区中的顺序绘制的。\n* 后绘制的会遮挡先绘制的图形。\n\n例如将上面的示例中的data数据顺序该下，就会出现以下的效果：\n\n{% codeblock lang:javascript %}\n// 四个三角形\nvar buffer_data = new Float32Array([\n\n    .75, 1.0, 0.8, .4, .4, 1.0,\n    .25, -1.0, .8, .4, .4, 1.0,\n    1.0, -1.0, .8, 1.0, .4, .4,\n\n    0.75, 1.0, -.8, 1.0, 1.0, .4,\n    .25, -1.0, -.8, 1.0, 1.0, .4,\n    1.0, -1.0, -.8, 1.0, .4, .4,\n\n    -.75, 1.0, .8, .4, .4, 1.0,\n    -1.0, -1.0, .8, .4, .4, 1.0,\n    -.25, -1.0, .8, 1.0, .4, .4,\n\n    -.75, 1.0, -.8, 1.0, 1.0, .4,\n    -1.0, -1.0, -.8, 1.0, 1.0, 0.4,\n    -0.25, -1.0, -.8, 1.0, .4, .4,\n\n]);\n{% endcodeblock %}\n\n<img width=\"400\" src=\"webgl-2017-07-11/8.jpeg\"/>\n\n但是实际情况中，可能很多图像并不知道出现的顺序，webgl提供了两个方法来解决这类问题。\n\n#### 解决方法\n\n* 启动隐藏面消除\n* 启动多边形偏移\n\n核心代码如下：\n\n{% codeblock lang:javascript %}\ngl.enable(gl.DEPTH_TEST);\ngl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n{% endcodeblock %}\n\n这样做之后，离视点远的对象会在后面展示。\n\n#### 深度冲突\n\n隐藏面消除是WebGL的一项复杂而又强大的特效，在绝大多数情况下，它都能很好地完成任务。然而，当几何图形或物体的两个表面极为接近时，就会出现新的问题，使得表面看上去斑斑驳驳的，这种现象被称为深度冲突（Z fighting）\n\n当所有的三角形一起绘画的时候，似乎不会出现这种情况，但是如果分开画三角形，可能会出现深度冲突的问题，通过以下代码可以解决：\n\n{% codeblock lang:javascript %}\ngl.enable(gl.POLYGON_OFFSET_FILL);\ngl.drawArrays(gl.TRIANGLES, 0, 3);\ngl.polygonOffset(1.0, 1.0);   \ngl.drawArrays(gl.TRIANGLES, 3, 3);\n{% endcodeblock %}\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/11","source":"_posts/webgl-2017-07-11.md","raw":"---\ntitle: WebGL系列教程--可视范围\ncomments: true\ntoc: true\ndate: 2017-07-11 21:09:11\ntags:\n    - 'javascript'\n    - 'webgl'\n---\n\n### 可视范围基础\n\n#### 盒状空间\n\n* 长方体可是空间，也叫盒状空间，是由正射投影产生。\n* 可视锥体空间，由透视投影产生。\n\n在透视投影下，产生的三维场景看上去更是有深度感，更加自然，因为我们平时观察真实世界用的也是透视投影。在大多数情况下，比如三维射击类游戏中，我们都应该采用透视投影。相比之下，正射投影的好处是用户可以方便的比较场景中物体的大小，这是因为物体看上去的大小与其所在的位置没有关系。在建筑平面图等技术绘图的相关场合，应当使用这种投影。\n\n<!-- more -->\n\n#### 盒状空间的工作原理\n\n盒状可视空间的由前后两个矩形表面确定，分别称近裁剪面和远裁剪面，前者的四个顶点为（right,top,-near）,(-left,top,-near),(-left,-bottom,-near),(right,-bottom,-near),而后者的四个顶点为(right,top,far),(-left,top,far),(-left,-bottom,far),(right,-bottom,far).\n\n<img width=\"300\" src=\"webgl-2017-07-11/01.jpeg\"/>\n\n<canvas>上显示的就是可视空间中物体在近裁剪面上的投。如果裁剪面的高宽比和<canvas>不一样，那么画面就会被按照<canvas>的高宽比进行压缩，物体会被扭曲。近裁剪面与远裁剪面之间的盒形空间就是可是空间，只有在此空间内的物体会被显示出来。如果某个物体一部分在可视空间内，一部分在其外，那就只显示可视空间内的部分。\n\n### 正射投影矩阵\n\n#### 函数\n\n* setOrtho(left , right , bottom , top , near , far)\n* left / right / bottom / top 参数含义：定位范围。\n* near  参数含义：近裁切面。\n* far  参数含义：远裁切面。\n\n基本方程式如下：\n\n<img width=\"300\" src=\"webgl-2017-07-11/2.jpeg\"/>\n\n写一个正射投影实例代码，核心代码如下：\n\n编写顶点着色器和片元着色器代码，定义一个uniform矩阵变量。\n{% codeblock lang:javascript %}\nvar vertexShaderSource = `\n    attribute vec4 pos;\n    uniform mat4 u_mx;\n    attribute vec4 a_Color;\n    varying vec4 v_Color;\n\n    void main(){\n        gl_Position = u_mx * pos;\n        v_Color = a_Color;\n    }\n`\n\nvar fragmentShaderSource = `\n    precision lowp float;\n    varying vec4 v_Color;\n    void main(){\n        gl_FragColor = v_Color;\n    }\n`  \n{% endcodeblock %}\n\n定义一个正射矩阵的方法\n{% codeblock lang:javascript %}\nfunction getOMX(left,right,bottom,top,near,far){\n\n    return new Float32Array([\n        2 / (right - left), 0, 0, 0,\n        0, 2 / (top - bottom), 0, 0,\n        0, 0, -2 / (far - near), 0,\n        -(right + left) / (right - left),\n        -(top + bottom) / (top - bottom),\n        -(far + near) / (far - near),\n        1\n    ]);\n\n}\nvar near = 0.0;\nvar far = .5;\n\nvar omx = getOMX(-.5,.5, -.5,.5, near , far);    \n{% endcodeblock %}\n\n\n定义数据data类型化数组\n{% codeblock lang:javascript %}\nvar data = new Float32Array([\n    0.0, 0.6, -.4, 0.4, 1.0, 0.4,\n    -.45, -.4, -.51, .4, 1.0, .4,\n    0.5, -.4, -.4, 1.0, .4, .4,\n\n    .5, .4, -.2, 1.0, .4, .4,\n    -.5, .4, -.2, 1.0, 1.0, .3,\n    .0, -.6, -.2, 1.0, 1.0, .4\n]);   \n{% endcodeblock %}\n\n由于定义的far为.5,而data类型化数组数据一个三角形的坐标为-.51，实际效果会产生一个缺角，可以根据改变三角形的顶点来看不同的效果，最终效果如下图：\n\n<img width=\"300\" src=\"webgl-2017-07-11/3.jpeg\"/>\n\n### 缺角的修补\n\n* 将远裁面移到距离视点更远的地方。\n* <正射投影矩阵> * <视图矩阵> * <顶点坐标>\n\n代码效果如下：\n\n<img width=\"300\" src=\"webgl-2017-07-11/4.jpeg\"/>\n\n### 透视投影\n\n#### 基础\n\n* 透视投影和正射投影基本一致，但存在一些参数差异。使得远处的物体看起来比较小，一般在游戏开发会用的比较多。\n* 可视空间顶面和底面的夹角必须大于0。\n* 指定近裁面的宽高比例。\n\n<img width=\"300\" src=\"webgl-2017-07-11/5.jpeg\"/>\n\n后面的三角形会根据与视点的距离做相应的缩放，并且做相应的平移。\n\n#### 透视投影矩阵\n\n### 矩阵公式\n\n<img width=\"500\" src=\"webgl-2017-07-11/6.jpeg\"/>\n\n通过一个示例来解释透视投影具体的效果。\n\n定义着色器代码：\n\n{% codeblock lang:javascript %}\nvar vertexShaderSource = `\n    attribute vec4 pos;\n    uniform mat4 u_mx;\n    attribute vec4 a_Color;\n    varying vec4 v_Color;\n\n    void main(){\n        gl_Position = u_mx * pos;\n        v_Color = a_Color;\n    }\n`\n\nvar fragmentShaderSource = `\n    precision lowp float;\n    varying vec4 v_Color;\n    void main(){\n        gl_FragColor = v_Color;\n    }\n`   \n{% endcodeblock %}\n\n创建program代码：\n\n{% codeblock lang:javascript %}\nvar gl = canvas.getContext('webgl');\n\nvar program = initShader(gl,vertexShaderSource,fragmentShaderSource); \n{% endcodeblock %}\n\n定义创建透视投影矩阵函数方法：\n\n{% codeblock lang:javascript %}\n/**\n * 创建透视投影矩阵\n * fov 指定垂直视角\n * aspect 宽度 ／ 高度\n * near  近裁切面\n * far  远裁切面\n */\nfunction getTS(fov,aspect,near,far){\n    fov = fov * Math.PI / 180; // 弧度\n    return new Float32Array([\n        1 / (aspect * Math.tan(fov / 2)), 0, 0, 0,\n        0, 1 / Math.tan(fov / 2), 0, 0,\n        0, 0, -(far + near) / (far - near), -1,\n        0, 0, -2 * (far * near) / (far - near), 0\n    ]);\n}\n{% endcodeblock %}\n\n创建ata，并且将data绑定到创建的buffer上：\n\n{% codeblock lang:javascript %}\n// 四个三角形\nvar buffer_data = new Float32Array([\n\n    0.75, 1.0, -.8, 1.0, 1.0, .4,\n    .25, -1.0, -.8, 1.0, 1.0, .4,\n    1.0, -1.0, -.8, 1.0, .4, .4,\n\n    .75, 1.0, 0.8, .4, .4, 1.0,\n    .25, -1.0, .8, .4, .4, 1.0,\n    1.0, -1.0, .8, 1.0, .4, .4,\n\n\n    // 第一个三角形\n    -.75, 1.0, -.8, 1.0, 1.0, .4,\n    -1.0, -1.0, -.8, 1.0, 1.0, 0.4,\n    -0.25, -1.0, -.8, 1.0, .4, .4,\n\n    -.75, 1.0, .8, .4, .4, 1.0,\n    -1.0, -1.0, .8, .4, .4, 1.0,\n    -.25, -1.0, .8, 1.0, .4, .4\n\n]);\n\nvar buffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\ngl.bufferData(gl.ARRAY_BUFFER, buffer_data, gl.STATIC_DRAW);\n{% endcodeblock %}\n\n得到Location，并且给其赋值：\n\n{% codeblock lang:javascript %}\nvar posLocation = gl.getAttribLocation(program, 'pos');\nvar aColorLocation = gl.getAttribLocation(program, 'a_Color');\nvar uMXLocation = gl.getUniformLocation(program, 'u_mx');\n\nvar BYTES_SIZE = buffer_data.BYTES_PER_ELEMENT;\n\ngl.vertexAttribPointer(posLocation, 3, gl.FLOAT, false, BYTES_SIZE * 6, 0);\ngl.vertexAttribPointer(aColorLocation, 3, gl.FLOAT, false, BYTES_SIZE * 6, BYTES_SIZE * 3);\ngl.enableVertexAttribArray(posLocation);\ngl.enableVertexAttribArray(aColorLocation);\n{% endcodeblock %}\n\n定义一个绘图函数方法，并且执行，其中getVMatrix和multiplyMatrix是lib库中的函数：\n\n{% codeblock lang:javascript %}\nfunction draw() {\n\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    var mx = getTS(30, canvas.width / canvas.height, 1, 100);\n    var vmx = getVMatrix(0,0,5,0,0,-100);\n    gl.uniformMatrix4fv(uMXLocation,false,multiplyMatrix(mx,vmx));\n\n    gl.drawArrays(gl.TRIANGLES, 0, 12);\n}\n\ndraw();\n{% endcodeblock %}\n\n最终运行结果如下：\n\n<img width=\"400\" src=\"webgl-2017-07-11/7.jpeg\"/>\n\n#### 物体前后关系\n\n* 默认情况下，WebGL 是按照顶点在缓冲区中的顺序绘制的。\n* 后绘制的会遮挡先绘制的图形。\n\n例如将上面的示例中的data数据顺序该下，就会出现以下的效果：\n\n{% codeblock lang:javascript %}\n// 四个三角形\nvar buffer_data = new Float32Array([\n\n    .75, 1.0, 0.8, .4, .4, 1.0,\n    .25, -1.0, .8, .4, .4, 1.0,\n    1.0, -1.0, .8, 1.0, .4, .4,\n\n    0.75, 1.0, -.8, 1.0, 1.0, .4,\n    .25, -1.0, -.8, 1.0, 1.0, .4,\n    1.0, -1.0, -.8, 1.0, .4, .4,\n\n    -.75, 1.0, .8, .4, .4, 1.0,\n    -1.0, -1.0, .8, .4, .4, 1.0,\n    -.25, -1.0, .8, 1.0, .4, .4,\n\n    -.75, 1.0, -.8, 1.0, 1.0, .4,\n    -1.0, -1.0, -.8, 1.0, 1.0, 0.4,\n    -0.25, -1.0, -.8, 1.0, .4, .4,\n\n]);\n{% endcodeblock %}\n\n<img width=\"400\" src=\"webgl-2017-07-11/8.jpeg\"/>\n\n但是实际情况中，可能很多图像并不知道出现的顺序，webgl提供了两个方法来解决这类问题。\n\n#### 解决方法\n\n* 启动隐藏面消除\n* 启动多边形偏移\n\n核心代码如下：\n\n{% codeblock lang:javascript %}\ngl.enable(gl.DEPTH_TEST);\ngl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n{% endcodeblock %}\n\n这样做之后，离视点远的对象会在后面展示。\n\n#### 深度冲突\n\n隐藏面消除是WebGL的一项复杂而又强大的特效，在绝大多数情况下，它都能很好地完成任务。然而，当几何图形或物体的两个表面极为接近时，就会出现新的问题，使得表面看上去斑斑驳驳的，这种现象被称为深度冲突（Z fighting）\n\n当所有的三角形一起绘画的时候，似乎不会出现这种情况，但是如果分开画三角形，可能会出现深度冲突的问题，通过以下代码可以解决：\n\n{% codeblock lang:javascript %}\ngl.enable(gl.POLYGON_OFFSET_FILL);\ngl.drawArrays(gl.TRIANGLES, 0, 3);\ngl.polygonOffset(1.0, 1.0);   \ngl.drawArrays(gl.TRIANGLES, 3, 3);\n{% endcodeblock %}\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/11","slug":"webgl-2017-07-11","published":1,"updated":"2017-11-05T09:38:18.000Z","_id":"cj9mi36s50014lmldi0zwe8yj","layout":"post","photos":[],"link":"","content":"<h3 id=\"可视范围基础\"><a href=\"#可视范围基础\" class=\"headerlink\" title=\"可视范围基础\"></a>可视范围基础</h3><h4 id=\"盒状空间\"><a href=\"#盒状空间\" class=\"headerlink\" title=\"盒状空间\"></a>盒状空间</h4><ul>\n<li>长方体可是空间，也叫盒状空间，是由正射投影产生。</li>\n<li>可视锥体空间，由透视投影产生。</li>\n</ul>\n<p>在透视投影下，产生的三维场景看上去更是有深度感，更加自然，因为我们平时观察真实世界用的也是透视投影。在大多数情况下，比如三维射击类游戏中，我们都应该采用透视投影。相比之下，正射投影的好处是用户可以方便的比较场景中物体的大小，这是因为物体看上去的大小与其所在的位置没有关系。在建筑平面图等技术绘图的相关场合，应当使用这种投影。</p>\n<a id=\"more\"></a>\n<h4 id=\"盒状空间的工作原理\"><a href=\"#盒状空间的工作原理\" class=\"headerlink\" title=\"盒状空间的工作原理\"></a>盒状空间的工作原理</h4><p>盒状可视空间的由前后两个矩形表面确定，分别称近裁剪面和远裁剪面，前者的四个顶点为（right,top,-near）,(-left,top,-near),(-left,-bottom,-near),(right,-bottom,-near),而后者的四个顶点为(right,top,far),(-left,top,far),(-left,-bottom,far),(right,-bottom,far).</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-11/01.jpeg\"></p>\n<p><canvas>上显示的就是可视空间中物体在近裁剪面上的投。如果裁剪面的高宽比和<canvas>不一样，那么画面就会被按照<canvas>的高宽比进行压缩，物体会被扭曲。近裁剪面与远裁剪面之间的盒形空间就是可是空间，只有在此空间内的物体会被显示出来。如果某个物体一部分在可视空间内，一部分在其外，那就只显示可视空间内的部分。</canvas></canvas></canvas></p>\n<h3 id=\"正射投影矩阵\"><a href=\"#正射投影矩阵\" class=\"headerlink\" title=\"正射投影矩阵\"></a>正射投影矩阵</h3><h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><ul>\n<li>setOrtho(left , right , bottom , top , near , far)</li>\n<li>left / right / bottom / top 参数含义：定位范围。</li>\n<li>near  参数含义：近裁切面。</li>\n<li>far  参数含义：远裁切面。</li>\n</ul>\n<p>基本方程式如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-11/2.jpeg\"></p>\n<p>写一个正射投影实例代码，核心代码如下：</p>\n<p>编写顶点着色器和片元着色器代码，定义一个uniform矩阵变量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vertexShaderSource = <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 u_mx;</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 a_Color;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">    void main()&#123;</span></div><div class=\"line\"><span class=\"string\">        gl_Position = u_mx * pos;</span></div><div class=\"line\"><span class=\"string\">        v_Color = a_Color;</span></div><div class=\"line\"><span class=\"string\">    &#125;</span></div><div class=\"line\"><span class=\"string\">`</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fragmentShaderSource = <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    precision lowp float;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\">    void main()&#123;</span></div><div class=\"line\"><span class=\"string\">        gl_FragColor = v_Color;</span></div><div class=\"line\"><span class=\"string\">    &#125;</span></div><div class=\"line\"><span class=\"string\">`</span>  </div></pre></td></tr></table></figure></p>\n<p>定义一个正射矩阵的方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getOMX</span>(<span class=\"params\">left,right,bottom,top,near,far</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">2</span> / (right - left), <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">2</span> / (top - bottom), <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-2</span> / (far - near), <span class=\"number\">0</span>,</div><div class=\"line\">        -(right + left) / (right - left),</div><div class=\"line\">        -(top + bottom) / (top - bottom),</div><div class=\"line\">        -(far + near) / (far - near),</div><div class=\"line\">        <span class=\"number\">1</span></div><div class=\"line\">    ]);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> near = <span class=\"number\">0.0</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> far = <span class=\"number\">.5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> omx = getOMX(<span class=\"number\">-.5</span>,<span class=\"number\">.5</span>, <span class=\"number\">-.5</span>,<span class=\"number\">.5</span>, near , far);    </div></pre></td></tr></table></figure></p>\n<p>定义数据data类型化数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">0.0</span>, <span class=\"number\">0.6</span>, <span class=\"number\">-.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">    <span class=\"number\">-.45</span>, <span class=\"number\">-.4</span>, <span class=\"number\">-.51</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">0.5</span>, <span class=\"number\">-.4</span>, <span class=\"number\">-.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">.4</span>, <span class=\"number\">-.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">.4</span>, <span class=\"number\">-.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.3</span>,</div><div class=\"line\">    <span class=\"number\">.0</span>, <span class=\"number\">-.6</span>, <span class=\"number\">-.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span></div><div class=\"line\">]);   </div></pre></td></tr></table></figure></p>\n<p>由于定义的far为.5,而data类型化数组数据一个三角形的坐标为-.51，实际效果会产生一个缺角，可以根据改变三角形的顶点来看不同的效果，最终效果如下图：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-11/3.jpeg\"></p>\n<h3 id=\"缺角的修补\"><a href=\"#缺角的修补\" class=\"headerlink\" title=\"缺角的修补\"></a>缺角的修补</h3><ul>\n<li>将远裁面移到距离视点更远的地方。</li>\n<li>&lt;正射投影矩阵&gt; <em> &lt;视图矩阵&gt; </em> &lt;顶点坐标&gt;</li>\n</ul>\n<p>代码效果如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-11/4.jpeg\"></p>\n<h3 id=\"透视投影\"><a href=\"#透视投影\" class=\"headerlink\" title=\"透视投影\"></a>透视投影</h3><h4 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h4><ul>\n<li>透视投影和正射投影基本一致，但存在一些参数差异。使得远处的物体看起来比较小，一般在游戏开发会用的比较多。</li>\n<li>可视空间顶面和底面的夹角必须大于0。</li>\n<li>指定近裁面的宽高比例。</li>\n</ul>\n<p><img width=\"300\" src=\"/webgl-2017-07-11/5.jpeg\"></p>\n<p>后面的三角形会根据与视点的距离做相应的缩放，并且做相应的平移。</p>\n<h4 id=\"透视投影矩阵\"><a href=\"#透视投影矩阵\" class=\"headerlink\" title=\"透视投影矩阵\"></a>透视投影矩阵</h4><h3 id=\"矩阵公式\"><a href=\"#矩阵公式\" class=\"headerlink\" title=\"矩阵公式\"></a>矩阵公式</h3><p><img width=\"500\" src=\"/webgl-2017-07-11/6.jpeg\"></p>\n<p>通过一个示例来解释透视投影具体的效果。</p>\n<p>定义着色器代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vertexShaderSource = <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 u_mx;</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 a_Color;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">    void main()&#123;</span></div><div class=\"line\"><span class=\"string\">        gl_Position = u_mx * pos;</span></div><div class=\"line\"><span class=\"string\">        v_Color = a_Color;</span></div><div class=\"line\"><span class=\"string\">    &#125;</span></div><div class=\"line\"><span class=\"string\">`</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fragmentShaderSource = <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    precision lowp float;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\">    void main()&#123;</span></div><div class=\"line\"><span class=\"string\">        gl_FragColor = v_Color;</span></div><div class=\"line\"><span class=\"string\">    &#125;</span></div><div class=\"line\"><span class=\"string\">`</span>   </div></pre></td></tr></table></figure>\n<p>创建program代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> gl = canvas.getContext(<span class=\"string\">'webgl'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> program = initShader(gl,vertexShaderSource,fragmentShaderSource); </div></pre></td></tr></table></figure>\n<p>定义创建透视投影矩阵函数方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 创建透视投影矩阵</span></div><div class=\"line\"><span class=\"comment\"> * fov 指定垂直视角</span></div><div class=\"line\"><span class=\"comment\"> * aspect 宽度 ／ 高度</span></div><div class=\"line\"><span class=\"comment\"> * near  近裁切面</span></div><div class=\"line\"><span class=\"comment\"> * far  远裁切面</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTS</span>(<span class=\"params\">fov,aspect,near,far</span>)</span>&#123;</div><div class=\"line\">    fov = fov * <span class=\"built_in\">Math</span>.PI / <span class=\"number\">180</span>; <span class=\"comment\">// 弧度</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">1</span> / (aspect * <span class=\"built_in\">Math</span>.tan(fov / <span class=\"number\">2</span>)), <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"built_in\">Math</span>.tan(fov / <span class=\"number\">2</span>), <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">0</span>, -(far + near) / (far - near), <span class=\"number\">-1</span>,</div><div class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-2</span> * (far * near) / (far - near), <span class=\"number\">0</span></div><div class=\"line\">    ]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建ata，并且将data绑定到创建的buffer上：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 四个三角形</span></div><div class=\"line\"><span class=\"keyword\">var</span> buffer_data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">0.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第一个三角形</span></div><div class=\"line\">    <span class=\"number\">-.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">    <span class=\"number\">-0.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">-.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">-.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span></div><div class=\"line\"></div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> buffer = gl.createBuffer();</div><div class=\"line\">gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</div><div class=\"line\">gl.bufferData(gl.ARRAY_BUFFER, buffer_data, gl.STATIC_DRAW);</div></pre></td></tr></table></figure>\n<p>得到Location，并且给其赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> posLocation = gl.getAttribLocation(program, <span class=\"string\">'pos'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> aColorLocation = gl.getAttribLocation(program, <span class=\"string\">'a_Color'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> uMXLocation = gl.getUniformLocation(program, <span class=\"string\">'u_mx'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> BYTES_SIZE = buffer_data.BYTES_PER_ELEMENT;</div><div class=\"line\"></div><div class=\"line\">gl.vertexAttribPointer(posLocation, <span class=\"number\">3</span>, gl.FLOAT, <span class=\"literal\">false</span>, BYTES_SIZE * <span class=\"number\">6</span>, <span class=\"number\">0</span>);</div><div class=\"line\">gl.vertexAttribPointer(aColorLocation, <span class=\"number\">3</span>, gl.FLOAT, <span class=\"literal\">false</span>, BYTES_SIZE * <span class=\"number\">6</span>, BYTES_SIZE * <span class=\"number\">3</span>);</div><div class=\"line\">gl.enableVertexAttribArray(posLocation);</div><div class=\"line\">gl.enableVertexAttribArray(aColorLocation);</div></pre></td></tr></table></figure>\n<p>定义一个绘图函数方法，并且执行，其中getVMatrix和multiplyMatrix是lib库中的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    gl.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\"></div><div class=\"line\">    gl.clear(gl.COLOR_BUFFER_BIT);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> mx = getTS(<span class=\"number\">30</span>, canvas.width / canvas.height, <span class=\"number\">1</span>, <span class=\"number\">100</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> vmx = getVMatrix(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-100</span>);</div><div class=\"line\">    gl.uniformMatrix4fv(uMXLocation,<span class=\"literal\">false</span>,multiplyMatrix(mx,vmx));</div><div class=\"line\"></div><div class=\"line\">    gl.drawArrays(gl.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">12</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">draw();</div></pre></td></tr></table></figure>\n<p>最终运行结果如下：</p>\n<p><img width=\"400\" src=\"/webgl-2017-07-11/7.jpeg\"></p>\n<h4 id=\"物体前后关系\"><a href=\"#物体前后关系\" class=\"headerlink\" title=\"物体前后关系\"></a>物体前后关系</h4><ul>\n<li>默认情况下，WebGL 是按照顶点在缓冲区中的顺序绘制的。</li>\n<li>后绘制的会遮挡先绘制的图形。</li>\n</ul>\n<p>例如将上面的示例中的data数据顺序该下，就会出现以下的效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 四个三角形</span></div><div class=\"line\"><span class=\"keyword\">var</span> buffer_data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">0.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">-.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">-.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">-.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">    <span class=\"number\">-0.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">]);</div></pre></td></tr></table></figure>\n<p><img width=\"400\" src=\"/webgl-2017-07-11/8.jpeg\"></p>\n<p>但是实际情况中，可能很多图像并不知道出现的顺序，webgl提供了两个方法来解决这类问题。</p>\n<h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><ul>\n<li>启动隐藏面消除</li>\n<li>启动多边形偏移</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">gl.enable(gl.DEPTH_TEST);</div><div class=\"line\">gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</div></pre></td></tr></table></figure>\n<p>这样做之后，离视点远的对象会在后面展示。</p>\n<h4 id=\"深度冲突\"><a href=\"#深度冲突\" class=\"headerlink\" title=\"深度冲突\"></a>深度冲突</h4><p>隐藏面消除是WebGL的一项复杂而又强大的特效，在绝大多数情况下，它都能很好地完成任务。然而，当几何图形或物体的两个表面极为接近时，就会出现新的问题，使得表面看上去斑斑驳驳的，这种现象被称为深度冲突（Z fighting）</p>\n<p>当所有的三角形一起绘画的时候，似乎不会出现这种情况，但是如果分开画三角形，可能会出现深度冲突的问题，通过以下代码可以解决：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gl.enable(gl.POLYGON_OFFSET_FILL);</div><div class=\"line\">gl.drawArrays(gl.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\">gl.polygonOffset(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>);   </div><div class=\"line\">gl.drawArrays(gl.TRIANGLES, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</div></pre></td></tr></table></figure>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/11\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/11</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"可视范围基础\"><a href=\"#可视范围基础\" class=\"headerlink\" title=\"可视范围基础\"></a>可视范围基础</h3><h4 id=\"盒状空间\"><a href=\"#盒状空间\" class=\"headerlink\" title=\"盒状空间\"></a>盒状空间</h4><ul>\n<li>长方体可是空间，也叫盒状空间，是由正射投影产生。</li>\n<li>可视锥体空间，由透视投影产生。</li>\n</ul>\n<p>在透视投影下，产生的三维场景看上去更是有深度感，更加自然，因为我们平时观察真实世界用的也是透视投影。在大多数情况下，比如三维射击类游戏中，我们都应该采用透视投影。相比之下，正射投影的好处是用户可以方便的比较场景中物体的大小，这是因为物体看上去的大小与其所在的位置没有关系。在建筑平面图等技术绘图的相关场合，应当使用这种投影。</p>","more":"<h4 id=\"盒状空间的工作原理\"><a href=\"#盒状空间的工作原理\" class=\"headerlink\" title=\"盒状空间的工作原理\"></a>盒状空间的工作原理</h4><p>盒状可视空间的由前后两个矩形表面确定，分别称近裁剪面和远裁剪面，前者的四个顶点为（right,top,-near）,(-left,top,-near),(-left,-bottom,-near),(right,-bottom,-near),而后者的四个顶点为(right,top,far),(-left,top,far),(-left,-bottom,far),(right,-bottom,far).</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-11/01.jpeg\"></p>\n<p><canvas>上显示的就是可视空间中物体在近裁剪面上的投。如果裁剪面的高宽比和<canvas>不一样，那么画面就会被按照<canvas>的高宽比进行压缩，物体会被扭曲。近裁剪面与远裁剪面之间的盒形空间就是可是空间，只有在此空间内的物体会被显示出来。如果某个物体一部分在可视空间内，一部分在其外，那就只显示可视空间内的部分。</canvas></canvas></canvas></p>\n<h3 id=\"正射投影矩阵\"><a href=\"#正射投影矩阵\" class=\"headerlink\" title=\"正射投影矩阵\"></a>正射投影矩阵</h3><h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><ul>\n<li>setOrtho(left , right , bottom , top , near , far)</li>\n<li>left / right / bottom / top 参数含义：定位范围。</li>\n<li>near  参数含义：近裁切面。</li>\n<li>far  参数含义：远裁切面。</li>\n</ul>\n<p>基本方程式如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-11/2.jpeg\"></p>\n<p>写一个正射投影实例代码，核心代码如下：</p>\n<p>编写顶点着色器和片元着色器代码，定义一个uniform矩阵变量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vertexShaderSource = <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 u_mx;</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 a_Color;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">    void main()&#123;</span></div><div class=\"line\"><span class=\"string\">        gl_Position = u_mx * pos;</span></div><div class=\"line\"><span class=\"string\">        v_Color = a_Color;</span></div><div class=\"line\"><span class=\"string\">    &#125;</span></div><div class=\"line\"><span class=\"string\">`</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fragmentShaderSource = <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    precision lowp float;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\">    void main()&#123;</span></div><div class=\"line\"><span class=\"string\">        gl_FragColor = v_Color;</span></div><div class=\"line\"><span class=\"string\">    &#125;</span></div><div class=\"line\"><span class=\"string\">`</span>  </div></pre></td></tr></table></figure></p>\n<p>定义一个正射矩阵的方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getOMX</span>(<span class=\"params\">left,right,bottom,top,near,far</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">2</span> / (right - left), <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">2</span> / (top - bottom), <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-2</span> / (far - near), <span class=\"number\">0</span>,</div><div class=\"line\">        -(right + left) / (right - left),</div><div class=\"line\">        -(top + bottom) / (top - bottom),</div><div class=\"line\">        -(far + near) / (far - near),</div><div class=\"line\">        <span class=\"number\">1</span></div><div class=\"line\">    ]);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> near = <span class=\"number\">0.0</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> far = <span class=\"number\">.5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> omx = getOMX(<span class=\"number\">-.5</span>,<span class=\"number\">.5</span>, <span class=\"number\">-.5</span>,<span class=\"number\">.5</span>, near , far);    </div></pre></td></tr></table></figure></p>\n<p>定义数据data类型化数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">    <span class=\"number\">0.0</span>, <span class=\"number\">0.6</span>, <span class=\"number\">-.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">    <span class=\"number\">-.45</span>, <span class=\"number\">-.4</span>, <span class=\"number\">-.51</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">0.5</span>, <span class=\"number\">-.4</span>, <span class=\"number\">-.4</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">.5</span>, <span class=\"number\">.4</span>, <span class=\"number\">-.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">-.5</span>, <span class=\"number\">.4</span>, <span class=\"number\">-.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.3</span>,</div><div class=\"line\">    <span class=\"number\">.0</span>, <span class=\"number\">-.6</span>, <span class=\"number\">-.2</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span></div><div class=\"line\">]);   </div></pre></td></tr></table></figure></p>\n<p>由于定义的far为.5,而data类型化数组数据一个三角形的坐标为-.51，实际效果会产生一个缺角，可以根据改变三角形的顶点来看不同的效果，最终效果如下图：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-11/3.jpeg\"></p>\n<h3 id=\"缺角的修补\"><a href=\"#缺角的修补\" class=\"headerlink\" title=\"缺角的修补\"></a>缺角的修补</h3><ul>\n<li>将远裁面移到距离视点更远的地方。</li>\n<li>&lt;正射投影矩阵&gt; <em> &lt;视图矩阵&gt; </em> &lt;顶点坐标&gt;</li>\n</ul>\n<p>代码效果如下：</p>\n<p><img width=\"300\" src=\"/webgl-2017-07-11/4.jpeg\"></p>\n<h3 id=\"透视投影\"><a href=\"#透视投影\" class=\"headerlink\" title=\"透视投影\"></a>透视投影</h3><h4 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h4><ul>\n<li>透视投影和正射投影基本一致，但存在一些参数差异。使得远处的物体看起来比较小，一般在游戏开发会用的比较多。</li>\n<li>可视空间顶面和底面的夹角必须大于0。</li>\n<li>指定近裁面的宽高比例。</li>\n</ul>\n<p><img width=\"300\" src=\"/webgl-2017-07-11/5.jpeg\"></p>\n<p>后面的三角形会根据与视点的距离做相应的缩放，并且做相应的平移。</p>\n<h4 id=\"透视投影矩阵\"><a href=\"#透视投影矩阵\" class=\"headerlink\" title=\"透视投影矩阵\"></a>透视投影矩阵</h4><h3 id=\"矩阵公式\"><a href=\"#矩阵公式\" class=\"headerlink\" title=\"矩阵公式\"></a>矩阵公式</h3><p><img width=\"500\" src=\"/webgl-2017-07-11/6.jpeg\"></p>\n<p>通过一个示例来解释透视投影具体的效果。</p>\n<p>定义着色器代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vertexShaderSource = <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">    uniform mat4 u_mx;</span></div><div class=\"line\"><span class=\"string\">    attribute vec4 a_Color;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">    void main()&#123;</span></div><div class=\"line\"><span class=\"string\">        gl_Position = u_mx * pos;</span></div><div class=\"line\"><span class=\"string\">        v_Color = a_Color;</span></div><div class=\"line\"><span class=\"string\">    &#125;</span></div><div class=\"line\"><span class=\"string\">`</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fragmentShaderSource = <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    precision lowp float;</span></div><div class=\"line\"><span class=\"string\">    varying vec4 v_Color;</span></div><div class=\"line\"><span class=\"string\">    void main()&#123;</span></div><div class=\"line\"><span class=\"string\">        gl_FragColor = v_Color;</span></div><div class=\"line\"><span class=\"string\">    &#125;</span></div><div class=\"line\"><span class=\"string\">`</span>   </div></pre></td></tr></table></figure>\n<p>创建program代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> gl = canvas.getContext(<span class=\"string\">'webgl'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> program = initShader(gl,vertexShaderSource,fragmentShaderSource); </div></pre></td></tr></table></figure>\n<p>定义创建透视投影矩阵函数方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 创建透视投影矩阵</span></div><div class=\"line\"><span class=\"comment\"> * fov 指定垂直视角</span></div><div class=\"line\"><span class=\"comment\"> * aspect 宽度 ／ 高度</span></div><div class=\"line\"><span class=\"comment\"> * near  近裁切面</span></div><div class=\"line\"><span class=\"comment\"> * far  远裁切面</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTS</span>(<span class=\"params\">fov,aspect,near,far</span>)</span>&#123;</div><div class=\"line\">    fov = fov * <span class=\"built_in\">Math</span>.PI / <span class=\"number\">180</span>; <span class=\"comment\">// 弧度</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\">        <span class=\"number\">1</span> / (aspect * <span class=\"built_in\">Math</span>.tan(fov / <span class=\"number\">2</span>)), <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"built_in\">Math</span>.tan(fov / <span class=\"number\">2</span>), <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">0</span>, -(far + near) / (far - near), <span class=\"number\">-1</span>,</div><div class=\"line\">        <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-2</span> * (far * near) / (far - near), <span class=\"number\">0</span></div><div class=\"line\">    ]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建ata，并且将data绑定到创建的buffer上：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 四个三角形</span></div><div class=\"line\"><span class=\"keyword\">var</span> buffer_data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">0.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第一个三角形</span></div><div class=\"line\">    <span class=\"number\">-.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">    <span class=\"number\">-0.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">-.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">-.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span></div><div class=\"line\"></div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> buffer = gl.createBuffer();</div><div class=\"line\">gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</div><div class=\"line\">gl.bufferData(gl.ARRAY_BUFFER, buffer_data, gl.STATIC_DRAW);</div></pre></td></tr></table></figure>\n<p>得到Location，并且给其赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> posLocation = gl.getAttribLocation(program, <span class=\"string\">'pos'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> aColorLocation = gl.getAttribLocation(program, <span class=\"string\">'a_Color'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> uMXLocation = gl.getUniformLocation(program, <span class=\"string\">'u_mx'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> BYTES_SIZE = buffer_data.BYTES_PER_ELEMENT;</div><div class=\"line\"></div><div class=\"line\">gl.vertexAttribPointer(posLocation, <span class=\"number\">3</span>, gl.FLOAT, <span class=\"literal\">false</span>, BYTES_SIZE * <span class=\"number\">6</span>, <span class=\"number\">0</span>);</div><div class=\"line\">gl.vertexAttribPointer(aColorLocation, <span class=\"number\">3</span>, gl.FLOAT, <span class=\"literal\">false</span>, BYTES_SIZE * <span class=\"number\">6</span>, BYTES_SIZE * <span class=\"number\">3</span>);</div><div class=\"line\">gl.enableVertexAttribArray(posLocation);</div><div class=\"line\">gl.enableVertexAttribArray(aColorLocation);</div></pre></td></tr></table></figure>\n<p>定义一个绘图函数方法，并且执行，其中getVMatrix和multiplyMatrix是lib库中的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    gl.clearColor(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\"></div><div class=\"line\">    gl.clear(gl.COLOR_BUFFER_BIT);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> mx = getTS(<span class=\"number\">30</span>, canvas.width / canvas.height, <span class=\"number\">1</span>, <span class=\"number\">100</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> vmx = getVMatrix(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-100</span>);</div><div class=\"line\">    gl.uniformMatrix4fv(uMXLocation,<span class=\"literal\">false</span>,multiplyMatrix(mx,vmx));</div><div class=\"line\"></div><div class=\"line\">    gl.drawArrays(gl.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">12</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">draw();</div></pre></td></tr></table></figure>\n<p>最终运行结果如下：</p>\n<p><img width=\"400\" src=\"/webgl-2017-07-11/7.jpeg\"></p>\n<h4 id=\"物体前后关系\"><a href=\"#物体前后关系\" class=\"headerlink\" title=\"物体前后关系\"></a>物体前后关系</h4><ul>\n<li>默认情况下，WebGL 是按照顶点在缓冲区中的顺序绘制的。</li>\n<li>后绘制的会遮挡先绘制的图形。</li>\n</ul>\n<p>例如将上面的示例中的data数据顺序该下，就会出现以下的效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 四个三角形</span></div><div class=\"line\"><span class=\"keyword\">var</span> buffer_data = <span class=\"keyword\">new</span> <span class=\"built_in\">Float32Array</span>([</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">0.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">-.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">    <span class=\"number\">-.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"number\">-.75</span>, <span class=\"number\">1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>,</div><div class=\"line\">    <span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.4</span>,</div><div class=\"line\">    <span class=\"number\">-0.25</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">-.8</span>, <span class=\"number\">1.0</span>, <span class=\"number\">.4</span>, <span class=\"number\">.4</span>,</div><div class=\"line\"></div><div class=\"line\">]);</div></pre></td></tr></table></figure>\n<p><img width=\"400\" src=\"/webgl-2017-07-11/8.jpeg\"></p>\n<p>但是实际情况中，可能很多图像并不知道出现的顺序，webgl提供了两个方法来解决这类问题。</p>\n<h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><ul>\n<li>启动隐藏面消除</li>\n<li>启动多边形偏移</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">gl.enable(gl.DEPTH_TEST);</div><div class=\"line\">gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</div></pre></td></tr></table></figure>\n<p>这样做之后，离视点远的对象会在后面展示。</p>\n<h4 id=\"深度冲突\"><a href=\"#深度冲突\" class=\"headerlink\" title=\"深度冲突\"></a>深度冲突</h4><p>隐藏面消除是WebGL的一项复杂而又强大的特效，在绝大多数情况下，它都能很好地完成任务。然而，当几何图形或物体的两个表面极为接近时，就会出现新的问题，使得表面看上去斑斑驳驳的，这种现象被称为深度冲突（Z fighting）</p>\n<p>当所有的三角形一起绘画的时候，似乎不会出现这种情况，但是如果分开画三角形，可能会出现深度冲突的问题，通过以下代码可以解决：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gl.enable(gl.POLYGON_OFFSET_FILL);</div><div class=\"line\">gl.drawArrays(gl.TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\">gl.polygonOffset(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>);   </div><div class=\"line\">gl.drawArrays(gl.TRIANGLES, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</div></pre></td></tr></table></figure>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/11\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/11</a></p>"},{"title":"WebGL系列教程--着色器语言","comments":1,"toc":true,"date":"2017-07-12T13:09:11.000Z","_content":"\n### 概述\n\n* 运行在建立在OpenGL基础上，删除和简化了一部分形成的。\n* 运行在小型设备\n* 与 C 语言语法类似\n\n#### 执行顺序\n\n* 从main主方法\n* void关键字\n* void main(){...}，没有函数返回值\n\n基本写法如下：\n{% codeblock lang:javascript %}\nvoid main(){\n   ...\n}\n{% endcodeblock %}\n\n<!-- more -->\n\n#### 基本类型\n\n* 数值类型\n* 布尔值类型\n\n{% codeblock lang:javascript %}\nbool a;\ninit b;\nfloat c;\nvoid main(){\n   ...\n}\n{% endcodeblock %}\n\n#### 变量\n\n* a-z , A-Z , 0-9 , _\n* 首字母不能为数字\n* 不能用关键字和保留字作变量名\n* 不能以 gl_  , _webgl_ 开头\n\n\n#### 基本运算符\n\n* - * / +\n* + -\n* ++ —\n* =\n* += -= *= /=\n* < > <= >=\n* ==  != \n* !   &&  ||  ^^  三元运算\n\n{% codeblock lang:javascript %}\nfloat a;\nfloat b;\n\nfloat c = a + b;\n++a/a++\n\ntrue ^^ true // false\nfalse ^^ false // false\nfalse ^^ true // true\n{% endcodeblock %}\n\n### 复杂类型\n\n#### 结构体\n\nstruct bright{\n   vec4 color;\n   vec3 position;\n}\n\n在赋值过程中必须按照保证类型一样，因为着色器语言是强类型。\n\n{% codeblock lang:javascript %}\n\nstruct user {\n\tfloat gezi;\n\tvec3 book;\n}\n\nuser wq;\nfloat a = 12.0;\nvec3 b = vec3(1.2,3.3,5.0);\nwq = user(a,b)\nwq = user(12.0,vec3(2.1,3.3,5.0));\n\n{% endcodeblock %}\n\n#### 数组\n\n* 只支持一维数组\n* 长度必须大于 0 的整型常量表达式\n* 不可用 const 修饰数组\n* float floatArr[4];\n\n#### 取样器\n\n* 通过取样器类型访问纹理\n* sampler2D\n* 只能是 uniform 变量\n* 纹理单元编号，至少支持8个单元变量\n\n### 程序流程控制\n\n#### 判断语句\n\nif (条件表达式1){\n 如果条件语句为 true，执行这里。\n}else if(条件表达式1){\n 如果条件语句1为 false，并且条件语句2为 true，执行这里。\n}else{\n   如果条件语句1和2都为 false ， 执行这里。\n}\n\n{% codeblock lang:javascript %}\n\nvarying vec4 vpos;\n\nif(vpos.x >= 0.0 && vpos.y >= 0.0){\n\tgl_FragColor = vec4(1.0,0.0,0.0,1.0); //红色\n}else if(vpos.x >= 0.0 && vpos.y < 0.0){\n\tgl_FragColor = vec4(0.0,1.0,0.0,1.0); //绿色\n}else if(vpos.x < 0.0 && vpos.y >= 0.0){\n\tgl_FragColor = vec4(0.0,0.0,1.0,1.0); //蓝色\n}else{\n\tgl_FragColor = vec4(1.0,1.0,0.0,1.0); //黄色\n}\n\n{% endcodeblock %}\n\n#### 循环语句\n\nfor ( 初始化表达式 ; 条件表达式 ; 循环步进表达式 ) {\n 反复执行这里\n}\n\n{% codeblock lang:javascript %}\n\ninit sum = 0;\nfor(init i = 0; i<10;i++){\n\tsum += 1;\n}\n// sum = 10;\n\nfloat sum = 0.0;\nfor(init i = 0; i<10;i++){\n\tsum += float(i);\n}\n{% endcodeblock %}\n\n### 函数\n\n#### 格式\n\n返回类型函数名 (type0 arg0 , type1 arg1 , …) {\n   函数运算\n   return  返回值;\n}\n{% codeblock lang:javascript %}\n\ninit sum(int a,int b){\n\treturn a + b;\n}\n{% endcodeblock %}\n\n#### 声明\n\n* float bright();  // 必须提前声明\n* void main(){ bright(); }\n* float bright(){ … }   \n\n#### 内置函数\n\n* 三角函数\n* 指数函数\n* 通用函数\n* 几何函数\n* 矩阵函数\n* 矢量函数\n* 纹理查询函数\n\n{% codeblock lang:javascript %}\n\n//三角函数\nradians(float d);\nradians(vec2 d);\nradians(vec3 d);\nradians(vec4 d);\n\ndegrees(float d);\ndegrees(vec2 d);\ndegrees(vec3 d);\ndegrees(vec4 d);\n\n// cos tan ...\nsin(float d);\nsin(vec2 d);\nsin(vec3 d);\nsin(vec4 d);\n\n// 指数函数\n\npow(float x,float y)\npow(vec2 x,vec2 y)\npow(vec3 x,vec3 y)\npow(vec4 x,vec4 y)\n\n// 通用函数\n\nabc(float x);\nabc(vec2 x);\nabc(vec3 x);\nabc(vec4 x);\n\nfloor(float x);\nfloor(vec2 x);\nfloor(vec3 x);\nfloor(vec4 x);\n\nmax(float x,float y);\n\n// 几何函数\n// 返回x轴的长度\nlength(float x) // vec2 ,vec3, vec4\n...\n{% endcodeblock %}\n\n\n### 限定字\n\n####  存储限定字\n\n<img width=\"500\" src=\"webgl-2017-07-12/1.jpeg\"/>\n\n* const 不可变的量\n* attribute 顶点着色器中使用\n* uniform 只读，必须是全局变量。\n* varying 顶点和片元着色器通信使用的，顶点着色器中赋给varying变量的值并不是直接传给了片元着色器的varying变量，这其中发生了光删化的过程，根据绘制的图形，对前者进行内插，然后再传递给后者。\n\n#### 精度限定字\n\n* highp   最高精度\n* mediump   中等精度\n* lowp   低精度\n* precision lowp float； //  定义精度\n\n","source":"_posts/webgl-2017-07-12.md","raw":"---\ntitle: WebGL系列教程--着色器语言\ncomments: true\ntoc: true\ndate: 2017-07-12 21:09:11\ntags:\n    - 'javascript'\n    - 'webgl'\n---\n\n### 概述\n\n* 运行在建立在OpenGL基础上，删除和简化了一部分形成的。\n* 运行在小型设备\n* 与 C 语言语法类似\n\n#### 执行顺序\n\n* 从main主方法\n* void关键字\n* void main(){...}，没有函数返回值\n\n基本写法如下：\n{% codeblock lang:javascript %}\nvoid main(){\n   ...\n}\n{% endcodeblock %}\n\n<!-- more -->\n\n#### 基本类型\n\n* 数值类型\n* 布尔值类型\n\n{% codeblock lang:javascript %}\nbool a;\ninit b;\nfloat c;\nvoid main(){\n   ...\n}\n{% endcodeblock %}\n\n#### 变量\n\n* a-z , A-Z , 0-9 , _\n* 首字母不能为数字\n* 不能用关键字和保留字作变量名\n* 不能以 gl_  , _webgl_ 开头\n\n\n#### 基本运算符\n\n* - * / +\n* + -\n* ++ —\n* =\n* += -= *= /=\n* < > <= >=\n* ==  != \n* !   &&  ||  ^^  三元运算\n\n{% codeblock lang:javascript %}\nfloat a;\nfloat b;\n\nfloat c = a + b;\n++a/a++\n\ntrue ^^ true // false\nfalse ^^ false // false\nfalse ^^ true // true\n{% endcodeblock %}\n\n### 复杂类型\n\n#### 结构体\n\nstruct bright{\n   vec4 color;\n   vec3 position;\n}\n\n在赋值过程中必须按照保证类型一样，因为着色器语言是强类型。\n\n{% codeblock lang:javascript %}\n\nstruct user {\n\tfloat gezi;\n\tvec3 book;\n}\n\nuser wq;\nfloat a = 12.0;\nvec3 b = vec3(1.2,3.3,5.0);\nwq = user(a,b)\nwq = user(12.0,vec3(2.1,3.3,5.0));\n\n{% endcodeblock %}\n\n#### 数组\n\n* 只支持一维数组\n* 长度必须大于 0 的整型常量表达式\n* 不可用 const 修饰数组\n* float floatArr[4];\n\n#### 取样器\n\n* 通过取样器类型访问纹理\n* sampler2D\n* 只能是 uniform 变量\n* 纹理单元编号，至少支持8个单元变量\n\n### 程序流程控制\n\n#### 判断语句\n\nif (条件表达式1){\n 如果条件语句为 true，执行这里。\n}else if(条件表达式1){\n 如果条件语句1为 false，并且条件语句2为 true，执行这里。\n}else{\n   如果条件语句1和2都为 false ， 执行这里。\n}\n\n{% codeblock lang:javascript %}\n\nvarying vec4 vpos;\n\nif(vpos.x >= 0.0 && vpos.y >= 0.0){\n\tgl_FragColor = vec4(1.0,0.0,0.0,1.0); //红色\n}else if(vpos.x >= 0.0 && vpos.y < 0.0){\n\tgl_FragColor = vec4(0.0,1.0,0.0,1.0); //绿色\n}else if(vpos.x < 0.0 && vpos.y >= 0.0){\n\tgl_FragColor = vec4(0.0,0.0,1.0,1.0); //蓝色\n}else{\n\tgl_FragColor = vec4(1.0,1.0,0.0,1.0); //黄色\n}\n\n{% endcodeblock %}\n\n#### 循环语句\n\nfor ( 初始化表达式 ; 条件表达式 ; 循环步进表达式 ) {\n 反复执行这里\n}\n\n{% codeblock lang:javascript %}\n\ninit sum = 0;\nfor(init i = 0; i<10;i++){\n\tsum += 1;\n}\n// sum = 10;\n\nfloat sum = 0.0;\nfor(init i = 0; i<10;i++){\n\tsum += float(i);\n}\n{% endcodeblock %}\n\n### 函数\n\n#### 格式\n\n返回类型函数名 (type0 arg0 , type1 arg1 , …) {\n   函数运算\n   return  返回值;\n}\n{% codeblock lang:javascript %}\n\ninit sum(int a,int b){\n\treturn a + b;\n}\n{% endcodeblock %}\n\n#### 声明\n\n* float bright();  // 必须提前声明\n* void main(){ bright(); }\n* float bright(){ … }   \n\n#### 内置函数\n\n* 三角函数\n* 指数函数\n* 通用函数\n* 几何函数\n* 矩阵函数\n* 矢量函数\n* 纹理查询函数\n\n{% codeblock lang:javascript %}\n\n//三角函数\nradians(float d);\nradians(vec2 d);\nradians(vec3 d);\nradians(vec4 d);\n\ndegrees(float d);\ndegrees(vec2 d);\ndegrees(vec3 d);\ndegrees(vec4 d);\n\n// cos tan ...\nsin(float d);\nsin(vec2 d);\nsin(vec3 d);\nsin(vec4 d);\n\n// 指数函数\n\npow(float x,float y)\npow(vec2 x,vec2 y)\npow(vec3 x,vec3 y)\npow(vec4 x,vec4 y)\n\n// 通用函数\n\nabc(float x);\nabc(vec2 x);\nabc(vec3 x);\nabc(vec4 x);\n\nfloor(float x);\nfloor(vec2 x);\nfloor(vec3 x);\nfloor(vec4 x);\n\nmax(float x,float y);\n\n// 几何函数\n// 返回x轴的长度\nlength(float x) // vec2 ,vec3, vec4\n...\n{% endcodeblock %}\n\n\n### 限定字\n\n####  存储限定字\n\n<img width=\"500\" src=\"webgl-2017-07-12/1.jpeg\"/>\n\n* const 不可变的量\n* attribute 顶点着色器中使用\n* uniform 只读，必须是全局变量。\n* varying 顶点和片元着色器通信使用的，顶点着色器中赋给varying变量的值并不是直接传给了片元着色器的varying变量，这其中发生了光删化的过程，根据绘制的图形，对前者进行内插，然后再传递给后者。\n\n#### 精度限定字\n\n* highp   最高精度\n* mediump   中等精度\n* lowp   低精度\n* precision lowp float； //  定义精度\n\n","slug":"webgl-2017-07-12","published":1,"updated":"2017-10-29T10:13:41.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36sa0017lmld1mb5y65o","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ul>\n<li>运行在建立在OpenGL基础上，删除和简化了一部分形成的。</li>\n<li>运行在小型设备</li>\n<li>与 C 语言语法类似</li>\n</ul>\n<h4 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h4><ul>\n<li>从main主方法</li>\n<li>void关键字</li>\n<li>void main(){…}，没有函数返回值</li>\n</ul>\n<p>基本写法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> main()&#123;</div><div class=\"line\">   ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h4 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h4><ul>\n<li>数值类型</li>\n<li>布尔值类型</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool a;</div><div class=\"line\">init b;</div><div class=\"line\">float c;</div><div class=\"line\"><span class=\"keyword\">void</span> main()&#123;</div><div class=\"line\">   ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><ul>\n<li>a-z , A-Z , 0-9 , _</li>\n<li>首字母不能为数字</li>\n<li>不能用关键字和保留字作变量名</li>\n<li>不能以 gl_  , <em>webgl</em> 开头</li>\n</ul>\n<h4 id=\"基本运算符\"><a href=\"#基本运算符\" class=\"headerlink\" title=\"基本运算符\"></a>基本运算符</h4><ul>\n<li><ul>\n<li><ul>\n<li>/ +</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>-</li>\n</ul>\n</li>\n<li>++ —</li>\n<li>=</li>\n<li>+= -= *= /=</li>\n<li>&lt; &gt; &lt;= &gt;=</li>\n<li>==  != </li>\n<li>!   &amp;&amp;  ||  ^^  三元运算</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">float a;</div><div class=\"line\">float b;</div><div class=\"line\"></div><div class=\"line\">float c = a + b;</div><div class=\"line\">++a/a++</div><div class=\"line\"></div><div class=\"line\"><span class=\"literal\">true</span> ^^ <span class=\"literal\">true</span> <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"literal\">false</span> ^^ <span class=\"literal\">false</span> <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"literal\">false</span> ^^ <span class=\"literal\">true</span> <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h3 id=\"复杂类型\"><a href=\"#复杂类型\" class=\"headerlink\" title=\"复杂类型\"></a>复杂类型</h3><h4 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h4><p>struct bright{<br>   vec4 color;<br>   vec3 position;<br>}</p>\n<p>在赋值过程中必须按照保证类型一样，因为着色器语言是强类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">struct user &#123;</div><div class=\"line\">\tfloat gezi;</div><div class=\"line\">\tvec3 book;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">user wq;</div><div class=\"line\">float a = <span class=\"number\">12.0</span>;</div><div class=\"line\">vec3 b = vec3(<span class=\"number\">1.2</span>,<span class=\"number\">3.3</span>,<span class=\"number\">5.0</span>);</div><div class=\"line\">wq = user(a,b)</div><div class=\"line\">wq = user(<span class=\"number\">12.0</span>,vec3(<span class=\"number\">2.1</span>,<span class=\"number\">3.3</span>,<span class=\"number\">5.0</span>));</div><div class=\"line\"></div></pre></td></tr></table></figure>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><ul>\n<li>只支持一维数组</li>\n<li>长度必须大于 0 的整型常量表达式</li>\n<li>不可用 const 修饰数组</li>\n<li>float floatArr[4];</li>\n</ul>\n<h4 id=\"取样器\"><a href=\"#取样器\" class=\"headerlink\" title=\"取样器\"></a>取样器</h4><ul>\n<li>通过取样器类型访问纹理</li>\n<li>sampler2D</li>\n<li>只能是 uniform 变量</li>\n<li>纹理单元编号，至少支持8个单元变量</li>\n</ul>\n<h3 id=\"程序流程控制\"><a href=\"#程序流程控制\" class=\"headerlink\" title=\"程序流程控制\"></a>程序流程控制</h3><h4 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h4><p>if (条件表达式1){<br> 如果条件语句为 true，执行这里。<br>}else if(条件表达式1){<br> 如果条件语句1为 false，并且条件语句2为 true，执行这里。<br>}else{<br>   如果条件语句1和2都为 false ， 执行这里。<br>}</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">varying vec4 vpos;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>(vpos.x &gt;= <span class=\"number\">0.0</span> &amp;&amp; vpos.y &gt;= <span class=\"number\">0.0</span>)&#123;</div><div class=\"line\">\tgl_FragColor = vec4(<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>); <span class=\"comment\">//红色</span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(vpos.x &gt;= <span class=\"number\">0.0</span> &amp;&amp; vpos.y &lt; <span class=\"number\">0.0</span>)&#123;</div><div class=\"line\">\tgl_FragColor = vec4(<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>); <span class=\"comment\">//绿色</span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(vpos.x &lt; <span class=\"number\">0.0</span> &amp;&amp; vpos.y &gt;= <span class=\"number\">0.0</span>)&#123;</div><div class=\"line\">\tgl_FragColor = vec4(<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>); <span class=\"comment\">//蓝色</span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\tgl_FragColor = vec4(<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>); <span class=\"comment\">//黄色</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div></pre></td></tr></table></figure>\n<h4 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h4><p>for ( 初始化表达式 ; 条件表达式 ; 循环步进表达式 ) {<br> 反复执行这里<br>}</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">init sum = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">for</span>(init i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>;i++)&#123;</div><div class=\"line\">\tsum += <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// sum = 10;</span></div><div class=\"line\"></div><div class=\"line\">float sum = <span class=\"number\">0.0</span>;</div><div class=\"line\"><span class=\"keyword\">for</span>(init i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>;i++)&#123;</div><div class=\"line\">\tsum += float(i);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h4><p>返回类型函数名 (type0 arg0 , type1 arg1 , …) {<br>   函数运算<br>   return  返回值;<br>}<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">init sum(int a,int b)&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h4><ul>\n<li>float bright();  // 必须提前声明</li>\n<li>void main(){ bright(); }</li>\n<li>float bright(){ … }   </li>\n</ul>\n<h4 id=\"内置函数\"><a href=\"#内置函数\" class=\"headerlink\" title=\"内置函数\"></a>内置函数</h4><ul>\n<li>三角函数</li>\n<li>指数函数</li>\n<li>通用函数</li>\n<li>几何函数</li>\n<li>矩阵函数</li>\n<li>矢量函数</li>\n<li>纹理查询函数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//三角函数</span></div><div class=\"line\">radians(float d);</div><div class=\"line\">radians(vec2 d);</div><div class=\"line\">radians(vec3 d);</div><div class=\"line\">radians(vec4 d);</div><div class=\"line\"></div><div class=\"line\">degrees(float d);</div><div class=\"line\">degrees(vec2 d);</div><div class=\"line\">degrees(vec3 d);</div><div class=\"line\">degrees(vec4 d);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// cos tan ...</span></div><div class=\"line\">sin(float d);</div><div class=\"line\">sin(vec2 d);</div><div class=\"line\">sin(vec3 d);</div><div class=\"line\">sin(vec4 d);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 指数函数</span></div><div class=\"line\"></div><div class=\"line\">pow(float x,float y)</div><div class=\"line\">pow(vec2 x,vec2 y)</div><div class=\"line\">pow(vec3 x,vec3 y)</div><div class=\"line\">pow(vec4 x,vec4 y)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 通用函数</span></div><div class=\"line\"></div><div class=\"line\">abc(float x);</div><div class=\"line\">abc(vec2 x);</div><div class=\"line\">abc(vec3 x);</div><div class=\"line\">abc(vec4 x);</div><div class=\"line\"></div><div class=\"line\">floor(float x);</div><div class=\"line\">floor(vec2 x);</div><div class=\"line\">floor(vec3 x);</div><div class=\"line\">floor(vec4 x);</div><div class=\"line\"></div><div class=\"line\">max(float x,float y);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 几何函数</span></div><div class=\"line\"><span class=\"comment\">// 返回x轴的长度</span></div><div class=\"line\">length(float x) <span class=\"comment\">// vec2 ,vec3, vec4</span></div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<h3 id=\"限定字\"><a href=\"#限定字\" class=\"headerlink\" title=\"限定字\"></a>限定字</h3><h4 id=\"存储限定字\"><a href=\"#存储限定字\" class=\"headerlink\" title=\"存储限定字\"></a>存储限定字</h4><p><img width=\"500\" src=\"/webgl-2017-07-12/1.jpeg\"></p>\n<ul>\n<li>const 不可变的量</li>\n<li>attribute 顶点着色器中使用</li>\n<li>uniform 只读，必须是全局变量。</li>\n<li>varying 顶点和片元着色器通信使用的，顶点着色器中赋给varying变量的值并不是直接传给了片元着色器的varying变量，这其中发生了光删化的过程，根据绘制的图形，对前者进行内插，然后再传递给后者。</li>\n</ul>\n<h4 id=\"精度限定字\"><a href=\"#精度限定字\" class=\"headerlink\" title=\"精度限定字\"></a>精度限定字</h4><ul>\n<li>highp   最高精度</li>\n<li>mediump   中等精度</li>\n<li>lowp   低精度</li>\n<li>precision lowp float； //  定义精度</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ul>\n<li>运行在建立在OpenGL基础上，删除和简化了一部分形成的。</li>\n<li>运行在小型设备</li>\n<li>与 C 语言语法类似</li>\n</ul>\n<h4 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h4><ul>\n<li>从main主方法</li>\n<li>void关键字</li>\n<li>void main(){…}，没有函数返回值</li>\n</ul>\n<p>基本写法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> main()&#123;</div><div class=\"line\">   ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>","more":"<h4 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h4><ul>\n<li>数值类型</li>\n<li>布尔值类型</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool a;</div><div class=\"line\">init b;</div><div class=\"line\">float c;</div><div class=\"line\"><span class=\"keyword\">void</span> main()&#123;</div><div class=\"line\">   ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><ul>\n<li>a-z , A-Z , 0-9 , _</li>\n<li>首字母不能为数字</li>\n<li>不能用关键字和保留字作变量名</li>\n<li>不能以 gl_  , <em>webgl</em> 开头</li>\n</ul>\n<h4 id=\"基本运算符\"><a href=\"#基本运算符\" class=\"headerlink\" title=\"基本运算符\"></a>基本运算符</h4><ul>\n<li><ul>\n<li><ul>\n<li>/ +</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>-</li>\n</ul>\n</li>\n<li>++ —</li>\n<li>=</li>\n<li>+= -= *= /=</li>\n<li>&lt; &gt; &lt;= &gt;=</li>\n<li>==  != </li>\n<li>!   &amp;&amp;  ||  ^^  三元运算</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">float a;</div><div class=\"line\">float b;</div><div class=\"line\"></div><div class=\"line\">float c = a + b;</div><div class=\"line\">++a/a++</div><div class=\"line\"></div><div class=\"line\"><span class=\"literal\">true</span> ^^ <span class=\"literal\">true</span> <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"literal\">false</span> ^^ <span class=\"literal\">false</span> <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"literal\">false</span> ^^ <span class=\"literal\">true</span> <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h3 id=\"复杂类型\"><a href=\"#复杂类型\" class=\"headerlink\" title=\"复杂类型\"></a>复杂类型</h3><h4 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h4><p>struct bright{<br>   vec4 color;<br>   vec3 position;<br>}</p>\n<p>在赋值过程中必须按照保证类型一样，因为着色器语言是强类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">struct user &#123;</div><div class=\"line\">\tfloat gezi;</div><div class=\"line\">\tvec3 book;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">user wq;</div><div class=\"line\">float a = <span class=\"number\">12.0</span>;</div><div class=\"line\">vec3 b = vec3(<span class=\"number\">1.2</span>,<span class=\"number\">3.3</span>,<span class=\"number\">5.0</span>);</div><div class=\"line\">wq = user(a,b)</div><div class=\"line\">wq = user(<span class=\"number\">12.0</span>,vec3(<span class=\"number\">2.1</span>,<span class=\"number\">3.3</span>,<span class=\"number\">5.0</span>));</div><div class=\"line\"></div></pre></td></tr></table></figure>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><ul>\n<li>只支持一维数组</li>\n<li>长度必须大于 0 的整型常量表达式</li>\n<li>不可用 const 修饰数组</li>\n<li>float floatArr[4];</li>\n</ul>\n<h4 id=\"取样器\"><a href=\"#取样器\" class=\"headerlink\" title=\"取样器\"></a>取样器</h4><ul>\n<li>通过取样器类型访问纹理</li>\n<li>sampler2D</li>\n<li>只能是 uniform 变量</li>\n<li>纹理单元编号，至少支持8个单元变量</li>\n</ul>\n<h3 id=\"程序流程控制\"><a href=\"#程序流程控制\" class=\"headerlink\" title=\"程序流程控制\"></a>程序流程控制</h3><h4 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h4><p>if (条件表达式1){<br> 如果条件语句为 true，执行这里。<br>}else if(条件表达式1){<br> 如果条件语句1为 false，并且条件语句2为 true，执行这里。<br>}else{<br>   如果条件语句1和2都为 false ， 执行这里。<br>}</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">varying vec4 vpos;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>(vpos.x &gt;= <span class=\"number\">0.0</span> &amp;&amp; vpos.y &gt;= <span class=\"number\">0.0</span>)&#123;</div><div class=\"line\">\tgl_FragColor = vec4(<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>); <span class=\"comment\">//红色</span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(vpos.x &gt;= <span class=\"number\">0.0</span> &amp;&amp; vpos.y &lt; <span class=\"number\">0.0</span>)&#123;</div><div class=\"line\">\tgl_FragColor = vec4(<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>); <span class=\"comment\">//绿色</span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(vpos.x &lt; <span class=\"number\">0.0</span> &amp;&amp; vpos.y &gt;= <span class=\"number\">0.0</span>)&#123;</div><div class=\"line\">\tgl_FragColor = vec4(<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>); <span class=\"comment\">//蓝色</span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\tgl_FragColor = vec4(<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>); <span class=\"comment\">//黄色</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div></pre></td></tr></table></figure>\n<h4 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h4><p>for ( 初始化表达式 ; 条件表达式 ; 循环步进表达式 ) {<br> 反复执行这里<br>}</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">init sum = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">for</span>(init i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>;i++)&#123;</div><div class=\"line\">\tsum += <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// sum = 10;</span></div><div class=\"line\"></div><div class=\"line\">float sum = <span class=\"number\">0.0</span>;</div><div class=\"line\"><span class=\"keyword\">for</span>(init i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>;i++)&#123;</div><div class=\"line\">\tsum += float(i);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h4><p>返回类型函数名 (type0 arg0 , type1 arg1 , …) {<br>   函数运算<br>   return  返回值;<br>}<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">init sum(int a,int b)&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h4><ul>\n<li>float bright();  // 必须提前声明</li>\n<li>void main(){ bright(); }</li>\n<li>float bright(){ … }   </li>\n</ul>\n<h4 id=\"内置函数\"><a href=\"#内置函数\" class=\"headerlink\" title=\"内置函数\"></a>内置函数</h4><ul>\n<li>三角函数</li>\n<li>指数函数</li>\n<li>通用函数</li>\n<li>几何函数</li>\n<li>矩阵函数</li>\n<li>矢量函数</li>\n<li>纹理查询函数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//三角函数</span></div><div class=\"line\">radians(float d);</div><div class=\"line\">radians(vec2 d);</div><div class=\"line\">radians(vec3 d);</div><div class=\"line\">radians(vec4 d);</div><div class=\"line\"></div><div class=\"line\">degrees(float d);</div><div class=\"line\">degrees(vec2 d);</div><div class=\"line\">degrees(vec3 d);</div><div class=\"line\">degrees(vec4 d);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// cos tan ...</span></div><div class=\"line\">sin(float d);</div><div class=\"line\">sin(vec2 d);</div><div class=\"line\">sin(vec3 d);</div><div class=\"line\">sin(vec4 d);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 指数函数</span></div><div class=\"line\"></div><div class=\"line\">pow(float x,float y)</div><div class=\"line\">pow(vec2 x,vec2 y)</div><div class=\"line\">pow(vec3 x,vec3 y)</div><div class=\"line\">pow(vec4 x,vec4 y)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 通用函数</span></div><div class=\"line\"></div><div class=\"line\">abc(float x);</div><div class=\"line\">abc(vec2 x);</div><div class=\"line\">abc(vec3 x);</div><div class=\"line\">abc(vec4 x);</div><div class=\"line\"></div><div class=\"line\">floor(float x);</div><div class=\"line\">floor(vec2 x);</div><div class=\"line\">floor(vec3 x);</div><div class=\"line\">floor(vec4 x);</div><div class=\"line\"></div><div class=\"line\">max(float x,float y);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 几何函数</span></div><div class=\"line\"><span class=\"comment\">// 返回x轴的长度</span></div><div class=\"line\">length(float x) <span class=\"comment\">// vec2 ,vec3, vec4</span></div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<h3 id=\"限定字\"><a href=\"#限定字\" class=\"headerlink\" title=\"限定字\"></a>限定字</h3><h4 id=\"存储限定字\"><a href=\"#存储限定字\" class=\"headerlink\" title=\"存储限定字\"></a>存储限定字</h4><p><img width=\"500\" src=\"/webgl-2017-07-12/1.jpeg\"></p>\n<ul>\n<li>const 不可变的量</li>\n<li>attribute 顶点着色器中使用</li>\n<li>uniform 只读，必须是全局变量。</li>\n<li>varying 顶点和片元着色器通信使用的，顶点着色器中赋给varying变量的值并不是直接传给了片元着色器的varying变量，这其中发生了光删化的过程，根据绘制的图形，对前者进行内插，然后再传递给后者。</li>\n</ul>\n<h4 id=\"精度限定字\"><a href=\"#精度限定字\" class=\"headerlink\" title=\"精度限定字\"></a>精度限定字</h4><ul>\n<li>highp   最高精度</li>\n<li>mediump   中等精度</li>\n<li>lowp   低精度</li>\n<li>precision lowp float； //  定义精度</li>\n</ul>"},{"title":"WebGL系列教程--贴图","comments":1,"toc":true,"date":"2017-07-10T13:09:11.000Z","_content":"\n### 贴图概述\n\n#### 图片类别\n\n\n* JPG 格式，24位的颜色储存单个的绘图，是有损的压缩，牺牲图像质量可以控制文件大小\n* GIF 格式，压缩比例能够达到40%到50%，无损压缩技术（必须保证256颜色的）\n* PNG 格式，无损压缩\n\n#### 贴图开发流程\n\n* 准备纹理图像\n* 配置图像映射方式\n* 加载纹理图像\n* 纹理贴图\n\n<!-- more -->\n\n\n### 贴图核心技术\n\n#### 纹理坐标\n\n* st坐标系\n\n<img width=\"300\" src=\"webgl-2017-07-10/1.jpeg\"/>\n\n#### 纹理对象\n\n* createTexture 创建纹理\n* deleteTexture(tex) 删除纹理\n\n#### 图片加载\n\n* 确定图片加载后调用的函数\n* 图片开始加载\n* 向服务器请求图片\n* 服务器查找图片\n* 服务器返回图片数据\n* 浏览器收到图片数据\n* 调用回调函数\n\n#### 配置纹理\n\n* Y 轴反转\n* 开启纹理单元\n* 绑定纹理对象\n* 配置纹理参数\n* 配置纹理图形\n* 将纹理传递给着色器\n\n编写着色器代码，在片元着色器中定义贴图，基本如下\n\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n\t    attribute vec4 pos;\n\t    attribute vec2 texPos;\n\t    varying vec2 v_texPos;\n\t    void main() {\n\t      gl_Position = pos;\n\t      v_texPos = texPos;\n\t}`\n\n\t    // 片元着色器程序\n\t    const fragmentShaderSource =\n\t        `\n\t        precision lowp float;\n\t        uniform sampler2D ss;\n\t        varying vec2 v_texPos;\n\t        void main() {\n\t      gl_FragColor = texture2D(ss,v_texPos);\n\t  }`   \n{% endcodeblock %}\n\n将加载的图片画在canvas上面，基本代码如下：\n{% codeblock lang:javascript %}\n\nfunction loadImg(url,callback){\n        var img = new Image;\n        img.src = url;\n        img.onload = function () {\n            callback(img);\n        }\n    }\n\n\n    loadImg('./img.png', function (img) {\n        var texture = cxt.createTexture();\n        cxt.pixelStorei(cxt.UNPACK_FLIP_Y_WEBGL,1);\n        cxt.activeTexture(cxt.TEXTURE0);\n        cxt.bindTexture(cxt.TEXTURE_2D,texture);\n\n        cxt.texParameteri(cxt.TEXTURE_2D,cxt.TEXTURE_MIN_FILTER,cxt.LINEAR);\n        cxt.texImage2D(cxt.TEXTURE_2D,0,cxt.RGB,cxt.RGB,cxt.UNSIGNED_BYTE,img);\n        cxt.uniform1i(texLocation,0);\n        cxt.drawArrays(cxt.TRIANGLE_STRIP,0,4);\n\n    });\n{% endcodeblock %}\n\n最终效果如下：\n<img width=\"300\" src=\"webgl-2017-07-10/2.jpeg\"/>\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/10","source":"_posts/webgl-2017-07-10.md","raw":"---\ntitle: WebGL系列教程--贴图\ncomments: true\ntoc: true\ndate: 2017-07-10 21:09:11\ntags:\n    - 'javascript'\n    - 'webgl'\n---\n\n### 贴图概述\n\n#### 图片类别\n\n\n* JPG 格式，24位的颜色储存单个的绘图，是有损的压缩，牺牲图像质量可以控制文件大小\n* GIF 格式，压缩比例能够达到40%到50%，无损压缩技术（必须保证256颜色的）\n* PNG 格式，无损压缩\n\n#### 贴图开发流程\n\n* 准备纹理图像\n* 配置图像映射方式\n* 加载纹理图像\n* 纹理贴图\n\n<!-- more -->\n\n\n### 贴图核心技术\n\n#### 纹理坐标\n\n* st坐标系\n\n<img width=\"300\" src=\"webgl-2017-07-10/1.jpeg\"/>\n\n#### 纹理对象\n\n* createTexture 创建纹理\n* deleteTexture(tex) 删除纹理\n\n#### 图片加载\n\n* 确定图片加载后调用的函数\n* 图片开始加载\n* 向服务器请求图片\n* 服务器查找图片\n* 服务器返回图片数据\n* 浏览器收到图片数据\n* 调用回调函数\n\n#### 配置纹理\n\n* Y 轴反转\n* 开启纹理单元\n* 绑定纹理对象\n* 配置纹理参数\n* 配置纹理图形\n* 将纹理传递给着色器\n\n编写着色器代码，在片元着色器中定义贴图，基本如下\n\n{% codeblock lang:javascript %}\n// 顶点着色器程序\n    const vertexShaderSource =\n        `\n\t    attribute vec4 pos;\n\t    attribute vec2 texPos;\n\t    varying vec2 v_texPos;\n\t    void main() {\n\t      gl_Position = pos;\n\t      v_texPos = texPos;\n\t}`\n\n\t    // 片元着色器程序\n\t    const fragmentShaderSource =\n\t        `\n\t        precision lowp float;\n\t        uniform sampler2D ss;\n\t        varying vec2 v_texPos;\n\t        void main() {\n\t      gl_FragColor = texture2D(ss,v_texPos);\n\t  }`   \n{% endcodeblock %}\n\n将加载的图片画在canvas上面，基本代码如下：\n{% codeblock lang:javascript %}\n\nfunction loadImg(url,callback){\n        var img = new Image;\n        img.src = url;\n        img.onload = function () {\n            callback(img);\n        }\n    }\n\n\n    loadImg('./img.png', function (img) {\n        var texture = cxt.createTexture();\n        cxt.pixelStorei(cxt.UNPACK_FLIP_Y_WEBGL,1);\n        cxt.activeTexture(cxt.TEXTURE0);\n        cxt.bindTexture(cxt.TEXTURE_2D,texture);\n\n        cxt.texParameteri(cxt.TEXTURE_2D,cxt.TEXTURE_MIN_FILTER,cxt.LINEAR);\n        cxt.texImage2D(cxt.TEXTURE_2D,0,cxt.RGB,cxt.RGB,cxt.UNSIGNED_BYTE,img);\n        cxt.uniform1i(texLocation,0);\n        cxt.drawArrays(cxt.TRIANGLE_STRIP,0,4);\n\n    });\n{% endcodeblock %}\n\n最终效果如下：\n<img width=\"300\" src=\"webgl-2017-07-10/2.jpeg\"/>\n\n源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/10","slug":"webgl-2017-07-10","published":1,"updated":"2017-10-15T04:10:00.000Z","layout":"post","photos":[],"link":"","_id":"cj9mi36sd0019lmldsffjxtgv","content":"<h3 id=\"贴图概述\"><a href=\"#贴图概述\" class=\"headerlink\" title=\"贴图概述\"></a>贴图概述</h3><h4 id=\"图片类别\"><a href=\"#图片类别\" class=\"headerlink\" title=\"图片类别\"></a>图片类别</h4><ul>\n<li>JPG 格式，24位的颜色储存单个的绘图，是有损的压缩，牺牲图像质量可以控制文件大小</li>\n<li>GIF 格式，压缩比例能够达到40%到50%，无损压缩技术（必须保证256颜色的）</li>\n<li>PNG 格式，无损压缩</li>\n</ul>\n<h4 id=\"贴图开发流程\"><a href=\"#贴图开发流程\" class=\"headerlink\" title=\"贴图开发流程\"></a>贴图开发流程</h4><ul>\n<li>准备纹理图像</li>\n<li>配置图像映射方式</li>\n<li>加载纹理图像</li>\n<li>纹理贴图</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"贴图核心技术\"><a href=\"#贴图核心技术\" class=\"headerlink\" title=\"贴图核心技术\"></a>贴图核心技术</h3><h4 id=\"纹理坐标\"><a href=\"#纹理坐标\" class=\"headerlink\" title=\"纹理坐标\"></a>纹理坐标</h4><ul>\n<li>st坐标系</li>\n</ul>\n<p><img width=\"300\" src=\"/webgl-2017-07-10/1.jpeg\"></p>\n<h4 id=\"纹理对象\"><a href=\"#纹理对象\" class=\"headerlink\" title=\"纹理对象\"></a>纹理对象</h4><ul>\n<li>createTexture 创建纹理</li>\n<li>deleteTexture(tex) 删除纹理</li>\n</ul>\n<h4 id=\"图片加载\"><a href=\"#图片加载\" class=\"headerlink\" title=\"图片加载\"></a>图片加载</h4><ul>\n<li>确定图片加载后调用的函数</li>\n<li>图片开始加载</li>\n<li>向服务器请求图片</li>\n<li>服务器查找图片</li>\n<li>服务器返回图片数据</li>\n<li>浏览器收到图片数据</li>\n<li>调用回调函数</li>\n</ul>\n<h4 id=\"配置纹理\"><a href=\"#配置纹理\" class=\"headerlink\" title=\"配置纹理\"></a>配置纹理</h4><ul>\n<li>Y 轴反转</li>\n<li>开启纹理单元</li>\n<li>绑定纹理对象</li>\n<li>配置纹理参数</li>\n<li>配置纹理图形</li>\n<li>将纹理传递给着色器</li>\n</ul>\n<p>编写着色器代码，在片元着色器中定义贴图，基本如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">\t    attribute vec2 texPos;</span></div><div class=\"line\"><span class=\"string\">\t    varying vec2 v_texPos;</span></div><div class=\"line\"><span class=\"string\">\t    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">\t      gl_Position = pos;</span></div><div class=\"line\"><span class=\"string\">\t      v_texPos = texPos;</span></div><div class=\"line\"><span class=\"string\">\t&#125;`</span></div><div class=\"line\"></div><div class=\"line\">\t    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">\t    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">\t        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t        precision lowp float;</span></div><div class=\"line\"><span class=\"string\">\t        uniform sampler2D ss;</span></div><div class=\"line\"><span class=\"string\">\t        varying vec2 v_texPos;</span></div><div class=\"line\"><span class=\"string\">\t        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">\t      gl_FragColor = texture2D(ss,v_texPos);</span></div><div class=\"line\"><span class=\"string\">\t  &#125;`</span>   </div></pre></td></tr></table></figure>\n<p>将加载的图片画在canvas上面，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadImg</span>(<span class=\"params\">url,callback</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image;</div><div class=\"line\">        img.src = url;</div><div class=\"line\">        img.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            callback(img);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    loadImg(<span class=\"string\">'./img.png'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">img</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> texture = cxt.createTexture();</div><div class=\"line\">        cxt.pixelStorei(cxt.UNPACK_FLIP_Y_WEBGL,<span class=\"number\">1</span>);</div><div class=\"line\">        cxt.activeTexture(cxt.TEXTURE0);</div><div class=\"line\">        cxt.bindTexture(cxt.TEXTURE_2D,texture);</div><div class=\"line\"></div><div class=\"line\">        cxt.texParameteri(cxt.TEXTURE_2D,cxt.TEXTURE_MIN_FILTER,cxt.LINEAR);</div><div class=\"line\">        cxt.texImage2D(cxt.TEXTURE_2D,<span class=\"number\">0</span>,cxt.RGB,cxt.RGB,cxt.UNSIGNED_BYTE,img);</div><div class=\"line\">        cxt.uniform1i(texLocation,<span class=\"number\">0</span>);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLE_STRIP,<span class=\"number\">0</span>,<span class=\"number\">4</span>);</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>最终效果如下：<br><img width=\"300\" src=\"/webgl-2017-07-10/2.jpeg\"></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/10\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/10</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"贴图概述\"><a href=\"#贴图概述\" class=\"headerlink\" title=\"贴图概述\"></a>贴图概述</h3><h4 id=\"图片类别\"><a href=\"#图片类别\" class=\"headerlink\" title=\"图片类别\"></a>图片类别</h4><ul>\n<li>JPG 格式，24位的颜色储存单个的绘图，是有损的压缩，牺牲图像质量可以控制文件大小</li>\n<li>GIF 格式，压缩比例能够达到40%到50%，无损压缩技术（必须保证256颜色的）</li>\n<li>PNG 格式，无损压缩</li>\n</ul>\n<h4 id=\"贴图开发流程\"><a href=\"#贴图开发流程\" class=\"headerlink\" title=\"贴图开发流程\"></a>贴图开发流程</h4><ul>\n<li>准备纹理图像</li>\n<li>配置图像映射方式</li>\n<li>加载纹理图像</li>\n<li>纹理贴图</li>\n</ul>","more":"<h3 id=\"贴图核心技术\"><a href=\"#贴图核心技术\" class=\"headerlink\" title=\"贴图核心技术\"></a>贴图核心技术</h3><h4 id=\"纹理坐标\"><a href=\"#纹理坐标\" class=\"headerlink\" title=\"纹理坐标\"></a>纹理坐标</h4><ul>\n<li>st坐标系</li>\n</ul>\n<p><img width=\"300\" src=\"/webgl-2017-07-10/1.jpeg\"></p>\n<h4 id=\"纹理对象\"><a href=\"#纹理对象\" class=\"headerlink\" title=\"纹理对象\"></a>纹理对象</h4><ul>\n<li>createTexture 创建纹理</li>\n<li>deleteTexture(tex) 删除纹理</li>\n</ul>\n<h4 id=\"图片加载\"><a href=\"#图片加载\" class=\"headerlink\" title=\"图片加载\"></a>图片加载</h4><ul>\n<li>确定图片加载后调用的函数</li>\n<li>图片开始加载</li>\n<li>向服务器请求图片</li>\n<li>服务器查找图片</li>\n<li>服务器返回图片数据</li>\n<li>浏览器收到图片数据</li>\n<li>调用回调函数</li>\n</ul>\n<h4 id=\"配置纹理\"><a href=\"#配置纹理\" class=\"headerlink\" title=\"配置纹理\"></a>配置纹理</h4><ul>\n<li>Y 轴反转</li>\n<li>开启纹理单元</li>\n<li>绑定纹理对象</li>\n<li>配置纹理参数</li>\n<li>配置纹理图形</li>\n<li>将纹理传递给着色器</li>\n</ul>\n<p>编写着色器代码，在片元着色器中定义贴图，基本如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 顶点着色器程序</span></div><div class=\"line\">    <span class=\"keyword\">const</span> vertexShaderSource =</div><div class=\"line\">        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t    attribute vec4 pos;</span></div><div class=\"line\"><span class=\"string\">\t    attribute vec2 texPos;</span></div><div class=\"line\"><span class=\"string\">\t    varying vec2 v_texPos;</span></div><div class=\"line\"><span class=\"string\">\t    void main() &#123;</span></div><div class=\"line\"><span class=\"string\">\t      gl_Position = pos;</span></div><div class=\"line\"><span class=\"string\">\t      v_texPos = texPos;</span></div><div class=\"line\"><span class=\"string\">\t&#125;`</span></div><div class=\"line\"></div><div class=\"line\">\t    <span class=\"comment\">// 片元着色器程序</span></div><div class=\"line\">\t    <span class=\"keyword\">const</span> fragmentShaderSource =</div><div class=\"line\">\t        <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">\t        precision lowp float;</span></div><div class=\"line\"><span class=\"string\">\t        uniform sampler2D ss;</span></div><div class=\"line\"><span class=\"string\">\t        varying vec2 v_texPos;</span></div><div class=\"line\"><span class=\"string\">\t        void main() &#123;</span></div><div class=\"line\"><span class=\"string\">\t      gl_FragColor = texture2D(ss,v_texPos);</span></div><div class=\"line\"><span class=\"string\">\t  &#125;`</span>   </div></pre></td></tr></table></figure>\n<p>将加载的图片画在canvas上面，基本代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadImg</span>(<span class=\"params\">url,callback</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image;</div><div class=\"line\">        img.src = url;</div><div class=\"line\">        img.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            callback(img);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    loadImg(<span class=\"string\">'./img.png'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">img</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> texture = cxt.createTexture();</div><div class=\"line\">        cxt.pixelStorei(cxt.UNPACK_FLIP_Y_WEBGL,<span class=\"number\">1</span>);</div><div class=\"line\">        cxt.activeTexture(cxt.TEXTURE0);</div><div class=\"line\">        cxt.bindTexture(cxt.TEXTURE_2D,texture);</div><div class=\"line\"></div><div class=\"line\">        cxt.texParameteri(cxt.TEXTURE_2D,cxt.TEXTURE_MIN_FILTER,cxt.LINEAR);</div><div class=\"line\">        cxt.texImage2D(cxt.TEXTURE_2D,<span class=\"number\">0</span>,cxt.RGB,cxt.RGB,cxt.UNSIGNED_BYTE,img);</div><div class=\"line\">        cxt.uniform1i(texLocation,<span class=\"number\">0</span>);</div><div class=\"line\">        cxt.drawArrays(cxt.TRIANGLE_STRIP,<span class=\"number\">0</span>,<span class=\"number\">4</span>);</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>最终效果如下：<br><img width=\"300\" src=\"/webgl-2017-07-10/2.jpeg\"></p>\n<p>源码链接请访问 <a href=\"https://github.com/wqzwh/webgl-code/tree/master/10\" target=\"_blank\" rel=\"external\">https://github.com/wqzwh/webgl-code/tree/master/10</a></p>"}],"PostAsset":[{"_id":"source/_posts/vue-ssr2/1.jpeg","slug":"1.jpeg","post":"cj9mi36rk000jlmldndw7q4dw","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/02.jpeg","slug":"02.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-08/1.jpeg","slug":"1.jpeg","post":"cj9mi36s1000zlmlddith6oqk","modified":0,"renderable":0},{"_id":"source/_posts/ajax/111.png","slug":"111.png","post":"cj9mi36re000elmld6w27wkeu","modified":0,"renderable":0},{"_id":"source/_posts/vue-ssr3/11.jpeg","slug":"11.jpeg","post":"cj9mi36rn000llmldesyz1z8e","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-09/1.jpeg","slug":"1.jpeg","post":"cj9mi36s30012lmld43a139rf","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-12/1.jpeg","slug":"1.jpeg","post":"cj9mi36sa0017lmld1mb5y65o","modified":0,"renderable":0},{"_id":"source/_posts/2017-06-11/01.jpeg","slug":"01.jpeg","post":"cj9mi36r9000almlda3wfio20","modified":0,"renderable":0},{"_id":"source/_posts/2017-06-11/02.jpeg","slug":"02.jpeg","post":"cj9mi36r9000almlda3wfio20","modified":0,"renderable":0},{"_id":"source/_posts/vue-ssr/11.png","slug":"11.png","post":"cj9mi36rh000hlmldry0a1u14","modified":0,"renderable":0},{"_id":"source/_posts/vue-ssr/22.jpeg","slug":"22.jpeg","post":"cj9mi36rh000hlmldry0a1u14","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-02/01.jpeg","slug":"01.jpeg","post":"cj9mi36rs000qlmldb2s9xha9","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-02/02.jpeg","slug":"02.jpeg","post":"cj9mi36rs000qlmldb2s9xha9","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-10/1.jpeg","slug":"1.jpeg","post":"cj9mi36sd0019lmldsffjxtgv","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-10/2.jpeg","slug":"2.jpeg","post":"cj9mi36sd0019lmldsffjxtgv","modified":0,"renderable":0},{"_id":"source/_posts/2017-05-07/1.png","slug":"1.png","post":"cj9mi36qz0006lmldbnp1idcc","modified":0,"renderable":0},{"_id":"source/_posts/2017-05-07/2.png","slug":"2.png","post":"cj9mi36qz0006lmldbnp1idcc","modified":0,"renderable":0},{"_id":"source/_posts/2017-05-07/3.png","slug":"3.png","post":"cj9mi36qz0006lmldbnp1idcc","modified":0,"renderable":0},{"_id":"source/_posts/vue-ssr2/2.jpeg","slug":"2.jpeg","post":"cj9mi36rk000jlmldndw7q4dw","modified":0,"renderable":0},{"_id":"source/_posts/vue-ssr2/3.jpeg","slug":"3.jpeg","post":"cj9mi36rk000jlmldndw7q4dw","modified":0,"renderable":0},{"_id":"source/_posts/vue-ssr2/4.jpeg","slug":"4.jpeg","post":"cj9mi36rk000jlmldndw7q4dw","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-04/01.jpeg","slug":"01.jpeg","post":"cj9mi36rx000vlmldis4kh05b","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-04/02.jpeg","slug":"02.jpeg","post":"cj9mi36rx000vlmldis4kh05b","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-04/03.jpeg","slug":"03.jpeg","post":"cj9mi36rx000vlmldis4kh05b","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-04/04.jpeg","slug":"04.jpeg","post":"cj9mi36rx000vlmldis4kh05b","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-11/01.jpeg","slug":"01.jpeg","post":"cj9mi36s50014lmldi0zwe8yj","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-11/2.jpeg","slug":"2.jpeg","post":"cj9mi36s50014lmldi0zwe8yj","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-11/3.jpeg","slug":"3.jpeg","post":"cj9mi36s50014lmldi0zwe8yj","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-11/4.jpeg","slug":"4.jpeg","post":"cj9mi36s50014lmldi0zwe8yj","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-03/01.jpeg","slug":"01.jpeg","post":"cj9mi36ru000tlmldbscwdhb8","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-03/02.jpeg","slug":"02.jpeg","post":"cj9mi36ru000tlmldbscwdhb8","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-03/03.jpeg","slug":"03.jpeg","post":"cj9mi36ru000tlmldbscwdhb8","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-03/04.jpeg","slug":"04.jpeg","post":"cj9mi36ru000tlmldbscwdhb8","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-03/05.jpeg","slug":"05.jpeg","post":"cj9mi36ru000tlmldbscwdhb8","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-06/1.jpeg","slug":"1.jpeg","post":"cj9mi36rz000xlmlduef0c4fo","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-06/2.jpeg","slug":"2.jpeg","post":"cj9mi36rz000xlmlduef0c4fo","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-06/3.jpeg","slug":"3.jpeg","post":"cj9mi36rz000xlmlduef0c4fo","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-06/4.jpeg","slug":"4.jpeg","post":"cj9mi36rz000xlmlduef0c4fo","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-06/5.jpeg","slug":"5.jpeg","post":"cj9mi36rz000xlmlduef0c4fo","modified":0,"renderable":0},{"_id":"source/_posts/2017-06-12/01.jpeg","slug":"01.jpeg","post":"cj9mi36rc000clmldmgqkhx90","modified":0,"renderable":0},{"_id":"source/_posts/2017-06-12/02.jpeg","slug":"02.jpeg","post":"cj9mi36rc000clmldmgqkhx90","modified":0,"renderable":0},{"_id":"source/_posts/2017-06-12/03.jpeg","slug":"03.jpeg","post":"cj9mi36rc000clmldmgqkhx90","modified":0,"renderable":0},{"_id":"source/_posts/2017-06-12/04.jpeg","slug":"04.jpeg","post":"cj9mi36rc000clmldmgqkhx90","modified":0,"renderable":0},{"_id":"source/_posts/2017-06-12/05.jpeg","slug":"05.jpeg","post":"cj9mi36rc000clmldmgqkhx90","modified":0,"renderable":0},{"_id":"source/_posts/2017-06-12/06.jpeg","slug":"06.jpeg","post":"cj9mi36rc000clmldmgqkhx90","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-08/2.jpeg","slug":"2.jpeg","post":"cj9mi36s1000zlmlddith6oqk","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-08/3.jpeg","slug":"3.jpeg","post":"cj9mi36s1000zlmlddith6oqk","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-08/5.jpeg","slug":"5.jpeg","post":"cj9mi36s1000zlmlddith6oqk","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-08/6.jpeg","slug":"6.jpeg","post":"cj9mi36s1000zlmlddith6oqk","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-08/7.jpeg","slug":"7.jpeg","post":"cj9mi36s1000zlmlddith6oqk","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/01.jpeg","slug":"01.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/03.jpeg","slug":"03.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/04.jpeg","slug":"04.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/05.jpeg","slug":"05.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/06.jpeg","slug":"06.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/07.jpeg","slug":"07.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/08.jpeg","slug":"08.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/09.jpeg","slug":"09.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/10.jpeg","slug":"10.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/11.jpeg","slug":"11.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/12.jpeg","slug":"12.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/13.jpeg","slug":"13.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/14.jpeg","slug":"14.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-01/15.jpeg","slug":"15.jpeg","post":"cj9mi36rp000nlmld1b0wh3hc","modified":0,"renderable":0},{"_id":"source/_posts/webgl-2017-07-11/5.jpeg","slug":"5.jpeg","post":"cj9mi36s50014lmldi0zwe8yj","modified":1,"renderable":0},{"_id":"source/_posts/webgl-2017-07-11/6.jpeg","slug":"6.jpeg","post":"cj9mi36s50014lmldi0zwe8yj","modified":1,"renderable":0},{"_id":"source/_posts/webgl-2017-07-11/7.jpeg","slug":"7.jpeg","post":"cj9mi36s50014lmldi0zwe8yj","modified":1,"renderable":0},{"_id":"source/_posts/webgl-2017-07-11/8.jpeg","slug":"8.jpeg","post":"cj9mi36s50014lmldi0zwe8yj","modified":1,"renderable":0}],"PostCategory":[{"post_id":"cj9mi36re000elmld6w27wkeu","category_id":"cj9mi36rj000ilmldivoj7wpd","_id":"cj9mi36ru000slmldncro8da2"}],"PostTag":[{"post_id":"cj9mi36qz0006lmldbnp1idcc","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36r90009lmldkcusy9sk"},{"post_id":"cj9mi36q80000lmlda0btjmke","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36re000dlmld13p27166"},{"post_id":"cj9mi36q80000lmlda0btjmke","tag_id":"cj9mi36r10007lmldmtwhn06s","_id":"cj9mi36rg000flmld27d4zdm9"},{"post_id":"cj9mi36qf0002lmldqax0zclp","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36ro000mlmld34fmgb4s"},{"post_id":"cj9mi36qf0002lmldqax0zclp","tag_id":"cj9mi36rg000glmldtr0ebocn","_id":"cj9mi36rr000olmldm6gt7tya"},{"post_id":"cj9mi36qm0004lmldw6enqe83","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36rt000rlmldxk5qh5f0"},{"post_id":"cj9mi36qu0005lmld5deopm8d","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36rz000wlmld2ieqgzpn"},{"post_id":"cj9mi36qu0005lmld5deopm8d","tag_id":"cj9mi36rr000plmldvah6b94u","_id":"cj9mi36s1000ylmld388ttvz3"},{"post_id":"cj9mi36r70008lmld8czfdf5m","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36s30011lmldu53t5hia"},{"post_id":"cj9mi36r70008lmld8czfdf5m","tag_id":"cj9mi36rx000ulmldnhah6rjs","_id":"cj9mi36s50013lmld5hkfw9db"},{"post_id":"cj9mi36r9000almlda3wfio20","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36s90016lmldoocdp8rb"},{"post_id":"cj9mi36r9000almlda3wfio20","tag_id":"cj9mi36rx000ulmldnhah6rjs","_id":"cj9mi36sd0018lmlde8v6ezfv"},{"post_id":"cj9mi36rc000clmldmgqkhx90","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36sg001blmld5ohcvnag"},{"post_id":"cj9mi36rc000clmldmgqkhx90","tag_id":"cj9mi36rx000ulmldnhah6rjs","_id":"cj9mi36sh001clmldsz0mu8aa"},{"post_id":"cj9mi36re000elmld6w27wkeu","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36si001flmldgg1rz0rq"},{"post_id":"cj9mi36re000elmld6w27wkeu","tag_id":"cj9mi36rr000plmldvah6b94u","_id":"cj9mi36si001glmld1187iizw"},{"post_id":"cj9mi36re000elmld6w27wkeu","tag_id":"cj9mi36sh001dlmldf3ylts5r","_id":"cj9mi36sj001ilmld737lsmlj"},{"post_id":"cj9mi36rh000hlmldry0a1u14","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36sj001jlmldaxuguds1"},{"post_id":"cj9mi36rh000hlmldry0a1u14","tag_id":"cj9mi36si001elmld4425zat4","_id":"cj9mi36sl001llmld0cgw4k2h"},{"post_id":"cj9mi36rk000jlmldndw7q4dw","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36sl001mlmldc0031731"},{"post_id":"cj9mi36rk000jlmldndw7q4dw","tag_id":"cj9mi36si001elmld4425zat4","_id":"cj9mi36sl001olmlddchqy5qc"},{"post_id":"cj9mi36rn000llmldesyz1z8e","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36sm001plmldqiedf8mi"},{"post_id":"cj9mi36rn000llmldesyz1z8e","tag_id":"cj9mi36si001elmld4425zat4","_id":"cj9mi36sn001rlmldyo0ewyzp"},{"post_id":"cj9mi36rp000nlmld1b0wh3hc","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36sn001slmldjgzq39tv"},{"post_id":"cj9mi36rp000nlmld1b0wh3hc","tag_id":"cj9mi36sl001nlmld48bor4ec","_id":"cj9mi36so001ulmld4jrd54gg"},{"post_id":"cj9mi36rs000qlmldb2s9xha9","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36so001vlmldhywau7z1"},{"post_id":"cj9mi36rs000qlmldb2s9xha9","tag_id":"cj9mi36sl001nlmld48bor4ec","_id":"cj9mi36sp001xlmlduobq6vd8"},{"post_id":"cj9mi36ru000tlmldbscwdhb8","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36sp001ylmldc17qke85"},{"post_id":"cj9mi36ru000tlmldbscwdhb8","tag_id":"cj9mi36sl001nlmld48bor4ec","_id":"cj9mi36sq0020lmldez4ztaom"},{"post_id":"cj9mi36rx000vlmldis4kh05b","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36sq0021lmld4pof1bhz"},{"post_id":"cj9mi36rx000vlmldis4kh05b","tag_id":"cj9mi36sl001nlmld48bor4ec","_id":"cj9mi36sq0023lmldpv4t1ce6"},{"post_id":"cj9mi36rz000xlmlduef0c4fo","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36sq0024lmldobuvf5vw"},{"post_id":"cj9mi36rz000xlmlduef0c4fo","tag_id":"cj9mi36sl001nlmld48bor4ec","_id":"cj9mi36sr0026lmlde5ogamzh"},{"post_id":"cj9mi36s1000zlmlddith6oqk","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36sr0027lmldts9o6131"},{"post_id":"cj9mi36s1000zlmlddith6oqk","tag_id":"cj9mi36sl001nlmld48bor4ec","_id":"cj9mi36ss0029lmld2jn434ds"},{"post_id":"cj9mi36s30012lmld43a139rf","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36ss002almldne349iws"},{"post_id":"cj9mi36s30012lmld43a139rf","tag_id":"cj9mi36sl001nlmld48bor4ec","_id":"cj9mi36st002clmldubzh85xk"},{"post_id":"cj9mi36s50014lmldi0zwe8yj","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36st002dlmldl38jtufu"},{"post_id":"cj9mi36s50014lmldi0zwe8yj","tag_id":"cj9mi36sl001nlmld48bor4ec","_id":"cj9mi36st002flmldv2cey2jw"},{"post_id":"cj9mi36sa0017lmld1mb5y65o","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36st002glmlduwm1ulsr"},{"post_id":"cj9mi36sa0017lmld1mb5y65o","tag_id":"cj9mi36sl001nlmld48bor4ec","_id":"cj9mi36su002hlmlddfkl1c5o"},{"post_id":"cj9mi36sd0019lmldsffjxtgv","tag_id":"cj9mi36qj0003lmldlwxx679o","_id":"cj9mi36su002ilmld8ln5nfa8"},{"post_id":"cj9mi36sd0019lmldsffjxtgv","tag_id":"cj9mi36sl001nlmld48bor4ec","_id":"cj9mi36su002jlmldhquw5e80"}],"Tag":[{"name":"javascript","_id":"cj9mi36qj0003lmldlwxx679o"},{"name":"node","_id":"cj9mi36r10007lmldmtwhn06s"},{"name":"es6","_id":"cj9mi36rg000glmldtr0ebocn"},{"name":"ajax","_id":"cj9mi36rr000plmldvah6b94u"},{"name":"react","_id":"cj9mi36rx000ulmldnhah6rjs"},{"name":"302","_id":"cj9mi36sh001dlmldf3ylts5r"},{"name":"vue","_id":"cj9mi36si001elmld4425zat4"},{"name":"webgl","_id":"cj9mi36sl001nlmld48bor4ec"}]}}