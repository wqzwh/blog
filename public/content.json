[{"title":"如何使用vue-ssr做服务端渲染初体验(二)","date":"2017-06-02T12:09:11.000Z","path":"vue-ssr2/","text":"1、前言上一节我们大致讲了为什么需要使用vue后端渲染，以及vue后端渲染的基本原理，这节内容我们将从零开始搭建属于自己的vue后端渲染脚手架，当然不能不参考官方页面响应的实例vue-hackernews-2.0，从零开始搭建项目,源码在将在下节与大家共享。 2、前期准备基本环境要求：node版本6.10.1以上，npm版本3.10.10以上，本机环境是这样的，建议升级到官方最新版本。 使用的技术栈： 1、vue 2.4.22、vuex 2.3.13、vue-router 2.7.04、vue-server-renderer 2.4.25、express 4.15.46、axios 0.16.27、q https://github.com/kriskowal/q.git8、webpack 3.5.09、mockjs 1.0.1-beta310、babel 以上是主要是用的技术栈，在构建过程中会是用相应的插件依赖包来配合进行压缩打包，以下是npm init后package.json文件所要添加的依赖包。 3、项目主目录搭建基本目录结构如下： 文件目录基本介绍： components 主要存放组件代码，里面可以根据业务场景再次细分模块组件等。lib 主要存放第三方库文件，方便用户直接引入使用public 主要存放公共组件代码和项目使用的公共文件代码，例如后期我们将axios封装成公共的api库文件等等。router 主要存放前端路由配置文件，写法规范按照vue-router官方例子即可。store 主要是存放共享状态文件，里面包含action.js,getter.js,mutationtype.js,state.js等，后期会根据模块再细分这些。app.js 是项目入口文件App.vue 是项目入口文件entry-client和entry-server分别是客户端入口文件和服务端的入口文件index.template.html是整个项目的模版文件 开始编写app.js项目入口代码使用vue开发项目入口文件一般都会如下写法：1234567891011import Vue from 'vue';import App from './index.vue';import router from './router'import store from './store';new Vue(&#123; el: '#app', store, router, render: (h) =&gt; h(App)&#125;); 这种写法是程序共享一个vue实例，但是在后端渲染中很容易导致交叉请求状态污染，导致数据流被污染了。 所以，避免状态单例,我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例，同样router和store入口文件也需要重新创建一个实例。 为了配合webpack动态加载路由配置，这里会改写常规路由引入写法，这样可以根据路由路径来判断加载相应的组件代码： 123import Home from '../components/Home.vue'// 改写成component: () =&gt; ('../components/Home.vue') 以下是路由的基本写法router，对外会抛出一个createRouter方法来创建一个新的路由实例： 1234567891011121314import Vue from 'vue'import Router from 'vue-router';Vue.use(Router)export function createRouter() &#123; return new Router(&#123; mode: 'history', routes: [&#123; name:'home', path: '/', component: () =&gt; import ('../components/Home.vue') &#125;] &#125;)&#125; 以下是store状态管理的基本写法，对外暴露了一个createStore方法，方便每次访问创建一个新的实例： 12345678910111213141516import Vue from 'vue'import Vuex from 'vuex'import actions from './actions'import getters from './getters'// 按照组件的复杂度是否使用modulesimport Home from './modules/Home'Vue.use(Vuex)export function createStore() &#123; return new Vuex.Store(&#123; actions, getters, modules:&#123; Home &#125;, &#125;)&#125; 结合写好的router和store入口文件代码来编写整个项目的入口文件app.js代码内容，同样最终也会对外暴露一个createApp方法，在每次创建app的时候保证router，store，app都是新创建的实例，这里还引入了一个vue路由插件vuex-router-sync，主要作用是同步路由状态(route state)到 store，以下是app.js完整代码： 1234567891011121314151617181920import Vue from 'vue'import App from './App.vue'import &#123; createRouter &#125; from './router'import &#123; createStore &#125; from './store'import &#123; sync &#125; from 'vuex-router-sync'export function createApp () &#123; // 创建 router 和 store 实例 const router = createRouter() const store = createStore() // 同步路由状态(route state)到 store sync(store, router) // 创建应用程序实例，将 router 和 store 注入 const app = new Vue(&#123; router, store, render: h =&gt; h(App) &#125;) // 暴露 app, router 和 store。 return &#123; app, router, store &#125;&#125; entry-client.js代码编写：首页引入从app文件中暴露出来的createApp方法，在每次调用客户端的时候，重新创建一个新的app，router，store，部分代码如下： 12import &#123; createApp &#125; from './app'const &#123; app, router, store &#125; = createApp() 这里我们会使用到onReady方法，此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染的时候，例子代码如下： 12345import &#123; createApp &#125; from './app'const &#123; app, router, store &#125; = createApp()router.onReady(() =&gt; &#123; app.$mount('#app')&#125;) 我们会调用一个新方法beforeResolve，只有在router2.5.0以上的版本才会有的方法，注册一个类似于全局路由保护router.beforeEach()，除了在导航确认之后，在所有其他保护和异步组件已解决之后调用。基本写法如下： 123456router.beforeResolve((to, from, next) =&gt; &#123; // to 和 from 都是 路由信息对象 // 返回目标位置或是当前路由匹配的组件数组（是数组的定义/构造类，不是实例）。通常在服务端渲染的数据预加载时时候。 const matched = router.getMatchedComponents(to) const prevMatched = router.getMatchedComponents(from)&#125;) 服务端把要给客户端的 state 放在了 window.INITIAL_STATE 这个全局变量上面。前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（INITIAL_STATE），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。基本代码如下：1234// 将服务端渲染时候的状态写入vuex中if (window.__INITIAL_STATE__) &#123; store.replaceState(window.__INITIAL_STATE__)&#125; 接下来贴出来完整的客户端代码，这里的Q也可以不用引入，直接使用babel就能编译es6自带的Promise，因为本人使用习惯了，这里可以根据自身的需求是否安装：1234567891011121314151617181920212223242526272829303132import &#123; createApp &#125; from './app'import Q from 'q';const &#123; app, router, store &#125; = createApp()router.onReady(() =&gt; &#123; router.beforeResolve((to, from, next) =&gt; &#123; const matched = router.getMatchedComponents(to) const prevMatched = router.getMatchedComponents(from) // 我们只关心之前没有渲染的组件 // 所以我们对比它们，找出两个匹配列表的差异组件 let diffed = false const activated = matched.filter((c, i) =&gt; &#123; return diffed || (diffed = (prevMatched[i] !== c)) &#125;) if (!activated.length) &#123; return next() &#125; // 这里如果有加载指示器(loading indicator)，就触发 Q.all(activated.map(c =&gt; &#123; if (c.asyncData) &#123; return c.asyncData(&#123; store, route: to &#125;) &#125; &#125;)).then(() =&gt; &#123; // 停止加载指示器(loading indicator) next() &#125;).catch(next) &#125;) app.$mount('#app')&#125;)// 将服务端渲染时候的状态写入vuex中if (window.__INITIAL_STATE__) &#123; store.replaceState(window.__INITIAL_STATE__)&#125; entry-server.js代码编写：基本编写和客户端的差不多，因为这是服务端渲染，涉及到与后端数据交互定义的问题，我们需要在这里定义好各组件与后端交互使用的方法名称，这样方便在组件内部直接使用，这里根我们常规在组件直接使用ajax获取数据有些不一样，代码片段如下：1234567//直接定义组件内部asyncData方法来触发相应的ajax获取数据if (Component.asyncData) &#123; return Component.asyncData(&#123; store, route: router.currentRoute &#125;)&#125; 以下是完整的服务端代码：12345678910111213141516171819202122232425262728293031import &#123; createApp &#125; from './app'import Q from 'q'export default context =&gt; &#123; return new Q.Promise((resolve, reject) =&gt; &#123; const &#123; app, router, store &#125; = createApp() router.push(context.url) router.onReady(() =&gt; &#123; const matchedComponents = router.getMatchedComponents() if (!matchedComponents.length) &#123; return reject(&#123; code: 404 &#125;) &#125; // 对所有匹配的路由组件调用 `asyncData()` Q.all(matchedComponents.map(Component =&gt; &#123; if (Component.asyncData) &#123; return Component.asyncData(&#123; store, route: router.currentRoute &#125;) &#125; &#125;)).then(() =&gt; &#123; // 在所有预取钩子(preFetch hook) resolve 后， // 我们的 store 现在已经填充入渲染应用程序所需的状态。 // 当我们将状态附加到上下文， // 并且 `template` 选项用于 renderer 时， // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。 context.state = store.state resolve(app) &#125;).catch(reject) &#125;, reject) &#125;)&#125; 4、脚手架其他目录介绍：到这里src下面主要的几个文件代码已经编写完成，接下里介绍下整个项目的目录结构如下： 主要几个文件介绍如下：build 主要存放webpack打包配置文件dist webpack打包后生成的目录log 使用pm2监控进程存放的日志文件目录server.js node服务器启动文件pmlog.json pm2配置文件 server.js入口文件编写我们还需要编写在服务端启动服务的代码server.js，我们会使用到部分node原生提供的api，片段代码如下：1234567const Vue = require('vue')const express = require('express')const path = require('path')const LRU = require('lru-cache')const &#123; createBundleRenderer &#125; = require('vue-server-renderer')const fs = require('fs')const net = require('net') 大致思路是，引入前端模版页面index.template.html，使用express启动服务，引入webpack打包项目代码的dist文件，引入缓存模块（这里不做深入介绍，后期会单独详细介绍），判断端口是否被占用，自动启动其他接口服务。 引入前端模版文件并且设置环境变量为production，片段代码如下：12const template = fs.readFileSync('./src/index.template.html', 'utf-8')const isProd = process.env.NODE_ENV === 'production' vue-server-renderer插件的具体使用，通过读取dist文件夹下的目录文件，来创建createBundleRenderer函数，并且使用LRU来设置缓存的时间，通过判断是生产环境还是开发环境，调用不同的方法，代码片段如下：12345678910111213141516171819202122232425const resolve = file =&gt; path.resolve(__dirname, file)function createRenderer (bundle, options) &#123; return createBundleRenderer(bundle, Object.assign(options, &#123; template, cache: LRU(&#123; max: 1000, maxAge: 1000 * 60 * 15 &#125;), basedir: resolve('./dist'), runInNewContext: false &#125;))&#125;let renderer;let readyPromiseif (isProd) &#123; const bundle = require('./dist/vue-ssr-server-bundle.json') const clientManifest = require('./dist/vue-ssr-client-manifest.json') renderer = createRenderer(bundle, &#123; clientManifest &#125;)&#125; else &#123; readyPromise = require('./build/setup-dev-server')(server, (bundle, options) =&gt; &#123; renderer = createRenderer(bundle, options) &#125;)&#125; 使用express启动服务，代码片段如下：1234567891011121314151617181920const server = express()；//定义在启动服务钱先判断中间件中的缓存是否过期，是否直接调用dist文件。const serve = (path, cache) =&gt; express.static(resolve(path), &#123; maxAge: cache &amp;&amp; isProd ? 1000 * 60 * 60 * 24 * 30 : 0&#125;)server.use('/dist', serve('./dist', true))server.get('*', (req, res) =&gt; &#123; const context = &#123; title: 'hello', url: req.url &#125; renderer.renderToString(context, (err, html) =&gt; &#123; if (err) &#123; res.status(500).end('Internal Server Error') return &#125; res.end(html) &#125;)&#125;) 判断端口是否被占用，片段代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function probe(port, callback) &#123; var servers = net.createServer().listen(port) var calledOnce = false var timeoutRef = setTimeout(function() &#123; calledOnce = true callback(false, port) &#125;, 2000) timeoutRef.unref() var connected = false servers.on('listening', function() &#123; clearTimeout(timeoutRef) if (servers) servers.close() if (!calledOnce) &#123; calledOnce = true callback(true, port) &#125; &#125;) servers.on('error', function(err) &#123; clearTimeout(timeoutRef) var result = true if (err.code === 'EADDRINUSE') result = false if (!calledOnce) &#123; calledOnce = true callback(result, port) &#125; &#125;)&#125;var checkPortPromise = new Promise((resolve) =&gt; &#123; (function serverport(_port) &#123; var pt = _port || 8080; probe(pt, function(bl, _pt) &#123; // 端口被占用 bl 返回false // _pt：传入的端口号 if (bl === true) &#123; // console.log(\"\\n Static file server running at\" + \"\\n\\n=&gt; http://localhost:\" + _pt + '\\n'); resolve(_pt); &#125; else &#123; serverport(_pt + 1) &#125; &#125;) &#125;)()&#125;)checkPortPromise.then(data =&gt; &#123; uri = 'http://localhost:' + data; console.log('启动服务路径'+uri) server.listen(data);&#125;); 到这里，基本的代码已经编写完成，webpack打包配置文件基本和官方保持不变，接下来可以尝试启动本地的项目服务，查看基本的demo展示。 下节，我将介绍下mockjs，axios怎么封装成公共函数便于使用","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"如何使用vue-ssr做服务端渲染初体验(-)","date":"2017-06-01T13:09:11.000Z","path":"vue-ssr/","text":"1、前言服务端渲染实现原理机制：在服务端拿数据进行解析渲染，直接生成html片段返回给前端。然后前端可以通过解析后端返回的html片段到前端页面，大致有以下两种形式： 1、服务器通过模版引擎直接渲染整个页面，例如java后端的vm模版引擎，php后端的smarty模版引擎。2、服务渲染生成html代码块, 前端通过AJAX获取然后使用js动态添加。 2、服务端渲染的优劣服务端渲染能够解决两大问题： 1、seo问题，有利于搜索引擎蜘蛛抓取网站内容，利于网站的收录和排名。2、首屏加载过慢问题，例如现在成熟的SPA项目中，打开首页需要加载很多资源，通过服务端渲染可以加速首屏渲染。 同样服务端渲染也会有弊端，主要是根据自己的业务场景来选择适合方式，由于服务端渲染前端页面，必将会给服务器增加压力。 3、SSR的实现原理客户端请求服务器，服务器根据请求地址获得匹配的组件，在调用匹配到的组件返回 Promise (官方是preFetch方法)来将需要的数据拿到。最后再通过 1&lt;script&gt;window.__initial_state=data&lt;/script&gt; 将其写入网页，最后将服务端渲染好的网页返回回去。 接下来客户端会将vuex将写入的 initial_state 替换为当前的全局状态树，再用这个状态树去检查服务端渲染好的数据有没有问题。遇到没被服务端渲染的组件，再去发异步请求拿数据。说白了就是一个类似React的 shouldComponentUpdate 的Diff操作。 Vue2使用的是单向数据流，用了它，就可以通过 SSR 返回唯一一个全局状态， 并确认某个组件是否已经SSR过了。 4、vue后端渲染主要插件：vue-server-renderer由于virtual dom的引入，使得vue的服务端渲染成为了可能，下面是官方 vue-server-renderer提供的渲染流程图: 可以看出vue的后端渲染分三个部分组成：页面的源码（source），node层的渲染部分和浏览器端的渲染部分。 source分为两种entry point,一个是前端页面的入口client entry,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口server entry,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象（经过测试，直接返回Vue对象也是可以的）; 前面的source部分就是业务开发的代码，开发完成之后通过 webpack 进行构建，生成对应的bundle，这里不再赘述client bundle,就是一个可在浏览器端执行的打包文件；这里说下server bundle, vue2提供 vue-server-renderer模块，模块可以提供两种render: rendererer/bundleRenderer ,下面分别介绍下这两种render。 renderer接收一个vue对象 ，然后进行渲染，这种对于简单的vue对象,可以这么去做，但是对于复杂的项目，如果使用这种直接require一个vue对象，这个对于服务端代码的结构和逻辑都不太友好，首先模块的状态会一直延续在每个请求渲染请求，我们需要去管理和避免这次渲染请求的状态影响到后面的请求,因此vue-server-renderer提供了另外一种渲染模式，通过一个 bundleRenderer去做渲染。 bundleRenderer是较为复杂项目进行服务端渲染官方推荐的方式，通过webpack以server entry按照一定的要求打包生成一个 server-bundle,它相当于一个可以给服务端用的app的打包压缩文件，每一次调用都会重新初始化 vue对象，保证了每次请求都是独立的，对于开发者来说，只需要专注于当前业务就可以，不用为服务端渲染开发更多的逻辑代码。renderer生成完成之后，都存在两个接口，分别是renderToString和renderToStream，一个是一次性将页面渲染成字符串文件，另外一个是流式渲染，适用于支持流的web服务器，可以是请求服务的速度更快。 5、项目基本结构如下 如何从零开始搭建适合自己的vue后端渲染框架？","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"浅谈webworker的使用场景","date":"2017-05-07T13:09:11.000Z","path":"2017-05-07/","text":"一、webWorker之初体验在”setTimeout那些事儿”中，说到JavaScript是单线程。也就是同一时间只能做同一事情。 也好理解，作为浏览器脚本语言，如果JavaScript不是单线程，那么就有点棘手了。比如，与用户交互或者对DOM进行操作时，在一个线程上修改某个DOM，另外的线程删除DOM，这时浏览器该如何抉择呢? 所以，JavaScript是单线程也是有背景的。 如下： 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;singleThread&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //添加到任务队列中，待同步任务所处的‘执行栈’执行完毕，1秒后执行任务队列中的这个匿名函数 setTimeout(function()&#123; console.log('come on'); &#125;,1000); //只要不关闭该alert，‘执行栈’就没结束，从而也就不会进入到任务队列中 alert('waiting'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 但，HTML5引入了一个工作线程（webWorker）的概念。它允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。 简而言之，就是允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。 从而，可以用webWorker来处理一些比较耗时的计算。 如下，主页面： 12345678910111213141516171819&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; //创建一个Worker对象，并向它传递将在新线程中执行的脚本url var worker = new Worker('worker.js'); //接收worker传递过来的数据 worker.onmessage = function(event)&#123; document.getElementById('result').innerHTML+=event.data+\"&lt;br/&gt;\" ; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 下面是worker.js的内容: 123456789101112131415var i = 0;function timedCount()&#123; for(var j = 0, sum = 0; j &lt; 100; j++)&#123; for(var i = 0; i &lt; 100000000; i++)&#123; sum+=i; &#125;; &#125;; //将得到的sum发送回主线程 postMessage(sum);&#125;;//将执行timedCount前的时间，通过postMessage发送回主线程postMessage('Before computing, '+new Date());timedCount();//结束timedCount后，将结束时间发送回主线程postMessage('After computing, ' +new Date()); 上面代码执行的流程是：创建的worker对象，并用onmessage方法接收worker.js里面postMessage传递过来的数据(event.data)，并将数据追加到div#result中。 所以，执行上面的代码结果如下： 待worker.js中的timedCount方法运算完后，执行postMessage操作，向主线程传数据，得图二。期间，并不影响主线程的运作。 二、webWorker之常用ＡＰＩ接下来，再来看看关于worker的常用API： 1、postMessage(data)子线程与主线程之间互相通信使用方法，传递的data为任意值。 123456//worker = new Worker('url');//worker.postMessage传递给子线程数据，对象worker.postMessage(&#123;first:1,second:2&#125;);//子线程中也可以使用postMessage，如传递字符串postMessage(‘test’); 2、terminate()主线程中终止worker，此后无法再利用其进行消息传递。注意：一旦terminate后，无法重新启用，只能另外创建。 12//worker = new Worker('url');worker.terminate(); 如，主页面： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; var worker = new Worker('worker.js'); //每隔100毫秒，向子线程传递&#123;name: 'monkey'&#125;信息 setInterval(function()&#123; worker.postMessage(&#123;name: 'monkey'&#125;); &#125;,100); //当主线程worker收到来自子线程的消息后，触发message事件 worker.onmessage = function(event)&#123; document.getElementById('result').innerHTML+=event.data+\"&lt;br/&gt;\" ; //主线程使用terminate方法中断与子线程来往，在浏览器中只能显示一次event.data worker.terminate(); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 子线程worker.js代码： 1234567&lt;script&gt;//当主线程发来信息后，触发该message事件onmessage = function(event)&#123; //向主线程发送event.data.name信息 postMessage(event.data.name);&#125;;&lt;/script&gt; 3、message当有消息发送时，触发该事件。且，消息发送是双向的，消息内容可通过data来获取。 message使用，可见terminate中的demo 4、error出错处理。且错误消息可以通过e.message来获取。 如下： 1234567//worker = new Worker('url');worker.onerror = function(e)&#123; //打印出错消息 console.log(e.message); //中断与子线程的联系 worker.terminate();&#125; 另：worker线程从上到下同步运行它的代码，然后进入异步阶段来对事件及计时器响应，如果worker注册了message事件处理程序，只要其有可能触发，worker就一直在内存中，不会退出，所以通信完毕后得手动在主线程中terminate或者子线程中close掉，但如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，他就会退出。 三、worker上下文先看下面这段代码： 主页面： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; var worker = new Worker('worker.js'); //接收消息事件 worker.onmessage = function(event)&#123; console.log(event.data); &#125;; //错误信息事件 worker.onerror = function(e)&#123; console.log('erro: ' + e.message); //终止线程 worker.terminate(); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;/body&gt;&lt;/html&gt; worker.js 123456//window对象的alert方法alert(1);onmessage = function(event)&#123; //向主线程发送event.data.name信息 postMessage(event.data.name);&#125;; 执行上面代码结果： 为什么会这样呢？原因是alert为window对象的方法，所以会报错undefined。 worker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做WorkerGlobalScope的东东，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。WorkerGlobalScope作用域下的常用属性、方法如下： 1、self 我们可以使用 WorkerGlobalScope 的 self 属性来或者这个对象本身的引用 2、location location 属性返回当线程被创建出来的时候与之关联的 WorkerLocation 对象，它表示用于初始化这个工作线程的脚步资源的绝对 URL，即使页面被多次重定向后，这个 URL 资源位置也不会改变。 3、close 关闭当前线程，与terminate作用类似 4、importScripts 我们可以通过importScripts()方法通过url在worker中加载库函数 5、XMLHttpRequest 有了它，才能发出Ajax请求 6、setTimeout/setInterval以及addEventListener/postMessage四、关于worker我们可以做什么： 1.可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信 2.可以在worker中通过importScripts(url)加载另外的脚本文件 3.可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval() 4.可以使用XMLHttpRequest来发送请求 5.可以访问navigator的部分属性 局限性： 1.不能跨域加载JS 2.worker内代码不能访问DOM 3.各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行 4.IE这个新特性","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"}]},{"title":"详解javascript对象方法Object.assign()痛点","date":"2017-04-11T13:55:28.000Z","path":"2017-04-11/","text":"函数原型首先看一下函数的定义：函数参数为一个目标对象（该对象作为最终的返回值）,源对象(此处可以为任意多个)。通过调用该函数可以拷贝所有可被枚举的自有属性值到目标对象中。 Object.assign(target, …sources) 这里我们需要强调的三点是： 可被枚举的属性 自有属性 string或者Symbol类型是可以被直接分配的 拷贝过程中将调用源对象的getter方法，并在target对象上使用setter方法实现目标对象的拷贝。 函数实例这里我们通过几个MDN上的例子来介绍一下使用方法： 实例一我们参考上面的原型函数说明即可知道其最开始的o1因为设置为target，则调用其setter方法设置了其他对象的属性到自身。 12345678var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed. 实例二我们自定义了一些对象，这些对象有一些包含了不可枚举的属性,另外注意使用 Object.defineProperty 初始化的对象默认是不可枚举的属性。对于可枚举的对象我们可以直接使用Object.keys()获得,或者使用for-in循环遍历出来. 对于不可枚举的属性，使用Object.assign的时候将被自动忽略。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124var obj = Object.create(&#123; foo: 1 &#125;, &#123; // foo is an inherit property. bar: &#123; value: 2 // bar is a non-enumerable property. &#125;, baz: &#123; value: 3, enumerable: true // baz is an own enumerable property. &#125;&#125;);var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; baz: 3 &#125; ``` ### 实例三对于只读的属性，当分配新的对象覆盖他的时候，将抛出异常:``` javascriptvar target = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 1, writable: false&#125;); Object.assign(target, &#123; bar: 2 &#125;)//&#123;bar: 2, foo: 1&#125;Object.assign(target, &#123; foo: 2 &#125;)//Uncaught TypeError: Cannot assign to read only property 'foo' of object '#&lt;Object&gt;'(…)``` ## Polyfill这里我们简单的看下如何实现es5版本的Object.assign：实现步骤：判断是否原生支持该函数，如果不存在的话创建一个立即执行函数，该函数将创建一个assign函数绑定到Object上。判断参数是否正确(目的对象不能为空，我们可以直接设置&#123;&#125;传递进去,但必须设置该值)使用Object在原有的对象基础上返回该对象，并保存为out使用for…in循环遍历出所有的可枚举的自有对象。并复制给新的目标对象(hasOwnProperty返回非原型链上的属性)源码如下：``` javascript if (typeof Object.assign != 'function') &#123; (function () &#123; Object.assign = function (target) &#123; 'use strict'; if (target === undefined || target === null) &#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; var output = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var source = arguments[index]; if (source !== undefined &amp;&amp; source !== null) &#123; for (var nextKey in source) &#123; if (source.hasOwnProperty(nextKey)) &#123; output[nextKey] = source[nextKey]; &#125; &#125; &#125; &#125; return output; &#125;;&#125;)();&#125;``` ## 扩展内容### 深度拷贝和前拷贝javascript中存储对象都是存地址的，所以浅拷贝是都指向同一块内存区块，而深拷贝则是另外开辟了一块区域，下面实例也可以看出这一点：``` javascript// 浅拷贝const a = &#123;t: 1, p: 'gg'&#125;;const b = a;b.t = 3;console.log(a); // &#123;t: 3, p: 'gg'&#125;console.log(b); // &#123;t: 3, p: 'gg'&#125;//深拷贝const c = &#123;t: 1, p: 'gg'&#125;;const d = deepCopy(c);d.t = 3;console.log(c); // &#123;t: 1, p: 'gg'&#125;console.log(d); // &#123;t: 3, p: 'gg'&#125;``` 可以明显看出，浅拷贝在改变其中一个值时，会导致其他也一起改变，而深拷贝不会。我需要的是深拷贝的方法，然后发现原来es6 中有Object.assign() 这个方法，感觉可以拿来用了。 贴一下两个官方例子：``` javascript// Cloning an objectvar obj = &#123; a: 1 &#125;;var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125;// Merging objectsvar o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed. 是不是很完美，又可以clone又可以merge。在我这种情况下，我觉得我的代码量又可以减少了，比如： 1234567891011121314151617const defaultOpt = &#123; title: 'hello', name: 'oo', type: 'line'&#125;;// 原来可能需要这样const opt1 = deepCopy(a);opt1.title = 'opt1';opt1.type = 'bar';opt1.extra = 'extra'; // 额外增加配置// 现在只要这样const opt2 = Object.assign(&#123;&#125;, a, &#123; title: 'opt2', type: 'bar', extra: 'extra'&#125;); 不过，很快，问题出现了，那就是merge和我想象的不一样且看例子： 1234567891011121314151617181920212223242526272829const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125;&#125;;const opt = Object.assign(&#123;&#125;, defaultOpt, &#123; title: &#123; subtext: 'Yes, your world.' &#125;&#125;);console.log(opt);// 预期结果&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125;// 实际结果&#123; title: &#123; subtext: 'Yes, your world.' &#125;&#125; 原本想的是它只会覆盖subtext ，然而其实它直接覆盖了整个title ，这个让我比较郁闷，相当于它只merge根属性，下面的就不做处理了。代码只能重构成相对麻烦一点的： 12345678910111213141516171819const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125;&#125;;const opt = Object.assign(&#123;&#125;, defaultOpt);opt.title.subtext = 'Yes, your world.';console.log(opt);// 结果正常&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125; 这样用虽然麻烦一点，但是也还好，可以用了。不过。。。很快，又出现问题了，如下： 12345678910111213141516171819202122232425262728293031const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125; &#125;;const opt1 = Object.assign(&#123;&#125;, defaultOpt);const opt2 = Object.assign(&#123;&#125;, defaultOpt);opt2.title.subtext = 'Yes, your world.';console.log('opt1:');console.log(opt1);console.log('opt2:');console.log(opt2);// 结果opt1:&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125;opt2:&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125; 上面结果发现两个配置变得一模一样，而其实我们并没有去更改opt1 的subtext ，只是改了opt2 的。这说明一点：在title 这一层只是简单的浅拷贝 ，而没有继续深入的深拷贝。 Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。用的时候，还是要注意这个问题的。不过github上已经有很多好的解决方案，比如deep-merge 通过递归的方式逐层的去调用assign函数。Lodash提供了深拷贝的api方法，其实熟悉jquery的同学，extend这个api就能直接完美解决深拷贝的问题。 附发现一个可以简单实现深拷贝的方法，当然，有一定限制，如下： const obj1 = JSON.parse(JSON.stringify(obj)); 思路就是将一个对象转成json字符串，然后又将字符串转回对象。但是在使用中还是会存在问题，进过测试会把function替换掉，使用的时候还得注意。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://www.iwangqi.com/tags/es6/"}]},{"title":"理解JavaScript函数式编程","date":"2017-04-10T14:14:43.000Z","path":"2017-04-10/","text":"JavaScript 函数式编程是一个存在了很久的话题，但似乎从 2016 年开始，它变得越来越火热。这可能是因为 ES6 语法对于函数式编程更为友好，也可能是因为诸如 RxJS (ReactiveX) 等函数式框架的流行。 看过许多关于函数式编程的讲解，但是其中大部分是停留在理论层面，还有一些是仅针对 Haskell 等纯函数式编程语言的。而本文旨在聊一聊我眼中的函数式编程在 JavaScript 中的具体实践，之所以是 “我眼中的” 即我所说的仅代表个人观点，可能和部分 严格概念 是有冲突的。 本文将略去一大堆形式化的概念介绍，重点展示在 JavaScript 中到底什么是函数式的代码、函数式代码与一般写法有什么区别、函数式的代码能给我们带来什么好处以及常见的一些函数式模型都有哪些。 函数式编程我认为函数式编程可以理解为，以函数作为主要载体的编程方式，用函数去拆解、抽象一般的表达式 与命令式相比，这样做的好处在哪？主要有以下几点： 语义更加清晰 可复用性更高 可维护性更好 作用域局限，副作用少 基本的函数式编程下面例子是一个具体的函数式体现 123456789101112131415161718192021222324// 一般写法const arr = ['apple', 'pen', 'apple-pen'];for(const i in arr)&#123; const c = arr[i][0]; arr[i] = c.toUpperCase() + arr[i].slice(1);&#125;console.log(arr);// 函数式写法一function upperFirst(word) &#123; return word[0].toUpperCase() + word.slice(1);&#125;function wordToUpperCase(arr) &#123; return arr.map(upperFirst);&#125;console.log(wordToUpperCase(['apple', 'pen', 'apple-pen']));// 函数式写法二console.log(arr.map(['apple', 'pen', 'apple-pen'], word =&gt; word[0].toUpperCase() + word.slice(1))); 当情况变得更加复杂时，表达式的写法会遇到几个问题： 表意不明显，逐渐变得难以维护 复用性差，会产生更多的代码量 会产生很多中间变量 函数式编程很好的解决了上述问题。首先参看 函数式写法一，它利用了函数封装性将功能做拆解（粒度不唯一），并封装为不同的函数，而再利用组合的调用达到目的。这样做使得表意清晰，易于维护、复用以及扩展。其次利用 高阶函数，Array.map 代替 for…of 做数组遍历，减少了中间变量和操作。 而 函数式写法一 和 函数式写法二 之间的主要差别在于，可以考虑函数是否后续有复用的可能，如果没有，则后者更优。 链式优化从上面 函数式写法二 中我们可以看出，函数式代码在写的过程中，很容易造成 横向延展，即产生多层嵌套，下面我们举个比较极端点的例子。 // 计算数字之和 // 一般写法 console.log(1 + 2 + 3 - 4) // 函数式写法 function sum(a, b) { return a + b; } function sub(a, b) { return a - b; } console.log(sub(sum(sum(1, 2), 3), 4); 本例仅为展示 横向延展 的比较极端的情况，随着函数的嵌套层数不断增多，导致代码的可读性大幅下降，还很容易产生错误。 在这种情况下，我们可以考虑多种优化方式，比如下面的 链式优化 。 // 优化写法 (嗯，你没看错，这就是 lodash 的链式写法) const utils = { chain(a) { this._temp = a; return this; }, sum(b) { this._temp += b; return this; }, sub(b) { this._temp -= b; return this; }, value() { const _temp = this._temp; this._temp = undefined; return _temp; } }; console.log(utils.chain(1).sum(2).sum(3).sub(4).value()); 这样改写后，结构会整体变得比较清晰，而且链的每一环在做什么也可以很容易的展现出来。函数的嵌套和链式的对比还有一个很好的例子，那就是 回调函数 和 Promise 模式。 // 顺序请求两个接口 // 回调函数 import $ from 'jquery'; $.post('a/url/to/target', (rs) =&gt; { if(rs){ $.post('a/url/to/another/target', (rs2) =&gt; { if(rs2){ $.post('a/url/to/third/target'); } }); } }); // Promise import request from 'catta'; // catta 是一个轻量级请求工具，支持 fetch,jsonp,ajax，无依赖 request('a/url/to/target') .then(rs =&gt; rs ? $.post('a/url/to/another/target') : Promise.reject()) .then(rs2 =&gt; rs2 ? $.post('a/url/to/third/target') : Promise.reject()); 随着回调函数嵌套层级和单层复杂度增加，它将会变得臃肿且难以维护，而 Promise 的链式结构，在高复杂度时，仍能纵向扩展，而且层次隔离很清晰。 常见的函数式编程模型闭包（Closure）可以保留局部变量不被释放的代码块，被称为一个闭包 闭包的概念比较抽象，相信大家都或多或少知道、用到这个特性 那么闭包到底能给我们带来什么好处？ 先来看一下如何创建一个闭包： // 创建一个闭包 function makeCounter() { let k = 0; return function() { return ++k; }; } const counter = makeCounter(); console.log(counter()); // 1 console.log(counter()); // 2 makeCounter 这个函数的代码块，在返回的函数中，对局部变量 k ，进行了引用，导致局部变量无法在函数执行结束后，被系统回收掉，从而产生了闭包。而这个闭包的作用就是，“保留住“ 了局部变量，使内层函数调用时，可以重复使用该变量；而不同于全局变量，该变量只能在函数内部被引用。 换句话说，闭包其实就是创造出了一些函数私有的 ”持久化变量“。 所以从这个例子，我们可以总结出，闭包的创造条件是： 存在内、外两层函数 内层函数对外层函数的局部变量进行了引用 ###闭包的用途 闭包的主要用途就是可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等等。 // 简单的缓存工具 // 匿名函数创造了一个闭包 const cache = (function() { const store = {}; return { get(key) { return store[key]; }, set(key, val) { store[key] = val; } } }()); cache.set('a', 1); cache.get('a'); // 1 上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。 ###闭包的弊端 持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。 ##高阶函数 接受或者返回一个函数的函数称为高阶函数 听上去很高冷的一个词汇，但是其实我们经常用到，只是原来不知道他们的名字而已。JavaScript 语言是原生支持高阶函数的，因为 JavaScript 的函数是一等公民，它既可以作为参数又可以作为另一个函数的返回值使用。 我们经常可以在 JavaScript 中见到许多原生的高阶函数，例如 Array.map , Array.reduce , Array.filter 下面以 map 为例，我们看看他是如何使用的 ###map （映射） 映射是对集合而言的，即把集合的每一项都做相同的变换，产生一个新的集合 map 作为一个高阶函数，他接受一个函数参数作为映射的逻辑 // 数组中每一项加一，组成一个新数组 // 一般写法 const arr = [1,2,3]; const rs = []; for(const n of arr){ rs.push(++n); } console.log(rs) // map改写 const arr = [1,2,3]; const rs = arr.map(n =&gt; ++n); 上面一般写法，利用 for…of 循环的方式遍历数组会产生额外的操作，而且有改变原数组的风险 而 map 函数封装了必要的操作，使我们仅需要关心映射逻辑的函数实现即可，减少了代码量，也降低了副作用产生的风险。 ###柯里化（Currying） 给定一个函数的部分参数，生成一个接受其他参数的新函数 可能不常听到这个名词，但是用过 undescore 或 lodash 的人都见过他。 有一个神奇的 _.partial 函数，它就是柯里化的实现 // 获取目标文件对基础路径的相对路径 // 一般写法 const BASE = '/path/to/base'; const relativePath = path.relative(BASE, '/some/path'); // _.parical 改写 const BASE = '/path/to/base'; const relativeFromBase = _.partial(path.relative, BASE); const relativePath = relativeFromBase('/some/path'); 通过 _.partial ，我们得到了新的函数 relativeFromBase ，这个函数在调用时就相当于调用 path.relative ，并默认将第一个参数传入 BASE ，后续传入的参数顺序后置。 本例中，我们真正想完成的操作是每次获得相对于 BASE 的路径，而非相对于任何路径。柯里化可以使我们只关心函数的部分参数，使函数的用途更加清晰，调用更加简单。 ###组合（Composing） 将多个函数的能力合并，创造一个新的函数 同样你第一次见到他可能还是在 lodash 中，compose 方法（现在叫 flow） // 数组中每个单词大写，做 Base64 // 一般写法 (其中一种) const arr = ['pen', 'apple', 'applypen']; const rs = []; for(const w of arr){ rs.push(btoa(w.toUpperCase())); } console.log(rs); // _.flow 改写 const arr = ['pen', 'apple', 'applypen']; const upperAndBase64 = _.partialRight(_.map, _.flow(_.upperCase, btoa)); console.log(upperAndBase64(arr)); _.flow 将转大写和转 Base64 的函数的能力合并，生成一个新的函数。方便作为参数函数或后续复用。 ##自己的观点 我理解的 JavaScript 函数式编程，将可以复用的功能提取出来，用函数方法来代替其实就是基本的函数编程思想，其实到最后会面临两个问题，一个是函数共用性好还是函数功能细分好，这其实都是根据自己具体需求而定的，个人认为函数功能还是细分好，这样方便维护，功能实现代码逻辑清晰。 函数式编程就是书写清新的逻辑代码，其实也是一种解耦的形式罢了。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"}]},{"title":"nodejs的process.nextTick方法理解和使用","date":"2017-04-04T09:49:45.000Z","path":"2017-04-04/","text":"今天重新温习了下nodejs开发指南中的核心模块全局对象中的process进程模块，其实nextTick和我目前使用的vue中的nextTick方法有些异曲同工之妙，于是上网搜整理了一些资料，详细的了解下nextTick到底该如何理解并且在实际项目中哪些地方会用到这个方法。 Node.js是单线程的，基于事件循环，非阻塞IO的。事件循环中使用一个事件队列，在每个时间点上，系统只会处理一个事件，即使电脑有多个CPU核心，也无法同时并行的处理多个事件。因此，node.js适合处理I／O型的应用，不适合那种CPU运算密集型的应用。在I／O型的应用中，给每一个输入输出定义一个回调函数，node.js会自动将其加入到事件轮询的处理队列里，当I／O操作完成后，这个回调函数会被触发，系统会继续处理其他的请求。 理解在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。 在这种处理模式下，process.nextTick()的意思就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行。我们来看一个例子。例子中有一个foo()，你想在下一个时间点上调用他，可以这么做： 12345function foo() &#123; console.error('foo');&#125;process.nextTick(foo);console.error('bar'); 运行上面的代码，你从下面终端打印的信息会看到，”bar”的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。 12barfoo 你也可以使用setTimeout()函数来达到貌似同样的执行效果： 12setTimeout(foo, 0);console.log('bar'); 但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时。process.nextTick()定义的调用会创建一个新的队列。在当前的队列里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须结束队列操作。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的队列。 具体使用场景在多个事件里交叉执行CPU运算密集型的任务在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。 但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。 1234567891011var http = require('http');function compute() &#123; // performs complicated calculations continuously // ... process.nextTick(compute);&#125;http.createServer(function(req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('Hello World');&#125;).listen(5000, '127.0.0.1');compute(); 在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。 当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。 保持回调函数异步执行的原则当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则： 123456789101112function maybeSync(arg, cb) &#123; if (arg) &#123; cb(); return; &#125; fs.stat('file', cb);&#125;maybeSync(true, function() &#123; foo();&#125;);bar(); 这段代码不明确的地方是, 我们不清楚foo()和bar()哪个会被先调用，使用nextTick将回调函数变成异步的。这样写更好： function definitelyAsync(arg, cb) { if (arg) { process.nextTick(cb); return; } fs.stat('file', cb); } 用在事件触发过程中来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写： var EventEmitter = require('events').EventEmitter; function StreamLibrary(resourceName) { this.emit('start'); // read from the file, and for every chunk read, do: this.emit('data', chunkRead); } StreamLibrary.prototype.__proto__ = EventEmitter.prototype; // inherit from EventEmitter 下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件： var stream = new StreamLibrary('fooResource'); stream.on('start', function() { console.log('Reading has started'); }); stream.on('data', function(chunk) { console.log('Received: ' + chunk); }); 但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本： function StreamLibrary(resourceName) { var self = this; process.nextTick(function() { self.emit('start'); }); // read from the file, and for every chunk read, do: this.emit('data', chunkRead); }","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"node","slug":"node","permalink":"http://www.iwangqi.com/tags/node/"}]},{"title":"ajax如何截取302响应","date":"2017-04-02T00:01:13.000Z","path":"ajax/","text":"在ajax请求中，如果服务器端的响应是302 Found，在ajax的回调函数中能够获取这个状态码吗？能够从Response Headers中得到Location的值进行重定向吗？让我们来一起看看实际情况。 使用jQuery的$.ajax()发起ajax请求的JavaScript代码如下：1234567891011$.ajax(&#123;url: '/oauth/respond',type: 'post',data: data,complete: function(jqXHR)&#123; console.log(jqXHR.status);&#125;,error: function (xhr) &#123; console.log(xhr.status);&#125;&#125;); 当服务器端返回302 Found的响应时，浏览器中的运行结果如下： 在ajax的complete()与error()回调函数中得到的状态码都是404，而不是302。为什么呢？在stackoverflow上找到了答案： 原来，当服务器将302响应发给浏览器时，浏览器并不是直接进行ajax回调处理，而是先执行302重定向——从Response Headers中读取Location信息，然后向Location中的Url发出请求，在收到这个请求的响应后才会进行ajax回调处理。大致流程如下： ajax -&gt; browser -&gt; server -&gt; 302 -&gt; browser(redirect) -&gt; server -&gt; browser -&gt; ajax callback 而在我们的测试程序中，由于302返回的重定向URL在服务器上没有相应的处理程序，所以在ajax回调函数中得到的是404状态码；如果存在对应的URL，得到的状态码就是200。 所以，如果你想在ajax请求中根据302响应通过location.href进行重定向是不可行的。 如何解决？【方法一】继续用ajax，修改服务器端代码，将原来的302响应改为json响应，比如下面的ASP.NET MVC示例代码： 123456789101112131415return Json(new &#123; status = 302, location = \"/oauth/respond\" &#125;);ajax代码稍作修改即可：$.ajax(&#123; url: '/oauth/respond', type: 'post', data: data, dataType: 'json', success: function (data) &#123; if (data.status == 302) &#123; location.href = data.location; &#125; &#125;&#125;); 【方法二】不用ajax，改用form。 12&lt;form method=\"post\" action=\"/oauth/respond\"&gt;&lt;/form&gt;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://www.iwangqi.com/tags/ajax/"},{"name":"302","slug":"302","permalink":"http://www.iwangqi.com/tags/302/"}]}]