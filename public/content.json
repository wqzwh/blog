[{"title":"webpack优化入门详解","date":"2017-12-30T09:06:58.000Z","path":"webpack-2017-12-30/","text":"以下测试中，均在webpack版本3.5以上，如有不对的地方请指出，谢谢。 新特性优化Scope Hoisting-作用域提升,将模块都放到一个闭包函数中，通过减少闭包函数数量从而加快JS的执行速度。基本配置如下：123plugins: [ new webpack.optimize.ModuleConcatenationPlugin()] 配置后，自定义的两个模块函数被放在一个必包函数体中，打包结果如下： 配置前，自定义的两个模块函数分别在不同的必包函数体中，通过行数就能看出来，打包结果如下： 配置项优化externals配置优化设置externals配置项分离不需要打包的库文件，然后在模版文件中使用script引入即可，配置代码片段如下：123externals: &#123; 'jquery': 'jquery'&#125;, alias配置优化 可以选择对应的需要打包文件的大小规格 通过定义全局路径，减少webpack编译过程中的搜索硬盘时间 基本配置代码片段如下： 1234567resolve: &#123; extensions: ['.js', '.json'], alias: &#123; 'jquery': 'jquery/dist/jquery.slim.min.js', '@': resolve('src'), &#125;&#125;, 插件使用优化内链css减少请求webpack插件配置片段代码如下：12345plugins: [ new StyleExtHtmlWebpackPlugin(&#123; minify: true &#125;)]最终打包可以将css文件直接以内链的形式插入网页中，进而可以减少网页请求。 preload插件使用webpack插件配置片段代码如下：1234567plugins: [ new PreloadWebpackPlugin(&#123; rel: 'preload', as: 'script', include: 'all' &#125;)]最终打包生成的页面在head上会生成preload的link标签，代码片段如下：1234&lt;link rel=\"preload\" as=\"script\" href=\"app.8898b6c9e3b39f7a1c9d.js\"&gt;&lt;link rel=\"preload\" as=\"script\" href=\"common.6ecc97ec2b5dceebbd5e800322c2a3c0.css\"&gt;&lt;link rel=\"preload\" as=\"script\" href=\"vendor.dcd374ee43fd57d2365b.js\"&gt;&lt;link rel=\"preload\" as=\"script\" href=\"manifest.f3e58576762e216d8867.js\"&gt; 更多配置参考这里详细更多 缓存优化与分析css打包优化contenthash使用webpack打包css用的是extract-text-webpack-plugin插件，由于hash是webpack的module identifier计算的，不变内容的情况下每次打包也会产生不同的hash，因此选用chunkhash，它是根据文件内容计算的，因此比较符合实际使用，基本配置片段代码如下： 123456789101112131415161718192021222324252627282930313233module: &#123; rules: [&#123; test: /\\.(less|scss|css)$/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: [ &#123; loader:\"css-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;, &#123; loader:\"less-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;, &#123; loader:\"sass-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;] &#125;) &#125;]&#125;,plugins: [ new ExtractTextPlugin(&#123; filename: 'common.[chunkhash].css', allChunks: true &#125;),] 单纯改变css文件 12345678910// a.less.ac &#123; .bc &#123; font-size: 12px; &#125; .cc &#123; font-weight: 700; border: 1px solid #ccc; &#125;&#125; module文件中的a.js引入了a.less文件 12// module/a.jsrequire('../style/a.less'); 多次打包发现hash值未改变，不但依赖的js文件hash未改变，就连css文件的hash也未改变，最终使用webpack打包如下： 这显然不是想要的结果，希望改变css文件内容，js文件的hash不会改变，只有相应的css文件的hash值改变，因此再ExtractTextPlugin插件中应该使用contenthash，这也是官方特别注明的，直到再次看到文档才发现。 设置contenthash之后，再次打包发现只有css文件hash变了，并且改变js代码依然不影响css文件的打包，最终打包结果如下： js打包优化HashedModuleIdsPluginwebpack插件基本配置片段代码如下： 123456789101112131415161718192021222324252627282930313233343536373839entry: &#123; app: './src/app.js', vendor: ['lodash']&#125;,plugins: [ new CleanWebpackPlugin(['cdist']), new HtmlWebpackPlugin(&#123; template: './src/index.template.html', //html模板路径 filename: 'wq.html', //生成的html存放路径，相对于path favicon: './src/favicon.ico', //favicon路径，通过webpack引入同时可以生成hash值 inject: 'body', //js插入的位置，true/'head'/'body'/false // chunks: ['app', 'vendor'], //hash: true ,//为静态资源生成hash值 minify: &#123; //压缩HTML文件 removeComments: true, //移除HTML中的注释 collapseWhitespace: false //删除空白符与换行符 &#125; &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor' &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest' &#125;), new ExtractTextPlugin(&#123; filename: 'common.[contenthash].css', allChunks: true &#125;), new webpack.optimize.UglifyJsPlugin(&#123; beautify: false, comments: false, compress: &#123; warnings: false, drop_console: true, collapse_vars: true, reduce_vars: true, &#125; &#125;) ] 项目入口文件为app.js 12345678910111213import _ from 'lodash';import a from './module/a';// import b from './module/b';require(\"babel-polyfill\")require('./style/lib.css')function fn () &#123; // let aa = _.clone(&#123;key:4&#125;) // aa.key = 2; return aa&#125;fn() 第一次打包生成的文件如下： 修改入口文件app.js代码如下：12345678910111213import _ from 'lodash';import a from './module/a';import b from './module/b';require(\"babel-polyfill\")require('./style/lib.css')function fn () &#123; let aa = _.clone(&#123;key:4&#125;) aa.key = 2; return aa&#125;fn() 再次使用webpack打包，最后显示如下： 从打包结果来看，不但入口文件app.js哈希值变了，第三方库vendor.js的哈希值也变了，这当然不是我想要的，因为我更本没有改变第三方库文件。为了解决这个问题可以引入HashedModuleIdsPlugin这个配置项，这样就可以解决以上遇到的问题。 将插件配置做如下修改，代码片段如下： 123456789plugins: [ new webpack.HashedModuleIdsPlugin(), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor' &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest' &#125;), ] 在经过以上两个步骤，再次使用webpack打包，结果如下： webpack3中tree-shaking分析tree-shaking其实是webpack2中就有的功能特性，但是会因模块函数定义的形式，会有失效的概率，因此，我想用webpack3来测试下，看看是否官网有优化这部分特性。 tree-shaking必须有UglifyJsPlugin这个配置项才能生效，否则统一不生效。 常规定义方法module/a.js代码如下： 12345require('../style/a.less');function a() &#123; return 'aaaaaa'&#125;export &#123;a&#125;; module/b.js代码如下： 12345require('../style/b.scss');function b() &#123; return 'bbbbbbb'&#125;export &#123;b&#125;; 入口文件代码如下： 12345678910// app.jsimport _ from 'lodash';import &#123; a &#125; from './module/a';import &#123;b&#125; from './module/b';require(\"babel-polyfill\")require('./style/lib.css')function wq() &#123; return a()&#125;wq() 最后使用webpack打包，在压缩的文件中发现bbbbbbb被删除了，因此可以得出一个结论，webpack会动态判断引入的包是否被使用从而再次精简打包文件大小。 原型定义方法这次我改写a.js和b.js的形式，再其原型链上定义方法，基本代码如下： 123456789// module/a.jsrequire('../style/a.less');function a() &#123; return 'aaaaaa'&#125;a.prototype.fn = () =&gt; &#123; return 'aaaaaa'&#125;export &#123;a&#125;; 123456789// module/b.jsrequire('../style/b.scss');function b() &#123; return 'bbbbbbb'&#125;b.prototype.fn = () =&gt; &#123; return 'bbbbbbb'&#125;export &#123;b&#125;; 入口文件代码如下： 123456789101112// app.jsimport _ from 'lodash';import &#123; a &#125; from './module/a';import &#123;b&#125; from './module/b';require(\"babel-polyfill\")require('./style/lib.css')function wq() &#123; return a.prototype.fn()&#125;wq() 最后使用webpack打包，在压缩的文件中发现bbbbbbb没有被删除，只是调用函数的方法不一样，导致tree-shaking并没有生效。 class类编写模式我再次使用es6中类的概念改写a、b的定义方法，基本代码如下： 12345678// module/a.jsrequire('../style/a.less');class a &#123; fn() &#123; return 'aaaaaaa' &#125;&#125;export &#123;a&#125;; 12345678// module/b.jsrequire('../style/b.scss');class b &#123; fn() &#123; return 'bbbbbb' &#125;&#125;export &#123;b&#125;; 最后使用webpack打包，在压缩的文件中发现bbbbbbb依然没有被删除，tree-shaking并没有生效。 let定义形式最后我使用最简单的定义形式改写，基本代码如下： 12345// module/a.jsrequire('../style/a.less');let a = 'aaaaaaa'export &#123;a&#125;; 12345// module/b.jsrequire('../style/b.scss');let b = 'bbbbbbb'export &#123;b&#125;; 最后使用webpack打包，在压缩的文件中发现bbbbbbb被删除，tree-shaking生效。 分析原型定义写法不会被删除很好理解，就是这些原型方法，因为原型方法可能会将要被调用，是一个未知情况，如果直接删除，那么一旦其他模块会动态调用原型方法，那就会造成代码报错，这样是不合理的。 class类的写法似乎不会产生副作用，类中的函数似乎也不是将来可能被调用，再来看最后webpack打包生成的代码，片段如下：12345678910111213141516/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(\"Zrlr\");/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);var b = function () &#123; function b() &#123; __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, b); &#125; __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(b, [&#123; key: 'fn', value: function fn() &#123; return 'bbbbbb'; &#125; &#125;]); return b;&#125;();首先b是一个自运行函数，并且最终还调用了webpack_require(“Zrlr”)这个模块，因此就类似prototype，会产生一点有副作用的函数，所以不能直接删除。 最后贴上完整的webpack配置项，这里并没有加上vue/react的相关配置，如需要可以自己安装相应插件，通过配合babel-loader进行编译打包，.babelrc配置入门详解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110const webpack = require('webpack'); //to access built-in pluginsconst path = require('path');const CleanWebpackPlugin = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npmconst ExtractTextPlugin = require('extract-text-webpack-plugin')const StyleExtHtmlWebpackPlugin = require('style-ext-html-webpack-plugin')const PreloadWebpackPlugin = require('preload-webpack-plugin')const config = &#123; entry: &#123; app: './src/app.js', vendor: ['lodash'] &#125;, output: &#123; path: path.resolve(__dirname, 'cdist'), filename: '[name].[chunkhash].js' &#125;, externals: &#123; 'jquery': 'jquery' &#125;, // resolve: &#123; // extensions: ['.js', '.json'], // alias: &#123; // 'jquery': 'jquery/dist/jquery.slim.min.js', // '@': resolve('src'), // &#125; // &#125;, module: &#123; rules: [&#123; test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.(less|scss|css)$/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: [ &#123; loader:\"css-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;, &#123; loader:\"less-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;, &#123; loader:\"sass-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;] &#125;) &#125; ] &#125;, plugins: [ new webpack.optimize.ModuleConcatenationPlugin(), new CleanWebpackPlugin(['cdist']), new HtmlWebpackPlugin(&#123; template: './src/index.template.html', //html模板路径 filename: 'wq.html', //生成的html存放路径，相对于path favicon: './src/favicon.ico', //favicon路径，通过webpack引入同时可以生成hash值 inject: 'body', //js插入的位置，true/'head'/'body'/false // chunks: ['app', 'vendor'], //hash: true ,//为静态资源生成hash值 minify: &#123; //压缩HTML文件 removeComments: true, //移除HTML中的注释 collapseWhitespace: false //删除空白符与换行符 &#125; &#125;), new PreloadWebpackPlugin(&#123; rel: 'preload', as: 'script', include: 'all' &#125;), // 解决第三方打包文件hash值不变，最大化缓存 new webpack.HashedModuleIdsPlugin(), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor' &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest' &#125;), new ExtractTextPlugin(&#123; filename: 'common.[contenthash].css', allChunks: true &#125;), new webpack.optimize.UglifyJsPlugin(&#123; beautify: false, comments: false, compress: &#123; warnings: false, drop_console: true, collapse_vars: true, reduce_vars: true, &#125; &#125;), new StyleExtHtmlWebpackPlugin(&#123; minify: true &#125;) ]&#125;;module.exports = config;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"http://www.iwangqi.com/tags/webpack/"}]},{"title":"babel之配置文件.babelrc入门详解","date":"2017-12-23T09:06:58.000Z","path":"babelrc-2017-12-23/","text":"什么是Babel官方解释,是下一代JavaScript 语法的编译器。 既然是下一代Javascript的标准，浏览器因版本的不同对此会有兼容性问题，JavaScript的新的方法都不能使用，但是目前我们在项目开发一直提倡使用最新的语法糖编写，不但能减少代码量，而且async,await等新特性还解决了回调的编写机制，减轻了代码维护成本。 Babel就因此而生，它可以让你放心使用大部分的JavaScript的新的标准的方法，然后编译成兼容绝大多数的主流浏览器的代码。在项目工程脚手架中，一般会使用.babelrc文件，通过配置一些参数配合webpack进行打包压缩。也通过网上了解，写法各有不同，参数也大不相同，因此，我重新整理一份资料，详细的介绍下各个配置项的意义所在，以便清晰了解如果使用。 以下配置主要正对webpack3+写法。 Babel转译器在.babelrc配置文件中，主要是对预设（presets）和插件（plugins）进行配置，因此不同的转译器作用不同的配置项，大致可分为以下三项： 1.语法转义器。主要对javascript最新的语法糖进行编译，并不负责转译javascript新增的api和全局对象。例如let/const就可以被编译，而includes/Object.assign等并不能被编译。常用到的转译器包有，babel-preset-env、babel-preset-es2015、babel-preset-es2016、babel-preset-es2017、babel-preset-latest等。在实际开发中可以只选用babel-preset-env来代替余下的，但是还需要配上javascirpt的制作规范一起使用，同时也是官方推荐 123456&#123; \"presets\": [\"env\", &#123; \"modules\": false &#125;], \"stage-2\"&#125; 2.补丁转义器。主要负责转译javascript新增的api和全局对象，例如babel-plugin-transform-runtime这个插件能够编译Object.assign,同时也可以引入babel-polyfill进一步对includes这类用法保证在浏览器的兼容性。Object.assign 会被编译成以下代码： 1__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default() 3.jsx和flow插件，这类转译器用来转译JSX语法和移除类型声明的，使用Rect的时候你将用到它，转译器名称为babel-preset-react 创建预设(presets)主要通过npm安装babel-preset-xx插件来配合使用，例如通过 npm install babel-preset-stage-2 babel-preset-env –save-dev 安装，会有相应如下配置。 123456&#123; \"presets\": [ [\"env\", options], \"stage-2\" ]&#125; stage-2配置babel主要提供以下几种转义器包,括号里面是对应配置文件的配置项 babel-preset-stage-0(stage-0) babel-preset-stage-1(stage-1) babel-preset-stage-2(stage-2) babel-preset-stage-3(stage-3)不同阶段的转译器之间是包含的关系，preset-stage-0转译器除了包含了preset-stage-1的所有功能还增加了transform-do-expressions插件和transform-function-bind插件，同样preset-stage-1转译器除了包含preset-stage-2的全部功能外还增加了一些额外的功能。 options配置介绍官方推荐使用babel-preset-env来替代一些插件包的安装（es2015-arrow-functions，es2015-block-scoped-functions等等），并且有如下几种配置信息,介绍几个常用的，更多配置可以参考官网https://babeljs.io/docs/plugins/preset-env/12345678&#123; \"targets\": &#123; \"chrome\": 52, \"browsers\": [\"last 2 versions\", \"safari 7\"], \"node\":\"6.10\" &#125; \"modules\": false&#125; targets可以制定兼容浏览器版本，如果设置了browsers，那么就会覆盖targets原本对浏览器的限制配置。 targets.node正对node版本进行编译 modules通常都会设置为false，因为默认都是支持CommonJS规范，同时还有其他配置参数：”amd” | “umd” | “systemjs” | “commonjs”，systemjs我还不知道规范写法是什么，amd和umd以及commonjs相对比较熟悉，下面简要列举下书写规范。 amd代码规范，在ng1中会用到比较多，主要用于依赖注入：1234567define(['jquery'], function ($) &#123; // 方法 function myFunc()&#123;&#125;; // 暴露公共方法 return myFunc;&#125;)commonjs规范，也是node环境中尊崇的一种规范：123456var $ = require('jquery');// 方法function myFunc()&#123;&#125;; // 暴露公共方法（一个）module.exports = myFunc;umd规范，兼容amd以及commonjs规范，目前在第三方插件编写使用比较多：123456789101112131415161718(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['jquery'], factory); &#125; else if (typeof exports === 'object') &#123; // Node, CommonJS之类的 module.exports = factory(require('jquery')); &#125; else &#123; // 浏览器全局变量(root 即 window) root.returnExports = factory(root.jQuery); &#125;&#125;(this, function ($) &#123; // 方法 function myFunc()&#123;&#125;; // 暴露公共方法 return myFunc;&#125;)); 插件（plugins）插件配置项同预设配置项一样，需要搭配babel相应的插件进行配置，可以选择配置插件来满足单个需求，例如早期我们会有如下配置：12345678&#123; \"plugins\": [ \"check-es2015-constants\", \"es2015-arrow-functions\", \"es2015-block-scoped-functions\", // ... ]&#125; 但是这些插件从维护到书写极为麻烦，后来官方统一推荐使用env，全部替代了这些单一的插件功能，可以简化配置如下，也就是我前面提到了babel-preset-env：12345&#123; \"presets\": [ \"es2015\" ]&#125; 这里主要介绍两款常用插件，分别是babel-plugin-transform-runtime，babel-plugin-syntax-dynamic-import。 基本配置代码如下：12345&#123; \"plugins\": [ \"syntax-dynamic-import\",[\"transform-runtime\"] ]&#125; transform-runtime为了解决这种全局对象或者全局对象方法编译不足的情况，才出现了transform-runtime这个插件，但是它只会对es6的语法进行转换，而不会对新api进行转换。如果需要转换新api，也可以通过使用babel-polyfill来规避兼容性问题。 对Object.assign进行编译，配置与未配置经过webpack编译后的代码片段如下： 1234567891011121314// 未设置代码片段：__webpack_require__(\"ez/6\");var aaa = 1;function fna() &#123; var dd = 33333; var cc = Object.assign(&#123; key: 2 &#125;); var xx = String.prototype.repeat.call('b', 3); if (\"foobar\".String.prototype.includes(\"foo\")) &#123; var vv = 1; &#125; return dd;&#125; 12345678910111213141516// 设置代码片段：/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);__webpack_require__(\"ez/6\");var aaa = 1;function fna() &#123; var dd = 33333; var cc = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(&#123; key: 2 &#125;); var xx = String.prototype.repeat.call('b', 3); if (\"foobar\".String.prototype.includes(\"foo\")) &#123; var vv = 1; &#125; return dd;&#125; 对class定义类会进行编译，配置与未配置经过webpack编译后的代码片段如下： 12345678910111213141516// 未设置代码片段：function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125; &#125;var Canvas = function Canvas(height, width) &#123; _classCallCheck(this, Canvas); this.height = height; this.width = width;&#125;;var Canvas2 = function Canvas2(height, width) &#123; _classCallCheck(this, Canvas2); this.height = height; this.width = width;&#125;; 12345678910111213141516// 设置代码片段：/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);var Canvas = function Canvas(height, width) &#123; __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Canvas); this.height = height; this.width = width;&#125;;var Canvas2 = function Canvas2(height, width) &#123; __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Canvas2); this.height = height; this.width = width;&#125;; 对Generator函数也有同上的编译效果，目前项目中使用该函数较小，一般使用promise替代，以及async await所以未对该函数做测试。 官方说对promise也会产生编译，但是实际测试结果却没有效果 经过webpack打包最终测试，引入transform-runtime该配置项后，打包入口js文件大小会略微增大，并不像官方说的能够缩小文件体积 未配置的最终打包效果： 配置后的最终打包效果： 虽然文件大小会有所增大，但是解决一些兼容性的问题，同时，从以上给出的测试代码例子来看，使用transform-runtime后，可以减少内部全局函数的定义，从结构上看尊崇了webpack的模块化思想，所以还是建议使用该插件。 syntax-dynamic-import这个插件主要解决动态引入模块的问题123456789function nDate() &#123; import('moment').then(function(moment) &#123; console.log(moment().format()); &#125;).catch(function(err) &#123; console.log('Failed to load moment', err); &#125;);&#125;nDate(); 如果.babelrc配置项中使用了”stage-2”，也可以不实用该插件，同样支持动态模块引入。 不然就会报以下错误： Module build failed: SyntaxError: ‘import’ and ‘export’ may only appear at the top level, or (import 和 export只能在最外层，也就是不能用在函数或者块中) Module build failed: SyntaxError: Unexpected token, expected { 其他配置项ignore主要作用就是可以指定不编译那些代码123&#123; \"ignore\":[\"./module/a.js\"]&#125; let,Object.assign,class定义都未编译，编译效果如下：12345678910111213141516171819202122232425262728293031__webpack_require__(\"ez/6\");const aaa = 1;function fna () &#123; let dd = 33333 let cc = Object.assign(&#123;key:2&#125;) let xx = String.prototype.repeat.call('b', 3) if (\"foobar\".String.prototype.includes(\"foo\")) &#123; let vv = 1 &#125; return dd&#125;function fna2 () &#123; return fna() + aaa + __WEBPACK_IMPORTED_MODULE_0__b__[\"a\" /* default */]&#125;class Canvas &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125;class Canvas2 &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125; minified主要设置编译后是否是压缩，boolean类型，如果使用babel-cli进行打包编译文件这个配置项能够起到作用，但是目前大部分还是会依赖第三方打包工具，例如webpack，所以这个配置参数一般不用设置，webpack插件中的UglifyJsPlugin做了压缩的工作。 comments在生成的文件中，不产生注释，boolean类型，webpack插件中的UglifyJsPlugin也同样集成了这个功能。 env基本配置如下： 12345678910&#123; \"env\": &#123; // test 是提前设置的环境变量，如果没有设置BABEL_ENV则使用NODE_ENV，如果都没有设置默认就是development \"test\": &#123; \"presets\": [\"env\", \"stage-2\"], // instanbul是一个用来测试转码后代码的工具 \"plugins\": [\"istanbul\"] &#125; &#125;&#125; 再谈兼容性问题Babel默认只转换新的JavaScript语法，而不转换新的API，比如Iterator、Generator、Set、Maps、Promise等等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码，具体的可以参考babel-plugin-transform-runtime模块的definitions.js文件。 这里主要涉及到babel编译后依然会存在浏览器兼容性问题，一般会使用transform-runtime和babel-polyfill配合使用，对于后者只需要在项目入口文件require引入即可。 当然在使用类似Object.assign函数功能时，可以使用lodash库来替代，promise可以使用Q.js替代等等方案，这样依赖可以不需要引入以上插件，具体可以根据项目具体安排 总结.babelrc配置文件主要还是以presets和plugins组成，通过和webpack配合进行使用，分享下我们在项目中常用的配置。以上都是通过学习总结出来的，有什么不对的地方希望指出。 vue项目开发使用的配置如下：12345678910111213141516171819&#123; \"presets\": [ [\"env\", &#123; \"modules\": false &#125;], \"stage-2\" ], // 下面指的是在生成的文件中，不产生注释 \"comments\": false, \"plugins\": [\"transform-runtime\",\"syntax-dynamic-import\"], \"env\": &#123; // test 是提前设置的环境变量，如果没有设置BABEL_ENV则使用NODE_ENV，如果都没有设置默认就是development \"test\": &#123; \"presets\": [\"env\", \"stage-2\"], // instanbul是一个用来测试转码后代码的工具 \"plugins\": [\"istanbul\"] &#125; &#125;&#125; react项目开发使用的配置如下：123456789101112131415&#123; \"presets\": [ [\"env\", &#123; \"modules\": false &#125;], \"stage-2\", \"react\" ], \"plugins\": [\"transform-runtime\"], \"comments\": false, \"env\": &#123; \"test\": &#123; \"presets\": [\"env\", \"stage-2\"], \"plugins\": [ \"istanbul\" ] &#125; &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"http://www.iwangqi.com/tags/webpack/"},{"name":"babel","slug":"babel","permalink":"http://www.iwangqi.com/tags/babel/"}]},{"title":"Three.js系列教程--动画和相机","date":"2017-07-19T13:09:11.000Z","path":"webgl-2017-07-19/","text":"动画基础 setTimeout / setInterval 存在弊端 window.requestAnimationFrame 性能更高 通过递归循环实现 相机分类 FirstPersonControls 第一人称控件,类似于使用鼠标使相机移动 FlyControls 飞行控件,通过键盘或者鼠标使相机移动 RollControls 翻滚控件,飞行控件的简化版本，绕着z轴旋转 TrackballControls 轨迹球控件,最常用的控件，可以用鼠标轻松的平移和缩放场景 OrbitControls 轨迹控件，用于特定场景，模拟轨道中的卫星等等 PathControls 路径控件，相机可以按照特定的路径进行移动，例如过山车等等 完整示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var scene = new THREE.Scene();var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, .1, 1000);var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0xEEEEEE,1.0));renderer.setSize(window.innerWidth,window.innerHeight);// 定义一个几何体var planeGeometry = new THREE.PlaneGeometry(60,20,1,1);var planeMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;);var plane = new THREE.Mesh(planeGeometry,planeMaterial);plane.position.set(15,0,0);plane.rotation.x = -0.5 * Math.PI;scene.add(plane);// 定义一个立方体 var cubeGeometry = new THREE.BoxGeometry(4,4,4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;); var cube = new THREE.Mesh(cubeGeometry,cubeMaterial); cube.position.set(-9,3,0); scene.add(cube); // 定义一个圆柱体 var cylinderGeometry = new THREE.CylinderGeometry(2,2,20); var cylinderMaterial = new THREE.MeshLambertMaterial(&#123;color:0x77ff78&#125;); var cylinder = new THREE.Mesh(cylinderGeometry,cylinderMaterial); cylinder.position.set(0,0,1); scene.add(cylinder); camera.position.set(-30,40,30); camera.lookAt(scene.position); // 定义环境光 var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); // 定义聚光灯 var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40,60,-10); scene.add(spotLight); document.body.appendChild(renderer.domElement); render(); function render()&#123; requestAnimationFrame(render); cube.rotation.x += 0.01; cube.rotation.y += 0.01; cube.rotation.z += 0.01; cylinder.rotation.x += 0.01; cylinder.rotation.y += 0.01; cylinder.rotation.z += 0.01; renderer.render(scene,camera) &#125; 最终效果如下图： 轨迹球控件属性 THREE.TrackballControls(camera)创建 rotateSpeed 转速 zoomSpeed 变焦速度 panSpeed 平移速度 完整示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667var clock = new THREE.Clock();var scene = new THREE.Scene();var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, .1, 1000);var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0xEEEEEE,1.0));renderer.setSize(window.innerWidth,window.innerHeight);// 定义一个几何体var planeGeometry = new THREE.PlaneGeometry(60,20,1,1);var planeMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;);var plane = new THREE.Mesh(planeGeometry,planeMaterial);plane.position.set(15,0,0);plane.rotation.x = -0.5 * Math.PI;scene.add(plane);// 定义一个立方体function addCube(x,y,z)&#123; var cubeGeometry = new THREE.BoxGeometry(4,4,4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color:0xff00ff&#125;); var cube = new THREE.Mesh(cubeGeometry,cubeMaterial); cube.position.set(x,y,z); scene.add(cube);&#125;addCube(3,10,5);addCube(13,2,5);addCube(33,8,5);var trackballControls = new THREE.TrackballControls(camera);trackballControls.rotateSpeed = 1.0;trackballControls.zoomSpeed = 1.0;trackballControls.panSpeed = 1.0;trackballControls.staticMoving = true; camera.position.set(-30,40,30); camera.lookAt(scene.position); // 定义环境光 var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight);// 定义聚光灯var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40,60,-10);scene.add(spotLight); document.body.appendChild(renderer.domElement); render(); function render()&#123; requestAnimationFrame(render); var delta = clock.getDelta(); trackballControls.update(delta); renderer.render(scene,camera) &#125; 最终效果如下图： 飞行控件属性 THREE.FlyControls(camera)创建 movementSpeed 移动速度 rollSpeed 转速 autoForward 自动前进 完整示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 var clock = new THREE.Clock();var scene = new THREE.Scene();var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, .1, 1000);var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0xEEEEEE,1.0));renderer.setSize(window.innerWidth,window.innerHeight);// 定义一个几何体var planeGeometry = new THREE.PlaneGeometry(60,20,1,1);var planeMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;);var plane = new THREE.Mesh(planeGeometry,planeMaterial);plane.position.set(15,0,0);plane.rotation.x = -0.5 * Math.PI;scene.add(plane);var cylinderMaterial = new THREE.MeshLambertMaterial(&#123;color:0x77ff78&#125;);// 定义一个立方体function addCyliner(x,y,z)&#123; // 定义一个圆柱体 var cylinderGeometry = new THREE.CylinderGeometry(2,2,20); var cylinder = new THREE.Mesh(cylinderGeometry,cylinderMaterial); cylinder.position.set(x,y,z); scene.add(cylinder);&#125;addCyliner(3,10,5);addCyliner(13,2,5);addCyliner(33,8,5);camera.position.set(-30,40,30);camera.lookAt(scene.position);// 定义环境光var ambientLight = new THREE.AmbientLight(0x0c0c0c);scene.add(ambientLight);// 定义聚光灯var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40,60,-10);scene.add(spotLight);document.body.appendChild(renderer.domElement);// 创建飞行控件var flyControls = new THREE.FlyControls(camera);flyControls.movementSpeed = 25;flyControls.domElement = document.body;flyControls.rollSpeed = Math.PI / 24;flyControls.autoForward = true;render();function render()&#123; requestAnimationFrame(render); var d = clock.getDelta(); flyControls.update(d); renderer.render(scene,camera)&#125; 最终效果如下图： 翻滚控件属性 THREE.RollControls(camera) 创建 movementSpeed 移动速度 lookSpeed 观看速度 核心示例代码如下： 123456789101112131415// 创建翻滚控件var rollControls = new THREE.RollControls(camera);rollControls.movementSpeed = 25;rollControls.lookSpeed = 3;render();function render()&#123; requestAnimationFrame(render); var d = clock.getDelta(); rollControls.update(d); renderer.render(scene,camera)&#125; 最终效果如下图： 第一人称控件属性 THREE.FirstPersonControls(camera) 创建 movementSpeed 移动速度 noFly 非飞行模式 lon／lat定位相机位置 核心示例代码如下： 12345678910111213141516171819202122// 创建控件var controls = new THREE.FirstPersonControls(camera);controls.movementSpeed = 25;controls.lookSpeed = 0.4;controls.noFly = true;controls.lookVertical = true;controls.constrainVertical = true;controls.verticalMax = 2.0;controls.verticalMin = 2.0;controls.lon = -150;controls.lat = 120;render();function render()&#123; requestAnimationFrame(render); var d = clock.getDelta(); controls.update(d); renderer.render(scene,camera)&#125; 最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/18","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"Three.js系列教程--粒子","date":"2017-07-18T13:09:11.000Z","path":"webgl-2017-07-18/","text":"粒子与粒子系统创建基本粒子 使用 THREE.Particle 构建粒子 使用 CanvasRenderer 渲染器 WebGLRenderer 需要 THREE.ParticleSystem 配合 常用属性 color 粒子的颜色 map 粒子的材质 size 粒子的大小 完整示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var shareObj = share(false);shareObj.camera.position.set(0, 0, 115);shareObj.camera.lookAt(shareObj.scene.position);createSprites();var cloud;// 创建粒子的方法function createSprites()&#123; var geom = new THREE.Geometry(); var material = new THREE.PointsMaterial(&#123; size:5, vertexColors:true, opacity:.5, transparent:true, sizeAttenuation:true, color:0xffffff &#125;); for(var x = -5;x&lt;5;x++)&#123; for(var y = -5;y&lt;5;y++)&#123; var particle = new THREE.Vector3(x*10,y*10,0); geom.vertices.push(particle); var color = new THREE.Color(0x00ffff); color.setHSL(color.getHSL().h,color.getHSL().s,Math.random() * color.getHSL().l); geom.colors.push(color); &#125; &#125; cloud = new THREE.Points(geom,material); shareObj.scene.add(cloud);&#125;var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; cloud.rotation.x += 0.01; cloud.rotation.y += 0.01; cloud.rotation.z += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 格式化粒子ParticleCanvasMaterial 的属性 color 粒子的颜色 program 该函数在渲染粒子时调用 opacity 粒子的透明度 transparent 粒子是否透明 WebGLRenderer 中使用画布 不可使用 ParticleCanvasMaterial 只能使用 ParticleBasicMaterial 用 map 属性加载纹理，纹理可以是canvas 使用纹理格式化粒子 ImageUtils.loadTexture 加载纹理 为 map 属性设置纹理 设置 blending 属性 采用canvas作为纹理的完整示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var shareObj = share(false);shareObj.camera.position.set(0, 0, 65);shareObj.camera.lookAt(shareObj.scene.position);// 创建纹理的方法function getTexture()&#123; var canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32; var ctx = canvas.getContext('2d'); ctx.translate(-81,-84); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(91,96); ctx.bezierCurveTo(88,96,87,99,87,101); ctx.bezierCurveTo(87,103,88,106,91,106); ctx.bezierCurveTo(94,106,95,103,95,101); ctx.bezierCurveTo(95,99,94,96,91,96); ctx.moveTo(103,96); ctx.bezierCurveTo(100,96,99,99,99,101); ctx.bezierCurveTo(99,103,100,106,103,106); ctx.bezierCurveTo(106,106,107,103,107,101) ctx.bezierCurveTo(107,99,106,96,103,96); ctx.fill(); var texture = new THREE.Texture(canvas); texture.needsUpdate = true; return texture;&#125;createSprites();var cloud;// 创建粒子的方法function createSprites()&#123; var geom = new THREE.Geometry(); var material = new THREE.PointsMaterial(&#123; size:5, vertexColors:true, opacity:.5, transparent:true, sizeAttenuation:true, color:0xffffff, map: getTexture() &#125;); for(var x = -5;x&lt;5;x++)&#123; for(var y = -5;y&lt;5;y++)&#123; var particle = new THREE.Vector3(x*10,y*10,0); geom.vertices.push(particle); var color = new THREE.Color(0x00ffff); color.setHSL(color.getHSL().h,color.getHSL().s,Math.random() * color.getHSL().l); geom.colors.push(color); &#125; &#125; cloud = new THREE.Points(geom,material); shareObj.scene.add(cloud);&#125;var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; cloud.rotation.x += 0.01; cloud.rotation.y += 0.01; cloud.rotation.z += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 采用png图片作为纹理的完整示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var shareObj = share(false);shareObj.camera.position.set(0, 0, 65);shareObj.camera.lookAt(shareObj.scene.position);createSprites();var cloud;// 创建粒子的方法function createSprites()&#123; if(cloud)&#123; shareObj.scene.remove(cloud); &#125; var texture = new THREE.ImageUtils.loadTexture('./yudi.png'); var geom = new THREE.Geometry(); var material = new THREE.PointsMaterial(&#123; size:10, transparent:true, opacity : 0.3, map:texture, // blending:THREE.AdditiveBlending, sizeAttenuation:true, color:0xffffff &#125;); var range = 600; for(var i = 0;i&lt;1000;i++)&#123; var particle = new THREE.Vector3( Math.random() * range - range/2, Math.random() * range - range/2, Math.random() * range - range/2 ); particle.velocityY = 0.1 + Math.random() /5; particle.velocityX = (Math.random()-0.5) / 3; geom.vertices.push(particle); &#125; cloud = new THREE.Points(geom,material); cloud.sortParticles = true; shareObj.scene.add(cloud);&#125;var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();var startTime = Date.now();function render() &#123; if(Date.now() - startTime &gt; 80)&#123; createSprites(); startTime = Date.now(); &#125; requestAnimationFrame(render); // 得到顶点 var vertices = cloud.geometry.vertices; vertices.forEach(function(v)&#123; v.y = v.y - v.velocityY; v.x = v.x - v.velocityX; if(v.y &lt;= 0 ) v.y = 60; if(v.x &lt;= -20 || v.x &gt;= 20) v.velocityX = v.velocityX -1; &#125;); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 精灵使用 THREE.Sprit 类的目的 创建基于屏幕坐标移动、缩放和定位的对象，可以用它来创建一个平视显示器，就好像三维场景上蒙上一层薄膜，简称 HUD。 创建类似粒子的，在三维空间移动的物体。 常用属性 color 粒子颜色 map 精灵所用的纹理 blending 渲染精灵时所用的融合模式 useScreenCoordinates 精灵的位置是否绝对定位 完整示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var shareObj = share(false);shareObj.camera.position.set(0, 0, 65);shareObj.camera.lookAt(shareObj.scene.position);createSprites();var group;// 创建粒子的方法function createSprites()&#123; group = new THREE.Object3D(); var range = 200; for(var i=0;i&lt;500;i++)&#123; group.add(createSprite(10,false,0.6,0xffffff,i%5,range)); &#125; shareObj.scene.add(group);&#125;function getTexture()&#123; return new THREE.ImageUtils.loadTexture('./yudi.png');&#125;function createSprite(size,transparent,opacity,color,spriteNumber,range)&#123; var spriteMaterial = new THREE.SpriteMaterial(&#123; opacity:opacity, color:color, transparent:transparent, map:getTexture() &#125;); spriteMaterial.map.offset = new THREE.Vector2(0.2 * spriteNumber, 0 ); spriteMaterial.map.repeat = new THREE.Vector2(1/5,1); spriteMaterial.depthTest = false; // spriteMaterial.blending = THREE.AdditiveBlending; // 创建精灵类 var sprite = new THREE.Sprite(spriteMaterial); // 对精灵进行裁剪 sprite.scale.set(size,size,size); sprite.position.set( Math.random() * range - range/2, Math.random() * range - range/2, Math.random() * range - range/2 ); sprite.velocityX = 5; return sprite;&#125;var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render()&#123; group.rotation.x += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene,shareObj.camera);&#125; 最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/17","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"Three.js系列教程--几何体","date":"2017-07-17T13:09:11.000Z","path":"webgl-2017-07-17/","text":"二位几何体二维矩形的属性 PlaneGeometry width 宽度 height 高度 wSegments 宽度段数 hSegments 高度段数 完整示例代码如下： 12345678910111213141516171819202122232425262728293031323334var shareObj = share();shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;var plane = createMesh(new THREE.PlaneGeometry(12, 15, 10, 15));shareObj.scene.add(plane);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; plane.rotation.x += 0.01; plane.rotation.z += 0.01; plane.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 二维圆的属性 CircleGeometry radius 圆半径 segments 所用面的数量 start 画圆起始位置 length 定义圆要画多大 完整示例代码如下： 12345678910111213141516171819202122232425262728293031323334var shareObj = share();shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;var circle = createMesh(new THREE.CircleGeometry(4,10,0.3 * Math.PI, 0.3 * Math.PI));shareObj.scene.add(circle);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; circle.rotation.x += 0.01; circle.rotation.z += 0.01; circle.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 球面几何体三维球体的属性 SphereGeometry radius 球体的半径 widthSegments 垂直方向上的分段数 heightSegments 水平方向上的分段数 phistart 定义 x 轴的绘制位置 thetaStart 定义 y 轴的绘制位置 theLength 定义绘制多大 完整示例代码如下： 1234567891011121314151617181920212223242526272829303132333435var shareObj = share();shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;// 定义一个球面体var sphere = createMesh(new THREE.SphereGeometry(10,50,50,0,2 * Math.PI));shareObj.scene.add(sphere);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; sphere.rotation.x += 0.01; sphere.rotation.z += 0.01; sphere.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 圆柱体的属性 CylinderGeometry radiusTop 顶部尺寸 radiusBottom 底部尺寸 height 高度 segmentsX 指定 x 轴分段数 segmentsY 指定 y 轴分段数 segmentsZ 指定 z 轴分段数 openEnded 指定网格顶部和底部是否封闭 TorusGeometry 的属性 radius 圆环的尺寸 tube 半径 radialSegments 长度分段数 tubularSegments 宽度分段数 arc 控制绘制的长度 环面纽结的属性 TorusKnotGeometry radius 圆环的尺寸 tube 半径 radialSegments 长度分段数 tubularSegments 宽度分段数 detail 为环面增加额外细节 完整示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879var shareObj = share();shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;var mesh;var sphere = createMesh(new THREE.SphereGeometry(10,50,50,0, 2 * Math.PI));var cylinder = createMesh(new THREE.CylinderGeometry(20,20,20,20,100))var torus = createMesh(new THREE.TorusGeometry(10,2,20,10,Math.PI * 2));var knot = createMesh(new THREE.TorusKnotGeometry(10,1,64,8,2,9,1))mesh = sphere;$('#sphere').click(function()&#123; shareObj.scene.remove(mesh); mesh = sphere; shareObj.scene.add(mesh);&#125;);$('#cylinder').click(function()&#123; shareObj.scene.remove(mesh); mesh = cylinder; shareObj.scene.add(mesh);&#125;);$('#torus').click(function()&#123; shareObj.scene.remove(mesh); mesh = torus; shareObj.scene.add(mesh);&#125;);$('#knot').click(function()&#123; shareObj.scene.remove(mesh); mesh = knot; shareObj.scene.add(mesh);&#125;);shareObj.scene.add(mesh);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);$(\"#webgl-scene\").append(shareObj.renderer.domElement)render();function render() &#123; sphere.rotation.y += 0.01; cylinder.rotation.y += 0.01; torus.rotation.y += 0.01; knot.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 通过按钮切换不同的形状，最终效果如下图： 多面几何体多面体的属性 PolyhedronGeometry vertices 多面体的顶点 faces 多面体的面 radius 多面体的大小 detail 为多面体添加额外细节 完整示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var shareObj = share();shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;var vertices = [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];var faces = [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];// 定义一个球面体var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices,faces,10));shareObj.scene.add(polyhedron);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; polyhedron.rotation.x += 0.01; polyhedron.rotation.z += 0.01; polyhedron.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 通过按钮切换不同的形状，最终效果如下图： 其他多面体 IcosahedronGeometry 正二十面体 TetrahedronGeometry 正四面体 Octahedron 正八面体 完整示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var shareObj = share(false);shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;var mesh = null;var size = 10;var z20 = createMesh(new THREE.IcosahedronGeometry(size));var z4 = createMesh(new THREE.TetrahedronGeometry(size));var z8 = createMesh(new THREE.OctahedronGeometry(size));mesh = z20;$(\"#z4\").click(function(e)&#123; shareObj.scene.remove(mesh); mesh = z4; shareObj.scene.add(mesh);&#125;)$(\"#z8\").click(function(e)&#123; shareObj.scene.remove(mesh); mesh = z8; shareObj.scene.add(mesh);&#125;)$(\"#z20\").click(function(e)&#123; shareObj.scene.remove(mesh); mesh = z20; shareObj.scene.add(mesh);&#125;)shareObj.scene.add(mesh);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);$(\"#webgl-scene\").append(shareObj.renderer.domElement);render();function render() &#123; z4.rotation.y += 0.01; z8.rotation.y += 0.01; z20.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 通过按钮切换不同的形状，最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/16","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"Three.js系列教程--材质","date":"2017-07-16T13:09:11.000Z","path":"webgl-2017-07-16/","text":"分类 基础材质，赋予几何体简单的颜色或者几何体的线框，也就是结构 深度材质，根据网格到相机的距离来决定如何绘制 法向材质，根据物体表面向量的计算来得到物体的颜色，并且对表面进行渲染 网格面材质，是一个容器，并且在容器里面为物体的各个表面制定不同的色彩 朗伯材质，考虑到光照的影响，适合创造光亮暗淡的物体 Phong 式材质，创造光亮的物体，比如说钻石等 着色器材质 共有属性 id 用来识别材质的标识符。 name 可以通过这个属性赋予材质名称。 opacity 物体的透明度。 transparent 是否透明。 overdraw 过度描绘。 visible 是否可见。 needsUpdate 是否刷新。 融合属性 深度测试 简单材质 不受光照影响。 使用这种材质的网格会被渲染成一些简单的多变形。 可以显示出几何体的线框。 常用属性 color 材质的颜色 wireframe 设置为 true ，可以显示出线框。 fog 指定当前材质是否会受全局雾化效果的影响。 完整示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var shareObj = share();var cubeGeometry = new THREE.BoxGeometry(5, 5, 5);var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xff0000 &#125;);var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);cube.castShadow = true;var sphereGeometry = new THREE.SphereGeometry(5, 20, 20);var sphereMaterial = new THREE.MeshLambertMaterial(&#123; color: 0x770077,wireframe:true &#125;);var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);sphere.position.set(0,3,2);cube.position = sphere.position;sphere.castShadow = true;shareObj.scene.add(sphere);shareObj.scene.add(cube);shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);var ambiLight = new THREE.AmbientLight('#1c1c1c');shareObj.scene.add(ambiLight);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40,60,10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; shareObj.renderer.render(shareObj.scene, shareObj.camera); cube.rotation.y += 0.01; sphere.rotation.y += 0.01; requestAnimationFrame(render);&#125; 最终效果如下图： 深度材质 外观不由光照和材质决定。 外观由物体到相机的距离决定。 可以与其他材质组合使用。 基本属性 wireframe 是否显示线框。 writeframeLinewidth 线框线的宽度。 完整示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var scene = new THREE.Scene;scene.overrideMaterial = new THREE.MeshDepthMaterial();var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 10, 130);var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0x000000, 1.0));renderer.setSize(window.innerWidth, window.innerHeight);camera.position.set(-50, 40, 50);camera.lookAt(scene.position);// 创建立方体的方法function addCube() &#123; var cubeSize = Math.ceil(3 + (Math.random() * 3)); var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize); var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: Math.random() * 0xffffff &#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.castShadow = true; cube.position.set( -60 + Math.round(Math.random() * 100), Math.round(Math.random() * 10), -100 + Math.round(Math.random() * 150) ); scene.add(cube)&#125;for (var i = 0; i &lt; 100; i++) &#123; addCube();&#125;document.body.appendChild(renderer.domElement);render();function render() &#123; requestAnimationFrame(render); scene.traverse(function(e) &#123; if (e instanceof THREE.Mesh) &#123; e.rotation.x += 0.02; e.rotation.y += 0.02; e.rotation.z += 0.02; &#125; &#125;); renderer.render(scene, camera);&#125; 最终效果如下图： 联合材质 联合多个材质，产生综合渲染效果。 联合材质创建方法 THREE.SceneUtils.createMultiMaterialObject 完整示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var scene = new THREE.Scene;var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 10, 130);var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0x000000, 1.0));renderer.setSize(window.innerWidth, window.innerHeight);camera.position.set(-50, 40, 50);camera.lookAt(scene.position);// 创建立方体的方法function addCube() &#123; var cubeSize = Math.ceil(3 + (Math.random() * 3)); var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize); // 深度材质 var cubeMaterial = new THREE.MeshDepthMaterial(); // 基础材质 var colorMaterial = new THREE.MeshBasicMaterial(&#123; color:0x00ff00, transparent:true, blending:THREE.MultiplyBlending &#125;); var cube = new THREE.SceneUtils.createMultiMaterialObject(cubeGeometry,[ colorMaterial,cubeMaterial ]); cube.children[1].scale.set(0.99,0.99,0.99); cube.castShadow = true; cube.position.set( -60 + Math.round(Math.random() * 100), Math.round(Math.random() * 10), -100 + Math.round(Math.random() * 150) ); scene.add(cube);&#125;for (var i = 0; i &lt; 100; i++) &#123; addCube();&#125;document.body.appendChild(renderer.domElement);render();function render() &#123; requestAnimationFrame(render); scene.traverse(function(e) &#123; if (e instanceof THREE.Mesh) &#123; e.rotation.x += 0.02; e.rotation.y += 0.02; e.rotation.z += 0.02; &#125; &#125;); renderer.render(scene, camera);&#125; 最终效果如下图： 法向材质 MeshNormalMaterial 材质是通过法向计算颜色的。 法向量是与面垂直的向量。 基本属性 wireframe 该属性指定是否显示线框。 wireframeLineWidth 指定线框线的宽度。 shading 设置着色方法。 完整示例代码如下： 123456789101112131415161718192021222324252627282930313233var shareObj = share();var cubeGeometry = new THREE.BoxGeometry(5, 5, 5);// 定义法向材质var cubeMaterial = new THREE.MeshNormalMaterial(&#123; color: 0x7777ff &#125;);var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);shareObj.scene.add(cube);shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);var ambiLight = new THREE.AmbientLight('#1c1c1c');shareObj.scene.add(ambiLight);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40,60,10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; shareObj.renderer.render(shareObj.scene, shareObj.camera); cube.rotation.y += 0.01; requestAnimationFrame(render);&#125; 最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/15","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"Three.js系列教程--光源","date":"2017-07-15T13:09:11.000Z","path":"webgl-2017-07-15/","text":"概述光源分类 AmbientLight 环境光源 PointLight 点光源 SpotLight 聚光灯光源 DirectionalLight 方向光 HemisphereLight 半球光 AreaLight 面光源 LensFlare 镜头眩光 影响整个场景的光源 影响整个场景的光源，也叫 AmbientLight 环境光。 没有特定来源，不会影响阴影的产生。 不能将环境光作为场景中唯一的光源。 three.color 函数 add(color) 添加到当前颜色上。 clone() 复制当前颜色。 示例核心代码如下： 12// 加入环境光shareObj.scene.add(new THREE.AmbientLight('#f00')) 最终效果如下图，环境光会作用在所有的几何图形上： 照射所有方向的光源 照射所有方向的光源，也叫 PointLight 点光源。 点光源是单点发光方式。 点光源不会产生阴影，是为了减少 GPU 的负担。 属性 color 光源颜色。 intensity 光照强度。 distance 光源照射的距离。 position 光源所在的位置。 示例核心代码如下： 1234567891011121314151617// 加入点光源var pointLight = new THREE.PointLight(0xffffff);pointLight.position.set(-40,60,10);shareObj.scene.add(pointLight);document.body.appendChild(shareObj.renderer.domElement);render();function render()&#123; requestAnimationFrame(render); pointLight.position.z += 0.2; shareObj.renderer.render(shareObj.scene,shareObj.camera);&#125; 最终效果如下图，点光源离物体越来越远： 锥形效果光源 具有锥形效果的光源，也叫做 SpotLight 。 最常用到的光源，它可以产生阴影。 锥形效果，类似电筒光照效果。 属性 castShadow 如果设置为 true ， 这个光源就会生成阴影。 target 决定光照的方向。 angle 光照的角度。 示例核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;spotLight.target = cube;spotLight.angle = Math.PI / 10;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);var angleNUM = 3;document.onkeydown = function(event) &#123; console.log(event.keyCode); switch (event.keyCode) &#123; case 38: angleNUM += 1; break; case 40: angleNUM -= 1; if (angleNUM &lt; 1) &#123; angleNUM = 1; &#125; break; case 37: spotLight.position.x += 0.2; break; case 39: spotLight.position.x -= 0.2; break; &#125;&#125;;function render() &#123; spotLight.angle = Math.PI / angleNUM; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125;render(); 最终效果如下图： 太阳的光源 模拟远处太阳的光源，也叫做 DirectinalLight 方向光。 方向光是一种平行光。 属性 它和平行光源的属性一样，常用的属性castShadow、target 和 angle 。 不常用的属性有 shadowCameraVisible 、shadowDarkness、shadowMapWidth 和 shadowMapHeight 等，这些属性很少会被用到。 示例核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var ambiLight = new THREE.AmbientLight('#1c1c1c');shareObj.scene.add(ambiLight);var target = new THREE.Object3D();target.position.set(5, 0, 0);var directionalLight = new THREE.DirectionalLight('#ff5818');directionalLight.position.set(-40, 60, -11);directionalLight.castShadow = true;directionalLight.shadowCameraFar = 200;directionalLight.shadowCameraNear = 3;directionalLight.intensity = 0.5;directionalLight.shadowMapWidth = 1000;directionalLight.shadowMapHeight = 2000;directionalLight.target = target;document.body.appendChild(shareObj.renderer.domElement);shareObj.scene.add(directionalLight);document.onkeydown = function(event) &#123; switch (event.keyCode) &#123; case 37: directionalLight.intensity += .1; break; case 39: directionalLight.intensity -= .1; if (directionalLight.intensity &gt; 0) &#123; directionalLight.intensity = .1; &#125; break; &#125;&#125;;render();function render() &#123; shareObj.renderer.render(shareObj.scene, shareObj.camera); requestAnimationFrame(render);&#125; 最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/14","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"Three.js系列教程--基础组件","date":"2017-07-14T13:09:11.000Z","path":"webgl-2017-07-14/","text":"场景必备组件 相机：决定哪些东西将被显示在屏幕上。 光源：生成阴影与改变物体表面显示效果。 物体：相机透视图里主要的渲染对象。 基本功能 scene.add() 在场景中添加物体。 scene.remove() 从场景中移除物体。 scene.getChildByName() 获得场景中所有对象的列表。 属性 fog 通过该属性可以设置场景的雾化效果。 overrideMaterial 通过这个属性可以让场景中的所有物体都使用相同材质。 children 返回所有对象的列表，包括相机和光源对象。 创建场景，相机，绘制函数等对象，设置画布背景，开启阴影模式： 123456789101112131415// 创建场景var scene = new THREE.Scene();// 创建相机var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, .1, 1000);// 创建渲染器var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));renderer.setSize(window.innerWidth, window.innerHeight);// 开启阴影效果renderer.shadowMapEnabled = true; 创建一个舞台，承载绘制的物体，并且将舞台加载到场景中： 123456789101112131415// 顶点着色器var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1);// 材质var planeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xffffff &#125;);var plane = new THREE.Mesh(planeGeometry, planeMaterial);plane.receiveShadow = true;plane.rotation.x = -.5 * Math.PI;plane.position.x = 16;plane.position.y = 0;plane.position.z = 0;scene.add(plane); 定义一个相机的位置1234camera.position.x = -30;camera.position.y = 40;camera.position.z = 30;camera.lookAt(scene.position); 添加环境光和电光源： 12345678// 创建环境光源var ambientLight = new THREE.AmbientLight(0x0c0c0c);scene.add(ambientLight);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, -10);spotLight.castShadow = true;scene.add(spotLight); 创建节点，并且渲染场景： 123document.body.appendChild(renderer.domElement);renderer.render(scene, camera); 创建添加立方体的方法： 123456789101112131415function addCube() &#123; // 创建立方体 var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xff0000 &#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); // cube.castShadow = true; cube.position.x = -4 + Math.round(Math.random() * planeGeometry.parameters.width); cube.position.y = 3 + Math.round(Math.random() * 5); cube.position.z = 0 + Math.round(Math.random() * planeGeometry.parameters.height); scene.add(cube);&#125; 最终效果如下图： 几何与网络对象几何对象的属性和函数 THREE.Geometry 是所有几何对象的基类（ 我们简称 geom ）。 geom.vertices 表示几何体的顶点，是一个数组。 geom.faces 表示几何体的侧面。 网格对象的属性和函数 position 决定该对象相对于父对象的位置。 rotation 设置对象绕任何一个轴的旋转弧度。 scale 沿 x , y和 z 轴缩放对象。 translateX x 轴平移。 translateY y 轴平移。 translateZ z 轴平移。 通过顶点和面来创建一个几何体，，创建场景、相机、渲染器等基本组件和之前保持一致，核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 绘制顶点var vertices = [ new THREE.Vector3(1, 3, 1), new THREE.Vector3(1, 3, -1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, -1, -1), new THREE.Vector3(-1, 3, -1), new THREE.Vector3(-1, 3, 1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(-1, -1, 1)];// 绘制面var faces = [ new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1), new THREE.Face3(4, 6, 5), new THREE.Face3(6, 7, 5), new THREE.Face3(4, 5, 1), new THREE.Face3(5, 0, 1), new THREE.Face3(7, 6, 2), new THREE.Face3(6, 3, 2), new THREE.Face3(5, 7, 0), new THREE.Face3(7, 2, 0), new THREE.Face3(1, 3, 4), new THREE.Face3(3, 6, 4)];var geom = new THREE.Geometry();geom.vertices = vertices;geom.faces = faces;geom.computeFaceNormals();var materials = [ new THREE.MeshLambertMaterial(&#123; opacity: 0.5, color: 0x44ff44, transparent: true &#125;), new THREE.MeshBasicMaterial(&#123; color: 0x000000, wireframe: true &#125;)];var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, materials);mesh.children.forEach(function(e) &#123; e.castShadow = true;&#125;);scene.add(mesh);document.body.appendChild(renderer.domElement);renderer.render(scene, camera); 最终效果如下图： 相机透视相机（PerspectiveCamera） fov 视野宽度 。 aspect 长宽比，推荐使用 window.innerWidth / window.innerHeight 。 near 近裁面，推荐值 0.1 。 far 远裁面，推荐值 1000 ， 值太大会影响性能，值太小场景显示不全。 正射投影相机（OrthographicCamera） left 左边界。 right 右边界。 top 上边界。 bottom 下边界。 near 近裁面。 far 远裁面。 camera.lookAt 设置目标点。 增加雾化效果的核心代码： 1234// 增加雾化处理scene.fog = new THREE.Fog( 0xffffff, .005, 100 ); 最终结果如下图： 示例代码来区分透视投影和正射投影的区别： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var cubeGeometry = new THREE.BoxGeometry(4, 4, 4);for (var j = 0; j &lt; planeGeometry.parameters.height / 5; j++) &#123; for (var i = 0; i &lt; planeGeometry.parameters.width / 5; i++) &#123; var rnd = Math.random() * 0.75 + 0.25; var cubeMaterial = new THREE.MeshLambertMaterial(); cubeMaterial.color = new THREE.Color(rnd, 0, 0); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.position.z = -(planeGeometry.parameters.height / 2) + 2 + (j * 5); cube.position.x = -(planeGeometry.parameters.width / 2) + 2 + (i * 5); cube.position.y = 2; scene.add(cube); &#125;&#125;// 定义相机切换的方法var controls = new function() &#123; this.perspective = 'Perspective'; this.switchCamera = function() &#123; if (camera instanceof THREE.PerspectiveCamera) &#123; camera = new THREE.OrthographicCamera( window.innerWidth / -16, window.innerWidth / 16, window.innerHeight / 16, window.innerHeight / -16, -200, 500 ); camera.position.x = -20; camera.position.y = 60; camera.position.z = 50; camera.lookAt(scene.position); this.perspective = 'Orthographic'; &#125; else &#123; this.perspective = 'Perspective'; camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.x = -20; camera.position.y = 60; camera.position.z = 50; camera.lookAt(scene.position); &#125; &#125;&#125;;setInterval(function()&#123;controls.switchCamera();&#125;,2000)function render() &#123; renderer.render(scene, camera);&#125;render(); 最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/13","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"WebGL系列教程--绘制立方体","date":"2017-07-13T13:09:11.000Z","path":"webgl-2017-07-13/","text":"顶点索引绘制立方体 正方体只有8个顶点。 压缩36个顶点到8个顶点。 顶点索引是减少顶点的解决之道。 使用 new Uint8Array( … ) 创建顶点索引数据。 运用到的绘制方法 gl.drawElements(mode , count , type , offset) mode 绘制方式。 count 绘制顶点的数量。 type 索引数据类型。 offset 指定索引数组中开始绘制的位置，以字节为单位。 核心代码如下： 定义8个顶点的数据，并且将数据添加到buffer对象上： 12345678910111213141516var buffer_data = new Float32Array([ // 设置顶点和颜色（偷的顶点代码位置） 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, // v0 White -1.0, 1.0, 1.0, 1.0, 0.0, 1.0, // v1 Magenta -1.0, -1.0, 1.0, 1.0, 0.0, 0.0, // v2 Red 1.0, -1.0, 1.0, 1.0, 1.0, 0.0, // v3 Yellow 1.0, -1.0, -1.0, 0.0, 1.0, 0.0, // v4 Green 1.0, 1.0, -1.0, 0.0, 1.0, 1.0, // v5 Cyan -1.0, 1.0, -1.0, 0.0, 0.0, 1.0, // v6 Blue -1.0, -1.0, -1.0, 0.0, 0.0, 0.0 // v7 Black]);var buffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, buffer);gl.bufferData(gl.ARRAY_BUFFER, buffer_data, gl.STATIC_DRAW); 同理，简历存放索引的buffer数据，并且将其添加到buffer对象上： 123456789101112var indices = new Uint8Array([ 0, 1, 2, 0, 2, 3, // 前 0, 3, 4, 0, 4, 5, // 右 0, 5, 6, 0, 6, 1, // 上 1, 6, 7, 1, 7, 2, // 左 7, 4, 3, 7, 3, 2, // 下 4, 7, 6, 4, 6, 5 // 后]);var indexBuffer = gl.createBuffer();gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,indices,gl.STATIC_DRAW); 建立透视投影矩阵和视图矩阵： 123456789// 透视投影矩阵var tsMX = getTS(30,1,1,100);// 视图矩阵var vMX = getVMatrix(3,3,7,0,0,0);var mx = multiplyMatrix(tsMX,vMX);gl.uniformMatrix4fv(mxLocation,false,mx); 使用gl.drawElements方法来绘制立方体： 1gl.drawElements(gl.TRIANGLES, indices.length,gl.UNSIGNED_BYTE,0); 最终效果如下： 添加颜色 顶点着色器进行的是逐顶点运算。 创建多个具有相同顶点坐标的原点。 为立方体每个面设置不同颜色。 立方体如下图： 12345678910// Create a cube// v6----- v5// /| /|// v1------v0|// | | | |// | |v7---|-|v4// |/ |/// v2------v3 基本实现原理如下图： 定义顶点的数据有所更改： 12345678var buffer_data = new Float32Array([ 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0,-1.0, 1.0, 1.0,-1.0, 1.0, // v0-v1-v2-v3 front 1.0, 1.0, 1.0, 1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0, // v0-v3-v4-v5 right 1.0, 1.0, 1.0, 1.0, 1.0,-1.0, -1.0, 1.0,-1.0, -1.0, 1.0, 1.0, // v0-v5-v6-v1 up -1.0, 1.0, 1.0, -1.0, 1.0,-1.0, -1.0,-1.0,-1.0, -1.0,-1.0, 1.0, // v1-v6-v7-v2 left -1.0,-1.0,-1.0, 1.0,-1.0,-1.0, 1.0,-1.0, 1.0, -1.0,-1.0, 1.0, // v7-v4-v3-v2 down 1.0,-1.0,-1.0, -1.0,-1.0,-1.0, -1.0, 1.0,-1.0, 1.0, 1.0,-1.0 // v4-v7-v6-v5 back]); 单独定义颜色数据： 12345678var color_data = new Float32Array([ 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, // v0-v1-v2-v3 front(blue) 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, // v0-v3-v4-v5 right(green) 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, // v0-v5-v6-v1 up(red) 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, // v1-v6-v7-v2 left 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, // v7-v4-v3-v2 down 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0 // v4-v7-v6-v5 back]); 在绘制前需要开启深度测试代码： 12// 开启深度测试gl.enable(gl.DEPTH_TEST); 如果不开启则效果如下图： 开启后效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/12","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--着色器语言","date":"2017-07-12T13:09:11.000Z","path":"webgl-2017-07-12/","text":"概述 运行在建立在OpenGL基础上，删除和简化了一部分形成的。 运行在小型设备 与 C 语言语法类似 执行顺序 从main主方法 void关键字 void main(){…}，没有函数返回值 基本写法如下：123void main()&#123; ...&#125; 基本类型 数值类型 布尔值类型 123456bool a;init b;float c;void main()&#123; ...&#125; 变量 a-z , A-Z , 0-9 , _ 首字母不能为数字 不能用关键字和保留字作变量名 不能以 gl_ , webgl 开头 基本运算符 / + - ++ — = += -= *= /= &lt; &gt; &lt;= &gt;= == != ! &amp;&amp; || ^^ 三元运算 123456789float a;float b;float c = a + b;++a/a++true ^^ true // falsefalse ^^ false // falsefalse ^^ true // true 复杂类型结构体struct bright{ vec4 color; vec3 position;} 在赋值过程中必须按照保证类型一样，因为着色器语言是强类型。 123456789101112struct user &#123; float gezi; vec3 book;&#125;user wq;float a = 12.0;vec3 b = vec3(1.2,3.3,5.0);wq = user(a,b)wq = user(12.0,vec3(2.1,3.3,5.0)); 数组 只支持一维数组 长度必须大于 0 的整型常量表达式 不可用 const 修饰数组 float floatArr[4]; 取样器 通过取样器类型访问纹理 sampler2D 只能是 uniform 变量 纹理单元编号，至少支持8个单元变量 程序流程控制判断语句if (条件表达式1){ 如果条件语句为 true，执行这里。}else if(条件表达式1){ 如果条件语句1为 false，并且条件语句2为 true，执行这里。}else{ 如果条件语句1和2都为 false ， 执行这里。} 12345678910111213varying vec4 vpos;if(vpos.x &gt;= 0.0 &amp;&amp; vpos.y &gt;= 0.0)&#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0); //红色&#125;else if(vpos.x &gt;= 0.0 &amp;&amp; vpos.y &lt; 0.0)&#123; gl_FragColor = vec4(0.0,1.0,0.0,1.0); //绿色&#125;else if(vpos.x &lt; 0.0 &amp;&amp; vpos.y &gt;= 0.0)&#123; gl_FragColor = vec4(0.0,0.0,1.0,1.0); //蓝色&#125;else&#123; gl_FragColor = vec4(1.0,1.0,0.0,1.0); //黄色&#125; 循环语句for ( 初始化表达式 ; 条件表达式 ; 循环步进表达式 ) { 反复执行这里} 1234567891011init sum = 0;for(init i = 0; i&lt;10;i++)&#123; sum += 1;&#125;// sum = 10;float sum = 0.0;for(init i = 0; i&lt;10;i++)&#123; sum += float(i);&#125; 函数格式返回类型函数名 (type0 arg0 , type1 arg1 , …) { 函数运算 return 返回值;}1234init sum(int a,int b)&#123; return a + b;&#125; 声明 float bright(); // 必须提前声明 void main(){ bright(); } float bright(){ … } 内置函数 三角函数 指数函数 通用函数 几何函数 矩阵函数 矢量函数 纹理查询函数 12345678910111213141516171819202122232425262728293031323334353637383940414243//三角函数radians(float d);radians(vec2 d);radians(vec3 d);radians(vec4 d);degrees(float d);degrees(vec2 d);degrees(vec3 d);degrees(vec4 d);// cos tan ...sin(float d);sin(vec2 d);sin(vec3 d);sin(vec4 d);// 指数函数pow(float x,float y)pow(vec2 x,vec2 y)pow(vec3 x,vec3 y)pow(vec4 x,vec4 y)// 通用函数abc(float x);abc(vec2 x);abc(vec3 x);abc(vec4 x);floor(float x);floor(vec2 x);floor(vec3 x);floor(vec4 x);max(float x,float y);// 几何函数// 返回x轴的长度length(float x) // vec2 ,vec3, vec4... 限定字存储限定字 const 不可变的量 attribute 顶点着色器中使用 uniform 只读，必须是全局变量。 varying 顶点和片元着色器通信使用的，顶点着色器中赋给varying变量的值并不是直接传给了片元着色器的varying变量，这其中发生了光删化的过程，根据绘制的图形，对前者进行内插，然后再传递给后者。 精度限定字 highp 最高精度 mediump 中等精度 lowp 低精度 precision lowp float； // 定义精度","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--可视范围","date":"2017-07-11T13:09:11.000Z","path":"webgl-2017-07-11/","text":"可视范围基础盒状空间 长方体可是空间，也叫盒状空间，是由正射投影产生。 可视锥体空间，由透视投影产生。 在透视投影下，产生的三维场景看上去更是有深度感，更加自然，因为我们平时观察真实世界用的也是透视投影。在大多数情况下，比如三维射击类游戏中，我们都应该采用透视投影。相比之下，正射投影的好处是用户可以方便的比较场景中物体的大小，这是因为物体看上去的大小与其所在的位置没有关系。在建筑平面图等技术绘图的相关场合，应当使用这种投影。 盒状空间的工作原理盒状可视空间的由前后两个矩形表面确定，分别称近裁剪面和远裁剪面，前者的四个顶点为（right,top,-near）,(-left,top,-near),(-left,-bottom,-near),(right,-bottom,-near),而后者的四个顶点为(right,top,far),(-left,top,far),(-left,-bottom,far),(right,-bottom,far). 上显示的就是可视空间中物体在近裁剪面上的投。如果裁剪面的高宽比和不一样，那么画面就会被按照的高宽比进行压缩，物体会被扭曲。近裁剪面与远裁剪面之间的盒形空间就是可是空间，只有在此空间内的物体会被显示出来。如果某个物体一部分在可视空间内，一部分在其外，那就只显示可视空间内的部分。 正射投影矩阵函数 setOrtho(left , right , bottom , top , near , far) left / right / bottom / top 参数含义：定位范围。 near 参数含义：近裁切面。 far 参数含义：远裁切面。 基本方程式如下： 写一个正射投影实例代码，核心代码如下： 编写顶点着色器和片元着色器代码，定义一个uniform矩阵变量。12345678910111213141516171819var vertexShaderSource = ` attribute vec4 pos; uniform mat4 u_mx; attribute vec4 a_Color; varying vec4 v_Color; void main()&#123; gl_Position = u_mx * pos; v_Color = a_Color; &#125;`var fragmentShaderSource = ` precision lowp float; varying vec4 v_Color; void main()&#123; gl_FragColor = v_Color; &#125;` 定义一个正射矩阵的方法1234567891011121314151617function getOMX(left,right,bottom,top,near,far)&#123; return new Float32Array([ 2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, -2 / (far - near), 0, -(right + left) / (right - left), -(top + bottom) / (top - bottom), -(far + near) / (far - near), 1 ]);&#125;var near = 0.0;var far = .5;var omx = getOMX(-.5,.5, -.5,.5, near , far); 定义数据data类型化数组123456789var data = new Float32Array([ 0.0, 0.6, -.4, 0.4, 1.0, 0.4, -.45, -.4, -.51, .4, 1.0, .4, 0.5, -.4, -.4, 1.0, .4, .4, .5, .4, -.2, 1.0, .4, .4, -.5, .4, -.2, 1.0, 1.0, .3, .0, -.6, -.2, 1.0, 1.0, .4]); 由于定义的far为.5,而data类型化数组数据一个三角形的坐标为-.51，实际效果会产生一个缺角，可以根据改变三角形的顶点来看不同的效果，最终效果如下图： 缺角的修补 将远裁面移到距离视点更远的地方。 &lt;正射投影矩阵&gt; &lt;视图矩阵&gt; &lt;顶点坐标&gt; 代码效果如下： 透视投影基础 透视投影和正射投影基本一致，但存在一些参数差异。使得远处的物体看起来比较小，一般在游戏开发会用的比较多。 可视空间顶面和底面的夹角必须大于0。 指定近裁面的宽高比例。 后面的三角形会根据与视点的距离做相应的缩放，并且做相应的平移。 透视投影矩阵矩阵公式 通过一个示例来解释透视投影具体的效果。 定义着色器代码： 12345678910111213141516171819var vertexShaderSource = ` attribute vec4 pos; uniform mat4 u_mx; attribute vec4 a_Color; varying vec4 v_Color; void main()&#123; gl_Position = u_mx * pos; v_Color = a_Color; &#125;`var fragmentShaderSource = ` precision lowp float; varying vec4 v_Color; void main()&#123; gl_FragColor = v_Color; &#125;` 创建program代码： 123var gl = canvas.getContext('webgl');var program = initShader(gl,vertexShaderSource,fragmentShaderSource); 定义创建透视投影矩阵函数方法： 12345678910111213141516/** * 创建透视投影矩阵 * fov 指定垂直视角 * aspect 宽度 ／ 高度 * near 近裁切面 * far 远裁切面 */function getTS(fov,aspect,near,far)&#123; fov = fov * Math.PI / 180; // 弧度 return new Float32Array([ 1 / (aspect * Math.tan(fov / 2)), 0, 0, 0, 0, 1 / Math.tan(fov / 2), 0, 0, 0, 0, -(far + near) / (far - near), -1, 0, 0, -2 * (far * near) / (far - near), 0 ]);&#125; 创建ata，并且将data绑定到创建的buffer上： 1234567891011121314151617181920212223242526// 四个三角形var buffer_data = new Float32Array([ 0.75, 1.0, -.8, 1.0, 1.0, .4, .25, -1.0, -.8, 1.0, 1.0, .4, 1.0, -1.0, -.8, 1.0, .4, .4, .75, 1.0, 0.8, .4, .4, 1.0, .25, -1.0, .8, .4, .4, 1.0, 1.0, -1.0, .8, 1.0, .4, .4, // 第一个三角形 -.75, 1.0, -.8, 1.0, 1.0, .4, -1.0, -1.0, -.8, 1.0, 1.0, 0.4, -0.25, -1.0, -.8, 1.0, .4, .4, -.75, 1.0, .8, .4, .4, 1.0, -1.0, -1.0, .8, .4, .4, 1.0, -.25, -1.0, .8, 1.0, .4, .4]);var buffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, buffer);gl.bufferData(gl.ARRAY_BUFFER, buffer_data, gl.STATIC_DRAW); 得到Location，并且给其赋值： 12345678910var posLocation = gl.getAttribLocation(program, 'pos');var aColorLocation = gl.getAttribLocation(program, 'a_Color');var uMXLocation = gl.getUniformLocation(program, 'u_mx');var BYTES_SIZE = buffer_data.BYTES_PER_ELEMENT;gl.vertexAttribPointer(posLocation, 3, gl.FLOAT, false, BYTES_SIZE * 6, 0);gl.vertexAttribPointer(aColorLocation, 3, gl.FLOAT, false, BYTES_SIZE * 6, BYTES_SIZE * 3);gl.enableVertexAttribArray(posLocation);gl.enableVertexAttribArray(aColorLocation); 定义一个绘图函数方法，并且执行，其中getVMatrix和multiplyMatrix是lib库中的函数： 1234567891011121314function draw() &#123; gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); var mx = getTS(30, canvas.width / canvas.height, 1, 100); var vmx = getVMatrix(0,0,5,0,0,-100); gl.uniformMatrix4fv(uMXLocation,false,multiplyMatrix(mx,vmx)); gl.drawArrays(gl.TRIANGLES, 0, 12);&#125;draw(); 最终运行结果如下： 物体前后关系 默认情况下，WebGL 是按照顶点在缓冲区中的顺序绘制的。 后绘制的会遮挡先绘制的图形。 例如将上面的示例中的data数据顺序该下，就会出现以下的效果： 1234567891011121314151617181920// 四个三角形var buffer_data = new Float32Array([ .75, 1.0, 0.8, .4, .4, 1.0, .25, -1.0, .8, .4, .4, 1.0, 1.0, -1.0, .8, 1.0, .4, .4, 0.75, 1.0, -.8, 1.0, 1.0, .4, .25, -1.0, -.8, 1.0, 1.0, .4, 1.0, -1.0, -.8, 1.0, .4, .4, -.75, 1.0, .8, .4, .4, 1.0, -1.0, -1.0, .8, .4, .4, 1.0, -.25, -1.0, .8, 1.0, .4, .4, -.75, 1.0, -.8, 1.0, 1.0, .4, -1.0, -1.0, -.8, 1.0, 1.0, 0.4, -0.25, -1.0, -.8, 1.0, .4, .4,]); 但是实际情况中，可能很多图像并不知道出现的顺序，webgl提供了两个方法来解决这类问题。 解决方法 启动隐藏面消除 启动多边形偏移 核心代码如下： 12gl.enable(gl.DEPTH_TEST);gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 这样做之后，离视点远的对象会在后面展示。 深度冲突隐藏面消除是WebGL的一项复杂而又强大的特效，在绝大多数情况下，它都能很好地完成任务。然而，当几何图形或物体的两个表面极为接近时，就会出现新的问题，使得表面看上去斑斑驳驳的，这种现象被称为深度冲突（Z fighting） 当所有的三角形一起绘画的时候，似乎不会出现这种情况，但是如果分开画三角形，可能会出现深度冲突的问题，通过以下代码可以解决： 1234gl.enable(gl.POLYGON_OFFSET_FILL);gl.drawArrays(gl.TRIANGLES, 0, 3);gl.polygonOffset(1.0, 1.0); gl.drawArrays(gl.TRIANGLES, 3, 3); 最终效果如下： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/11","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--贴图","date":"2017-07-10T13:09:11.000Z","path":"webgl-2017-07-10/","text":"贴图概述图片类别 JPG 格式，24位的颜色储存单个的绘图，是有损的压缩，牺牲图像质量可以控制文件大小 GIF 格式，压缩比例能够达到40%到50%，无损压缩技术（必须保证256颜色的） PNG 格式，无损压缩 贴图开发流程 准备纹理图像 配置图像映射方式 加载纹理图像 纹理贴图 贴图核心技术纹理坐标 st坐标系 纹理对象 createTexture 创建纹理 deleteTexture(tex) 删除纹理 图片加载 确定图片加载后调用的函数 图片开始加载 向服务器请求图片 服务器查找图片 服务器返回图片数据 浏览器收到图片数据 调用回调函数 配置纹理 Y 轴反转 开启纹理单元 绑定纹理对象 配置纹理参数 配置纹理图形 将纹理传递给着色器 编写着色器代码，在片元着色器中定义贴图，基本如下 1234567891011121314151617181920// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; attribute vec2 texPos; varying vec2 v_texPos; void main() &#123; gl_Position = pos; v_texPos = texPos; &#125;` // 片元着色器程序 const fragmentShaderSource = ` precision lowp float; uniform sampler2D ss; varying vec2 v_texPos; void main() &#123; gl_FragColor = texture2D(ss,v_texPos); &#125;` 将加载的图片画在canvas上面，基本代码如下：12345678910111213141516171819202122function loadImg(url,callback)&#123; var img = new Image; img.src = url; img.onload = function () &#123; callback(img); &#125; &#125; loadImg('./img.png', function (img) &#123; var texture = cxt.createTexture(); cxt.pixelStorei(cxt.UNPACK_FLIP_Y_WEBGL,1); cxt.activeTexture(cxt.TEXTURE0); cxt.bindTexture(cxt.TEXTURE_2D,texture); cxt.texParameteri(cxt.TEXTURE_2D,cxt.TEXTURE_MIN_FILTER,cxt.LINEAR); cxt.texImage2D(cxt.TEXTURE_2D,0,cxt.RGB,cxt.RGB,cxt.UNSIGNED_BYTE,img); cxt.uniform1i(texLocation,0); cxt.drawArrays(cxt.TRIANGLE_STRIP,0,4); &#125;); 最终效果如下： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/10","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--视点与视线","date":"2017-07-09T13:09:11.000Z","path":"webgl-2017-07-09/","text":"视点、目标点和上方向 视点：观察者所在的三维世界中的位置。 目标点：被观察的目标所在的位置。 上方向：相机正上方的方向。 试图矩阵 默认情况下，视点位于坐标系原点 lookAt(out, eye, center, up) eye 指定视点 center 指定观察点 up 指定向上方向 定义顶点着色器和片元着色器代码，在定义着色器代码中，需要定义点的坐标，点的颜色，矩阵，和片元着色器通信的颜色变量1234567891011121314151617181920// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_vmatrix; varying vec4 v_Color; void main() &#123; gl_Position = u_vmatrix * a_Position; v_Color = a_Color;&#125;` // 片元着色器程序 const fragmentShaderSource = ` precision lowp float; varying vec4 v_Color; void main() &#123; gl_FragColor = v_Color; &#125;` 定义几个公共工具类函数，基本代码如下：1234567891011121314151617181920212223242526function normalize(v)&#123; var sum = 0; for (var i=0;i&lt; v.length;i++)&#123; sum += v[i] * v[i]; &#125; var result = Math.sqrt(sum); for(var j=0;j&lt; v.length; j++)&#123; v[i] = v[i] / result; &#125; &#125; function cross(a,b)&#123; var nX = a[1] * b[2] - a[2] * b[1]; var nY = a[2] * b[0] -a[0] * b[2]; var nZ = a[0] * b[1] - a[1] * b[0]; return new Float32Array([nX,nY,nZ]); &#125; function dot(a,b)&#123; return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; &#125; function minus(a , b)&#123; return new Float32Array([a[0] - b[0], a[1] - b[1] , a[2] - b[2]]); &#125; 通过工具类函数创建一个新的视图矩阵，基本代码如下：1234567891011121314151617181920212223function getVMatrix()&#123; var eye = new Float32Array([0.4,0.0,0.26]); var lookat = new Float32Array([0.0,0.0,0.0]); var up = new Float32Array([0,1,1]); var zA = minus(eye , lookat); normalize(zA); normalize(up); var xA = cross(up, zA); var yA = cross(zA,xA); return new Float32Array([ xA[0],yA[0],zA[0], 0, xA[1],yA[1],zA[1], 0, xA[2],yA[2],zA[2], 0, - dot(xA,eye), -dot(yA,eye),-dot(zA,eye),1 ]) &#125; 创建三角形类型化数组，基本代码如下：12345678910var data = new Float32Array([ 0.0, 0.5, -0.4, 0.4, 1.0, 0.4, -0.5, -0.5, -0.4, 0.4, 1.0, 0.4, 0.5, -0.5, -0.4, 1.0, 0.4, 0.4, 0.5, 0.4, -0.2, 1.0, 0.4, 0.4, -0.5, 0.4, -0.2, 1.0, 1.0, 0.4, 0.0, -0.6, -0.2, 1.0, 1.0, 0.4 ]); 视图矩阵数据添加，基本代码如下：123456var u_vmatrixLocation = cxt.getUniformLocation(program,'u_vmatrix');var mx = getVMatrix(); // 视图矩阵cxt.uniformMatrix4fv(u_vmatrixLocation,false,mx); 最终效果如下： 视点控制 旋转后顶点坐标 ＝ 旋转矩阵 * 原始顶点坐标 （从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 * 旋转后顶点坐标 （从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 旋转矩阵 原始顶点坐标 视图矩阵 模型矩阵 原始顶点坐标 添加键盘控制视点位置，基本代码如下：123456789101112131415161718192021222324252627282930var eyeX = 0.25; function draw(eyeX)&#123; var mx = getVMatrix(eyeX); // 视图矩阵 cxt.uniformMatrix4fv(u_vmatrixLocation,false,mx); cxt.clearColor(1.0,1.0,1.0,1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.drawArrays(cxt.TRIANGLES,0,6); &#125; document.addEventListener('keydown', function (event) &#123; switch (event.keyCode)&#123; case 37: eyeX += .01; break; case 39: eyeX -= .01; break; &#125; draw(eyeX); &#125;); draw(eyeX); 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/09","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--着色器技术","date":"2017-07-08T13:09:11.000Z","path":"webgl-2017-07-08/","text":"数据传入顶点着色器创建多个缓冲区 例如上图显示的，创建点的坐标和创建点的大小两个缓冲区，就要在顶点着色器中创建两个attribute变量 在顶点着色器中定义两个attribute变量，分别是点和点的大小，基本代码如下：123456789// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; attribute float size; void main() &#123; gl_Position = pos; gl_PointSize = size;&#125;` 创建program变量，代码基本如下：1var program = initShader(cxt, vertexShaderSource, fragmentShaderSource); 使用lib库中的bindAttribute函数创建两个buffer相关代码，基本如下：12345678bindAttribute(cxt, 'pos', new Float32Array([ 0.0,0.0, 0.3,0.5, 0.2,1.0 ]), program, 2); bindAttribute(cxt, 'size', new Float32Array([ 10.0,20.0,30.0 ]), program, 1); 最后调用drawArrays直接画点即可，代码如下：1cxt.drawArrays(cxt.POINTS, 0, 3); 偏移参数 一个缓冲区多种用途 通过偏移参数划分数据类别 类数组定义方式有所变化，将点的位置和点的大小定义在一个数组中，前面两位代表点的位置，最后一位代表点的大小，基本代码如下：12345var data = new Float32Array([ 0.0, 0.0, 10.0, 0.5, 0.5, 30.0, 0.2, -.6, 50.0 ]); vertexAttribPointer函数的参数形式有所变化，data.BYTES_PER_ELEMENT代表偏移量单位，3代表每一组数据有三个，所以3，*2代表从偏移2两位开始计算，基本代码如下：12cxt.vertexAttribPointer(posLocation, 2, cxt.FLOAT, false, data.BYTES_PER_ELEMENT * 3, 0); cxt.vertexAttribPointer(sizeLocation, 1, cxt.FLOAT, false, data.BYTES_PER_ELEMENT * 3, data.BYTES_PER_ELEMENT * 2) 顶点着色器和片元着色器通信 通过 uniform 实现顶点和片元着色器共用数据，uniform是不可变的值 通过 varying 传递数据 着色器代码如下：12345678910111213141516171819// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; varying vec4 color; void main() &#123; gl_Position = pos; gl_PointSize = abs(pos.x) * 30.0; color = pos;&#125;` // 片元着色器程序 const fragmentShaderSource = ` precision lowp float; varying vec4 color; void main() &#123; gl_FragColor = color; &#125;` 最终效果是根据坐标的大小和坐标的位置，显示不同的颜色，基本效果如下： 编写一个渐变三角形的示例效果，使用一个buffer数据，分别定义坐标点和点的颜色值，着色器代码如下：12345678910111213141516171819// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; attribute vec4 vcolor; varying vec4 color; void main() &#123; gl_Position = pos; color = vcolor;&#125;` // 片元着色器程序 const fragmentShaderSource = ` precision lowp float; varying vec4 color; void main() &#123; gl_FragColor = color; &#125;` buffer数据data代码如下：123456var data = new Float32Array([ 0.0, .3, 1.0 ,0.0,0.0, -.5, -.5, 0.0, 1.0,0.0, .5, -.5 , 0.0, 0.0,1.0 ]); 最终效果效果如下： 制作一个旋转四边形，并且四边形四个坐标系分别是不同的颜色，首先初步定义着色器代码，基本代码如下： 12345678910111213141516171819// 顶点着色器程序 const vertexShaderSource = ` uniform mat4 xf; attribute vec4 pos; varying vec4 vpos; void main() &#123; gl_Position = xf * pos; vpos = gl_Position;&#125;` // 片元着色器程序 const fragmentShaderSource = ` precision lowp float; varying vec4 vpos; void main() &#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0); &#125;` 获取上下文和program示例代码，利用lib库中的initShader函数，基本如下： 123var cxt = document.getElementById('example06').getContext('webgl'); var program = initShader(cxt, vertexShaderSource, fragmentShaderSource); 定义一个四边形相关的buffer数据内容，基本代码如下： 123456789var data = new Float32Array([ -.3, .3, -0.5, -.3, .5, .3, .3, -.3 ]); bindAttribute(cxt,'pos',data,program); 定义着色器中定义的xf变量相关代码，并且创建旋转矩阵，定义旋转角度等，基本如下：12345678910var xfLocation = cxt.getUniformLocation(program,'xf');var angle = 0;run() function run() &#123; angle++ var xzm = createXZMatrix(angle); cxt.uniformMatrix4fv(xfLocation, false, xzm); cxt.drawArrays(cxt.TRIANGLE_STRIP, 0, 4); setTimeout(run, 100) &#125; 此时的效果是四边形可以旋转，但是颜色还是之前定义的红色，基本效果如下： 通过修改片元着色器中的代码实现不同象限中显示不同颜色，基本代码如下：1234567891011121314151617// 片元着色器程序 const fragmentShaderSource = ` precision lowp float; varying vec4 vpos; void main() &#123; if(vpos.x &gt;= 0.0 &amp;&amp; vpos.y &gt;= 0.0)&#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0); &#125;else if(vpos.x &gt;0.0 &amp;&amp; vpos.y &lt; 0.0)&#123; gl_FragColor = vec4(0.0,1.0,0.0,1.0); &#125;else if(vpos.x &lt; 0.0 &amp;&amp; vpos.y &gt; 0.0)&#123; gl_FragColor = vec4(0.0,0.0,1.0,1.0); &#125;else&#123; gl_FragColor = vec4(0.2,0.2,0.2,1.0); &#125; &#125;` 修改完之后，最终效果如下： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/06","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--图形的变换","date":"2017-07-06T13:09:11.000Z","path":"webgl-2017-07-06/","text":"图形的移动原理 图形的移动，实际上就是定量改变顶点的位置。 在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。 可以使用setTimeout定时执行画点的方法，来逐一改变点的位置实现图形的移动。 先编写顶点着色器，需要单独定义a，b来分别改变点的x方向和y方向，基本代码如下：1234567891011const vertexShaderSource = ` attribute vec4 pos; uniform float a; uniform float b; void main() &#123; gl_Position.x = pos.x + a; gl_Position.y = pos.y + b; gl_Position.z = .0; gl_PointSize = 10.0;&#125;` 片元着色器代码和之前写法基本一致，基本代码如下：1234const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,0.5,0.0,1.0); &#125;` 给顶点着色器中的变量定义响应的location，基本代码如下：123var posLocation = cxt.getAttribLocation(program, 'pos');var aLocation = cxt.getUniformLocation(program, 'a');var bLocation = cxt.getUniformLocation(program, 'b'); 使用setTimeOut函数定义简单的平移效果，基本代码如下：1234567891011121314run(); function run() &#123; cxt.uniform1f(aLocation, a); cxt.uniform1f(bLocation, b); cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.drawArrays(cxt.TRIANGLES, 0, 3); a += .05; b += .05; setTimeout(run, 500) &#125; 图形的缩放原理 基于原点，基于定义的某一个点进行缩小和放大(其实还做了平移操作) 在着色器中，逐顶点乘以缩放的倍数，对x轴和y轴同时进行缩放 编写顶点着色器,定义一个cj变量，通过x轴和y轴同时乘以cj这个变量，来实现逐顶点缩放，基本代码如下： 1234567891011 const vertexShaderSource = ` attribute vec4 pos; uniform float cj; void main() &#123; gl_Position.x = pos.x * cj; gl_Position.y = pos.y * cj; gl_Position.z = .0; gl_Position.w = 1.0; gl_PointSize = 10.0;&#125;` 定义cjLocation，代码如下：1var cjLocation = cxt.getUniformLocation(program, 'cj'); 定义基本渲染函数render，再单独定义放大缩小函数，基本代码如下：1234567891011121314151617var cj = 1.0; render(); function render() &#123; cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.uniform1f(cjLocation, cj); cxt.drawArrays(cxt.TRIANGLES, 0, 3); &#125; function fangda() &#123; cj += .05; render() &#125; function suoxiao() &#123; cj -= .05; render() &#125; 利用w快速缩放修改着色器代码，将vec4改成vec2，基本意思就是pos存在x和y两个点，基本修改后如下： 1234567 const vertexShaderSource = ` attribute vec2 pos; uniform float w; void main() &#123; gl_Position = vec4(pos,0.0,w);&#125;` 该方法实现效果刚好和vec4的时候相反，基本原因是vec4(x/w,y/w,z/w,w),所以w越大，其实x和y轴会越小，所以最终放大效果和之前是相反的。 图形的旋转原理 基于原点，以一定的角度旋转 在顶点着色器中，更改gl.Position.x和gl.Position.y的值 旋转方程 x = r.cos(a) y = r.sin(a) x1 = r.cos(a+b) y1 = r.sin(a+b) x1 = x.cos(b) - y.sin(b) y1 = x.sin(b) + y.cos(b) z1 = z = 0.0 顶点着色器代码基本写法如下： 1234567891011const vertexShaderSource = ` attribute vec4 pos; uniform float cosB; uniform float sinB; void main() &#123; gl_Position.x = pos.x * cosB - pos.y * sinB; gl_Position.y = pos.x * sinB + pos.y * cosB; gl_Position.z = .0; gl_Position.w = 1.0;&#125;` 实现简单动画基本如下： 12345678910111213141516var angle = 10.0; function render() &#123; var t = Math.PI * angle / 180; var cosB = Math.sin(t); var sinB = Math.cos(t); cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.uniform1f(cosBLocation, cosB); cxt.uniform1f(sinBLocation, sinB); cxt.drawArrays(cxt.TRIANGLES, 0, 3); &#125; setInterval(() =&gt; &#123; angle += 1.0; render(); &#125;, 1000) 矩阵变换实现图形的移动原理 图形的移动，实际上就是定量改变顶点的位置。 在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。 只要改变Tx,Ty,就能分别改变图形的x方向和y方向 在顶点着色器中定义一个xf举证变量，基本代码如下： 1234567const vertexShaderSource = ` attribute vec4 pos; uniform mat4 xf; void main() &#123; gl_Position = xf * pos;&#125;` 定义一个矩阵代码： 123456var xf = new Float32Array([ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, Tx, Ty, 0.0, 1.0 ]); 只需要通过改变Tx，Ty就能实现改变图形的移动，并不需要改变着色器代码，这样效率会很高，render函数基本如下：12345678910111213141516var Tx = 1.0, Ty = 0.0; function render() &#123; var xf = new Float32Array([ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, Tx, Ty, 0.0, 1.0 ]); cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.uniformMatrix4fv(xfLocation,false,xf); cxt.drawArrays(cxt.TRIANGLES, 0, 3); &#125; render() 矩阵变换实现图形的缩放原理 基于原点。 在着色器中，逐顶点乘以缩放倍数 Sx,Sy改变就会使得图形成比例的缩放 主要是矩阵函数不一样，其他基本一样，代码基本如下：123456789101112131415161718var sx = 1.0, sy = 1.0; function render() &#123; var xf = new Float32Array([ sx, 0.0, 0.0, 0.0, 0.0, sy, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ]); cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.uniformMatrix4fv(xfLocation, false, xf); cxt.drawArrays(cxt.TRIANGLES, 0, 3); &#125; render() 矩阵变换实现图形的旋转原理 基于原点，以一定的角度旋转。 在顶点着色器中，更改 gl_Position.x 和 gl_Position.y 值。 实现一个时钟指针的旋转，并且控制其速度和开关。 定义一个顶点着色器和片元着色器，基本代码如下：1234567891011121314// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; uniform mat4 xf; void main() &#123; gl_Position = xf * pos;&#125;` // 片元着色器程序 const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,.0,.0,1.0); &#125;` 最终render函数基本如下：123456789101112131415161718192021222324252627var time; function render() &#123; angle += zl; t = Math.PI * angle / 180; sinB = Math.sin(t); cosB = Math.cos(t); var xf = new Float32Array([ cosB, sinB, 0.0, 0.0, -sinB, cosB, 0.0, .0, 0.0, .0, 1.0, .0, 0.0, .0, .0, 1.0 ]); cxt.uniformMatrix4fv(xfLocation, false, xf); cxt.clearColor(.5, .5, .5, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.drawArrays(cxt.LINES, 0, 2); time = setTimeout(render, 500); if (!isOpen) &#123; clearTimeout(time); &#125; &#125; render() 最终效果如下图： WebGL动画原理原理 通过 setTimeout 定时渲染 每次渲染都用背景色刷屏 每次渲染都修改变换参数 变换矩阵A 变换矩阵B 原始顶点坐标矢量 ＝ 最终顶点坐标矢量 基本步骤 编写着色器代码 编写基础代码 编写平移和缩放代码 开发平移且缩放小动画 编写着色器代码，示例如下： 123456789101112131415// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; uniform mat4 xz; uniform mat4 py; void main() &#123; gl_Position = pos * xz * py;&#125;` // 片元着色器程序 const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,.0,.0,1.0); &#125;` 编写基础代码，上下文确定，buffer编写以及buffer数据加载等等，基本代码如下：1234567891011121314151617181920var cxt = document.getElementById('example08').getContext('webgl'); var buffer = cxt.createBuffer(); cxt.bindBuffer(cxt.ARRAY_BUFFER, buffer); var data = new Float32Array([ 0.0, 0.2, -.2, -.2, .2, -.2, ]); cxt.bufferData(cxt.ARRAY_BUFFER, data, cxt.STATIC_DRAW); var program = initShader(cxt, vertexShaderSource, fragmentShaderSource); var posLocation = cxt.getAttribLocation(program, 'pos'); var xzLocation = cxt.getUniformLocation(program, 'xz'); var pyLocation = cxt.getUniformLocation(program, 'py'); cxt.vertexAttribPointer(posLocation, 2, cxt.FLOAT, false, 0, 0); cxt.enableVertexAttribArray(posLocation); 定义平移矩阵和缩放矩阵代码：123456789101112131415var xz = new Float32Array([ cosB, sinB, 0.0, 0.0, -sinB, cosB, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ]); var py = new Float32Array([ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, tx, ty, 0.0, 1.0 ]); cxt.uniformMatrix4fv(xzLocation,false, xz); cxt.uniformMatrix4fv(pyLocation,false, py); 最终加入setTimeOut函数的run方法代码如下： 123456789101112131415161718192021222324252627282930313233343536function run() &#123; var t = Math.PI * ANGLE / 180; sinB = Math.sin(t); cosB = Math.cos(t); var xz = new Float32Array([ cosB, sinB, 0.0, 0.0, -sinB, cosB, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ]); tx += .005; ty += .005; ANGLE += 1; var py = new Float32Array([ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, tx, ty, 0.0, 1.0 ]); cxt.uniformMatrix4fv(xzLocation,false, xz); cxt.uniformMatrix4fv(pyLocation,false, py); cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.drawArrays(cxt.TRIANGLES, 0, 3); setTimeout(run, 500) &#125; run(); 矩阵复合变换 复合变换是多种变换同时进行，通过4 * 4 矩阵相乘得出来的结果，可以使用上面的示例，简化着色器中定义的矩阵变量。 开发一个矩阵运算方法，基本原理如下图： 完整方法代码如下：12345678910111213function mix(a, b) &#123; var result = new Float32Array(16); for (var i = 0; i &lt; 4; i++) &#123; result[i] = a[i] * b[0] + a[i + 4] * b[1] + a[i + 8] * b[2] + a[i + 12] * b[3]; result[i + 4] = a[i] * b[4] + a[i + 4] * b[5] + a[i + 8] * b[6] + a[i + 12] * b[7]; result[i + 8] = a[i] * b[8] + a[i + 4] * b[9] + a[i + 8] * b[10] + a[i + 12] * b[11]; result[i + 12] = a[i] * b[12] + a[i + 4] * b[13] + a[i + 8] * b[14] + a[i + 12] * b[15]; &#125; return result; &#125; 简化着色器代码，基本如下：12345678910111213const vertexShaderSource = ` attribute vec4 pos; uniform mat4 xf; void main() &#123; gl_Position = pos * xf;&#125;` // 片元着色器程序 const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,.0,.0,1.0); &#125;` 简化Location和矩阵数据导入的函数方法，剩余代码和前面的动画原理示例一样，片段代码如下：12var xfLocation = cxt.getUniformLocation(program, 'xf');cxt.uniformMatrix4fv(xfLocation, false, mix(xz,py)); 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/05","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--基本图形绘制","date":"2017-07-04T13:09:11.000Z","path":"webgl-2017-07-04/","text":"点的绘制单点绘制 gl.drawArrays( gl.POINTS, start , count ) gl.POINTS，标示绘制点的 start 起始位置 count 绘制数量，绘制点的个数不能超过在buffer中存在点的个数 多点绘制 采用 javascript 循环，实现多点绘制 采用 WebGL 缓冲区对象，实现多点绘制 上一节代码示例中分别采用了循环绘制点和使用缓冲区对象绘制点，详细请查看上一节内容。 线段绘制绘制单线段 gl.drawArray( gl.LINES , start , count ) gl.LINES，可以绘制一条线，也可以绘制多条线 绘制一条线 绘制多条线 最重要的画线代码如下： 1cxt.drawArrays(cxt.LINES,0,4); 绘制多线段 gl.drawArray( gl.LINE_STRIP , start , count ) gl.LINE_STRIP 绘制线段带 例如绘制一个矩形框需要定义五个点才能绘制出来，线段带是没有绘路的概念 绘制一个矩形重要的相关代码如下： 1234567891011//类型化数组定义五个点var data = new Float32Array([ -.5,.5, .5,.5 , .5, -.5, -.5, -.5, -.5,.5]);// 最终绘制也是绘制5个点cxt.drawArrays(cxt.LINE_STRIP,0,5); 绘制回路线段 gl.drawArray( gl.LINE_LOOP , start , count ) gl.LINE_LOOP 自动闭合线段，例如绘制矩形只需要4个点即可，默认会将最后一个点和第一个开始的点连接起来 绘制一个矩形重要的相关代码如下： 1234567891011//类型化数组定义4个点var data = new Float32Array([ -.5,.5, .5,.5 , .5, -.5, -.5, -.5, -.5,.5]);// 最终绘制也是绘制5个点cxt.drawArrays(cxt.LINE_LOOP,0,4); 使用gl.LINE_LOOP绘制一个领结形状的图形，其实只是利用了LINE_LOOP自动闭合线段绘制出来的，核心片段代码如下：12345678910//类型化数组定义4个点var data = new Float32Array([ -.5, .5, .5, .5, -.5, -.5, .5, -.5]);// 最终绘制也是绘制5个点cxt.drawArrays(cxt.LINE_LOOP,0,4); 运行效果图如下： 多边形绘制绘制三角形 gl.drawArray( gl.TRIANGLES , start , count ) gl. TRIANGLES 核心代码片段如下：1234567var data = new Float32Array([ 0,0, -.5,-.5 , .5, -.5]);cxt.drawArrays(cxt.TRIANGLES,0,3); 运行效果图如下： 绘制三角带 gl.drawArray( gl.TRIANGLE_STRIP , start , count ) gl.TRIANGLE_STRIP 绘制一个平行四边形的核心代码如下：12345678var data = new Float32Array([ -.3,.3, .5,.3, -.5, -.3, .3, -.3 ]);cxt.drawArrays(cxt.TRIANGLE_STRIP,0,4); 运行效果图如下： 绘制三角扇 gl.drawArray( gl.TRIANGLE_FAN , start , count ) gl.TRIANGLE_FAN 绘制一个六边形的核心代码如下：123456789101112var data = new Float32Array([ .0,0, -.3,.5, -.6,.3, -.3, -.3, .3, -.3, .6, .3, .4,.5, -.3,.5 ]);cxt.drawArrays(cxt.TRIANGLE_FAN,0,8); 运行效果图如下： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/04","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--缓冲区对象","date":"2017-07-03T13:09:11.000Z","path":"webgl-2017-07-03/","text":"attribute 变量的使用主要职能是在顶点着色器当中使用的，只能被申明为全局变量，用来表示顶点的信息，比如一个图形中包含多个顶点，顶点着色器是针对逐顶点进行运算的，都会传导到attribute变量中，然而，两个顶点之间的部分是不会被传导到顶点着色器中的。 这个变量只能支持矢量和矩阵两种类型，attribute变量的个数限制和设备有关系，最小支持8个attribute变量。 在顶点着色器中，声明 attribute 变量 将 attribute 变量赋值给 gl_Position 变量 向 attribute 变量传递数据 首先创建顶点着色器的基本代码： 1234567// 顶点着色器程序const vertexShaderSource = `attribute vec4 apos; void main() &#123; gl_Position = apos; gl_PointSize = 10.0;&#125;` 书写基本的片元着色器的代码：12345// 片元着色器程序const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,0.5,0.0,1.0); &#125;` 获取webgl上下文代码：1var cxt = canvas.getContext('webgl'); 获得顶点着色器和片元着色器对象,并且把源代码写入到顶点着色器及片元着色器中去，然后进行编译，片段代码如下：123456var vertexShader = cxt.createShader(cxt.VERTEX_SHADER);var fragmentShader = cxt.createShader(cxt.FRAGMENT_SHADER);cxt.shaderSource(vertexShader,vertexShaderSource);cxt.shaderSource(fragmentShader,fragmentShaderSource);cxt.compileShader(vertexShader);cxt.compileShader(fragmentShader); 创建program，并且将顶点着色器和片元着色器附着在program上，代码如下12345var program = cxt.createProgram();cxt.attachShader(program,vertexShader);cxt.attachShader(program,fragmentShader);cxt.linkProgram(program);cxt.useProgram(program); 得到顶点着色器中的变量apos，片段代码如下：1var aposLocation = cxt.getAttribLocation(program,'apos'); 清屏处理，代码如下：12cxt.clearColor(0.2,0.2,0.2,1.0);cxt.clear(cxt.COLOR_BUFFER_BIT); 通过for循环来绘制多个点，代码如下：1234for(var i= 0,num = points.length;i&lt;num;i++)&#123; cxt.vertexAttrib4f(aposLocation,points[i].x,points[i].y,1.0,1.0); cxt.drawArrays(cxt.POINTS,0,1);&#125; 缓冲区对象的创建、绑定、写入数据缓冲区对象是什么 绘制面所必需的技术 一次性写入多个顶点数据 一块内存区域 创建缓冲区对象 创建缓冲区的方法 var buffer = gl.createBuffer() 根据返回值判断是否创建成功 绑定缓冲区方法 gl.bindBuffer(gl.ARRAY_BUFFER , buffer) 写入数据 gl.bufferData(gl.ARRAY_BUFFER , data , gl.STATIC_DRAW) data 是类型化数组 gl.STATIC_DRAW，一次写入多次绘制 gl.STREAM_DRAW，一次写入多次绘制，比第一次调用的少 gl.DYNAMIC_DRAW，多次写入多次绘制 类型化数组接口都是通过类型化数组来进行通信 Int8Array Uint8Array Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array 缓冲区数据导入 attribute 变量 vertexAttribPointer(location , size , type , normalized , stride , offset ) 错误信息 INVALID_OPERATION，表示没有可用的program对象 错误信息 INVALID_VALUE，表示attribute的最大值已经超出的范围 enableVertexAttribArray(location)，激活localtion 错误信息 INVALID_OPERATION，表示没有可用的program对象 代码分析创建类型化数组对象1234567var data = new Float32Array([ -1.0,1.0, 1.0,1.0, -1.0,-1.0, 1.0,-1.0, 0.0,0.0]); 创建buffer和绑定baffer片段代码如下：12var buf = cxt.createBuffer();cxt.bindBuffer(cxt.ARRAY_BUFFER,buf); 将类型化数组绑定到缓冲区中：1cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW); 将缓冲区数据导入attribute变量中：12cxt.vertexAttribPointer(aposLocation,2,cxt.FLOAT,false,0,0);cxt.enableVertexAttribArray(aposLocation); 开始绘制，代码如下：123cxt.clearColor(0.0,0.5,0.5,1.0);cxt.clear(cxt.COLOR_BUFFER_BIT);cxt.drawArrays(cxt.POINTS,0,5); 完整代码如下：1234567891011121314151617181920212223242526272829303132333435&lt;canvas id=\"e03\" width=\"500\" height=\"500\"&gt;&lt;/canvas&gt;&lt;script src=\"../lib.js\"&gt;&lt;/script&gt;&lt;script&gt; var canvas = document.getElementById('e03'); var cxt = canvas.getContext('webgl'); // 顶点着色器程序 const vertexShaderSource = `attribute vec4 apos; void main() &#123; gl_Position = apos; gl_PointSize = 10.0; &#125;` // 片元着色器程序 const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,0.5,0.0,1.0); &#125;` var program = initShader(cxt,vertexShaderSource,fragmentShaderSource); var aposLocation = cxt.getAttribLocation(program,'apos'); var buffer = cxt.createBuffer(); cxt.bindBuffer(cxt.ARRAY_BUFFER,buffer); var data = new Float32Array([ -1.0,1.0, 1.0,1.0, -1.0,-1.0, 1.0,-1.0, 0.0,0.0 ]); cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW); cxt.vertexAttribPointer(aposLocation,2,cxt.FLOAT,false,0,0); cxt.enableVertexAttribArray(aposLocation); cxt.clearColor(0.0,0.5,0.5,1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.drawArrays(cxt.POINTS,0,5);&lt;/script&gt; 运行效果图如下： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/03","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--基本概述","date":"2017-07-02T13:09:11.000Z","path":"webgl-2017-07-02/","text":"WebGL是什么在浏览器绘制3D图形的的一门技术，是内嵌在浏览器中，目前支持高版本浏览器，因此不需要安装任何插件，同样也支持多平台运行，它是基于OpenGL ES 2.0技术。 优势 快速传播 维护简单 跨平台性 开放的标准 硬件加速 无需安装插件 充分利用浏览器功能 图形API模式即时模式，每一帧的场景不管是否发生了变化，都需要重新绘制，提供API的图形库并没有保存需要绘图场景的内部模型，但是应用程序需要在内存中用自己的方式表示场景，这种设计模式大大提高了应用程序的灵活性和控制的能力，但是需要应用程序执行更多的操作，如跟踪场景的模型，应用初始化等等，包括清除操作。webGL采用的是即时模式，非常灵活，但是相对而言手工代码会多一点。 保留模式，它的API保留了所有图形库的模型和场景，但应用程序调用保留模式API时需要更新内部的模型，图形库决定在什么时候执行实际的绘制方法，这意味着不需要为每一帧场景重新绘制命令，因此保留模式API似乎更容易使用。 图像硬件介绍 WebGL程序执行原理图形流水线 通过顶点来确定图形，具备形状之后内部时空的，通过光栅化进行“面积”的填充，然后进入片元着色器，进入“绘图”过程，类似上色过程，再次进逐片元操作 定点着色器 顶点着色器源代码，javascript字符串形式表示出来 内置变量，名字不可辨，区分大小写 自定义 Attribute 变量，表示每一个点的数据，可以定义多个 自定义 Uniform 变量，表示一个常量，是个恒定的，所有点的数据都是一样的 自定义 Varying 变量，定点着色器和片着色器传导数据用的 片元着色器 片元着色器源代码，javascript字符串形式表示出来 内置变量，名字不可辨，区分大小写 Uniform 和 Samplers，Samplers用来储存纹理 自定义 Varying 变量，定点着色器和片着色器传导数据用的 WebGL和HTML5及Javascript的关系 需要 HTML5 Canvas 元素，webgl和canvas画图都需要canvas这个api 用 Javascript 处理逻辑 可利用支持 HTML5 浏览器的一切功能 用 Javascript 字符串形式编写着色器源代码 基本示例代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body onload=\"main()\"&gt; &lt;canvas id=\"webgl\" width=\"500\" height=\"400\"&gt;&lt;/canvas&gt; &lt;script src=\"../lib/webgl-utils.js\"&gt;&lt;/script&gt; &lt;script src=\"../lib/webgl-debug.js\"&gt;&lt;/script&gt; &lt;script src=\"../lib/cuon-utils.js\"&gt;&lt;/script&gt; &lt;script&gt; // 顶点着色器程序 const VSHADER_SOURCE = `void main() &#123; gl_Position = vec4(1.0,0.0,0.0,1.0); gl_PointSize = 30.0; &#125;` // 片元着色器程序 const FSHADER_SOURCE = `void main() &#123; gl_FragColor = vec4(1.0,1.0,0.0,1.0); &#125;` function main() &#123; // 获取canvan元素 var canvas = document.getElementById(\"webgl\"); // 获取webgl绘图上下文 var gl = getWebGLContext(canvas, true); if (!gl) &#123; console.log('error'); return; &#125; // 初始化着色器 if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) &#123; console.log('error'); return; &#125; // 制定清空canvas的颜色 gl.clearColor(0.0, 0.0, 0.0, 1.0); // 清空canvas gl.clear(gl.COLOR_BUFFER_BIT); // 绘制一个点 gl.drawArrays(gl.POINTS, 0, 1); &#125; &lt;/script&gt;&lt;/body&gt; 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/02","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--3D图形学入门","date":"2017-07-01T13:09:11.000Z","path":"webgl-2017-07-01/","text":"3D的基本元素2D坐标系由x轴和y轴构成。其中，笛卡尔坐标系是最常见的2D坐标系。原点为（0.0），每个系统的坐标系不一样，有的系统y轴是正方向，有的是y轴的负方向为正方向。 HTML5 canvas2D坐标系,canvas坐标原点在左上角，从x为右是正方向，向下为y轴的正方向 示例代码片段：1234567891011121314151617&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;canvas id=\"canvas\"&gt;&lt;/canvas&gt;&lt;script&gt; var cxt = canvas.getContext('2d'); // 设置正方体左上角坐标（x，y） var x = 50; var y = 50; // 绘制正方形 cxt.fillRect(x,y,50,50);&lt;/script&gt; 效果如下： 修改x和y轴后展示效果如下：123// 设置正方体左上角坐标（x，y）var x = 0;var y = 0; 3D坐标系增加了表示深度的z轴，即3D物体离屏幕的深度。 WebGL坐标系的方向，向上为y轴的正方向，向右为x轴的正方向，从原点向外为z轴的正方向。绘图的可视范围是+1到-1之间 基本示例代码如下：12345 const VSHADER_SOURCE = `void main() &#123; gl_Position = vec4(1.0,0.0,0.0,1.0); gl_PointSize = 30.0;&#125;` webgl规定1.0为可视区域的最外层，不是像素值的意义。 三角形是基础图形，所有的图形都能根据三角形进行拼凑而成，也就是3D图形是由一个或者多个三角形组成；网格是由一个或者多个图形组成。 法线:始终垂直于某平面的虚线，在几何中，法线是指平面上垂直于曲线在某点切线的直线。法线和切线的交点称作切点，法线在3D绘图当中尤其在切图当中起到很大作用，通常的切图会失真，用法线切图方式算法的切图效果相对比较逼真。 3D的变换概念变换：变换的原理是对顶点的改变，变换的方式有三种，分别是缩放、平移、旋转。 旋转规定Z轴不变，定义初始旋转角度变量，示例代码我们先用着色器来计算顶点坐标位置，性能会比较低，在实际开发中，会定义矩阵来计算复杂的位置，示例代码片段如下：12345678910111213141516171819// 定义旋转角度var ANGLE = 30.0;const VSHADER_SOURCE = ` attribute vec4 a_Position; uniform float u_CosB,u_SinB; attribute float a_PointSize; void main() &#123; gl_Position.x = a_Position.x * u_CosB - a_Position.y * u_SinB; gl_Position.y = a_Position.x * u_SinB - a_Position.y * u_CosB; gl_Position.z = a_Position.z; gl_Position.w = 1.0; &#125;`// 片元着色器程序const FSHADER_SOURCE = ` precision mediump float; uniform vec4 u_FragColor; void main() &#123; gl_FragColor = vec4(1.0,1.0,0.0,1.0); &#125;` 矩阵：解决的复杂是针对着色器的，在实际开发中，应保证着色器的简单，因为着色器越复杂性能就越低。在webgl中矩阵可以理解为是一种数据类型，专门处理复杂的计算，可以进行乘法和加法的运算。代码片段如下：1234567891011121314// 定义矩阵的方式来处理变换效果// 定义旋转角度var ANGLE = 30.0;const VSHADER_SOURCE = ` attribute vec4 a_Position; uniform mat4 u_xformMatrix; //定义矩阵来变化 void main() &#123; gl_Position = u_xformMatrix * a_Position; &#125;`// 片元着色器程序const FSHADER_SOURCE = ` void main() &#123; gl_FragColor = vec4(1.0,1.0,0.0,1.0); &#125;` 网格表面纹理与材质：纹理可以定义网格表面的外观，例如在模型上贴一张图片；材质是网格表面的特性，也就是光滑度、透明度等等。光照原理：光线方向决定物体的明暗度与阴影,在着色过程中，需要考虑光源类型与反射类型。光照类型：平行光（从一个方向平行的打在一个物体上，有方向感的）、点光源光（由中心光源散发出来的光线，越往四周光线越弱）、环境光（在任何一个地方，光线的强弱都是一样的） 反射类型：漫反射光色由入射光色、表面漆色和入射角决定，环境反射由入射光色和表面漆色决定。 着色器代替传统的固定渲染管线，固定的渲染管线是不可变的；着色器具有可编程性的；着色器分为，顶点着色器和片元着色器。 顶点着色器：顶点着色器用来描述顶点的位置、颜色的程序，写法类似c语言，会定义一个主函数main，同时有系统变量，这个变量是不可以变的，变量对应的值是强类型，片段代码如下： 1234void main() &#123; gl_Position = vec4(0.0,0.0,0.0,1.0); gl_PointSize = 20.0;&#125; 片元着色器：对网格表面像素的处理程序，例如网格表面的贴图就需要用到片元着色器，系统变量对应的值是不能超过1.0的，片段代码如下： 123void main()&#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0);&#125; 3D世界相机、视口、投影：相机角度的不同，观察物力的景象就是不同的，远近决定观察看到物体的大小不同，图片中绿色的区域表示视口，也就是canvas决定的，它的大小决定了可视化的范围，红色部分表示场景显示最远能够到哪里，两者之间的可视化锥体，就代表可视化的范围，最终的影像会在视口中呈现出来，大小是由相机决定的。投影的概念就是物体投影在前方视口最终形成的影像。 这一节简要的介绍了以上几个概念的基本知识，下一节将介绍WebGL的基本概念。后期所有的例子都会提供源码供大家下载。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"React深入浅出系列--如何设计高质量的React组件","date":"2017-06-12T13:09:11.000Z","path":"2017-06-12/","text":"组件的设计要素在项目开发初期，针对模块或者组件的分配是及其重要，基本会按照“分而治之”的思想去合理的设计组件的功能以及扩展它们的复用性等等。拆分组件最关键的就是确定组件功能的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的职责，那这两个组件本身就不该被拆分，作为同一个组件或许更加合理。 组件的划分需要满足两个基本原则：高内聚和低耦合 高内聚:把逻辑紧密相关的内容放在一个组件中。早期开发html、css、js基本会以三个不同的文件存放，这样其实是违背高聚合的原则，react正好提供将跟组件相关的css、js、html放在一起的语法结构，这样一来，组件的复用性能够达到极致。 低耦合:不同的组件之间的依赖关系要尽量弱化。也就是每个组件要尽量独立。保持整个系统的低耦合度，让不同的组件去实现不同的功能，复杂的功能是通过细分的组件组装起来完成的，这样设计的话，方便开发者写出低耦合的系统。 react组件的数据react组件的数据主要分两种：prop和state。无论prop、state的改变都可能引发组件的渲染，其实react有基本的规范，prop主要作为组件对外部的接口，负责接受其他组件传过来的数据参数等，state主要是组件内部定义的数据状态，仅仅属于当前组件内部使用，片段代码如下： 123456789101112131415161718192021222324252627282930// 定义一个子组件class Counter extends Component &#123; constructor(props) &#123; // 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props super(props); //使用state定义自己内部状态数据 this.state = &#123; text: 1 &#125; &#125; render() &#123; const &#123;caption&#125; = this.props; //通过this.props来获取父亲组件传进来的caption值 return ( &lt;div className=\"App\"&gt; &#123;this.state.text&#125; &lt;/div&gt; ); &#125;&#125;// 定义一个父组件class ControlPanel extends Component &#123; render() &#123; console.log('enter ControlPanel render'); return ( &lt;div style=&#123;style&#125;&gt; &lt;Counter caption=\"First\"/&gt; &lt;/div&gt; ); &#125;&#125;; React中的prop给prop赋值和读取prop的值，以下只是代码片段，主要为了解释那些是赋值那些是读取值1234567891011121314//在构造函数中读取父组件传过来的值constructor(props) &#123; // 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props super(props); //使用state定义自己内部状态数据 this.state = &#123; text: 1 &#125; &#125;//在render函数中返回一个组件，并且带上要给该组件传递的数据 return ( &lt;Counter caption=\"First\"/&gt;); 如果一个组件需要定义自己的构造函数，一定要在构造函数的第一行通过super调用父级也就是React.Component的构造函数，只有这样才能通过this.props来获取父级传下来的数据。因此常常会在构造函数中绑定this的指向，避免在render中多次绑定而造成性能问题。 propTypes的检查通过propTypes属性来定义prop规格，在组件渲染运行和静态代码检查时，都可以根据propTypes判断外部传递数据的格式是否正确，基本代码片段如下：1234Counter.propTypes = &#123; caption:PropTypes.string.isRequired, initValue:PropTypes.number&#125;其中要求caption必须是string类型，initValue必须是number类型，isRequired代表该caption必须传递，不能缺失，而initValue可以不传。 所以在具体项目开发中，最好的方式是，在开发模式下带上propTypes，而在上线的时候可以去掉这些代码，可以用babel-react-optimize工具自动去除propTypes，这样部署到产品环境的代码就会更优。 React中的statestate代表组件内部状态，常常用来定义组件内部初始值。组件内部的state必须是一个对象，不能是string或者number这样简单的数据类型。基本使用如下：123456constructor(props) &#123; this.state = &#123; text: 1, // 使用state定义自己内部状态数据 num:props.num || 1 // 接受父组件传来的参数 &#125; &#125;在当前组件对象内部通过this.state来访问内部定义的变量，如果要改变状态千万不要直接通过this.state赋值改变，使用react提供的setState这个方法来改变状态，这样改变能够直接触发组件重新render使得界面绑定的相应的状态更新。 prop和state的对比 prop用于定义外部接口，state用于定义内部状态； prop的赋值在外部世界使用组件时，state的赋值在组件内部； 组件不应该改变prop的值，而state存在的目的就是让组件来改变的； 一个子组件去修改props中的值，就是违背react的设计初衷，如果必须修改，建议使用组件内部状态先保存props，然后通过改变组件内部状态变相改变了props。 使用prop建立组件间的通信应用示例如下： 使用prop建立组件间的通信原理就是在子组件内部定义改变内部状态的方法并且触发父组件改变父组件的方法，并且在自组件自定一个空函数作为父子组件通信的桥接。 具体实现代码如下，我们现在Counter子组件中定义需要改变状态的方法，除了触发改变内部状态的updateCount方法，同时也会触发父组件的this.props.onUpdate方法：123456789101112131415onClickIncrementButton() &#123; this.updateCount(true);&#125;onClickDecrementButton() &#123; this.updateCount(false);&#125;updateCount(isIncrement) &#123; const previousValue = this.state.count; const newValue = isIncrement ? previousValue + 1 : previousValue - 1; this.setState(&#123;count: newValue&#125;) this.props.onUpdate(newValue, previousValue)&#125; 接下来我们定义一个默认的空函数，来桥接父子组件通信，代码片段如下：12345678910Counter.propTypes = &#123; caption: PropTypes.string.isRequired, initValue: PropTypes.number, onUpdate: PropTypes.func&#125;;Counter.defaultProps = &#123; initValue: 0, onUpdate: f =&gt; f //什么都不做的函数&#125;; 并且在父组件中建立相应的更新方法，并且在render将onCounterUpdate方法以onUpdate名字传递给子组件中，自组件定义onUpdate来接受父组件传递下来的方法，从而解决了父子组件的通信，代码片段如下：123456789101112131415onCounterUpdate(newValue, previousValue) &#123; const valueChange = newValue - previousValue; this.setState(&#123; sum: this.state.sum + valueChange&#125;);&#125;render() &#123; return ( &lt;div style=&#123;style&#125;&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"First\" /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Second\" initValue=&#123;this.initValues[1]&#125; /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Third\" initValue=&#123;this.initValues[2]&#125; /&gt; &lt;hr/&gt; &lt;div&gt;Total Count: &#123;this.state.sum&#125;&lt;/div&gt; &lt;/div&gt; );&#125; 使用prop传递参数的局限从上面的示例不难看出，子组件和父组件都各自维护一套属于自己的状态，并且通过update来相互通信，如果update内部内部逻辑出现bug，这个时候，计数器的结果到底是子组件的对还是父组件的对呢，这个时候就需要共享状态的概念出现，通过一个全局状态来同步各个子组件内部的状态，开发者也只要关注共享全局状态走向就行。 组件状态不统一：全局状态同步状态： 如果一个系统中，存在多层嵌套组件，如果按照prop规则传递参数，岂不是非常麻烦，所以必须引入全局状态Redux，将在下节中为大家介绍基本的Redux思想及原理。 react生命周期介绍生命周期基本分成三个主要阶段： 装载过程，组件第一次渲染过程 更新过程，当组件重新渲染过程 卸载过程，组件从DOM中删除过程 装载过程依次调用一下生命周期函数方法(按照es6最新语法介绍)： constructor defaultProps componentWillMount render componentDidMount constructor这是es6中构造函数的写法，如果是无状态的React组件无需定义构造函数，因此定义构造函数基本的作用是： 初始化state，在组件定义个函数中需要访问state状态。 绑定函数的this上下文。 代码片段如下：12345constructor(props) &#123; super(props); this.onClickIncrementButton = this.onClickIncrementButton.bind(this); this.onClickDecrementButton = this.onClickDecrementButton.bind(this); &#125; defaultProps主要作用是给props定义初始值，基本写法如下：1234Counter.defaultProps = &#123; initValue: 0, onUpdate: f =&gt; f //什么都不做的函数&#125;; render主要作用返回一个JSX描述的结构，最终再交付给React来操作渲染，组件在有些情况下如果不需要返回JSX结构，可以通过返回null或者false来告诉React不渲染任何DOM元素。 注意：在render中不要操作对状态的改变，应该在自定义函数中改变 componentWillMount和componentDidMountcomponentWillMount在render函数之前调用，也就是DOM还没有挂载，这个时候如果调用this.setState修改状态也不会发生重新渲染，其实我们可以在创建构造函数中就做好在componentWillMount应该做的事情。此函数既可以在服务端被调用，也可以在浏览器端被调用。 componentDidMount在render之后调用，也就是挂载DOM的操作，如果一个父组件嵌套多个子组件，这个时候挂载DOM的顺序是等到子组件全部调用render函数之后再开始挂载相应子组件的DOM。该函数只能在浏览器端被调用。如果需要对DOM操作的话，建议可以在componentDidMount中定义函数进行操作。DOM挂载顺序结果如下： 更新过程 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate componentWillReceiveProps这个函数是根据新的props的值来计算出是不是要更新组件内部state状态。同同时，只要父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发componentWillReceiveProps函数运行。 在Counter组件中增加函数：123componentWillReceiveProps(nextProps) &#123; console.log('enter componentWillReceiveProps ' + this.props.caption) &#125; 在ControlPanel函数中定义强制更新函数：1234567891011121314render() &#123; console.log('enter ControlPanel render'); return ( &lt;div style=&#123;style&#125;&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"First\" /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Second\" initValue=&#123;this.initValues[1]&#125; /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Third\" initValue=&#123;this.initValues[2]&#125; /&gt; &lt;button onClick=&#123; () =&gt; this.forceUpdate() &#125;&gt; Click me to re-render! &lt;/button&gt; &lt;hr/&gt; &lt;div&gt;Total Count: &#123;this.state.sum&#125;&lt;/div&gt; &lt;/div&gt; );ControlPanel组件中触发了render函数，子组件中的componentWillReceiveProps都被触发了，但是并没有改变props的值，运行结果截图如下： 这个函数会接受nextProps参数，一般会用nextProps（这一次渲染传入的值）与this.props（上一次渲染传入的值）进行比较，只有两者有变化的时候才会调用this.setState更新内部状态。 shouldComponentUpdate主要作用根据nextProps, nextState接收的两个参数来判断组件是否需要执行render函数，react中这个函数如果不做任何设置，默认都是返回true，所以再做性能优化的时候，这个函数起到了至关重要的作用。在Counter组件中增加函数：1234shouldComponentUpdate(nextProps, nextState) &#123; return (nextProps.caption !== this.props.caption) || (nextState.count !== this.state.count); &#125;改变任何一个值，只会触发当前这个组件调用render函数，运行结构如下： componentWillUpdate和componentDidUpdate只要shouldComponentUpdate函数返回为true，就会以此调用componentWillUpdate、render、componentDidUpdate这三个函数，同样这两个函数即可以在服务端调用也可以在浏览器端调用。 卸载过程这个过程主要是卸载不使用的组件DOM元素，或者使用非React方式创建的DOM元素，还是非常有作用的，例如，如果在componentDidMount中可以使用了js原生创建了DOM元素，但是在组件卸载过程中没有清楚，这个时候会造成内存泄露，所以在使用卸载组件的函数，必须确定相关的DOM都清除。 本篇简要的React组件的通信和基本的生命周期运行流程，在使用prop通信会有一定的局限，下节会引入Redux共享状态概念，来解决prop传递的局限，本篇涉及到的源码可以访问https://github.com/wqzwh/react-redux-demo/tree/master/src/demo/01","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"}]},{"title":"React深入浅出系列--React的工作方式","date":"2017-06-11T13:09:11.000Z","path":"2017-06-11/","text":"jQuery如何工作在讲解React的工作方式之前，先了解下jQuery的工作方式，我们使用jQuery给网页添加一个onclick事件基本写发如下：12345678910&lt;div&gt; &lt;button type=\"btn\" id=\"btn\"&gt;点击我&lt;/button&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $(\"#btn\").click(fucntion()&#123; // do some things &#125;) &#125;)&lt;/script&gt;在jQuery的解决方案中，首先根据css规则找到id为btn的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。 但是对于庞大的项目，这种模式会造成代码结构复杂，难易维护，每个jQuery的使用者都会有这种体会。 React的理念react给dom添加事件并不是通过选择器选中某个dom，然后添加相应的事件，使用react开发，开发者不需要关心dom的组成结构，只需关注数据从哪里来，该去哪个组件中显示，也就是关心整个数据流的走向，通过render函数将相应的数据显示在界面上，如果需要更新界面，只需要找到相应的数据data更新即可，用户界面自然会做出响应，所以说react也是响应式编程。 Virtual DOM对于改变普通的html中的DOM会造成页面的重排和重绘，这也是前端性能优化主要的方面，就是尽量减少对DOM的操作。其实虚拟DOM说的简单点就是js动态生成的html标签在js内存中存储，并没有实际插入到页面当中。例如使用createElement（’Button’）和DocumentFragment创建虚拟的标签。简单的虚拟DOM代码示例如下，主要是方面从简单的层面理解虚拟DOM： 1234567var frag=document.createDocumentFragment();for(var i=0;i&lt;10;i++)&#123; var l=document.createElement(\"li\"); l.innerHTML=\"ss\"; frag.appendChild(l);&#125;document.getElementById(\"list\").appendChild(frag); 当然React中的虚拟DOM并没有像以上的例子这么简单，但是核心思想是这样的，相比直接操作DOM而言，通过操作js生成的DOM数结构改变映射到页面上的内容能提高不少性能。虚拟DOM就是对DOM树的抽象，仅仅是存在与javascript空间的树形结构，例如最简单的形式如下：1234567891011var a = &#123; type: 'a', props: &#123; children: 'React', className: 'link', href: 'facebook/react · GitHub' &#125;, _isReactElement: true&#125;React.render(a, document.body) 虚拟DOM中有个核心算法就是diff算法，主要实现以下三个步骤： 步骤一：用JS对象模拟DOM树 步骤二：比较两棵虚拟DOM树的差异 步骤三：把差异应用到真正的DOM树上react会根据diff算法计算出需要更新改变虚拟DOM，从而只更新页面中映射的那一小块DOM。对于diff算法以及react性能优化后期会单独用一节分析。 React工作方式的优点传统化的jquery的方式直观易懂，但是随着项目变得庞大时，用jquery写出的代码往往相互纠缠，难以维护。 使用react的方式，可以避免构建这样复杂的程序结构，无论何种事件，引发的都是react组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发这不需要关心。react利用函数式编程的思想来解决用户界面渲染问题，最大的优势能够提高开发效率，代码可维护性和可阅读性增强。 react会强制所有组件都按照这种由数据驱动渲染的模式来工作，无论应用多大，都让程序处于可控范围内。下一篇将为大家介绍如何设计高质量的React组件。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"}]},{"title":"React深入浅出系列--如何理解JSX","date":"2017-06-10T13:09:11.000Z","path":"2017-06-10/","text":"1、JSX介绍所谓JSX,是javascript的语法扩展，并不是一门新的编程语言，看起来有点像XML，让我们在javascript中可以编写像HTML一样的代码。例如以下示例代码：123456789101112class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;div className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;h2&gt;Welcome to React&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;JSX中的这几段代码看起来和HTML几乎一模一样，可以使用div,button之类的标签，但是，JSX和HTML之间还是有不同之处。 注意：React判断一个元素HTNML元素还是React组件的原则就是看第一个字母是否大写，小写的话，React会认为是HTML标签 12345678class App extends Component &#123; render() &#123; return ( &lt;hello/&gt; //默认认为是html标签，错误写法 &lt;Hello/&gt; //默认是自定义Hello组件 ); &#125;&#125; 2、事件绑定在早期时候绑定事件写法如下：1&lt;button onclick=\"checkAndSubmit(this.form)\"&gt;Submit&lt;/button&gt;随着业务不断复杂，虽然这种写法便于阅读，但是复杂的业务加上复杂的DOM结构，为了html和js解耦，所以绑定事件写法有如下变化，通过获取DOM节点，通过代理机制来绑定事件：1$('#my-button').on('click', this.checkAndSubmit.bind(this));然而react中的JSX绑定事件的写法格式如下：1&lt;button onClick=&#123;this.checkAndSubmit.bind(this)&#125;&gt;Submit&lt;/button&gt; 大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。注意：在真正开发中，并不提倡给在组件添加事件中bind（this）这种写法，一般会在constructor的时候就绑定上下文this，这样在组件里面就不会因为多次绑定this而造成内存泄露。 3、JSX绑定事件和html绑定事件的区别 在html添加事件有如下问题： 1、在html中使用onclick添加的事件处理函数是在全局环境下执行的，这样会污染全局环境，很容易产生意料不到的后果。 2、给多个DOM添加onclick事件，可能会影响网页性能，毕竟，网页需要的事件处理函数越多，性能就会越低。 3、对于使用onclick的DOM元素，如果要动态地从DOM树中删掉的话，需要把对应的时间处理器注销，假如忘了注销，就可能造成内存泄露，这样的bug很难被发现。 以上说的这些问题在JSX中都不存在，其有如下特点： 1、JSX中添加onclick事件并没有直接在相应的html中添加事件，而是使用了事件委托的方式处理点击事件，无论有多少个onclick的出现，其实最后都只在DOM树上添加一个事件处理函数，并挂载在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定的函数，使用事件委托的性能比为每一个onclick都挂载一个事件函数要高。 2、jsx中同样可以添加自定义样式，外层定义一个样式对象，然后在jsx中将对象赋值给相应的dom上，这样真正意义上组件封装的思想（html，css，js在一起），提高复用性，大致写法如下：123456789101112class App extends Component &#123; render() &#123; const Style = &#123; margin:'10px' &#125; return ( &lt;div style=&#123;Style&#125;&gt; &lt;p&gt;测试文字&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 4、JSX编译JSX是一种新的语法，浏览器并不能直接运行，因此需要这种翻译器。这里我们推荐使用Babel编译JSX，打包编译建议使用Webpack，大致配置如下：12345module: &#123; loaders: [ &#123; test: /\\.jsx?$/, loaders: ['babel-loader']&#125; ]&#125; 本文主要介绍JSX优势所在，在添加事件上性能高于普通的html添加事件形式，组件方式的开发模式，更利于代码的通用性和维护性，下一篇将为大家介绍React的理念／Virtual DOM／工作方式的优点。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"}]},{"title":"如何使用vue-ssr做服务端渲染初体验(三)","date":"2017-06-05T12:09:11.000Z","path":"vue-ssr3/","text":"1、前言上一节大致介绍了服务端和客户端入口文件代码内容，现在已经可以正常运行你的后端渲染脚手架了，这一节，跟大家分享下如何使用axios做ajax请求，如何使用mockjs做本地假数据，跑通本地基本逻辑，为以后前后端连调做准备。 2、前期准备需要用npm安装axios，mockjs依赖包,由于mockjs只是代码开发的辅助工具，所以安装的时候我会加–save-dev来区分，具体可以根据自己的需求来定，当然，如果有mock服务平台的话，可以直接走mock平台造假数据，本地直接访问mock平台的接口，例如可以使用阿里的Rap平台管理工具生成。 12npm install axios --savenpm install mockjs --save-dev 3、简要介绍axios 其他请求方式，代码示例如下： 1234567axios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]]) 具体详细可以点击查看axios基本使用介绍 api.js完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990function ajax(url, type, options) &#123; return Q.Promise((resolve, reject) =&gt; &#123; axios(&#123; method : type, url : url, // responseType:'stream', data : options &#125;) .then((result) =&gt; &#123; if (result &amp;&amp; result.status === 401) &#123; location.href = '/views/401.html' &#125; if (result &amp;&amp; result.status === 200) &#123; resolve(result.data); &#125; else &#123; reject(&#123; errno: result.errno, msg: result.msg &#125;); &#125; &#125;) .catch(function(error) &#123; console.log(error,url); &#125;); &#125;)&#125;const config = &#123; get(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'get', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, post(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'post', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, put(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'put', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, delete(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'delete', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, jsonp(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'jsonp', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;&#125;;export default config; mockjs项目基本配置如下： 1、在public下新建conf.js全局定义请求url地址，代码如下：1234module.exports = &#123; HOST: \"http://www.xxx.com\", DEBUGMOCK: true&#125;; 2、在component根目录下新建conf.js，定义组件mock的请求路径，并且定义是否开始单个组件使用mock数据还是线上接口数据，代码如下：12345678910111213141516const PUBCONF = require('../public/conf.js');export const DEMO = &#123; DEBUGMOCK : PUBCONF.DEBUGMOCK, INDEX_URL : PUBCONF.HOST + '/demo', INDEX_URL_MOCK : true &amp;&amp; PUBCONF.DEBUGMOCK&#125;export const ANOTHER_DEMO = &#123;&#125;export default &#123; DEMO, ANOTHER_DEMO&#125; 3、在组件内部定义conf.js文件，主要编写单个组件的基本配置信息，请求路径，mock数据对应的url地址，代码如下：123456789101112import &#123;DEMO&#125; from '../conf.js';const MODULECONF = &#123; 'demo': &#123; NAME: 'demo', ICON: '', MOCK: DEMO.INDEX_URL_MOCK, API: &#123; GET: DEMO.INDEX_URL, &#125; &#125;,&#125;;export default MODULECONF; 4、在组件内部定义mockjs来编写mock假数据，代码如下：12345678910import Mock from 'mockjs';export default Mock.mock('http://www.xxx.com/demo', &#123; errno: 0, msg: \"成功\", data: [&#123; 'name': '@name', 'age|1-100': 100, 'color': '@color' &#125;]&#125;); 查看数据返回效果，数据在控制台打印出来 以上就是基本的流程，如果有更好更灵活的使用方案，希望能够参与沟通并且分享，这里会有个问题，就是目前mockjs未能跟业务代码隔离，webpack如果单纯加上externals配置，项目打包后,直接本地运行会报错，找不到mockjs，不知道是不是自己配置的原因，但是基本的思想就是最终上线代码不要把工具类的函数打包进去。项目脚手架已经在github上分享，点击查看详情","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"如何使用vue-ssr做服务端渲染初体验(二)","date":"2017-06-02T12:09:11.000Z","path":"vue-ssr2/","text":"1、前言上一节我们大致讲了为什么需要使用vue后端渲染，以及vue后端渲染的基本原理，这节内容我们将从零开始搭建属于自己的vue后端渲染脚手架，当然不能不参考官方页面响应的实例vue-hackernews-2.0，从零开始搭建项目,源码在将在下节与大家共享。 2、前期准备基本环境要求：node版本6.10.1以上，npm版本3.10.10以上，本机环境是这样的，建议升级到官方最新版本。 使用的技术栈： 1、vue 2.4.22、vuex 2.3.13、vue-router 2.7.04、vue-server-renderer 2.4.25、express 4.15.46、axios 0.16.27、q https://github.com/kriskowal/q.git8、webpack 3.5.09、mockjs 1.0.1-beta310、babel 以上是主要是用的技术栈，在构建过程中会是用相应的插件依赖包来配合进行压缩打包，以下是npm init后package.json文件所要添加的依赖包。 3、项目主目录搭建基本目录结构如下： 文件目录基本介绍： components 主要存放组件代码，里面可以根据业务场景再次细分模块组件等。lib 主要存放第三方库文件，方便用户直接引入使用public 主要存放公共组件代码和项目使用的公共文件代码，例如后期我们将axios封装成公共的api库文件等等。router 主要存放前端路由配置文件，写法规范按照vue-router官方例子即可。store 主要是存放共享状态文件，里面包含action.js,getter.js,mutationtype.js,state.js等，后期会根据模块再细分这些。app.js 是项目入口文件App.vue 是项目入口文件entry-client和entry-server分别是客户端入口文件和服务端的入口文件index.template.html是整个项目的模版文件 开始编写app.js项目入口代码使用vue开发项目入口文件一般都会如下写法：1234567891011import Vue from 'vue';import App from './index.vue';import router from './router'import store from './store';new Vue(&#123; el: '#app', store, router, render: (h) =&gt; h(App)&#125;); 这种写法是程序共享一个vue实例，但是在后端渲染中很容易导致交叉请求状态污染，导致数据流被污染了。 所以，避免状态单例,我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例，同样router和store入口文件也需要重新创建一个实例。 为了配合webpack动态加载路由配置，这里会改写常规路由引入写法，这样可以根据路由路径来判断加载相应的组件代码： 123import Home from '../components/Home.vue'// 改写成component: () =&gt; ('../components/Home.vue') 以下是路由的基本写法router，对外会抛出一个createRouter方法来创建一个新的路由实例： 1234567891011121314import Vue from 'vue'import Router from 'vue-router';Vue.use(Router)export function createRouter() &#123; return new Router(&#123; mode: 'history', routes: [&#123; name:'home', path: '/', component: () =&gt; import ('../components/Home.vue') &#125;] &#125;)&#125; 以下是store状态管理的基本写法，对外暴露了一个createStore方法，方便每次访问创建一个新的实例： 12345678910111213141516import Vue from 'vue'import Vuex from 'vuex'import actions from './actions'import getters from './getters'// 按照组件的复杂度是否使用modulesimport Home from './modules/Home'Vue.use(Vuex)export function createStore() &#123; return new Vuex.Store(&#123; actions, getters, modules:&#123; Home &#125;, &#125;)&#125; 结合写好的router和store入口文件代码来编写整个项目的入口文件app.js代码内容，同样最终也会对外暴露一个createApp方法，在每次创建app的时候保证router，store，app都是新创建的实例，这里还引入了一个vue路由插件vuex-router-sync，主要作用是同步路由状态(route state)到 store，以下是app.js完整代码： 1234567891011121314151617181920import Vue from 'vue'import App from './App.vue'import &#123; createRouter &#125; from './router'import &#123; createStore &#125; from './store'import &#123; sync &#125; from 'vuex-router-sync'export function createApp () &#123; // 创建 router 和 store 实例 const router = createRouter() const store = createStore() // 同步路由状态(route state)到 store sync(store, router) // 创建应用程序实例，将 router 和 store 注入 const app = new Vue(&#123; router, store, render: h =&gt; h(App) &#125;) // 暴露 app, router 和 store。 return &#123; app, router, store &#125;&#125; entry-client.js代码编写：首页引入从app文件中暴露出来的createApp方法，在每次调用客户端的时候，重新创建一个新的app，router，store，部分代码如下： 12import &#123; createApp &#125; from './app'const &#123; app, router, store &#125; = createApp() 这里我们会使用到onReady方法，此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染的时候，例子代码如下： 12345import &#123; createApp &#125; from './app'const &#123; app, router, store &#125; = createApp()router.onReady(() =&gt; &#123; app.$mount('#app')&#125;) 我们会调用一个新方法beforeResolve，只有在router2.5.0以上的版本才会有的方法，注册一个类似于全局路由保护router.beforeEach()，除了在导航确认之后，在所有其他保护和异步组件已解决之后调用。基本写法如下： 123456router.beforeResolve((to, from, next) =&gt; &#123; // to 和 from 都是 路由信息对象 // 返回目标位置或是当前路由匹配的组件数组（是数组的定义/构造类，不是实例）。通常在服务端渲染的数据预加载时时候。 const matched = router.getMatchedComponents(to) const prevMatched = router.getMatchedComponents(from)&#125;) 服务端把要给客户端的 state 放在了 window.INITIAL_STATE 这个全局变量上面。前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（INITIAL_STATE），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。基本代码如下：1234// 将服务端渲染时候的状态写入vuex中if (window.__INITIAL_STATE__) &#123; store.replaceState(window.__INITIAL_STATE__)&#125; 接下来贴出来完整的客户端代码，这里的Q也可以不用引入，直接使用babel就能编译es6自带的Promise，因为本人使用习惯了，这里可以根据自身的需求是否安装：1234567891011121314151617181920212223242526272829303132import &#123; createApp &#125; from './app'import Q from 'q';const &#123; app, router, store &#125; = createApp()router.onReady(() =&gt; &#123; router.beforeResolve((to, from, next) =&gt; &#123; const matched = router.getMatchedComponents(to) const prevMatched = router.getMatchedComponents(from) // 我们只关心之前没有渲染的组件 // 所以我们对比它们，找出两个匹配列表的差异组件 let diffed = false const activated = matched.filter((c, i) =&gt; &#123; return diffed || (diffed = (prevMatched[i] !== c)) &#125;) if (!activated.length) &#123; return next() &#125; // 这里如果有加载指示器(loading indicator)，就触发 Q.all(activated.map(c =&gt; &#123; if (c.asyncData) &#123; return c.asyncData(&#123; store, route: to &#125;) &#125; &#125;)).then(() =&gt; &#123; // 停止加载指示器(loading indicator) next() &#125;).catch(next) &#125;) app.$mount('#app')&#125;)// 将服务端渲染时候的状态写入vuex中if (window.__INITIAL_STATE__) &#123; store.replaceState(window.__INITIAL_STATE__)&#125; entry-server.js代码编写：基本编写和客户端的差不多，因为这是服务端渲染，涉及到与后端数据交互定义的问题，我们需要在这里定义好各组件与后端交互使用的方法名称，这样方便在组件内部直接使用，这里根我们常规在组件直接使用ajax获取数据有些不一样，代码片段如下：1234567//直接定义组件内部asyncData方法来触发相应的ajax获取数据if (Component.asyncData) &#123; return Component.asyncData(&#123; store, route: router.currentRoute &#125;)&#125; 以下是完整的服务端代码：12345678910111213141516171819202122232425262728293031import &#123; createApp &#125; from './app'import Q from 'q'export default context =&gt; &#123; return new Q.Promise((resolve, reject) =&gt; &#123; const &#123; app, router, store &#125; = createApp() router.push(context.url) router.onReady(() =&gt; &#123; const matchedComponents = router.getMatchedComponents() if (!matchedComponents.length) &#123; return reject(&#123; code: 404 &#125;) &#125; // 对所有匹配的路由组件调用 `asyncData()` Q.all(matchedComponents.map(Component =&gt; &#123; if (Component.asyncData) &#123; return Component.asyncData(&#123; store, route: router.currentRoute &#125;) &#125; &#125;)).then(() =&gt; &#123; // 在所有预取钩子(preFetch hook) resolve 后， // 我们的 store 现在已经填充入渲染应用程序所需的状态。 // 当我们将状态附加到上下文， // 并且 `template` 选项用于 renderer 时， // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。 context.state = store.state resolve(app) &#125;).catch(reject) &#125;, reject) &#125;)&#125; 4、脚手架其他目录介绍：到这里src下面主要的几个文件代码已经编写完成，接下里介绍下整个项目的目录结构如下： 主要几个文件介绍如下：build 主要存放webpack打包配置文件dist webpack打包后生成的目录log 使用pm2监控进程存放的日志文件目录server.js node服务器启动文件pmlog.json pm2配置文件 server.js入口文件编写我们还需要编写在服务端启动服务的代码server.js，我们会使用到部分node原生提供的api，片段代码如下：1234567const Vue = require('vue')const express = require('express')const path = require('path')const LRU = require('lru-cache')const &#123; createBundleRenderer &#125; = require('vue-server-renderer')const fs = require('fs')const net = require('net') 大致思路是，引入前端模版页面index.template.html，使用express启动服务，引入webpack打包项目代码的dist文件，引入缓存模块（这里不做深入介绍，后期会单独详细介绍），判断端口是否被占用，自动启动其他接口服务。 引入前端模版文件并且设置环境变量为production，片段代码如下：12const template = fs.readFileSync('./src/index.template.html', 'utf-8')const isProd = process.env.NODE_ENV === 'production' vue-server-renderer插件的具体使用，通过读取dist文件夹下的目录文件，来创建createBundleRenderer函数，并且使用LRU来设置缓存的时间，通过判断是生产环境还是开发环境，调用不同的方法，代码片段如下：12345678910111213141516171819202122232425const resolve = file =&gt; path.resolve(__dirname, file)function createRenderer (bundle, options) &#123; return createBundleRenderer(bundle, Object.assign(options, &#123; template, cache: LRU(&#123; max: 1000, maxAge: 1000 * 60 * 15 &#125;), basedir: resolve('./dist'), runInNewContext: false &#125;))&#125;let renderer;let readyPromiseif (isProd) &#123; const bundle = require('./dist/vue-ssr-server-bundle.json') const clientManifest = require('./dist/vue-ssr-client-manifest.json') renderer = createRenderer(bundle, &#123; clientManifest &#125;)&#125; else &#123; readyPromise = require('./build/setup-dev-server')(server, (bundle, options) =&gt; &#123; renderer = createRenderer(bundle, options) &#125;)&#125; 使用express启动服务，代码片段如下：1234567891011121314151617181920const server = express()；//定义在启动服务钱先判断中间件中的缓存是否过期，是否直接调用dist文件。const serve = (path, cache) =&gt; express.static(resolve(path), &#123; maxAge: cache &amp;&amp; isProd ? 1000 * 60 * 60 * 24 * 30 : 0&#125;)server.use('/dist', serve('./dist', true))server.get('*', (req, res) =&gt; &#123; const context = &#123; title: 'hello', url: req.url &#125; renderer.renderToString(context, (err, html) =&gt; &#123; if (err) &#123; res.status(500).end('Internal Server Error') return &#125; res.end(html) &#125;)&#125;) 判断端口是否被占用，片段代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function probe(port, callback) &#123; var servers = net.createServer().listen(port) var calledOnce = false var timeoutRef = setTimeout(function() &#123; calledOnce = true callback(false, port) &#125;, 2000) timeoutRef.unref() var connected = false servers.on('listening', function() &#123; clearTimeout(timeoutRef) if (servers) servers.close() if (!calledOnce) &#123; calledOnce = true callback(true, port) &#125; &#125;) servers.on('error', function(err) &#123; clearTimeout(timeoutRef) var result = true if (err.code === 'EADDRINUSE') result = false if (!calledOnce) &#123; calledOnce = true callback(result, port) &#125; &#125;)&#125;var checkPortPromise = new Promise((resolve) =&gt; &#123; (function serverport(_port) &#123; var pt = _port || 8080; probe(pt, function(bl, _pt) &#123; // 端口被占用 bl 返回false // _pt：传入的端口号 if (bl === true) &#123; // console.log(\"\\n Static file server running at\" + \"\\n\\n=&gt; http://localhost:\" + _pt + '\\n'); resolve(_pt); &#125; else &#123; serverport(_pt + 1) &#125; &#125;) &#125;)()&#125;)checkPortPromise.then(data =&gt; &#123; uri = 'http://localhost:' + data; console.log('启动服务路径'+uri) server.listen(data);&#125;); 到这里，基本的代码已经编写完成，webpack打包配置文件基本和官方保持不变，接下来可以尝试启动本地的项目服务，查看基本的demo展示。 下节，我将介绍下mockjs，axios怎么封装成公共函数便于使用","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"如何使用vue-ssr做服务端渲染初体验(-)","date":"2017-06-01T13:09:11.000Z","path":"vue-ssr/","text":"1、前言服务端渲染实现原理机制：在服务端拿数据进行解析渲染，直接生成html片段返回给前端。然后前端可以通过解析后端返回的html片段到前端页面，大致有以下两种形式： 1、服务器通过模版引擎直接渲染整个页面，例如java后端的vm模版引擎，php后端的smarty模版引擎。2、服务渲染生成html代码块, 前端通过AJAX获取然后使用js动态添加。 2、服务端渲染的优劣服务端渲染能够解决两大问题： 1、seo问题，有利于搜索引擎蜘蛛抓取网站内容，利于网站的收录和排名。2、首屏加载过慢问题，例如现在成熟的SPA项目中，打开首页需要加载很多资源，通过服务端渲染可以加速首屏渲染。 同样服务端渲染也会有弊端，主要是根据自己的业务场景来选择适合方式，由于服务端渲染前端页面，必将会给服务器增加压力。 3、SSR的实现原理客户端请求服务器，服务器根据请求地址获得匹配的组件，在调用匹配到的组件返回 Promise (官方是preFetch方法)来将需要的数据拿到。最后再通过 1&lt;script&gt;window.__initial_state=data&lt;/script&gt; 将其写入网页，最后将服务端渲染好的网页返回回去。 接下来客户端会将vuex将写入的 initial_state 替换为当前的全局状态树，再用这个状态树去检查服务端渲染好的数据有没有问题。遇到没被服务端渲染的组件，再去发异步请求拿数据。说白了就是一个类似React的 shouldComponentUpdate 的Diff操作。 Vue2使用的是单向数据流，用了它，就可以通过 SSR 返回唯一一个全局状态， 并确认某个组件是否已经SSR过了。 4、vue后端渲染主要插件：vue-server-renderer由于virtual dom的引入，使得vue的服务端渲染成为了可能，下面是官方 vue-server-renderer提供的渲染流程图: 可以看出vue的后端渲染分三个部分组成：页面的源码（source），node层的渲染部分和浏览器端的渲染部分。 source分为两种entry point,一个是前端页面的入口client entry,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口server entry,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象（经过测试，直接返回Vue对象也是可以的）; 前面的source部分就是业务开发的代码，开发完成之后通过 webpack 进行构建，生成对应的bundle，这里不再赘述client bundle,就是一个可在浏览器端执行的打包文件；这里说下server bundle, vue2提供 vue-server-renderer模块，模块可以提供两种render: rendererer/bundleRenderer ,下面分别介绍下这两种render。 renderer接收一个vue对象 ，然后进行渲染，这种对于简单的vue对象,可以这么去做，但是对于复杂的项目，如果使用这种直接require一个vue对象，这个对于服务端代码的结构和逻辑都不太友好，首先模块的状态会一直延续在每个请求渲染请求，我们需要去管理和避免这次渲染请求的状态影响到后面的请求,因此vue-server-renderer提供了另外一种渲染模式，通过一个 bundleRenderer去做渲染。 bundleRenderer是较为复杂项目进行服务端渲染官方推荐的方式，通过webpack以server entry按照一定的要求打包生成一个 server-bundle,它相当于一个可以给服务端用的app的打包压缩文件，每一次调用都会重新初始化 vue对象，保证了每次请求都是独立的，对于开发者来说，只需要专注于当前业务就可以，不用为服务端渲染开发更多的逻辑代码。renderer生成完成之后，都存在两个接口，分别是renderToString和renderToStream，一个是一次性将页面渲染成字符串文件，另外一个是流式渲染，适用于支持流的web服务器，可以是请求服务的速度更快。 5、项目基本结构如下 如何从零开始搭建适合自己的vue后端渲染框架？","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"浅谈webworker的使用场景","date":"2017-05-07T13:09:11.000Z","path":"2017-05-07/","text":"一、webWorker之初体验在”setTimeout那些事儿”中，说到JavaScript是单线程。也就是同一时间只能做同一事情。 也好理解，作为浏览器脚本语言，如果JavaScript不是单线程，那么就有点棘手了。比如，与用户交互或者对DOM进行操作时，在一个线程上修改某个DOM，另外的线程删除DOM，这时浏览器该如何抉择呢? 所以，JavaScript是单线程也是有背景的。 如下： 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;singleThread&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //添加到任务队列中，待同步任务所处的‘执行栈’执行完毕，1秒后执行任务队列中的这个匿名函数 setTimeout(function()&#123; console.log('come on'); &#125;,1000); //只要不关闭该alert，‘执行栈’就没结束，从而也就不会进入到任务队列中 alert('waiting'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 但，HTML5引入了一个工作线程（webWorker）的概念。它允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。 简而言之，就是允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。 从而，可以用webWorker来处理一些比较耗时的计算。 如下，主页面： 12345678910111213141516171819&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; //创建一个Worker对象，并向它传递将在新线程中执行的脚本url var worker = new Worker('worker.js'); //接收worker传递过来的数据 worker.onmessage = function(event)&#123; document.getElementById('result').innerHTML+=event.data+\"&lt;br/&gt;\" ; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 下面是worker.js的内容: 123456789101112131415var i = 0;function timedCount()&#123; for(var j = 0, sum = 0; j &lt; 100; j++)&#123; for(var i = 0; i &lt; 100000000; i++)&#123; sum+=i; &#125;; &#125;; //将得到的sum发送回主线程 postMessage(sum);&#125;;//将执行timedCount前的时间，通过postMessage发送回主线程postMessage('Before computing, '+new Date());timedCount();//结束timedCount后，将结束时间发送回主线程postMessage('After computing, ' +new Date()); 上面代码执行的流程是：创建的worker对象，并用onmessage方法接收worker.js里面postMessage传递过来的数据(event.data)，并将数据追加到div#result中。 所以，执行上面的代码结果如下： 待worker.js中的timedCount方法运算完后，执行postMessage操作，向主线程传数据，得图二。期间，并不影响主线程的运作。 二、webWorker之常用ＡＰＩ接下来，再来看看关于worker的常用API： 1、postMessage(data)子线程与主线程之间互相通信使用方法，传递的data为任意值。 123456//worker = new Worker('url');//worker.postMessage传递给子线程数据，对象worker.postMessage(&#123;first:1,second:2&#125;);//子线程中也可以使用postMessage，如传递字符串postMessage(‘test’); 2、terminate()主线程中终止worker，此后无法再利用其进行消息传递。注意：一旦terminate后，无法重新启用，只能另外创建。 12//worker = new Worker('url');worker.terminate(); 如，主页面： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; var worker = new Worker('worker.js'); //每隔100毫秒，向子线程传递&#123;name: 'monkey'&#125;信息 setInterval(function()&#123; worker.postMessage(&#123;name: 'monkey'&#125;); &#125;,100); //当主线程worker收到来自子线程的消息后，触发message事件 worker.onmessage = function(event)&#123; document.getElementById('result').innerHTML+=event.data+\"&lt;br/&gt;\" ; //主线程使用terminate方法中断与子线程来往，在浏览器中只能显示一次event.data worker.terminate(); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 子线程worker.js代码： 1234567&lt;script&gt;//当主线程发来信息后，触发该message事件onmessage = function(event)&#123; //向主线程发送event.data.name信息 postMessage(event.data.name);&#125;;&lt;/script&gt; 3、message当有消息发送时，触发该事件。且，消息发送是双向的，消息内容可通过data来获取。 message使用，可见terminate中的demo 4、error出错处理。且错误消息可以通过e.message来获取。 如下： 1234567//worker = new Worker('url');worker.onerror = function(e)&#123; //打印出错消息 console.log(e.message); //中断与子线程的联系 worker.terminate();&#125; 另：worker线程从上到下同步运行它的代码，然后进入异步阶段来对事件及计时器响应，如果worker注册了message事件处理程序，只要其有可能触发，worker就一直在内存中，不会退出，所以通信完毕后得手动在主线程中terminate或者子线程中close掉，但如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，他就会退出。 三、worker上下文先看下面这段代码： 主页面： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; var worker = new Worker('worker.js'); //接收消息事件 worker.onmessage = function(event)&#123; console.log(event.data); &#125;; //错误信息事件 worker.onerror = function(e)&#123; console.log('erro: ' + e.message); //终止线程 worker.terminate(); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;/body&gt;&lt;/html&gt; worker.js 123456//window对象的alert方法alert(1);onmessage = function(event)&#123; //向主线程发送event.data.name信息 postMessage(event.data.name);&#125;; 执行上面代码结果： 为什么会这样呢？原因是alert为window对象的方法，所以会报错undefined。 worker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做WorkerGlobalScope的东东，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。WorkerGlobalScope作用域下的常用属性、方法如下： 1、self 我们可以使用 WorkerGlobalScope 的 self 属性来或者这个对象本身的引用 2、location location 属性返回当线程被创建出来的时候与之关联的 WorkerLocation 对象，它表示用于初始化这个工作线程的脚步资源的绝对 URL，即使页面被多次重定向后，这个 URL 资源位置也不会改变。 3、close 关闭当前线程，与terminate作用类似 4、importScripts 我们可以通过importScripts()方法通过url在worker中加载库函数 5、XMLHttpRequest 有了它，才能发出Ajax请求 6、setTimeout/setInterval以及addEventListener/postMessage四、关于worker我们可以做什么： 1.可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信 2.可以在worker中通过importScripts(url)加载另外的脚本文件 3.可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval() 4.可以使用XMLHttpRequest来发送请求 5.可以访问navigator的部分属性 局限性： 1.不能跨域加载JS 2.worker内代码不能访问DOM 3.各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行 4.IE这个新特性","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"}]},{"title":"axios基本使用介绍","date":"2017-05-02T10:56:15.000Z","path":"2017-05-02/","text":"axios建议使用高版本浏览器，目前在手机端使用频繁，但是在低版本的安卓上其实是有兼容性问题的，安卓4.2就开始出问题了，主要是由于Promise不支持，需要额外引入兼容包来处理。并且axios也是vue官方推荐使用的库。 1require('es6-promise').polyfill(); 发送一个GET请求，代码示例如下： 1234567891011121314151617181920//通过给定的ID来发送请求axios.get('/user?ID=12345') .then(function(response)&#123; console.log(response); &#125;) .catch(function(err)&#123; console.log(err); &#125;);//以上请求也可以通过这种方式来发送axios.get('/user',&#123; params:&#123; ID:12345 &#125;&#125;).then(function(response)&#123; console.log(response);&#125;).catch(function(err)&#123; console.log(err);&#125;); 发送一个POST请求，代码示例如下： 12345678910axios.post('/user',&#123; firstName:'Fred', lastName:'Flintstone'&#125;).then(function(res)&#123; console.log(res);&#125;).catch(function(err)&#123; console.log(err);&#125;); 一次性并发多个请求，代码示例如下： 12345678910function getUserAccount()&#123; return axios.get('/user/12345');&#125;function getUserPermissions()&#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms)&#123; //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果 &#125;)) axios可以通过配置（config）来发送请求，代码示例如下： 123456789//发送一个`POST`请求axios(&#123; method:\"POST\", url:'/user/12345', data:&#123; firstName:\"Fred\", lastName:\"Flintstone\" &#125;&#125;); 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名,注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明 1234567axios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]]) 并发请求（concurrency）,即是帮助处理并发请求的辅助函数 1234//iterable是一个可以迭代的参数如数组等axios.all(iterable)//callback要等到所有请求都完成才会执行axios.spread(callback) 创建一个axios实例，并且可以自定义其配置 1、axios.create([config])12345var instance = axios.create(&#123; baseURL:\"https://some-domain.com/api/\", timeout:1000, headers: &#123;'X-Custom-Header':'foobar'&#125;&#125;); 2、实例的方法，注意已经定义的配置将和利用create创建的实例的配置合并1234567axios#request(config)axios#get(url[,config])axios#delete(url[,config])axios#head(url[,config])axios#post(url[,data[,config]])axios#put(url[,data[,config]])axios#patch(url[,data[,config]]) 请求的配置（request config），以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&#123; //`url`是请求的服务器地址 url:'/user', //`method`是请求资源的方式 method:'get'//default //如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面 //当`url`是相对地址的时候，设置`baseURL`会非常的方便 baseURL:'https://some-domain.com/api/', //`transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动 //该选项只适用于以下请求方式：`put/post/patch` //数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream` transformRequest:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动 transformResponse:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`headers`选项是需要被发送的自定义请求头信息 headers: &#123;'X-Requested-With':'XMLHttpRequest'&#125;, //`params`选项是要随请求一起发送的请求参数----一般链接在URL后面 //他的类型必须是一个纯对象或者是URLSearchParams对象 params: &#123; ID:12345 &#125;, //`paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化 //例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param) paramsSerializer: function(params)&#123; return Qs.stringify(params,&#123;arrayFormat:'brackets'&#125;) &#125;, //`data`选项是作为一个请求体而需要被发送的数据 //该选项只适用于方法：`put/post/patch` //当没有设置`transformRequest`选项时dada必须是以下几种类型之一 //string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams //仅仅浏览器：FormData/File/Bold //仅node:Stream data &#123; firstName:\"Fred\" &#125;, //`timeout`选项定义了请求发出的延迟毫秒数 //如果请求花费的时间超过延迟的时间，那么请求会被终止 timeout:1000, //`withCredentails`选项表明了是否是跨域请求 withCredentials:false,//default //`adapter`适配器选项允许自定义处理请求，这会使得测试变得方便 //返回一个promise,并提供验证返回 adapter: function(config)&#123; /*..........*/ &#125;, //`auth`表明HTTP基础的认证应该被使用，并提供证书 //这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息 auth: &#123; username:\"zhangsan\", password: \"s00sdkf\" &#125;, //返回数据的格式 //其可选项是arraybuffer,blob,document,json,text,stream responseType:'json',//default // xsrfCookieName: 'XSRF-TOKEN',//default xsrfHeaderName:'X-XSRF-TOKEN',//default //`onUploadProgress`上传进度事件 onUploadProgress:function(progressEvent)&#123; //下载进度的事件onDownloadProgress:function(progressEvent)&#123;&#125; &#125;, //相应内容的最大值 maxContentLength:2000, //`validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise //如果`validateStatus`返回true(或者设置为`null`或者`undefined`),那么promise的状态将会是resolved,否则其状态就是rejected validateStatus:function(status)&#123; return status &gt;= 200 &amp;&amp; status &lt;300;//default &#125;, //`maxRedirects`定义了在nodejs中重定向的最大数量 maxRedirects: 5,//default //`httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理 //keeyAlive在选项中没有被默认激活 httpAgent: new http.Agent(&#123;keeyAlive:true&#125;), httpsAgent: new https.Agent(&#123;keeyAlive:true&#125;), //proxy定义了主机名字和端口号， //`auth`表明http基本认证应该与proxy代理链接，并提供证书 //这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的`Proxy-Authorization` header proxy: &#123; host:'127.0.0.1', port: 9000, auth: &#123; username:'skda', password:'radsd' &#125; &#125;, //`cancelToken`定义了一个用于取消请求的cancel token //详见cancelation部分 cancelToken: new cancelToken(function(cancel)&#123; &#125;)&#125; 请求返回的内容 12345678910 &#123; data:&#123;&#125;, status:200, //从服务器返回的http状态文本 statusText:'OK', //响应头信息 headers: &#123;&#125;, //`config`是在请求的时候的一些配置信息 config: &#123;&#125;&#125; 默认配置 1、全局默认配置123axios.defaults.baseURL = 'http://api.exmple.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['content-Type'] = 'appliction/x-www-form-urlencoded'; 2、自定义的实例默认设置1234567//当创建实例的时候配置默认配置var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);//当实例创建时候修改配置instance.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN; 3、配置中的有优先级，config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。12345678910//创建一个实例的时候会使用libray目录中的默认配置//在这里timeout配置的值为0，来自于libray的默认值var instance = axios.create();//回覆盖掉library的默认值//现在所有的请求都要等2.5S之后才会发出instance.defaults.timeout = 2500;//这里的timeout回覆盖之前的2.5S变成5sinstance.get('/longRequest',&#123; timeout: 5000&#125;); 拦截器 1、你可以在请求、响应在到达then/catch之前拦截他们12345678910111213141516//添加一个请求拦截器axios.interceptors.request.use(function(config)&#123; //在请求发出之前进行一些操作 return config;&#125;,function(err)&#123; //Do something with request error return Promise.reject(error);&#125;);//添加一个响应拦截器axios.interceptors.response.use(function(res)&#123; //在这里对返回的数据进行处理 return res;&#125;,function(err)&#123; //Do something with response error return Promise.reject(error);&#125;) 2、取消拦截器12var myInterceptor = axios.interceptor.request.use(function()&#123;/*....*/&#125;);axios.interceptors.request.eject(myInterceptor); 3、给自定义的axios实例添加拦截器12var instance = axios.create();instance.interceptors.request.use(function()&#123;&#125;) 错误处理 12345678910111213axios.get('/user/12345') .catch(function(error)&#123; if(error.response)&#123; //请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.header); &#125;else &#123; //一些错误是在设置请求的时候触发 console.log('Error',error.message); &#125; console.log(error.config); &#125;); 取消,你可以通过一个cancel token来取消一个请求 1、你可以通过CancelToken.source工厂函数来创建一个cancel token123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345',&#123; cancelToken: source.token&#125;).catch(function(thrown)&#123; if(axios.isCancel(thrown))&#123; console.log('Request canceled',thrown.message); &#125;else &#123; //handle error &#125;&#125;);//取消请求（信息的参数可以设置的）source.cance(\"操作被用户取消\"); 2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:12345678910var cancelToken = axios.CancelToken;var cance;axios.get('/user/12345',&#123; cancelToken: new CancelToken(function(c)&#123; //这个executor函数接受一个cancel function作为参数 cancel = c; &#125;)&#125;)//取消请求cancel(); 使用 application/x-www-form-urlencoded 格式化,默认情况下，axios串联js对象为 JSON 格式。为了发送 application/x-wwww-form-urlencoded 格式数据，你可以使用一下的设置。在浏览器中你可以如下使用 URLSearchParams API: 1234var params = new URLSearchParams();params.append('param1','value1');params.append('param2','value2');axios.post('/foo',params); URLSearchParams 不支持所有的浏览器,polyfill可用（确保垫片在浏览器全局环境中）,同样还有其他方法，片段代码如下： 12var qs = require('qs');axios.post('/foo', qs.stringify(&#123;'bar':123&#125;)); 如果在node环境中，可以使用以下querystring方法，代码片段如下： 12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123;foo:'bar'&#125;)); axios 基于原生的ES6 Promise 实现。如果环境不支持请使用es6-promise这个库来处理。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://www.iwangqi.com/tags/ajax/"}]},{"title":"详解javascript对象方法Object.assign()痛点","date":"2017-04-11T13:55:28.000Z","path":"2017-04-11/","text":"函数原型首先看一下函数的定义：函数参数为一个目标对象（该对象作为最终的返回值）,源对象(此处可以为任意多个)。通过调用该函数可以拷贝所有可被枚举的自有属性值到目标对象中。 Object.assign(target, …sources) 这里我们需要强调的三点是： 可被枚举的属性 自有属性 string或者Symbol类型是可以被直接分配的 拷贝过程中将调用源对象的getter方法，并在target对象上使用setter方法实现目标对象的拷贝。 函数实例这里我们通过几个MDN上的例子来介绍一下使用方法： 实例一我们参考上面的原型函数说明即可知道其最开始的o1因为设置为target，则调用其setter方法设置了其他对象的属性到自身。 12345678var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed. 实例二我们自定义了一些对象，这些对象有一些包含了不可枚举的属性,另外注意使用 Object.defineProperty 初始化的对象默认是不可枚举的属性。对于可枚举的对象我们可以直接使用Object.keys()获得,或者使用for-in循环遍历出来. 对于不可枚举的属性，使用Object.assign的时候将被自动忽略。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124var obj = Object.create(&#123; foo: 1 &#125;, &#123; // foo is an inherit property. bar: &#123; value: 2 // bar is a non-enumerable property. &#125;, baz: &#123; value: 3, enumerable: true // baz is an own enumerable property. &#125;&#125;);var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; baz: 3 &#125; ``` ### 实例三对于只读的属性，当分配新的对象覆盖他的时候，将抛出异常:``` javascriptvar target = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 1, writable: false&#125;); Object.assign(target, &#123; bar: 2 &#125;)//&#123;bar: 2, foo: 1&#125;Object.assign(target, &#123; foo: 2 &#125;)//Uncaught TypeError: Cannot assign to read only property 'foo' of object '#&lt;Object&gt;'(…)``` ## Polyfill这里我们简单的看下如何实现es5版本的Object.assign：实现步骤：判断是否原生支持该函数，如果不存在的话创建一个立即执行函数，该函数将创建一个assign函数绑定到Object上。判断参数是否正确(目的对象不能为空，我们可以直接设置&#123;&#125;传递进去,但必须设置该值)使用Object在原有的对象基础上返回该对象，并保存为out使用for…in循环遍历出所有的可枚举的自有对象。并复制给新的目标对象(hasOwnProperty返回非原型链上的属性)源码如下：``` javascript if (typeof Object.assign != 'function') &#123; (function () &#123; Object.assign = function (target) &#123; 'use strict'; if (target === undefined || target === null) &#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; var output = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var source = arguments[index]; if (source !== undefined &amp;&amp; source !== null) &#123; for (var nextKey in source) &#123; if (source.hasOwnProperty(nextKey)) &#123; output[nextKey] = source[nextKey]; &#125; &#125; &#125; &#125; return output; &#125;;&#125;)();&#125;``` ## 扩展内容### 深度拷贝和前拷贝javascript中存储对象都是存地址的，所以浅拷贝是都指向同一块内存区块，而深拷贝则是另外开辟了一块区域，下面实例也可以看出这一点：``` javascript// 浅拷贝const a = &#123;t: 1, p: 'gg'&#125;;const b = a;b.t = 3;console.log(a); // &#123;t: 3, p: 'gg'&#125;console.log(b); // &#123;t: 3, p: 'gg'&#125;//深拷贝const c = &#123;t: 1, p: 'gg'&#125;;const d = deepCopy(c);d.t = 3;console.log(c); // &#123;t: 1, p: 'gg'&#125;console.log(d); // &#123;t: 3, p: 'gg'&#125;``` 可以明显看出，浅拷贝在改变其中一个值时，会导致其他也一起改变，而深拷贝不会。我需要的是深拷贝的方法，然后发现原来es6 中有Object.assign() 这个方法，感觉可以拿来用了。 贴一下两个官方例子：``` javascript// Cloning an objectvar obj = &#123; a: 1 &#125;;var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125;// Merging objectsvar o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed. 是不是很完美，又可以clone又可以merge。在我这种情况下，我觉得我的代码量又可以减少了，比如： 1234567891011121314151617const defaultOpt = &#123; title: 'hello', name: 'oo', type: 'line'&#125;;// 原来可能需要这样const opt1 = deepCopy(a);opt1.title = 'opt1';opt1.type = 'bar';opt1.extra = 'extra'; // 额外增加配置// 现在只要这样const opt2 = Object.assign(&#123;&#125;, a, &#123; title: 'opt2', type: 'bar', extra: 'extra'&#125;); 不过，很快，问题出现了，那就是merge和我想象的不一样且看例子： 1234567891011121314151617181920212223242526272829const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125;&#125;;const opt = Object.assign(&#123;&#125;, defaultOpt, &#123; title: &#123; subtext: 'Yes, your world.' &#125;&#125;);console.log(opt);// 预期结果&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125;// 实际结果&#123; title: &#123; subtext: 'Yes, your world.' &#125;&#125; 原本想的是它只会覆盖subtext ，然而其实它直接覆盖了整个title ，这个让我比较郁闷，相当于它只merge根属性，下面的就不做处理了。代码只能重构成相对麻烦一点的： 12345678910111213141516171819const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125;&#125;;const opt = Object.assign(&#123;&#125;, defaultOpt);opt.title.subtext = 'Yes, your world.';console.log(opt);// 结果正常&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125; 这样用虽然麻烦一点，但是也还好，可以用了。不过。。。很快，又出现问题了，如下： 12345678910111213141516171819202122232425262728293031const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125; &#125;;const opt1 = Object.assign(&#123;&#125;, defaultOpt);const opt2 = Object.assign(&#123;&#125;, defaultOpt);opt2.title.subtext = 'Yes, your world.';console.log('opt1:');console.log(opt1);console.log('opt2:');console.log(opt2);// 结果opt1:&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125;opt2:&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125; 上面结果发现两个配置变得一模一样，而其实我们并没有去更改opt1 的subtext ，只是改了opt2 的。这说明一点：在title 这一层只是简单的浅拷贝 ，而没有继续深入的深拷贝。 Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。用的时候，还是要注意这个问题的。不过github上已经有很多好的解决方案，比如deep-merge 通过递归的方式逐层的去调用assign函数。Lodash提供了深拷贝的api方法，其实熟悉jquery的同学，extend这个api就能直接完美解决深拷贝的问题。 附发现一个可以简单实现深拷贝的方法，当然，有一定限制，如下： const obj1 = JSON.parse(JSON.stringify(obj)); 思路就是将一个对象转成json字符串，然后又将字符串转回对象。但是在使用中还是会存在问题，进过测试会把function替换掉，使用的时候还得注意。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://www.iwangqi.com/tags/es6/"}]},{"title":"理解JavaScript函数式编程","date":"2017-04-10T14:14:43.000Z","path":"2017-04-10/","text":"JavaScript 函数式编程是一个存在了很久的话题，但似乎从 2016 年开始，它变得越来越火热。这可能是因为 ES6 语法对于函数式编程更为友好，也可能是因为诸如 RxJS (ReactiveX) 等函数式框架的流行。 看过许多关于函数式编程的讲解，但是其中大部分是停留在理论层面，还有一些是仅针对 Haskell 等纯函数式编程语言的。而本文旨在聊一聊我眼中的函数式编程在 JavaScript 中的具体实践，之所以是 “我眼中的” 即我所说的仅代表个人观点，可能和部分 严格概念 是有冲突的。 本文将略去一大堆形式化的概念介绍，重点展示在 JavaScript 中到底什么是函数式的代码、函数式代码与一般写法有什么区别、函数式的代码能给我们带来什么好处以及常见的一些函数式模型都有哪些。 函数式编程我认为函数式编程可以理解为，以函数作为主要载体的编程方式，用函数去拆解、抽象一般的表达式 与命令式相比，这样做的好处在哪？主要有以下几点： 语义更加清晰 可复用性更高 可维护性更好 作用域局限，副作用少 基本的函数式编程下面例子是一个具体的函数式体现 123456789101112131415161718192021222324// 一般写法const arr = ['apple', 'pen', 'apple-pen'];for(const i in arr)&#123; const c = arr[i][0]; arr[i] = c.toUpperCase() + arr[i].slice(1);&#125;console.log(arr);// 函数式写法一function upperFirst(word) &#123; return word[0].toUpperCase() + word.slice(1);&#125;function wordToUpperCase(arr) &#123; return arr.map(upperFirst);&#125;console.log(wordToUpperCase(['apple', 'pen', 'apple-pen']));// 函数式写法二console.log(arr.map(['apple', 'pen', 'apple-pen'], word =&gt; word[0].toUpperCase() + word.slice(1))); 当情况变得更加复杂时，表达式的写法会遇到几个问题： 表意不明显，逐渐变得难以维护 复用性差，会产生更多的代码量 会产生很多中间变量 函数式编程很好的解决了上述问题。首先参看 函数式写法一，它利用了函数封装性将功能做拆解（粒度不唯一），并封装为不同的函数，而再利用组合的调用达到目的。这样做使得表意清晰，易于维护、复用以及扩展。其次利用 高阶函数，Array.map 代替 for…of 做数组遍历，减少了中间变量和操作。 而 函数式写法一 和 函数式写法二 之间的主要差别在于，可以考虑函数是否后续有复用的可能，如果没有，则后者更优。 链式优化从上面 函数式写法二 中我们可以看出，函数式代码在写的过程中，很容易造成 横向延展，即产生多层嵌套，下面我们举个比较极端点的例子。 // 计算数字之和 // 一般写法 console.log(1 + 2 + 3 - 4) // 函数式写法 function sum(a, b) { return a + b; } function sub(a, b) { return a - b; } console.log(sub(sum(sum(1, 2), 3), 4); 本例仅为展示 横向延展 的比较极端的情况，随着函数的嵌套层数不断增多，导致代码的可读性大幅下降，还很容易产生错误。 在这种情况下，我们可以考虑多种优化方式，比如下面的 链式优化 。 // 优化写法 (嗯，你没看错，这就是 lodash 的链式写法) const utils = { chain(a) { this._temp = a; return this; }, sum(b) { this._temp += b; return this; }, sub(b) { this._temp -= b; return this; }, value() { const _temp = this._temp; this._temp = undefined; return _temp; } }; console.log(utils.chain(1).sum(2).sum(3).sub(4).value()); 这样改写后，结构会整体变得比较清晰，而且链的每一环在做什么也可以很容易的展现出来。函数的嵌套和链式的对比还有一个很好的例子，那就是 回调函数 和 Promise 模式。 // 顺序请求两个接口 // 回调函数 import $ from 'jquery'; $.post('a/url/to/target', (rs) =&gt; { if(rs){ $.post('a/url/to/another/target', (rs2) =&gt; { if(rs2){ $.post('a/url/to/third/target'); } }); } }); // Promise import request from 'catta'; // catta 是一个轻量级请求工具，支持 fetch,jsonp,ajax，无依赖 request('a/url/to/target') .then(rs =&gt; rs ? $.post('a/url/to/another/target') : Promise.reject()) .then(rs2 =&gt; rs2 ? $.post('a/url/to/third/target') : Promise.reject()); 随着回调函数嵌套层级和单层复杂度增加，它将会变得臃肿且难以维护，而 Promise 的链式结构，在高复杂度时，仍能纵向扩展，而且层次隔离很清晰。 常见的函数式编程模型闭包（Closure）可以保留局部变量不被释放的代码块，被称为一个闭包 闭包的概念比较抽象，相信大家都或多或少知道、用到这个特性 那么闭包到底能给我们带来什么好处？ 先来看一下如何创建一个闭包： // 创建一个闭包 function makeCounter() { let k = 0; return function() { return ++k; }; } const counter = makeCounter(); console.log(counter()); // 1 console.log(counter()); // 2 makeCounter 这个函数的代码块，在返回的函数中，对局部变量 k ，进行了引用，导致局部变量无法在函数执行结束后，被系统回收掉，从而产生了闭包。而这个闭包的作用就是，“保留住“ 了局部变量，使内层函数调用时，可以重复使用该变量；而不同于全局变量，该变量只能在函数内部被引用。 换句话说，闭包其实就是创造出了一些函数私有的 ”持久化变量“。 所以从这个例子，我们可以总结出，闭包的创造条件是： 存在内、外两层函数 内层函数对外层函数的局部变量进行了引用 ###闭包的用途 闭包的主要用途就是可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等等。 // 简单的缓存工具 // 匿名函数创造了一个闭包 const cache = (function() { const store = {}; return { get(key) { return store[key]; }, set(key, val) { store[key] = val; } } }()); cache.set('a', 1); cache.get('a'); // 1 上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。 ###闭包的弊端 持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。 ##高阶函数 接受或者返回一个函数的函数称为高阶函数 听上去很高冷的一个词汇，但是其实我们经常用到，只是原来不知道他们的名字而已。JavaScript 语言是原生支持高阶函数的，因为 JavaScript 的函数是一等公民，它既可以作为参数又可以作为另一个函数的返回值使用。 我们经常可以在 JavaScript 中见到许多原生的高阶函数，例如 Array.map , Array.reduce , Array.filter 下面以 map 为例，我们看看他是如何使用的 ###map （映射） 映射是对集合而言的，即把集合的每一项都做相同的变换，产生一个新的集合 map 作为一个高阶函数，他接受一个函数参数作为映射的逻辑 // 数组中每一项加一，组成一个新数组 // 一般写法 const arr = [1,2,3]; const rs = []; for(const n of arr){ rs.push(++n); } console.log(rs) // map改写 const arr = [1,2,3]; const rs = arr.map(n =&gt; ++n); 上面一般写法，利用 for…of 循环的方式遍历数组会产生额外的操作，而且有改变原数组的风险 而 map 函数封装了必要的操作，使我们仅需要关心映射逻辑的函数实现即可，减少了代码量，也降低了副作用产生的风险。 ###柯里化（Currying） 给定一个函数的部分参数，生成一个接受其他参数的新函数 可能不常听到这个名词，但是用过 undescore 或 lodash 的人都见过他。 有一个神奇的 _.partial 函数，它就是柯里化的实现 // 获取目标文件对基础路径的相对路径 // 一般写法 const BASE = '/path/to/base'; const relativePath = path.relative(BASE, '/some/path'); // _.parical 改写 const BASE = '/path/to/base'; const relativeFromBase = _.partial(path.relative, BASE); const relativePath = relativeFromBase('/some/path'); 通过 _.partial ，我们得到了新的函数 relativeFromBase ，这个函数在调用时就相当于调用 path.relative ，并默认将第一个参数传入 BASE ，后续传入的参数顺序后置。 本例中，我们真正想完成的操作是每次获得相对于 BASE 的路径，而非相对于任何路径。柯里化可以使我们只关心函数的部分参数，使函数的用途更加清晰，调用更加简单。 ###组合（Composing） 将多个函数的能力合并，创造一个新的函数 同样你第一次见到他可能还是在 lodash 中，compose 方法（现在叫 flow） // 数组中每个单词大写，做 Base64 // 一般写法 (其中一种) const arr = ['pen', 'apple', 'applypen']; const rs = []; for(const w of arr){ rs.push(btoa(w.toUpperCase())); } console.log(rs); // _.flow 改写 const arr = ['pen', 'apple', 'applypen']; const upperAndBase64 = _.partialRight(_.map, _.flow(_.upperCase, btoa)); console.log(upperAndBase64(arr)); _.flow 将转大写和转 Base64 的函数的能力合并，生成一个新的函数。方便作为参数函数或后续复用。 ##自己的观点 我理解的 JavaScript 函数式编程，将可以复用的功能提取出来，用函数方法来代替其实就是基本的函数编程思想，其实到最后会面临两个问题，一个是函数共用性好还是函数功能细分好，这其实都是根据自己具体需求而定的，个人认为函数功能还是细分好，这样方便维护，功能实现代码逻辑清晰。 函数式编程就是书写清新的逻辑代码，其实也是一种解耦的形式罢了。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"}]},{"title":"nodejs的process.nextTick方法理解和使用","date":"2017-04-04T09:49:45.000Z","path":"2017-04-04/","text":"今天重新温习了下nodejs开发指南中的核心模块全局对象中的process进程模块，其实nextTick和我目前使用的vue中的nextTick方法有些异曲同工之妙，于是上网搜整理了一些资料，详细的了解下nextTick到底该如何理解并且在实际项目中哪些地方会用到这个方法。 Node.js是单线程的，基于事件循环，非阻塞IO的。事件循环中使用一个事件队列，在每个时间点上，系统只会处理一个事件，即使电脑有多个CPU核心，也无法同时并行的处理多个事件。因此，node.js适合处理I／O型的应用，不适合那种CPU运算密集型的应用。在I／O型的应用中，给每一个输入输出定义一个回调函数，node.js会自动将其加入到事件轮询的处理队列里，当I／O操作完成后，这个回调函数会被触发，系统会继续处理其他的请求。 理解在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。 在这种处理模式下，process.nextTick()的意思就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行。我们来看一个例子。例子中有一个foo()，你想在下一个时间点上调用他，可以这么做： 12345function foo() &#123; console.error('foo');&#125;process.nextTick(foo);console.error('bar'); 运行上面的代码，你从下面终端打印的信息会看到，”bar”的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。 12barfoo 你也可以使用setTimeout()函数来达到貌似同样的执行效果： 12setTimeout(foo, 0);console.log('bar'); 但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时。process.nextTick()定义的调用会创建一个新的队列。在当前的队列里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须结束队列操作。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的队列。 具体使用场景在多个事件里交叉执行CPU运算密集型的任务在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。 但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。 1234567891011var http = require('http');function compute() &#123; // performs complicated calculations continuously // ... process.nextTick(compute);&#125;http.createServer(function(req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('Hello World');&#125;).listen(5000, '127.0.0.1');compute(); 在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。 当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。 保持回调函数异步执行的原则当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则： 123456789101112function maybeSync(arg, cb) &#123; if (arg) &#123; cb(); return; &#125; fs.stat('file', cb);&#125;maybeSync(true, function() &#123; foo();&#125;);bar(); 这段代码不明确的地方是, 我们不清楚foo()和bar()哪个会被先调用，使用nextTick将回调函数变成异步的。这样写更好： function definitelyAsync(arg, cb) { if (arg) { process.nextTick(cb); return; } fs.stat('file', cb); } 用在事件触发过程中来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写： var EventEmitter = require('events').EventEmitter; function StreamLibrary(resourceName) { this.emit('start'); // read from the file, and for every chunk read, do: this.emit('data', chunkRead); } StreamLibrary.prototype.__proto__ = EventEmitter.prototype; // inherit from EventEmitter 下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件： var stream = new StreamLibrary('fooResource'); stream.on('start', function() { console.log('Reading has started'); }); stream.on('data', function(chunk) { console.log('Received: ' + chunk); }); 但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本： function StreamLibrary(resourceName) { var self = this; process.nextTick(function() { self.emit('start'); }); // read from the file, and for every chunk read, do: this.emit('data', chunkRead); }","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"node","slug":"node","permalink":"http://www.iwangqi.com/tags/node/"}]},{"title":"ajax如何截取302响应","date":"2017-04-02T12:09:11.000Z","path":"ajax/","text":"在ajax请求中，如果服务器端的响应是302 Found，在ajax的回调函数中能够获取这个状态码吗？能够从Response Headers中得到Location的值进行重定向吗？让我们来一起看看实际情况。 使用jQuery的$.ajax()发起ajax请求的JavaScript代码如下：1234567891011$.ajax(&#123;url: '/oauth/respond',type: 'post',data: data,complete: function(jqXHR)&#123; console.log(jqXHR.status);&#125;,error: function (xhr) &#123; console.log(xhr.status);&#125;&#125;); 当服务器端返回302 Found的响应时，浏览器中的运行结果如下： 在ajax的complete()与error()回调函数中得到的状态码都是404，而不是302。为什么呢？在stackoverflow上找到了答案： 原来，当服务器将302响应发给浏览器时，浏览器并不是直接进行ajax回调处理，而是先执行302重定向——从Response Headers中读取Location信息，然后向Location中的Url发出请求，在收到这个请求的响应后才会进行ajax回调处理。大致流程如下： ajax -&gt; browser -&gt; server -&gt; 302 -&gt; browser(redirect) -&gt; server -&gt; browser -&gt; ajax callback 而在我们的测试程序中，由于302返回的重定向URL在服务器上没有相应的处理程序，所以在ajax回调函数中得到的是404状态码；如果存在对应的URL，得到的状态码就是200。 所以，如果你想在ajax请求中根据302响应通过location.href进行重定向是不可行的。 如何解决？【方法一】继续用ajax，修改服务器端代码，将原来的302响应改为json响应，比如下面的ASP.NET MVC示例代码： 123456789101112131415return Json(new &#123; status = 302, location = \"/oauth/respond\" &#125;);ajax代码稍作修改即可：$.ajax(&#123; url: '/oauth/respond', type: 'post', data: data, dataType: 'json', success: function (data) &#123; if (data.status == 302) &#123; location.href = data.location; &#125; &#125;&#125;); 【方法二】不用ajax，改用form。 12&lt;form method=\"post\" action=\"/oauth/respond\"&gt;&lt;/form&gt;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://www.iwangqi.com/tags/ajax/"},{"name":"302","slug":"302","permalink":"http://www.iwangqi.com/tags/302/"}]}]