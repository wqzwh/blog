[{"title":"WebGL系列教程--缓冲区对象","date":"2017-07-03T13:09:11.000Z","path":"webgl-2017-07-03/","text":"attribute 变量的使用主要职能是在顶点着色器当中使用的，只能被申明为全局变量，用来表示顶点的信息，比如一个图形中包含多个顶点，顶点着色器是针对逐顶点进行运算的，都会传导到attribute变量中，然而，两个顶点之间的部分是不会被传导到顶点着色器中的。 这个变量只能支持矢量和矩阵两种类型，attribute变量的个数限制和设备有关系，最小支持8个attribute变量。 在顶点着色器中，声明 attribute 变量 将 attribute 变量赋值给 gl_Position 变量 向 attribute 变量传递数据 首先创建顶点着色器的基本代码： 1234567// 顶点着色器程序const vertexShaderSource = `attribute vec4 apos; void main() &#123; gl_Position = apos; gl_PointSize = 10.0;&#125;` 书写基本的片元着色器的代码：12345// 片元着色器程序const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,0.5,0.0,1.0); &#125;` 获取webgl上下文代码：1var cxt = canvas.getContext('webgl'); 获得顶点着色器和片元着色器对象,并且把源代码写入到顶点着色器及片元着色器中去，然后进行编译，片段代码如下：123456var vertexShader = cxt.createShader(cxt.VERTEX_SHADER);var fragmentShader = cxt.createShader(cxt.FRAGMENT_SHADER);cxt.shaderSource(vertexShader,vertexShaderSource);cxt.shaderSource(fragmentShader,fragmentShaderSource);cxt.compileShader(vertexShader);cxt.compileShader(fragmentShader); 创建program，并且将顶点着色器和片元着色器附着在program上，代码如下12345var program = cxt.createProgram();cxt.attachShader(program,vertexShader);cxt.attachShader(program,fragmentShader);cxt.linkProgram(program);cxt.useProgram(program); 得到顶点着色器中的变量apos，片段代码如下：1var aposLocation = cxt.getAttribLocation(program,'apos'); 清屏处理，代码如下：12cxt.clearColor(0.2,0.2,0.2,1.0);cxt.clear(cxt.COLOR_BUFFER_BIT); 通过for循环来绘制多个点，代码如下：1234for(var i= 0,num = points.length;i&lt;num;i++)&#123; cxt.vertexAttrib4f(aposLocation,points[i].x,points[i].y,1.0,1.0); cxt.drawArrays(cxt.POINTS,0,1);&#125; 缓冲区对象的创建、绑定、写入数据缓冲区对象是什么 绘制面所必需的技术 一次性写入多个顶点数据 一块内存区域 创建缓冲区对象 创建缓冲区的方法 var buffer = gl.createBuffer() 根据返回值判断是否创建成功 绑定缓冲区方法 gl.bindBuffer(gl.ARRAY_BUFFER , buffer) 写入数据 gl.bufferData(gl.ARRAY_BUFFER , data , gl.STATIC_DRAW) data 是类型化数组 gl.STATIC_DRAW，一次写入多次绘制 gl.STREAM_DRAW，一次写入多次绘制，比第一次调用的少 gl.DYNAMIC_DRAW，多次写入多次绘制 类型化数组接口都是通过类型化数组来进行通信 Int8Array Uint8Array Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array 缓冲区数据导入 attribute 变量 vertexAttribPointer(location , size , type , normalized , stride , offset ) 错误信息 INVALID_OPERATION，表示没有可用的program对象 错误信息 INVALID_VALUE，表示attribute的最大值已经超出的范围 enableVertexAttribArray(location)，激活localtion 错误信息 INVALID_OPERATION，表示没有可用的program对象 代码分析创建类型化数组对象1234567var data = new Float32Array([ -1.0,1.0, 1.0,1.0, -1.0,-1.0, 1.0,-1.0, 0.0,0.0]); 创建buffer和绑定baffer片段代码如下：12var buf = cxt.createBuffer();cxt.bindBuffer(cxt.ARRAY_BUFFER,buf); 将类型化数组绑定到缓冲区中：1cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW); 将缓冲区数据导入attribute变量中：12cxt.vertexAttribPointer(aposLocation,2,cxt.FLOAT,false,0,0);cxt.enableVertexAttribArray(aposLocation); 开始绘制，代码如下：123cxt.clearColor(0.0,0.5,0.5,1.0);cxt.clear(cxt.COLOR_BUFFER_BIT);cxt.drawArrays(cxt.POINTS,0,5); 完整代码如下：1234567891011121314151617181920212223242526272829303132333435&lt;canvas id=\"e03\" width=\"500\" height=\"500\"&gt;&lt;/canvas&gt;&lt;script src=\"../lib.js\"&gt;&lt;/script&gt;&lt;script&gt; var canvas = document.getElementById('e03'); var cxt = canvas.getContext('webgl'); // 顶点着色器程序 const vertexShaderSource = `attribute vec4 apos; void main() &#123; gl_Position = apos; gl_PointSize = 10.0; &#125;` // 片元着色器程序 const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,0.5,0.0,1.0); &#125;` var program = initShader(cxt,vertexShaderSource,fragmentShaderSource); var aposLocation = cxt.getAttribLocation(program,'apos'); var buffer = cxt.createBuffer(); cxt.bindBuffer(cxt.ARRAY_BUFFER,buffer); var data = new Float32Array([ -1.0,1.0, 1.0,1.0, -1.0,-1.0, 1.0,-1.0, 0.0,0.0 ]); cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW); cxt.vertexAttribPointer(aposLocation,2,cxt.FLOAT,false,0,0); cxt.enableVertexAttribArray(aposLocation); cxt.clearColor(0.0,0.5,0.5,1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.drawArrays(cxt.POINTS,0,5);&lt;/script&gt; 运行效果图如下： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/03","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--基本概述","date":"2017-07-02T13:09:11.000Z","path":"webgl-2017-07-02/","text":"WebGL是什么在浏览器绘制3D图形的的一门技术，是内嵌在浏览器中，目前支持高版本浏览器，因此不需要安装任何插件，同样也支持多平台运行，它是基于OpenGL ES 2.0技术。 优势 快速传播 维护简单 跨平台性 开放的标准 硬件加速 无需安装插件 充分利用浏览器功能 图形API模式即时模式，每一帧的场景不管是否发生了变化，都需要重新绘制，提供API的图形库并没有保存需要绘图场景的内部模型，但是应用程序需要在内存中用自己的方式表示场景，这种设计模式大大提高了应用程序的灵活性和控制的能力，但是需要应用程序执行更多的操作，如跟踪场景的模型，应用初始化等等，包括清除操作。webGL采用的是即时模式，非常灵活，但是相对而言手工代码会多一点。 保留模式，它的API保留了所有图形库的模型和场景，但应用程序调用保留模式API时需要更新内部的模型，图形库决定在什么时候执行实际的绘制方法，这意味着不需要为每一帧场景重新绘制命令，因此保留模式API似乎更容易使用。 图像硬件介绍 WebGL程序执行原理图形流水线 通过顶点来确定图形，具备形状之后内部时空的，通过光栅化进行“面积”的填充，然后进入片元着色器，进入“绘图”过程，类似上色过程，再次进逐片元操作 定点着色器 顶点着色器源代码，javascript字符串形式表示出来 内置变量，名字不可辨，区分大小写 自定义 Attribute 变量，表示每一个点的数据，可以定义多个 自定义 Uniform 变量，表示一个常量，是个恒定的，所有点的数据都是一样的 自定义 Varying 变量，定点着色器和片着色器传导数据用的 片元着色器 片元着色器源代码，javascript字符串形式表示出来 内置变量，名字不可辨，区分大小写 Uniform 和 Samplers，Samplers用来储存纹理 自定义 Varying 变量，定点着色器和片着色器传导数据用的 WebGL和HTML5及Javascript的关系 需要 HTML5 Canvas 元素，webgl和canvas画图都需要canvas这个api 用 Javascript 处理逻辑 可利用支持 HTML5 浏览器的一切功能 用 Javascript 字符串形式编写着色器源代码 基本示例代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body onload=\"main()\"&gt; &lt;canvas id=\"webgl\" width=\"500\" height=\"400\"&gt;&lt;/canvas&gt; &lt;script src=\"../lib/webgl-utils.js\"&gt;&lt;/script&gt; &lt;script src=\"../lib/webgl-debug.js\"&gt;&lt;/script&gt; &lt;script src=\"../lib/cuon-utils.js\"&gt;&lt;/script&gt; &lt;script&gt; // 顶点着色器程序 const VSHADER_SOURCE = `void main() &#123; gl_Position = vec4(1.0,0.0,0.0,1.0); gl_PointSize = 30.0; &#125;` // 片元着色器程序 const FSHADER_SOURCE = `void main() &#123; gl_FragColor = vec4(1.0,1.0,0.0,1.0); &#125;` function main() &#123; // 获取canvan元素 var canvas = document.getElementById(\"webgl\"); // 获取webgl绘图上下文 var gl = getWebGLContext(canvas, true); if (!gl) &#123; console.log('error'); return; &#125; // 初始化着色器 if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) &#123; console.log('error'); return; &#125; // 制定清空canvas的颜色 gl.clearColor(0.0, 0.0, 0.0, 1.0); // 清空canvas gl.clear(gl.COLOR_BUFFER_BIT); // 绘制一个点 gl.drawArrays(gl.POINTS, 0, 1); &#125; &lt;/script&gt;&lt;/body&gt; 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/02","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--3D图形学入门","date":"2017-07-01T13:09:11.000Z","path":"webgl-2017-07-01/","text":"3D的基本元素2D坐标系由x轴和y轴构成。其中，笛卡尔坐标系是最常见的2D坐标系。原点为（0.0），每个系统的坐标系不一样，有的系统y轴是正方向，有的是y轴的负方向为正方向。 HTML5 canvas2D坐标系,canvas坐标原点在左上角，从x为右是正方向，向下为y轴的正方向 示例代码片段：1234567891011121314151617&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;canvas id=\"canvas\"&gt;&lt;/canvas&gt;&lt;script&gt; var cxt = canvas.getContext('2d'); // 设置正方体左上角坐标（x，y） var x = 50; var y = 50; // 绘制正方形 cxt.fillRect(x,y,50,50);&lt;/script&gt; 效果如下： 修改x和y轴后展示效果如下：123// 设置正方体左上角坐标（x，y）var x = 0;var y = 0; 3D坐标系增加了表示深度的z轴，即3D物体离屏幕的深度。 WebGL坐标系的方向，向上为y轴的正方向，向右为x轴的正方向，从原点向外为z轴的正方向。绘图的可视范围是+1到-1之间 基本示例代码如下：12345 const VSHADER_SOURCE = `void main() &#123; gl_Position = vec4(1.0,0.0,0.0,1.0); gl_PointSize = 30.0;&#125;` webgl规定1.0为可视区域的最外层，不是像素值的意义。 三角形是基础图形，所有的图形都能根据三角形进行拼凑而成，也就是3D图形是由一个或者多个三角形组成；网格是由一个或者多个图形组成。 法线:始终垂直于某平面的虚线，在几何中，法线是指平面上垂直于曲线在某点切线的直线。法线和切线的交点称作切点，法线在3D绘图当中尤其在切图当中起到很大作用，通常的切图会失真，用法线切图方式算法的切图效果相对比较逼真。 3D的变换概念变换：变换的原理是对顶点的改变，变换的方式有三种，分别是缩放、平移、旋转。 旋转规定Z轴不变，定义初始旋转角度变量，示例代码我们先用着色器来计算顶点坐标位置，性能会比较低，在实际开发中，会定义矩阵来计算复杂的位置，示例代码片段如下：12345678910111213141516171819// 定义旋转角度var ANGLE = 30.0;const VSHADER_SOURCE = ` attribute vec4 a_Position; uniform float u_CosB,u_SinB; attribute float a_PointSize; void main() &#123; gl_Position.x = a_Position.x * u_CosB - a_Position.y * u_SinB; gl_Position.y = a_Position.x * u_SinB - a_Position.y * u_CosB; gl_Position.z = a_Position.z; gl_Position.w = 1.0; &#125;`// 片元着色器程序const FSHADER_SOURCE = ` precision mediump float; uniform vec4 u_FragColor; void main() &#123; gl_FragColor = vec4(1.0,1.0,0.0,1.0); &#125;` 矩阵：解决的复杂是针对着色器的，在实际开发中，应保证着色器的简单，因为着色器越复杂性能就越低。在webgl中矩阵可以理解为是一种数据类型，专门处理复杂的计算，可以进行乘法和加法的运算。代码片段如下：1234567891011121314// 定义矩阵的方式来处理变换效果// 定义旋转角度var ANGLE = 30.0;const VSHADER_SOURCE = ` attribute vec4 a_Position; uniform mat4 u_xformMatrix; //定义矩阵来变化 void main() &#123; gl_Position = u_xformMatrix * a_Position; &#125;`// 片元着色器程序const FSHADER_SOURCE = ` void main() &#123; gl_FragColor = vec4(1.0,1.0,0.0,1.0); &#125;` 网格表面纹理与材质：纹理可以定义网格表面的外观，例如在模型上贴一张图片；材质是网格表面的特性，也就是光滑度、透明度等等。光照原理：光线方向决定物体的明暗度与阴影,在着色过程中，需要考虑光源类型与反射类型。光照类型：平行光（从一个方向平行的打在一个物体上，有方向感的）、点光源光（由中心光源散发出来的光线，越往四周光线越弱）、环境光（在任何一个地方，光线的强弱都是一样的） 反射类型：漫反射光色由入射光色、表面漆色和入射角决定，环境反射由入射光色和表面漆色决定。 着色器代替传统的固定渲染管线，固定的渲染管线是不可变的；着色器具有可编程性的；着色器分为，顶点着色器和片元着色器。 顶点着色器：顶点着色器用来描述顶点的位置、颜色的程序，写法类似c语言，会定义一个主函数main，同时有系统变量，这个变量是不可以变的，变量对应的值是强类型，片段代码如下： 1234void main() &#123; gl_Position = vec4(0.0,0.0,0.0,1.0); gl_PointSize = 20.0;&#125; 片元着色器：对网格表面像素的处理程序，例如网格表面的贴图就需要用到片元着色器，系统变量对应的值是不能超过1.0的，片段代码如下： 123void main()&#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0);&#125; 3D世界相机、视口、投影：相机角度的不同，观察物力的景象就是不同的，远近决定观察看到物体的大小不同，图片中绿色的区域表示视口，也就是canvas决定的，它的大小决定了可视化的范围，红色部分表示场景显示最远能够到哪里，两者之间的可视化锥体，就代表可视化的范围，最终的影像会在视口中呈现出来，大小是由相机决定的。投影的概念就是物体投影在前方视口最终形成的影像。 这一节简要的介绍了以上几个概念的基本知识，下一节将介绍WebGL的基本概念。后期所有的例子都会提供源码供大家下载。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"React深入浅出系列--如何设计高质量的React组件","date":"2017-06-12T13:09:11.000Z","path":"2017-06-12/","text":"组件的设计要素在项目开发初期，针对模块或者组件的分配是及其重要，基本会按照“分而治之”的思想去合理的设计组件的功能以及扩展它们的复用性等等。拆分组件最关键的就是确定组件功能的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的职责，那这两个组件本身就不该被拆分，作为同一个组件或许更加合理。 组件的划分需要满足两个基本原则：高内聚和低耦合 高内聚:把逻辑紧密相关的内容放在一个组件中。早期开发html、css、js基本会以三个不同的文件存放，这样其实是违背高聚合的原则，react正好提供将跟组件相关的css、js、html放在一起的语法结构，这样一来，组件的复用性能够达到极致。 低耦合:不同的组件之间的依赖关系要尽量弱化。也就是每个组件要尽量独立。保持整个系统的低耦合度，让不同的组件去实现不同的功能，复杂的功能是通过细分的组件组装起来完成的，这样设计的话，方便开发者写出低耦合的系统。 react组件的数据react组件的数据主要分两种：prop和state。无论prop、state的改变都可能引发组件的渲染，其实react有基本的规范，prop主要作为组件对外部的接口，负责接受其他组件传过来的数据参数等，state主要是组件内部定义的数据状态，仅仅属于当前组件内部使用，片段代码如下： 123456789101112131415161718192021222324252627282930// 定义一个子组件class Counter extends Component &#123; constructor(props) &#123; // 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props super(props); //使用state定义自己内部状态数据 this.state = &#123; text: 1 &#125; &#125; render() &#123; const &#123;caption&#125; = this.props; //通过this.props来获取父亲组件传进来的caption值 return ( &lt;div className=\"App\"&gt; &#123;this.state.text&#125; &lt;/div&gt; ); &#125;&#125;// 定义一个父组件class ControlPanel extends Component &#123; render() &#123; console.log('enter ControlPanel render'); return ( &lt;div style=&#123;style&#125;&gt; &lt;Counter caption=\"First\"/&gt; &lt;/div&gt; ); &#125;&#125;; React中的prop给prop赋值和读取prop的值，以下只是代码片段，主要为了解释那些是赋值那些是读取值1234567891011121314//在构造函数中读取父组件传过来的值constructor(props) &#123; // 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props super(props); //使用state定义自己内部状态数据 this.state = &#123; text: 1 &#125; &#125;//在render函数中返回一个组件，并且带上要给该组件传递的数据 return ( &lt;Counter caption=\"First\"/&gt;); 如果一个组件需要定义自己的构造函数，一定要在构造函数的第一行通过super调用父级也就是React.Component的构造函数，只有这样才能通过this.props来获取父级传下来的数据。因此常常会在构造函数中绑定this的指向，避免在render中多次绑定而造成性能问题。 propTypes的检查通过propTypes属性来定义prop规格，在组件渲染运行和静态代码检查时，都可以根据propTypes判断外部传递数据的格式是否正确，基本代码片段如下：1234Counter.propTypes = &#123; caption:PropTypes.string.isRequired, initValue:PropTypes.number&#125;其中要求caption必须是string类型，initValue必须是number类型，isRequired代表该caption必须传递，不能缺失，而initValue可以不传。 所以在具体项目开发中，最好的方式是，在开发模式下带上propTypes，而在上线的时候可以去掉这些代码，可以用babel-react-optimize工具自动去除propTypes，这样部署到产品环境的代码就会更优。 React中的statestate代表组件内部状态，常常用来定义组件内部初始值。组件内部的state必须是一个对象，不能是string或者number这样简单的数据类型。基本使用如下：123456constructor(props) &#123; this.state = &#123; text: 1, // 使用state定义自己内部状态数据 num:props.num || 1 // 接受父组件传来的参数 &#125; &#125;在当前组件对象内部通过this.state来访问内部定义的变量，如果要改变状态千万不要直接通过this.state赋值改变，使用react提供的setState这个方法来改变状态，这样改变能够直接触发组件重新render使得界面绑定的相应的状态更新。 prop和state的对比 prop用于定义外部接口，state用于定义内部状态； prop的赋值在外部世界使用组件时，state的赋值在组件内部； 组件不应该改变prop的值，而state存在的目的就是让组件来改变的； 一个子组件去修改props中的值，就是违背react的设计初衷，如果必须修改，建议使用组件内部状态先保存props，然后通过改变组件内部状态变相改变了props。 使用prop建立组件间的通信应用示例如下： 使用prop建立组件间的通信原理就是在子组件内部定义改变内部状态的方法并且触发父组件改变父组件的方法，并且在自组件自定一个空函数作为父子组件通信的桥接。 具体实现代码如下，我们现在Counter子组件中定义需要改变状态的方法，除了触发改变内部状态的updateCount方法，同时也会触发父组件的this.props.onUpdate方法：123456789101112131415onClickIncrementButton() &#123; this.updateCount(true);&#125;onClickDecrementButton() &#123; this.updateCount(false);&#125;updateCount(isIncrement) &#123; const previousValue = this.state.count; const newValue = isIncrement ? previousValue + 1 : previousValue - 1; this.setState(&#123;count: newValue&#125;) this.props.onUpdate(newValue, previousValue)&#125; 接下来我们定义一个默认的空函数，来桥接父子组件通信，代码片段如下：12345678910Counter.propTypes = &#123; caption: PropTypes.string.isRequired, initValue: PropTypes.number, onUpdate: PropTypes.func&#125;;Counter.defaultProps = &#123; initValue: 0, onUpdate: f =&gt; f //什么都不做的函数&#125;; 并且在父组件中建立相应的更新方法，并且在render将onCounterUpdate方法以onUpdate名字传递给子组件中，自组件定义onUpdate来接受父组件传递下来的方法，从而解决了父子组件的通信，代码片段如下：123456789101112131415onCounterUpdate(newValue, previousValue) &#123; const valueChange = newValue - previousValue; this.setState(&#123; sum: this.state.sum + valueChange&#125;);&#125;render() &#123; return ( &lt;div style=&#123;style&#125;&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"First\" /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Second\" initValue=&#123;this.initValues[1]&#125; /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Third\" initValue=&#123;this.initValues[2]&#125; /&gt; &lt;hr/&gt; &lt;div&gt;Total Count: &#123;this.state.sum&#125;&lt;/div&gt; &lt;/div&gt; );&#125; 使用prop传递参数的局限从上面的示例不难看出，子组件和父组件都各自维护一套属于自己的状态，并且通过update来相互通信，如果update内部内部逻辑出现bug，这个时候，计数器的结果到底是子组件的对还是父组件的对呢，这个时候就需要共享状态的概念出现，通过一个全局状态来同步各个子组件内部的状态，开发者也只要关注共享全局状态走向就行。 组件状态不统一：全局状态同步状态： 如果一个系统中，存在多层嵌套组件，如果按照prop规则传递参数，岂不是非常麻烦，所以必须引入全局状态Redux，将在下节中为大家介绍基本的Redux思想及原理。 react生命周期介绍生命周期基本分成三个主要阶段： 装载过程，组件第一次渲染过程 更新过程，当组件重新渲染过程 卸载过程，组件从DOM中删除过程 装载过程依次调用一下生命周期函数方法(按照es6最新语法介绍)： constructor defaultProps componentWillMount render componentDidMount constructor这是es6中构造函数的写法，如果是无状态的React组件无需定义构造函数，因此定义构造函数基本的作用是： 初始化state，在组件定义个函数中需要访问state状态。 绑定函数的this上下文。 代码片段如下：12345constructor(props) &#123; super(props); this.onClickIncrementButton = this.onClickIncrementButton.bind(this); this.onClickDecrementButton = this.onClickDecrementButton.bind(this); &#125; defaultProps主要作用是给props定义初始值，基本写法如下：1234Counter.defaultProps = &#123; initValue: 0, onUpdate: f =&gt; f //什么都不做的函数&#125;; render主要作用返回一个JSX描述的结构，最终再交付给React来操作渲染，组件在有些情况下如果不需要返回JSX结构，可以通过返回null或者false来告诉React不渲染任何DOM元素。 注意：在render中不要操作对状态的改变，应该在自定义函数中改变 componentWillMount和componentDidMountcomponentWillMount在render函数之前调用，也就是DOM还没有挂载，这个时候如果调用this.setState修改状态也不会发生重新渲染，其实我们可以在创建构造函数中就做好在componentWillMount应该做的事情。此函数既可以在服务端被调用，也可以在浏览器端被调用。 componentDidMount在render之后调用，也就是挂载DOM的操作，如果一个父组件嵌套多个子组件，这个时候挂载DOM的顺序是等到子组件全部调用render函数之后再开始挂载相应子组件的DOM。该函数只能在浏览器端被调用。如果需要对DOM操作的话，建议可以在componentDidMount中定义函数进行操作。DOM挂载顺序结果如下： 更新过程 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate componentWillReceiveProps这个函数是根据新的props的值来计算出是不是要更新组件内部state状态。同同时，只要父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发componentWillReceiveProps函数运行。 在Counter组件中增加函数：123componentWillReceiveProps(nextProps) &#123; console.log('enter componentWillReceiveProps ' + this.props.caption) &#125; 在ControlPanel函数中定义强制更新函数：1234567891011121314render() &#123; console.log('enter ControlPanel render'); return ( &lt;div style=&#123;style&#125;&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"First\" /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Second\" initValue=&#123;this.initValues[1]&#125; /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Third\" initValue=&#123;this.initValues[2]&#125; /&gt; &lt;button onClick=&#123; () =&gt; this.forceUpdate() &#125;&gt; Click me to re-render! &lt;/button&gt; &lt;hr/&gt; &lt;div&gt;Total Count: &#123;this.state.sum&#125;&lt;/div&gt; &lt;/div&gt; );ControlPanel组件中触发了render函数，子组件中的componentWillReceiveProps都被触发了，但是并没有改变props的值，运行结果截图如下： 这个函数会接受nextProps参数，一般会用nextProps（这一次渲染传入的值）与this.props（上一次渲染传入的值）进行比较，只有两者有变化的时候才会调用this.setState更新内部状态。 shouldComponentUpdate主要作用根据nextProps, nextState接收的两个参数来判断组件是否需要执行render函数，react中这个函数如果不做任何设置，默认都是返回true，所以再做性能优化的时候，这个函数起到了至关重要的作用。在Counter组件中增加函数：1234shouldComponentUpdate(nextProps, nextState) &#123; return (nextProps.caption !== this.props.caption) || (nextState.count !== this.state.count); &#125;改变任何一个值，只会触发当前这个组件调用render函数，运行结构如下： componentWillUpdate和componentDidUpdate只要shouldComponentUpdate函数返回为true，就会以此调用componentWillUpdate、render、componentDidUpdate这三个函数，同样这两个函数即可以在服务端调用也可以在浏览器端调用。 卸载过程这个过程主要是卸载不使用的组件DOM元素，或者使用非React方式创建的DOM元素，还是非常有作用的，例如，如果在componentDidMount中可以使用了js原生创建了DOM元素，但是在组件卸载过程中没有清楚，这个时候会造成内存泄露，所以在使用卸载组件的函数，必须确定相关的DOM都清除。 本篇简要的React组件的通信和基本的生命周期运行流程，在使用prop通信会有一定的局限，下节会引入Redux共享状态概念，来解决prop传递的局限，本篇涉及到的源码可以访问https://github.com/wqzwh/react-redux-demo/tree/master/src/demo/01","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"}]},{"title":"React深入浅出系列--React的工作方式","date":"2017-06-11T13:09:11.000Z","path":"2017-06-11/","text":"jQuery如何工作在讲解React的工作方式之前，先了解下jQuery的工作方式，我们使用jQuery给网页添加一个onclick事件基本写发如下：12345678910&lt;div&gt; &lt;button type=\"btn\" id=\"btn\"&gt;点击我&lt;/button&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $(\"#btn\").click(fucntion()&#123; // do some things &#125;) &#125;)&lt;/script&gt;在jQuery的解决方案中，首先根据css规则找到id为btn的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。 但是对于庞大的项目，这种模式会造成代码结构复杂，难易维护，每个jQuery的使用者都会有这种体会。 React的理念react给dom添加事件并不是通过选择器选中某个dom，然后添加相应的事件，使用react开发，开发者不需要关心dom的组成结构，只需关注数据从哪里来，该去哪个组件中显示，也就是关心整个数据流的走向，通过render函数将相应的数据显示在界面上，如果需要更新界面，只需要找到相应的数据data更新即可，用户界面自然会做出响应，所以说react也是响应式编程。 Virtual DOM对于改变普通的html中的DOM会造成页面的重排和重绘，这也是前端性能优化主要的方面，就是尽量减少对DOM的操作。其实虚拟DOM说的简单点就是js动态生成的html标签在js内存中存储，并没有实际插入到页面当中。例如使用createElement（’Button’）和DocumentFragment创建虚拟的标签。简单的虚拟DOM代码示例如下，主要是方面从简单的层面理解虚拟DOM： 1234567var frag=document.createDocumentFragment();for(var i=0;i&lt;10;i++)&#123; var l=document.createElement(\"li\"); l.innerHTML=\"ss\"; frag.appendChild(l);&#125;document.getElementById(\"list\").appendChild(frag); 当然React中的虚拟DOM并没有像以上的例子这么简单，但是核心思想是这样的，相比直接操作DOM而言，通过操作js生成的DOM数结构改变映射到页面上的内容能提高不少性能。虚拟DOM就是对DOM树的抽象，仅仅是存在与javascript空间的树形结构，例如最简单的形式如下：1234567891011var a = &#123; type: 'a', props: &#123; children: 'React', className: 'link', href: 'facebook/react · GitHub' &#125;, _isReactElement: true&#125;React.render(a, document.body) 虚拟DOM中有个核心算法就是diff算法，主要实现以下三个步骤： 步骤一：用JS对象模拟DOM树 步骤二：比较两棵虚拟DOM树的差异 步骤三：把差异应用到真正的DOM树上react会根据diff算法计算出需要更新改变虚拟DOM，从而只更新页面中映射的那一小块DOM。对于diff算法以及react性能优化后期会单独用一节分析。 React工作方式的优点传统化的jquery的方式直观易懂，但是随着项目变得庞大时，用jquery写出的代码往往相互纠缠，难以维护。 使用react的方式，可以避免构建这样复杂的程序结构，无论何种事件，引发的都是react组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发这不需要关心。react利用函数式编程的思想来解决用户界面渲染问题，最大的优势能够提高开发效率，代码可维护性和可阅读性增强。 react会强制所有组件都按照这种由数据驱动渲染的模式来工作，无论应用多大，都让程序处于可控范围内。下一篇将为大家介绍如何设计高质量的React组件。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"}]},{"title":"React深入浅出系列--如何理解JSX","date":"2017-06-10T13:09:11.000Z","path":"2017-06-10/","text":"1、JSX介绍所谓JSX,是javascript的语法扩展，并不是一门新的编程语言，看起来有点像XML，让我们在javascript中可以编写像HTML一样的代码。例如以下示例代码：123456789101112class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;div className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;h2&gt;Welcome to React&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;JSX中的这几段代码看起来和HTML几乎一模一样，可以使用div,button之类的标签，但是，JSX和HTML之间还是有不同之处。 注意：React判断一个元素HTNML元素还是React组件的原则就是看第一个字母是否大写，小写的话，React会认为是HTML标签 12345678class App extends Component &#123; render() &#123; return ( &lt;hello/&gt; //默认认为是html标签，错误写法 &lt;Hello/&gt; //默认是自定义Hello组件 ); &#125;&#125; 2、事件绑定在早期时候绑定事件写法如下：1&lt;button onclick=\"checkAndSubmit(this.form)\"&gt;Submit&lt;/button&gt;随着业务不断复杂，虽然这种写法便于阅读，但是复杂的业务加上复杂的DOM结构，为了html和js解耦，所以绑定事件写法有如下变化，通过获取DOM节点，通过代理机制来绑定事件：1$('#my-button').on('click', this.checkAndSubmit.bind(this));然而react中的JSX绑定事件的写法格式如下：1&lt;button onClick=&#123;this.checkAndSubmit.bind(this)&#125;&gt;Submit&lt;/button&gt; 大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。注意：在真正开发中，并不提倡给在组件添加事件中bind（this）这种写法，一般会在constructor的时候就绑定上下文this，这样在组件里面就不会因为多次绑定this而造成内存泄露。 3、JSX绑定事件和html绑定事件的区别 在html添加事件有如下问题： 1、在html中使用onclick添加的事件处理函数是在全局环境下执行的，这样会污染全局环境，很容易产生意料不到的后果。 2、给多个DOM添加onclick事件，可能会影响网页性能，毕竟，网页需要的事件处理函数越多，性能就会越低。 3、对于使用onclick的DOM元素，如果要动态地从DOM树中删掉的话，需要把对应的时间处理器注销，假如忘了注销，就可能造成内存泄露，这样的bug很难被发现。 以上说的这些问题在JSX中都不存在，其有如下特点： 1、JSX中添加onclick事件并没有直接在相应的html中添加事件，而是使用了事件委托的方式处理点击事件，无论有多少个onclick的出现，其实最后都只在DOM树上添加一个事件处理函数，并挂载在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定的函数，使用事件委托的性能比为每一个onclick都挂载一个事件函数要高。 2、jsx中同样可以添加自定义样式，外层定义一个样式对象，然后在jsx中将对象赋值给相应的dom上，这样真正意义上组件封装的思想（html，css，js在一起），提高复用性，大致写法如下：123456789101112class App extends Component &#123; render() &#123; const Style = &#123; margin:'10px' &#125; return ( &lt;div style=&#123;Style&#125;&gt; &lt;p&gt;测试文字&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 4、JSX编译JSX是一种新的语法，浏览器并不能直接运行，因此需要这种翻译器。这里我们推荐使用Babel编译JSX，打包编译建议使用Webpack，大致配置如下：12345module: &#123; loaders: [ &#123; test: /\\.jsx?$/, loaders: ['babel-loader']&#125; ]&#125; 本文主要介绍JSX优势所在，在添加事件上性能高于普通的html添加事件形式，组件方式的开发模式，更利于代码的通用性和维护性，下一篇将为大家介绍React的理念／Virtual DOM／工作方式的优点。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"}]},{"title":"如何使用vue-ssr做服务端渲染初体验(三)","date":"2017-06-05T12:09:11.000Z","path":"vue-ssr3/","text":"1、前言上一节大致介绍了服务端和客户端入口文件代码内容，现在已经可以正常运行你的后端渲染脚手架了，这一节，跟大家分享下如何使用axios做ajax请求，如何使用mockjs做本地假数据，跑通本地基本逻辑，为以后前后端连调做准备。 2、前期准备需要用npm安装axios，mockjs依赖包,由于mockjs只是代码开发的辅助工具，所以安装的时候我会加–save-dev来区分，具体可以根据自己的需求来定，当然，如果有mock服务平台的话，可以直接走mock平台造假数据，本地直接访问mock平台的接口，例如可以使用阿里的Rap平台管理工具生成。 12npm install axios --savenpm install mockjs --save-dev 3、简要介绍axios 其他请求方式，代码示例如下： 1234567axios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]]) 具体详细可以点击查看axios基本使用介绍 api.js完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990function ajax(url, type, options) &#123; return Q.Promise((resolve, reject) =&gt; &#123; axios(&#123; method : type, url : url, // responseType:'stream', data : options &#125;) .then((result) =&gt; &#123; if (result &amp;&amp; result.status === 401) &#123; location.href = '/views/401.html' &#125; if (result &amp;&amp; result.status === 200) &#123; resolve(result.data); &#125; else &#123; reject(&#123; errno: result.errno, msg: result.msg &#125;); &#125; &#125;) .catch(function(error) &#123; console.log(error,url); &#125;); &#125;)&#125;const config = &#123; get(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'get', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, post(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'post', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, put(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'put', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, delete(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'delete', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, jsonp(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'jsonp', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;&#125;;export default config; mockjs项目基本配置如下： 1、在public下新建conf.js全局定义请求url地址，代码如下：1234module.exports = &#123; HOST: \"http://www.xxx.com\", DEBUGMOCK: true&#125;; 2、在component根目录下新建conf.js，定义组件mock的请求路径，并且定义是否开始单个组件使用mock数据还是线上接口数据，代码如下：12345678910111213141516const PUBCONF = require('../public/conf.js');export const DEMO = &#123; DEBUGMOCK : PUBCONF.DEBUGMOCK, INDEX_URL : PUBCONF.HOST + '/demo', INDEX_URL_MOCK : true &amp;&amp; PUBCONF.DEBUGMOCK&#125;export const ANOTHER_DEMO = &#123;&#125;export default &#123; DEMO, ANOTHER_DEMO&#125; 3、在组件内部定义conf.js文件，主要编写单个组件的基本配置信息，请求路径，mock数据对应的url地址，代码如下：123456789101112import &#123;DEMO&#125; from '../conf.js';const MODULECONF = &#123; 'demo': &#123; NAME: 'demo', ICON: '', MOCK: DEMO.INDEX_URL_MOCK, API: &#123; GET: DEMO.INDEX_URL, &#125; &#125;,&#125;;export default MODULECONF; 4、在组件内部定义mockjs来编写mock假数据，代码如下：12345678910import Mock from 'mockjs';export default Mock.mock('http://www.xxx.com/demo', &#123; errno: 0, msg: \"成功\", data: [&#123; 'name': '@name', 'age|1-100': 100, 'color': '@color' &#125;]&#125;); 查看数据返回效果，数据在控制台打印出来 以上就是基本的流程，如果有更好更灵活的使用方案，希望能够参与沟通并且分享，这里会有个问题，就是目前mockjs未能跟业务代码隔离，webpack如果单纯加上externals配置，项目打包后,直接本地运行会报错，找不到mockjs，不知道是不是自己配置的原因，但是基本的思想就是最终上线代码不要把工具类的函数打包进去。项目脚手架已经在github上分享，点击查看详情","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"如何使用vue-ssr做服务端渲染初体验(二)","date":"2017-06-02T12:09:11.000Z","path":"vue-ssr2/","text":"1、前言上一节我们大致讲了为什么需要使用vue后端渲染，以及vue后端渲染的基本原理，这节内容我们将从零开始搭建属于自己的vue后端渲染脚手架，当然不能不参考官方页面响应的实例vue-hackernews-2.0，从零开始搭建项目,源码在将在下节与大家共享。 2、前期准备基本环境要求：node版本6.10.1以上，npm版本3.10.10以上，本机环境是这样的，建议升级到官方最新版本。 使用的技术栈： 1、vue 2.4.22、vuex 2.3.13、vue-router 2.7.04、vue-server-renderer 2.4.25、express 4.15.46、axios 0.16.27、q https://github.com/kriskowal/q.git8、webpack 3.5.09、mockjs 1.0.1-beta310、babel 以上是主要是用的技术栈，在构建过程中会是用相应的插件依赖包来配合进行压缩打包，以下是npm init后package.json文件所要添加的依赖包。 3、项目主目录搭建基本目录结构如下： 文件目录基本介绍： components 主要存放组件代码，里面可以根据业务场景再次细分模块组件等。lib 主要存放第三方库文件，方便用户直接引入使用public 主要存放公共组件代码和项目使用的公共文件代码，例如后期我们将axios封装成公共的api库文件等等。router 主要存放前端路由配置文件，写法规范按照vue-router官方例子即可。store 主要是存放共享状态文件，里面包含action.js,getter.js,mutationtype.js,state.js等，后期会根据模块再细分这些。app.js 是项目入口文件App.vue 是项目入口文件entry-client和entry-server分别是客户端入口文件和服务端的入口文件index.template.html是整个项目的模版文件 开始编写app.js项目入口代码使用vue开发项目入口文件一般都会如下写法：1234567891011import Vue from 'vue';import App from './index.vue';import router from './router'import store from './store';new Vue(&#123; el: '#app', store, router, render: (h) =&gt; h(App)&#125;); 这种写法是程序共享一个vue实例，但是在后端渲染中很容易导致交叉请求状态污染，导致数据流被污染了。 所以，避免状态单例,我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例，同样router和store入口文件也需要重新创建一个实例。 为了配合webpack动态加载路由配置，这里会改写常规路由引入写法，这样可以根据路由路径来判断加载相应的组件代码： 123import Home from '../components/Home.vue'// 改写成component: () =&gt; ('../components/Home.vue') 以下是路由的基本写法router，对外会抛出一个createRouter方法来创建一个新的路由实例： 1234567891011121314import Vue from 'vue'import Router from 'vue-router';Vue.use(Router)export function createRouter() &#123; return new Router(&#123; mode: 'history', routes: [&#123; name:'home', path: '/', component: () =&gt; import ('../components/Home.vue') &#125;] &#125;)&#125; 以下是store状态管理的基本写法，对外暴露了一个createStore方法，方便每次访问创建一个新的实例： 12345678910111213141516import Vue from 'vue'import Vuex from 'vuex'import actions from './actions'import getters from './getters'// 按照组件的复杂度是否使用modulesimport Home from './modules/Home'Vue.use(Vuex)export function createStore() &#123; return new Vuex.Store(&#123; actions, getters, modules:&#123; Home &#125;, &#125;)&#125; 结合写好的router和store入口文件代码来编写整个项目的入口文件app.js代码内容，同样最终也会对外暴露一个createApp方法，在每次创建app的时候保证router，store，app都是新创建的实例，这里还引入了一个vue路由插件vuex-router-sync，主要作用是同步路由状态(route state)到 store，以下是app.js完整代码： 1234567891011121314151617181920import Vue from 'vue'import App from './App.vue'import &#123; createRouter &#125; from './router'import &#123; createStore &#125; from './store'import &#123; sync &#125; from 'vuex-router-sync'export function createApp () &#123; // 创建 router 和 store 实例 const router = createRouter() const store = createStore() // 同步路由状态(route state)到 store sync(store, router) // 创建应用程序实例，将 router 和 store 注入 const app = new Vue(&#123; router, store, render: h =&gt; h(App) &#125;) // 暴露 app, router 和 store。 return &#123; app, router, store &#125;&#125; entry-client.js代码编写：首页引入从app文件中暴露出来的createApp方法，在每次调用客户端的时候，重新创建一个新的app，router，store，部分代码如下： 12import &#123; createApp &#125; from './app'const &#123; app, router, store &#125; = createApp() 这里我们会使用到onReady方法，此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染的时候，例子代码如下： 12345import &#123; createApp &#125; from './app'const &#123; app, router, store &#125; = createApp()router.onReady(() =&gt; &#123; app.$mount('#app')&#125;) 我们会调用一个新方法beforeResolve，只有在router2.5.0以上的版本才会有的方法，注册一个类似于全局路由保护router.beforeEach()，除了在导航确认之后，在所有其他保护和异步组件已解决之后调用。基本写法如下： 123456router.beforeResolve((to, from, next) =&gt; &#123; // to 和 from 都是 路由信息对象 // 返回目标位置或是当前路由匹配的组件数组（是数组的定义/构造类，不是实例）。通常在服务端渲染的数据预加载时时候。 const matched = router.getMatchedComponents(to) const prevMatched = router.getMatchedComponents(from)&#125;) 服务端把要给客户端的 state 放在了 window.INITIAL_STATE 这个全局变量上面。前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（INITIAL_STATE），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。基本代码如下：1234// 将服务端渲染时候的状态写入vuex中if (window.__INITIAL_STATE__) &#123; store.replaceState(window.__INITIAL_STATE__)&#125; 接下来贴出来完整的客户端代码，这里的Q也可以不用引入，直接使用babel就能编译es6自带的Promise，因为本人使用习惯了，这里可以根据自身的需求是否安装：1234567891011121314151617181920212223242526272829303132import &#123; createApp &#125; from './app'import Q from 'q';const &#123; app, router, store &#125; = createApp()router.onReady(() =&gt; &#123; router.beforeResolve((to, from, next) =&gt; &#123; const matched = router.getMatchedComponents(to) const prevMatched = router.getMatchedComponents(from) // 我们只关心之前没有渲染的组件 // 所以我们对比它们，找出两个匹配列表的差异组件 let diffed = false const activated = matched.filter((c, i) =&gt; &#123; return diffed || (diffed = (prevMatched[i] !== c)) &#125;) if (!activated.length) &#123; return next() &#125; // 这里如果有加载指示器(loading indicator)，就触发 Q.all(activated.map(c =&gt; &#123; if (c.asyncData) &#123; return c.asyncData(&#123; store, route: to &#125;) &#125; &#125;)).then(() =&gt; &#123; // 停止加载指示器(loading indicator) next() &#125;).catch(next) &#125;) app.$mount('#app')&#125;)// 将服务端渲染时候的状态写入vuex中if (window.__INITIAL_STATE__) &#123; store.replaceState(window.__INITIAL_STATE__)&#125; entry-server.js代码编写：基本编写和客户端的差不多，因为这是服务端渲染，涉及到与后端数据交互定义的问题，我们需要在这里定义好各组件与后端交互使用的方法名称，这样方便在组件内部直接使用，这里根我们常规在组件直接使用ajax获取数据有些不一样，代码片段如下：1234567//直接定义组件内部asyncData方法来触发相应的ajax获取数据if (Component.asyncData) &#123; return Component.asyncData(&#123; store, route: router.currentRoute &#125;)&#125; 以下是完整的服务端代码：12345678910111213141516171819202122232425262728293031import &#123; createApp &#125; from './app'import Q from 'q'export default context =&gt; &#123; return new Q.Promise((resolve, reject) =&gt; &#123; const &#123; app, router, store &#125; = createApp() router.push(context.url) router.onReady(() =&gt; &#123; const matchedComponents = router.getMatchedComponents() if (!matchedComponents.length) &#123; return reject(&#123; code: 404 &#125;) &#125; // 对所有匹配的路由组件调用 `asyncData()` Q.all(matchedComponents.map(Component =&gt; &#123; if (Component.asyncData) &#123; return Component.asyncData(&#123; store, route: router.currentRoute &#125;) &#125; &#125;)).then(() =&gt; &#123; // 在所有预取钩子(preFetch hook) resolve 后， // 我们的 store 现在已经填充入渲染应用程序所需的状态。 // 当我们将状态附加到上下文， // 并且 `template` 选项用于 renderer 时， // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。 context.state = store.state resolve(app) &#125;).catch(reject) &#125;, reject) &#125;)&#125; 4、脚手架其他目录介绍：到这里src下面主要的几个文件代码已经编写完成，接下里介绍下整个项目的目录结构如下： 主要几个文件介绍如下：build 主要存放webpack打包配置文件dist webpack打包后生成的目录log 使用pm2监控进程存放的日志文件目录server.js node服务器启动文件pmlog.json pm2配置文件 server.js入口文件编写我们还需要编写在服务端启动服务的代码server.js，我们会使用到部分node原生提供的api，片段代码如下：1234567const Vue = require('vue')const express = require('express')const path = require('path')const LRU = require('lru-cache')const &#123; createBundleRenderer &#125; = require('vue-server-renderer')const fs = require('fs')const net = require('net') 大致思路是，引入前端模版页面index.template.html，使用express启动服务，引入webpack打包项目代码的dist文件，引入缓存模块（这里不做深入介绍，后期会单独详细介绍），判断端口是否被占用，自动启动其他接口服务。 引入前端模版文件并且设置环境变量为production，片段代码如下：12const template = fs.readFileSync('./src/index.template.html', 'utf-8')const isProd = process.env.NODE_ENV === 'production' vue-server-renderer插件的具体使用，通过读取dist文件夹下的目录文件，来创建createBundleRenderer函数，并且使用LRU来设置缓存的时间，通过判断是生产环境还是开发环境，调用不同的方法，代码片段如下：12345678910111213141516171819202122232425const resolve = file =&gt; path.resolve(__dirname, file)function createRenderer (bundle, options) &#123; return createBundleRenderer(bundle, Object.assign(options, &#123; template, cache: LRU(&#123; max: 1000, maxAge: 1000 * 60 * 15 &#125;), basedir: resolve('./dist'), runInNewContext: false &#125;))&#125;let renderer;let readyPromiseif (isProd) &#123; const bundle = require('./dist/vue-ssr-server-bundle.json') const clientManifest = require('./dist/vue-ssr-client-manifest.json') renderer = createRenderer(bundle, &#123; clientManifest &#125;)&#125; else &#123; readyPromise = require('./build/setup-dev-server')(server, (bundle, options) =&gt; &#123; renderer = createRenderer(bundle, options) &#125;)&#125; 使用express启动服务，代码片段如下：1234567891011121314151617181920const server = express()；//定义在启动服务钱先判断中间件中的缓存是否过期，是否直接调用dist文件。const serve = (path, cache) =&gt; express.static(resolve(path), &#123; maxAge: cache &amp;&amp; isProd ? 1000 * 60 * 60 * 24 * 30 : 0&#125;)server.use('/dist', serve('./dist', true))server.get('*', (req, res) =&gt; &#123; const context = &#123; title: 'hello', url: req.url &#125; renderer.renderToString(context, (err, html) =&gt; &#123; if (err) &#123; res.status(500).end('Internal Server Error') return &#125; res.end(html) &#125;)&#125;) 判断端口是否被占用，片段代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function probe(port, callback) &#123; var servers = net.createServer().listen(port) var calledOnce = false var timeoutRef = setTimeout(function() &#123; calledOnce = true callback(false, port) &#125;, 2000) timeoutRef.unref() var connected = false servers.on('listening', function() &#123; clearTimeout(timeoutRef) if (servers) servers.close() if (!calledOnce) &#123; calledOnce = true callback(true, port) &#125; &#125;) servers.on('error', function(err) &#123; clearTimeout(timeoutRef) var result = true if (err.code === 'EADDRINUSE') result = false if (!calledOnce) &#123; calledOnce = true callback(result, port) &#125; &#125;)&#125;var checkPortPromise = new Promise((resolve) =&gt; &#123; (function serverport(_port) &#123; var pt = _port || 8080; probe(pt, function(bl, _pt) &#123; // 端口被占用 bl 返回false // _pt：传入的端口号 if (bl === true) &#123; // console.log(\"\\n Static file server running at\" + \"\\n\\n=&gt; http://localhost:\" + _pt + '\\n'); resolve(_pt); &#125; else &#123; serverport(_pt + 1) &#125; &#125;) &#125;)()&#125;)checkPortPromise.then(data =&gt; &#123; uri = 'http://localhost:' + data; console.log('启动服务路径'+uri) server.listen(data);&#125;); 到这里，基本的代码已经编写完成，webpack打包配置文件基本和官方保持不变，接下来可以尝试启动本地的项目服务，查看基本的demo展示。 下节，我将介绍下mockjs，axios怎么封装成公共函数便于使用","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"如何使用vue-ssr做服务端渲染初体验(-)","date":"2017-06-01T13:09:11.000Z","path":"vue-ssr/","text":"1、前言服务端渲染实现原理机制：在服务端拿数据进行解析渲染，直接生成html片段返回给前端。然后前端可以通过解析后端返回的html片段到前端页面，大致有以下两种形式： 1、服务器通过模版引擎直接渲染整个页面，例如java后端的vm模版引擎，php后端的smarty模版引擎。2、服务渲染生成html代码块, 前端通过AJAX获取然后使用js动态添加。 2、服务端渲染的优劣服务端渲染能够解决两大问题： 1、seo问题，有利于搜索引擎蜘蛛抓取网站内容，利于网站的收录和排名。2、首屏加载过慢问题，例如现在成熟的SPA项目中，打开首页需要加载很多资源，通过服务端渲染可以加速首屏渲染。 同样服务端渲染也会有弊端，主要是根据自己的业务场景来选择适合方式，由于服务端渲染前端页面，必将会给服务器增加压力。 3、SSR的实现原理客户端请求服务器，服务器根据请求地址获得匹配的组件，在调用匹配到的组件返回 Promise (官方是preFetch方法)来将需要的数据拿到。最后再通过 1&lt;script&gt;window.__initial_state=data&lt;/script&gt; 将其写入网页，最后将服务端渲染好的网页返回回去。 接下来客户端会将vuex将写入的 initial_state 替换为当前的全局状态树，再用这个状态树去检查服务端渲染好的数据有没有问题。遇到没被服务端渲染的组件，再去发异步请求拿数据。说白了就是一个类似React的 shouldComponentUpdate 的Diff操作。 Vue2使用的是单向数据流，用了它，就可以通过 SSR 返回唯一一个全局状态， 并确认某个组件是否已经SSR过了。 4、vue后端渲染主要插件：vue-server-renderer由于virtual dom的引入，使得vue的服务端渲染成为了可能，下面是官方 vue-server-renderer提供的渲染流程图: 可以看出vue的后端渲染分三个部分组成：页面的源码（source），node层的渲染部分和浏览器端的渲染部分。 source分为两种entry point,一个是前端页面的入口client entry,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口server entry,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象（经过测试，直接返回Vue对象也是可以的）; 前面的source部分就是业务开发的代码，开发完成之后通过 webpack 进行构建，生成对应的bundle，这里不再赘述client bundle,就是一个可在浏览器端执行的打包文件；这里说下server bundle, vue2提供 vue-server-renderer模块，模块可以提供两种render: rendererer/bundleRenderer ,下面分别介绍下这两种render。 renderer接收一个vue对象 ，然后进行渲染，这种对于简单的vue对象,可以这么去做，但是对于复杂的项目，如果使用这种直接require一个vue对象，这个对于服务端代码的结构和逻辑都不太友好，首先模块的状态会一直延续在每个请求渲染请求，我们需要去管理和避免这次渲染请求的状态影响到后面的请求,因此vue-server-renderer提供了另外一种渲染模式，通过一个 bundleRenderer去做渲染。 bundleRenderer是较为复杂项目进行服务端渲染官方推荐的方式，通过webpack以server entry按照一定的要求打包生成一个 server-bundle,它相当于一个可以给服务端用的app的打包压缩文件，每一次调用都会重新初始化 vue对象，保证了每次请求都是独立的，对于开发者来说，只需要专注于当前业务就可以，不用为服务端渲染开发更多的逻辑代码。renderer生成完成之后，都存在两个接口，分别是renderToString和renderToStream，一个是一次性将页面渲染成字符串文件，另外一个是流式渲染，适用于支持流的web服务器，可以是请求服务的速度更快。 5、项目基本结构如下 如何从零开始搭建适合自己的vue后端渲染框架？","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"浅谈webworker的使用场景","date":"2017-05-07T13:09:11.000Z","path":"2017-05-07/","text":"一、webWorker之初体验在”setTimeout那些事儿”中，说到JavaScript是单线程。也就是同一时间只能做同一事情。 也好理解，作为浏览器脚本语言，如果JavaScript不是单线程，那么就有点棘手了。比如，与用户交互或者对DOM进行操作时，在一个线程上修改某个DOM，另外的线程删除DOM，这时浏览器该如何抉择呢? 所以，JavaScript是单线程也是有背景的。 如下： 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;singleThread&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //添加到任务队列中，待同步任务所处的‘执行栈’执行完毕，1秒后执行任务队列中的这个匿名函数 setTimeout(function()&#123; console.log('come on'); &#125;,1000); //只要不关闭该alert，‘执行栈’就没结束，从而也就不会进入到任务队列中 alert('waiting'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 但，HTML5引入了一个工作线程（webWorker）的概念。它允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。 简而言之，就是允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。 从而，可以用webWorker来处理一些比较耗时的计算。 如下，主页面： 12345678910111213141516171819&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; //创建一个Worker对象，并向它传递将在新线程中执行的脚本url var worker = new Worker('worker.js'); //接收worker传递过来的数据 worker.onmessage = function(event)&#123; document.getElementById('result').innerHTML+=event.data+\"&lt;br/&gt;\" ; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 下面是worker.js的内容: 123456789101112131415var i = 0;function timedCount()&#123; for(var j = 0, sum = 0; j &lt; 100; j++)&#123; for(var i = 0; i &lt; 100000000; i++)&#123; sum+=i; &#125;; &#125;; //将得到的sum发送回主线程 postMessage(sum);&#125;;//将执行timedCount前的时间，通过postMessage发送回主线程postMessage('Before computing, '+new Date());timedCount();//结束timedCount后，将结束时间发送回主线程postMessage('After computing, ' +new Date()); 上面代码执行的流程是：创建的worker对象，并用onmessage方法接收worker.js里面postMessage传递过来的数据(event.data)，并将数据追加到div#result中。 所以，执行上面的代码结果如下： 待worker.js中的timedCount方法运算完后，执行postMessage操作，向主线程传数据，得图二。期间，并不影响主线程的运作。 二、webWorker之常用ＡＰＩ接下来，再来看看关于worker的常用API： 1、postMessage(data)子线程与主线程之间互相通信使用方法，传递的data为任意值。 123456//worker = new Worker('url');//worker.postMessage传递给子线程数据，对象worker.postMessage(&#123;first:1,second:2&#125;);//子线程中也可以使用postMessage，如传递字符串postMessage(‘test’); 2、terminate()主线程中终止worker，此后无法再利用其进行消息传递。注意：一旦terminate后，无法重新启用，只能另外创建。 12//worker = new Worker('url');worker.terminate(); 如，主页面： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; var worker = new Worker('worker.js'); //每隔100毫秒，向子线程传递&#123;name: 'monkey'&#125;信息 setInterval(function()&#123; worker.postMessage(&#123;name: 'monkey'&#125;); &#125;,100); //当主线程worker收到来自子线程的消息后，触发message事件 worker.onmessage = function(event)&#123; document.getElementById('result').innerHTML+=event.data+\"&lt;br/&gt;\" ; //主线程使用terminate方法中断与子线程来往，在浏览器中只能显示一次event.data worker.terminate(); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 子线程worker.js代码： 1234567&lt;script&gt;//当主线程发来信息后，触发该message事件onmessage = function(event)&#123; //向主线程发送event.data.name信息 postMessage(event.data.name);&#125;;&lt;/script&gt; 3、message当有消息发送时，触发该事件。且，消息发送是双向的，消息内容可通过data来获取。 message使用，可见terminate中的demo 4、error出错处理。且错误消息可以通过e.message来获取。 如下： 1234567//worker = new Worker('url');worker.onerror = function(e)&#123; //打印出错消息 console.log(e.message); //中断与子线程的联系 worker.terminate();&#125; 另：worker线程从上到下同步运行它的代码，然后进入异步阶段来对事件及计时器响应，如果worker注册了message事件处理程序，只要其有可能触发，worker就一直在内存中，不会退出，所以通信完毕后得手动在主线程中terminate或者子线程中close掉，但如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，他就会退出。 三、worker上下文先看下面这段代码： 主页面： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; var worker = new Worker('worker.js'); //接收消息事件 worker.onmessage = function(event)&#123; console.log(event.data); &#125;; //错误信息事件 worker.onerror = function(e)&#123; console.log('erro: ' + e.message); //终止线程 worker.terminate(); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;/body&gt;&lt;/html&gt; worker.js 123456//window对象的alert方法alert(1);onmessage = function(event)&#123; //向主线程发送event.data.name信息 postMessage(event.data.name);&#125;; 执行上面代码结果： 为什么会这样呢？原因是alert为window对象的方法，所以会报错undefined。 worker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做WorkerGlobalScope的东东，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。WorkerGlobalScope作用域下的常用属性、方法如下： 1、self 我们可以使用 WorkerGlobalScope 的 self 属性来或者这个对象本身的引用 2、location location 属性返回当线程被创建出来的时候与之关联的 WorkerLocation 对象，它表示用于初始化这个工作线程的脚步资源的绝对 URL，即使页面被多次重定向后，这个 URL 资源位置也不会改变。 3、close 关闭当前线程，与terminate作用类似 4、importScripts 我们可以通过importScripts()方法通过url在worker中加载库函数 5、XMLHttpRequest 有了它，才能发出Ajax请求 6、setTimeout/setInterval以及addEventListener/postMessage四、关于worker我们可以做什么： 1.可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信 2.可以在worker中通过importScripts(url)加载另外的脚本文件 3.可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval() 4.可以使用XMLHttpRequest来发送请求 5.可以访问navigator的部分属性 局限性： 1.不能跨域加载JS 2.worker内代码不能访问DOM 3.各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行 4.IE这个新特性","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"}]},{"title":"axios基本使用介绍","date":"2017-05-02T10:56:15.000Z","path":"2017-05-02/","text":"axios建议使用高版本浏览器，目前在手机端使用频繁，但是在低版本的安卓上其实是有兼容性问题的，安卓4.2就开始出问题了，主要是由于Promise不支持，需要额外引入兼容包来处理。并且axios也是vue官方推荐使用的库。 1require('es6-promise').polyfill(); 发送一个GET请求，代码示例如下： 1234567891011121314151617181920//通过给定的ID来发送请求axios.get('/user?ID=12345') .then(function(response)&#123; console.log(response); &#125;) .catch(function(err)&#123; console.log(err); &#125;);//以上请求也可以通过这种方式来发送axios.get('/user',&#123; params:&#123; ID:12345 &#125;&#125;).then(function(response)&#123; console.log(response);&#125;).catch(function(err)&#123; console.log(err);&#125;); 发送一个POST请求，代码示例如下： 12345678910axios.post('/user',&#123; firstName:'Fred', lastName:'Flintstone'&#125;).then(function(res)&#123; console.log(res);&#125;).catch(function(err)&#123; console.log(err);&#125;); 一次性并发多个请求，代码示例如下： 12345678910function getUserAccount()&#123; return axios.get('/user/12345');&#125;function getUserPermissions()&#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms)&#123; //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果 &#125;)) axios可以通过配置（config）来发送请求，代码示例如下： 123456789//发送一个`POST`请求axios(&#123; method:\"POST\", url:'/user/12345', data:&#123; firstName:\"Fred\", lastName:\"Flintstone\" &#125;&#125;); 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名,注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明 1234567axios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]]) 并发请求（concurrency）,即是帮助处理并发请求的辅助函数 1234//iterable是一个可以迭代的参数如数组等axios.all(iterable)//callback要等到所有请求都完成才会执行axios.spread(callback) 创建一个axios实例，并且可以自定义其配置 1、axios.create([config])12345var instance = axios.create(&#123; baseURL:\"https://some-domain.com/api/\", timeout:1000, headers: &#123;'X-Custom-Header':'foobar'&#125;&#125;); 2、实例的方法，注意已经定义的配置将和利用create创建的实例的配置合并1234567axios#request(config)axios#get(url[,config])axios#delete(url[,config])axios#head(url[,config])axios#post(url[,data[,config]])axios#put(url[,data[,config]])axios#patch(url[,data[,config]]) 请求的配置（request config），以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&#123; //`url`是请求的服务器地址 url:'/user', //`method`是请求资源的方式 method:'get'//default //如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面 //当`url`是相对地址的时候，设置`baseURL`会非常的方便 baseURL:'https://some-domain.com/api/', //`transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动 //该选项只适用于以下请求方式：`put/post/patch` //数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream` transformRequest:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动 transformResponse:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`headers`选项是需要被发送的自定义请求头信息 headers: &#123;'X-Requested-With':'XMLHttpRequest'&#125;, //`params`选项是要随请求一起发送的请求参数----一般链接在URL后面 //他的类型必须是一个纯对象或者是URLSearchParams对象 params: &#123; ID:12345 &#125;, //`paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化 //例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param) paramsSerializer: function(params)&#123; return Qs.stringify(params,&#123;arrayFormat:'brackets'&#125;) &#125;, //`data`选项是作为一个请求体而需要被发送的数据 //该选项只适用于方法：`put/post/patch` //当没有设置`transformRequest`选项时dada必须是以下几种类型之一 //string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams //仅仅浏览器：FormData/File/Bold //仅node:Stream data &#123; firstName:\"Fred\" &#125;, //`timeout`选项定义了请求发出的延迟毫秒数 //如果请求花费的时间超过延迟的时间，那么请求会被终止 timeout:1000, //`withCredentails`选项表明了是否是跨域请求 withCredentials:false,//default //`adapter`适配器选项允许自定义处理请求，这会使得测试变得方便 //返回一个promise,并提供验证返回 adapter: function(config)&#123; /*..........*/ &#125;, //`auth`表明HTTP基础的认证应该被使用，并提供证书 //这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息 auth: &#123; username:\"zhangsan\", password: \"s00sdkf\" &#125;, //返回数据的格式 //其可选项是arraybuffer,blob,document,json,text,stream responseType:'json',//default // xsrfCookieName: 'XSRF-TOKEN',//default xsrfHeaderName:'X-XSRF-TOKEN',//default //`onUploadProgress`上传进度事件 onUploadProgress:function(progressEvent)&#123; //下载进度的事件onDownloadProgress:function(progressEvent)&#123;&#125; &#125;, //相应内容的最大值 maxContentLength:2000, //`validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise //如果`validateStatus`返回true(或者设置为`null`或者`undefined`),那么promise的状态将会是resolved,否则其状态就是rejected validateStatus:function(status)&#123; return status &gt;= 200 &amp;&amp; status &lt;300;//default &#125;, //`maxRedirects`定义了在nodejs中重定向的最大数量 maxRedirects: 5,//default //`httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理 //keeyAlive在选项中没有被默认激活 httpAgent: new http.Agent(&#123;keeyAlive:true&#125;), httpsAgent: new https.Agent(&#123;keeyAlive:true&#125;), //proxy定义了主机名字和端口号， //`auth`表明http基本认证应该与proxy代理链接，并提供证书 //这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的`Proxy-Authorization` header proxy: &#123; host:'127.0.0.1', port: 9000, auth: &#123; username:'skda', password:'radsd' &#125; &#125;, //`cancelToken`定义了一个用于取消请求的cancel token //详见cancelation部分 cancelToken: new cancelToken(function(cancel)&#123; &#125;)&#125; 请求返回的内容 12345678910 &#123; data:&#123;&#125;, status:200, //从服务器返回的http状态文本 statusText:'OK', //响应头信息 headers: &#123;&#125;, //`config`是在请求的时候的一些配置信息 config: &#123;&#125;&#125; 默认配置 1、全局默认配置123axios.defaults.baseURL = 'http://api.exmple.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['content-Type'] = 'appliction/x-www-form-urlencoded'; 2、自定义的实例默认设置1234567//当创建实例的时候配置默认配置var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);//当实例创建时候修改配置instance.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN; 3、配置中的有优先级，config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。12345678910//创建一个实例的时候会使用libray目录中的默认配置//在这里timeout配置的值为0，来自于libray的默认值var instance = axios.create();//回覆盖掉library的默认值//现在所有的请求都要等2.5S之后才会发出instance.defaults.timeout = 2500;//这里的timeout回覆盖之前的2.5S变成5sinstance.get('/longRequest',&#123; timeout: 5000&#125;); 拦截器 1、你可以在请求、响应在到达then/catch之前拦截他们12345678910111213141516//添加一个请求拦截器axios.interceptors.request.use(function(config)&#123; //在请求发出之前进行一些操作 return config;&#125;,function(err)&#123; //Do something with request error return Promise.reject(error);&#125;);//添加一个响应拦截器axios.interceptors.response.use(function(res)&#123; //在这里对返回的数据进行处理 return res;&#125;,function(err)&#123; //Do something with response error return Promise.reject(error);&#125;) 2、取消拦截器12var myInterceptor = axios.interceptor.request.use(function()&#123;/*....*/&#125;);axios.interceptors.request.eject(myInterceptor); 3、给自定义的axios实例添加拦截器12var instance = axios.create();instance.interceptors.request.use(function()&#123;&#125;) 错误处理 12345678910111213axios.get('/user/12345') .catch(function(error)&#123; if(error.response)&#123; //请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.header); &#125;else &#123; //一些错误是在设置请求的时候触发 console.log('Error',error.message); &#125; console.log(error.config); &#125;); 取消,你可以通过一个cancel token来取消一个请求 1、你可以通过CancelToken.source工厂函数来创建一个cancel token123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345',&#123; cancelToken: source.token&#125;).catch(function(thrown)&#123; if(axios.isCancel(thrown))&#123; console.log('Request canceled',thrown.message); &#125;else &#123; //handle error &#125;&#125;);//取消请求（信息的参数可以设置的）source.cance(\"操作被用户取消\"); 2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:12345678910var cancelToken = axios.CancelToken;var cance;axios.get('/user/12345',&#123; cancelToken: new CancelToken(function(c)&#123; //这个executor函数接受一个cancel function作为参数 cancel = c; &#125;)&#125;)//取消请求cancel(); 使用 application/x-www-form-urlencoded 格式化,默认情况下，axios串联js对象为 JSON 格式。为了发送 application/x-wwww-form-urlencoded 格式数据，你可以使用一下的设置。在浏览器中你可以如下使用 URLSearchParams API: 1234var params = new URLSearchParams();params.append('param1','value1');params.append('param2','value2');axios.post('/foo',params); URLSearchParams 不支持所有的浏览器,polyfill可用（确保垫片在浏览器全局环境中）,同样还有其他方法，片段代码如下： 12var qs = require('qs');axios.post('/foo', qs.stringify(&#123;'bar':123&#125;)); 如果在node环境中，可以使用以下querystring方法，代码片段如下： 12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123;foo:'bar'&#125;)); axios 基于原生的ES6 Promise 实现。如果环境不支持请使用es6-promise这个库来处理。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://www.iwangqi.com/tags/ajax/"}]},{"title":"详解javascript对象方法Object.assign()痛点","date":"2017-04-11T13:55:28.000Z","path":"2017-04-11/","text":"函数原型首先看一下函数的定义：函数参数为一个目标对象（该对象作为最终的返回值）,源对象(此处可以为任意多个)。通过调用该函数可以拷贝所有可被枚举的自有属性值到目标对象中。 Object.assign(target, …sources) 这里我们需要强调的三点是： 可被枚举的属性 自有属性 string或者Symbol类型是可以被直接分配的 拷贝过程中将调用源对象的getter方法，并在target对象上使用setter方法实现目标对象的拷贝。 函数实例这里我们通过几个MDN上的例子来介绍一下使用方法： 实例一我们参考上面的原型函数说明即可知道其最开始的o1因为设置为target，则调用其setter方法设置了其他对象的属性到自身。 12345678var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed. 实例二我们自定义了一些对象，这些对象有一些包含了不可枚举的属性,另外注意使用 Object.defineProperty 初始化的对象默认是不可枚举的属性。对于可枚举的对象我们可以直接使用Object.keys()获得,或者使用for-in循环遍历出来. 对于不可枚举的属性，使用Object.assign的时候将被自动忽略。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124var obj = Object.create(&#123; foo: 1 &#125;, &#123; // foo is an inherit property. bar: &#123; value: 2 // bar is a non-enumerable property. &#125;, baz: &#123; value: 3, enumerable: true // baz is an own enumerable property. &#125;&#125;);var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; baz: 3 &#125; ``` ### 实例三对于只读的属性，当分配新的对象覆盖他的时候，将抛出异常:``` javascriptvar target = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 1, writable: false&#125;); Object.assign(target, &#123; bar: 2 &#125;)//&#123;bar: 2, foo: 1&#125;Object.assign(target, &#123; foo: 2 &#125;)//Uncaught TypeError: Cannot assign to read only property 'foo' of object '#&lt;Object&gt;'(…)``` ## Polyfill这里我们简单的看下如何实现es5版本的Object.assign：实现步骤：判断是否原生支持该函数，如果不存在的话创建一个立即执行函数，该函数将创建一个assign函数绑定到Object上。判断参数是否正确(目的对象不能为空，我们可以直接设置&#123;&#125;传递进去,但必须设置该值)使用Object在原有的对象基础上返回该对象，并保存为out使用for…in循环遍历出所有的可枚举的自有对象。并复制给新的目标对象(hasOwnProperty返回非原型链上的属性)源码如下：``` javascript if (typeof Object.assign != 'function') &#123; (function () &#123; Object.assign = function (target) &#123; 'use strict'; if (target === undefined || target === null) &#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; var output = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var source = arguments[index]; if (source !== undefined &amp;&amp; source !== null) &#123; for (var nextKey in source) &#123; if (source.hasOwnProperty(nextKey)) &#123; output[nextKey] = source[nextKey]; &#125; &#125; &#125; &#125; return output; &#125;;&#125;)();&#125;``` ## 扩展内容### 深度拷贝和前拷贝javascript中存储对象都是存地址的，所以浅拷贝是都指向同一块内存区块，而深拷贝则是另外开辟了一块区域，下面实例也可以看出这一点：``` javascript// 浅拷贝const a = &#123;t: 1, p: 'gg'&#125;;const b = a;b.t = 3;console.log(a); // &#123;t: 3, p: 'gg'&#125;console.log(b); // &#123;t: 3, p: 'gg'&#125;//深拷贝const c = &#123;t: 1, p: 'gg'&#125;;const d = deepCopy(c);d.t = 3;console.log(c); // &#123;t: 1, p: 'gg'&#125;console.log(d); // &#123;t: 3, p: 'gg'&#125;``` 可以明显看出，浅拷贝在改变其中一个值时，会导致其他也一起改变，而深拷贝不会。我需要的是深拷贝的方法，然后发现原来es6 中有Object.assign() 这个方法，感觉可以拿来用了。 贴一下两个官方例子：``` javascript// Cloning an objectvar obj = &#123; a: 1 &#125;;var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125;// Merging objectsvar o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed. 是不是很完美，又可以clone又可以merge。在我这种情况下，我觉得我的代码量又可以减少了，比如： 1234567891011121314151617const defaultOpt = &#123; title: 'hello', name: 'oo', type: 'line'&#125;;// 原来可能需要这样const opt1 = deepCopy(a);opt1.title = 'opt1';opt1.type = 'bar';opt1.extra = 'extra'; // 额外增加配置// 现在只要这样const opt2 = Object.assign(&#123;&#125;, a, &#123; title: 'opt2', type: 'bar', extra: 'extra'&#125;); 不过，很快，问题出现了，那就是merge和我想象的不一样且看例子： 1234567891011121314151617181920212223242526272829const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125;&#125;;const opt = Object.assign(&#123;&#125;, defaultOpt, &#123; title: &#123; subtext: 'Yes, your world.' &#125;&#125;);console.log(opt);// 预期结果&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125;// 实际结果&#123; title: &#123; subtext: 'Yes, your world.' &#125;&#125; 原本想的是它只会覆盖subtext ，然而其实它直接覆盖了整个title ，这个让我比较郁闷，相当于它只merge根属性，下面的就不做处理了。代码只能重构成相对麻烦一点的： 12345678910111213141516171819const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125;&#125;;const opt = Object.assign(&#123;&#125;, defaultOpt);opt.title.subtext = 'Yes, your world.';console.log(opt);// 结果正常&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125; 这样用虽然麻烦一点，但是也还好，可以用了。不过。。。很快，又出现问题了，如下： 12345678910111213141516171819202122232425262728293031const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125; &#125;;const opt1 = Object.assign(&#123;&#125;, defaultOpt);const opt2 = Object.assign(&#123;&#125;, defaultOpt);opt2.title.subtext = 'Yes, your world.';console.log('opt1:');console.log(opt1);console.log('opt2:');console.log(opt2);// 结果opt1:&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125;opt2:&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125; 上面结果发现两个配置变得一模一样，而其实我们并没有去更改opt1 的subtext ，只是改了opt2 的。这说明一点：在title 这一层只是简单的浅拷贝 ，而没有继续深入的深拷贝。 Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。用的时候，还是要注意这个问题的。不过github上已经有很多好的解决方案，比如deep-merge 通过递归的方式逐层的去调用assign函数。Lodash提供了深拷贝的api方法，其实熟悉jquery的同学，extend这个api就能直接完美解决深拷贝的问题。 附发现一个可以简单实现深拷贝的方法，当然，有一定限制，如下： const obj1 = JSON.parse(JSON.stringify(obj)); 思路就是将一个对象转成json字符串，然后又将字符串转回对象。但是在使用中还是会存在问题，进过测试会把function替换掉，使用的时候还得注意。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://www.iwangqi.com/tags/es6/"}]},{"title":"理解JavaScript函数式编程","date":"2017-04-10T14:14:43.000Z","path":"2017-04-10/","text":"JavaScript 函数式编程是一个存在了很久的话题，但似乎从 2016 年开始，它变得越来越火热。这可能是因为 ES6 语法对于函数式编程更为友好，也可能是因为诸如 RxJS (ReactiveX) 等函数式框架的流行。 看过许多关于函数式编程的讲解，但是其中大部分是停留在理论层面，还有一些是仅针对 Haskell 等纯函数式编程语言的。而本文旨在聊一聊我眼中的函数式编程在 JavaScript 中的具体实践，之所以是 “我眼中的” 即我所说的仅代表个人观点，可能和部分 严格概念 是有冲突的。 本文将略去一大堆形式化的概念介绍，重点展示在 JavaScript 中到底什么是函数式的代码、函数式代码与一般写法有什么区别、函数式的代码能给我们带来什么好处以及常见的一些函数式模型都有哪些。 函数式编程我认为函数式编程可以理解为，以函数作为主要载体的编程方式，用函数去拆解、抽象一般的表达式 与命令式相比，这样做的好处在哪？主要有以下几点： 语义更加清晰 可复用性更高 可维护性更好 作用域局限，副作用少 基本的函数式编程下面例子是一个具体的函数式体现 123456789101112131415161718192021222324// 一般写法const arr = ['apple', 'pen', 'apple-pen'];for(const i in arr)&#123; const c = arr[i][0]; arr[i] = c.toUpperCase() + arr[i].slice(1);&#125;console.log(arr);// 函数式写法一function upperFirst(word) &#123; return word[0].toUpperCase() + word.slice(1);&#125;function wordToUpperCase(arr) &#123; return arr.map(upperFirst);&#125;console.log(wordToUpperCase(['apple', 'pen', 'apple-pen']));// 函数式写法二console.log(arr.map(['apple', 'pen', 'apple-pen'], word =&gt; word[0].toUpperCase() + word.slice(1))); 当情况变得更加复杂时，表达式的写法会遇到几个问题： 表意不明显，逐渐变得难以维护 复用性差，会产生更多的代码量 会产生很多中间变量 函数式编程很好的解决了上述问题。首先参看 函数式写法一，它利用了函数封装性将功能做拆解（粒度不唯一），并封装为不同的函数，而再利用组合的调用达到目的。这样做使得表意清晰，易于维护、复用以及扩展。其次利用 高阶函数，Array.map 代替 for…of 做数组遍历，减少了中间变量和操作。 而 函数式写法一 和 函数式写法二 之间的主要差别在于，可以考虑函数是否后续有复用的可能，如果没有，则后者更优。 链式优化从上面 函数式写法二 中我们可以看出，函数式代码在写的过程中，很容易造成 横向延展，即产生多层嵌套，下面我们举个比较极端点的例子。 // 计算数字之和 // 一般写法 console.log(1 + 2 + 3 - 4) // 函数式写法 function sum(a, b) { return a + b; } function sub(a, b) { return a - b; } console.log(sub(sum(sum(1, 2), 3), 4); 本例仅为展示 横向延展 的比较极端的情况，随着函数的嵌套层数不断增多，导致代码的可读性大幅下降，还很容易产生错误。 在这种情况下，我们可以考虑多种优化方式，比如下面的 链式优化 。 // 优化写法 (嗯，你没看错，这就是 lodash 的链式写法) const utils = { chain(a) { this._temp = a; return this; }, sum(b) { this._temp += b; return this; }, sub(b) { this._temp -= b; return this; }, value() { const _temp = this._temp; this._temp = undefined; return _temp; } }; console.log(utils.chain(1).sum(2).sum(3).sub(4).value()); 这样改写后，结构会整体变得比较清晰，而且链的每一环在做什么也可以很容易的展现出来。函数的嵌套和链式的对比还有一个很好的例子，那就是 回调函数 和 Promise 模式。 // 顺序请求两个接口 // 回调函数 import $ from 'jquery'; $.post('a/url/to/target', (rs) =&gt; { if(rs){ $.post('a/url/to/another/target', (rs2) =&gt; { if(rs2){ $.post('a/url/to/third/target'); } }); } }); // Promise import request from 'catta'; // catta 是一个轻量级请求工具，支持 fetch,jsonp,ajax，无依赖 request('a/url/to/target') .then(rs =&gt; rs ? $.post('a/url/to/another/target') : Promise.reject()) .then(rs2 =&gt; rs2 ? $.post('a/url/to/third/target') : Promise.reject()); 随着回调函数嵌套层级和单层复杂度增加，它将会变得臃肿且难以维护，而 Promise 的链式结构，在高复杂度时，仍能纵向扩展，而且层次隔离很清晰。 常见的函数式编程模型闭包（Closure）可以保留局部变量不被释放的代码块，被称为一个闭包 闭包的概念比较抽象，相信大家都或多或少知道、用到这个特性 那么闭包到底能给我们带来什么好处？ 先来看一下如何创建一个闭包： // 创建一个闭包 function makeCounter() { let k = 0; return function() { return ++k; }; } const counter = makeCounter(); console.log(counter()); // 1 console.log(counter()); // 2 makeCounter 这个函数的代码块，在返回的函数中，对局部变量 k ，进行了引用，导致局部变量无法在函数执行结束后，被系统回收掉，从而产生了闭包。而这个闭包的作用就是，“保留住“ 了局部变量，使内层函数调用时，可以重复使用该变量；而不同于全局变量，该变量只能在函数内部被引用。 换句话说，闭包其实就是创造出了一些函数私有的 ”持久化变量“。 所以从这个例子，我们可以总结出，闭包的创造条件是： 存在内、外两层函数 内层函数对外层函数的局部变量进行了引用 ###闭包的用途 闭包的主要用途就是可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等等。 // 简单的缓存工具 // 匿名函数创造了一个闭包 const cache = (function() { const store = {}; return { get(key) { return store[key]; }, set(key, val) { store[key] = val; } } }()); cache.set('a', 1); cache.get('a'); // 1 上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。 ###闭包的弊端 持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。 ##高阶函数 接受或者返回一个函数的函数称为高阶函数 听上去很高冷的一个词汇，但是其实我们经常用到，只是原来不知道他们的名字而已。JavaScript 语言是原生支持高阶函数的，因为 JavaScript 的函数是一等公民，它既可以作为参数又可以作为另一个函数的返回值使用。 我们经常可以在 JavaScript 中见到许多原生的高阶函数，例如 Array.map , Array.reduce , Array.filter 下面以 map 为例，我们看看他是如何使用的 ###map （映射） 映射是对集合而言的，即把集合的每一项都做相同的变换，产生一个新的集合 map 作为一个高阶函数，他接受一个函数参数作为映射的逻辑 // 数组中每一项加一，组成一个新数组 // 一般写法 const arr = [1,2,3]; const rs = []; for(const n of arr){ rs.push(++n); } console.log(rs) // map改写 const arr = [1,2,3]; const rs = arr.map(n =&gt; ++n); 上面一般写法，利用 for…of 循环的方式遍历数组会产生额外的操作，而且有改变原数组的风险 而 map 函数封装了必要的操作，使我们仅需要关心映射逻辑的函数实现即可，减少了代码量，也降低了副作用产生的风险。 ###柯里化（Currying） 给定一个函数的部分参数，生成一个接受其他参数的新函数 可能不常听到这个名词，但是用过 undescore 或 lodash 的人都见过他。 有一个神奇的 _.partial 函数，它就是柯里化的实现 // 获取目标文件对基础路径的相对路径 // 一般写法 const BASE = '/path/to/base'; const relativePath = path.relative(BASE, '/some/path'); // _.parical 改写 const BASE = '/path/to/base'; const relativeFromBase = _.partial(path.relative, BASE); const relativePath = relativeFromBase('/some/path'); 通过 _.partial ，我们得到了新的函数 relativeFromBase ，这个函数在调用时就相当于调用 path.relative ，并默认将第一个参数传入 BASE ，后续传入的参数顺序后置。 本例中，我们真正想完成的操作是每次获得相对于 BASE 的路径，而非相对于任何路径。柯里化可以使我们只关心函数的部分参数，使函数的用途更加清晰，调用更加简单。 ###组合（Composing） 将多个函数的能力合并，创造一个新的函数 同样你第一次见到他可能还是在 lodash 中，compose 方法（现在叫 flow） // 数组中每个单词大写，做 Base64 // 一般写法 (其中一种) const arr = ['pen', 'apple', 'applypen']; const rs = []; for(const w of arr){ rs.push(btoa(w.toUpperCase())); } console.log(rs); // _.flow 改写 const arr = ['pen', 'apple', 'applypen']; const upperAndBase64 = _.partialRight(_.map, _.flow(_.upperCase, btoa)); console.log(upperAndBase64(arr)); _.flow 将转大写和转 Base64 的函数的能力合并，生成一个新的函数。方便作为参数函数或后续复用。 ##自己的观点 我理解的 JavaScript 函数式编程，将可以复用的功能提取出来，用函数方法来代替其实就是基本的函数编程思想，其实到最后会面临两个问题，一个是函数共用性好还是函数功能细分好，这其实都是根据自己具体需求而定的，个人认为函数功能还是细分好，这样方便维护，功能实现代码逻辑清晰。 函数式编程就是书写清新的逻辑代码，其实也是一种解耦的形式罢了。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"}]},{"title":"nodejs的process.nextTick方法理解和使用","date":"2017-04-04T09:49:45.000Z","path":"2017-04-04/","text":"今天重新温习了下nodejs开发指南中的核心模块全局对象中的process进程模块，其实nextTick和我目前使用的vue中的nextTick方法有些异曲同工之妙，于是上网搜整理了一些资料，详细的了解下nextTick到底该如何理解并且在实际项目中哪些地方会用到这个方法。 Node.js是单线程的，基于事件循环，非阻塞IO的。事件循环中使用一个事件队列，在每个时间点上，系统只会处理一个事件，即使电脑有多个CPU核心，也无法同时并行的处理多个事件。因此，node.js适合处理I／O型的应用，不适合那种CPU运算密集型的应用。在I／O型的应用中，给每一个输入输出定义一个回调函数，node.js会自动将其加入到事件轮询的处理队列里，当I／O操作完成后，这个回调函数会被触发，系统会继续处理其他的请求。 理解在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。 在这种处理模式下，process.nextTick()的意思就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行。我们来看一个例子。例子中有一个foo()，你想在下一个时间点上调用他，可以这么做： 12345function foo() &#123; console.error('foo');&#125;process.nextTick(foo);console.error('bar'); 运行上面的代码，你从下面终端打印的信息会看到，”bar”的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。 12barfoo 你也可以使用setTimeout()函数来达到貌似同样的执行效果： 12setTimeout(foo, 0);console.log('bar'); 但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时。process.nextTick()定义的调用会创建一个新的队列。在当前的队列里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须结束队列操作。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的队列。 具体使用场景在多个事件里交叉执行CPU运算密集型的任务在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。 但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。 1234567891011var http = require('http');function compute() &#123; // performs complicated calculations continuously // ... process.nextTick(compute);&#125;http.createServer(function(req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('Hello World');&#125;).listen(5000, '127.0.0.1');compute(); 在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。 当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。 保持回调函数异步执行的原则当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则： 123456789101112function maybeSync(arg, cb) &#123; if (arg) &#123; cb(); return; &#125; fs.stat('file', cb);&#125;maybeSync(true, function() &#123; foo();&#125;);bar(); 这段代码不明确的地方是, 我们不清楚foo()和bar()哪个会被先调用，使用nextTick将回调函数变成异步的。这样写更好： function definitelyAsync(arg, cb) { if (arg) { process.nextTick(cb); return; } fs.stat('file', cb); } 用在事件触发过程中来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写： var EventEmitter = require('events').EventEmitter; function StreamLibrary(resourceName) { this.emit('start'); // read from the file, and for every chunk read, do: this.emit('data', chunkRead); } StreamLibrary.prototype.__proto__ = EventEmitter.prototype; // inherit from EventEmitter 下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件： var stream = new StreamLibrary('fooResource'); stream.on('start', function() { console.log('Reading has started'); }); stream.on('data', function(chunk) { console.log('Received: ' + chunk); }); 但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本： function StreamLibrary(resourceName) { var self = this; process.nextTick(function() { self.emit('start'); }); // read from the file, and for every chunk read, do: this.emit('data', chunkRead); }","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"node","slug":"node","permalink":"http://www.iwangqi.com/tags/node/"}]},{"title":"ajax如何截取302响应","date":"2017-04-02T12:09:11.000Z","path":"ajax/","text":"在ajax请求中，如果服务器端的响应是302 Found，在ajax的回调函数中能够获取这个状态码吗？能够从Response Headers中得到Location的值进行重定向吗？让我们来一起看看实际情况。 使用jQuery的$.ajax()发起ajax请求的JavaScript代码如下：1234567891011$.ajax(&#123;url: '/oauth/respond',type: 'post',data: data,complete: function(jqXHR)&#123; console.log(jqXHR.status);&#125;,error: function (xhr) &#123; console.log(xhr.status);&#125;&#125;); 当服务器端返回302 Found的响应时，浏览器中的运行结果如下： 在ajax的complete()与error()回调函数中得到的状态码都是404，而不是302。为什么呢？在stackoverflow上找到了答案： 原来，当服务器将302响应发给浏览器时，浏览器并不是直接进行ajax回调处理，而是先执行302重定向——从Response Headers中读取Location信息，然后向Location中的Url发出请求，在收到这个请求的响应后才会进行ajax回调处理。大致流程如下： ajax -&gt; browser -&gt; server -&gt; 302 -&gt; browser(redirect) -&gt; server -&gt; browser -&gt; ajax callback 而在我们的测试程序中，由于302返回的重定向URL在服务器上没有相应的处理程序，所以在ajax回调函数中得到的是404状态码；如果存在对应的URL，得到的状态码就是200。 所以，如果你想在ajax请求中根据302响应通过location.href进行重定向是不可行的。 如何解决？【方法一】继续用ajax，修改服务器端代码，将原来的302响应改为json响应，比如下面的ASP.NET MVC示例代码： 123456789101112131415return Json(new &#123; status = 302, location = \"/oauth/respond\" &#125;);ajax代码稍作修改即可：$.ajax(&#123; url: '/oauth/respond', type: 'post', data: data, dataType: 'json', success: function (data) &#123; if (data.status == 302) &#123; location.href = data.location; &#125; &#125;&#125;); 【方法二】不用ajax，改用form。 12&lt;form method=\"post\" action=\"/oauth/respond\"&gt;&lt;/form&gt;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://www.iwangqi.com/tags/ajax/"},{"name":"302","slug":"302","permalink":"http://www.iwangqi.com/tags/302/"}]}]