[{"title":"react源码分析之ReactElement分析（二）","date":"2019-05-16T09:11:52.000Z","path":"2019-05-16-react-ReactElement/","text":"开场白render函数想必是每个react开发者必会写到的一个方法，即使是些函数式组件那么return一个带标签的字符串肯定会用到，最终能使得浏览器识别标签，主要依赖babel以及babel相关的react插件转化成React.createElement形式的代码创建dom元素，那么到底React.createElement做了什么？为什么上一篇文章说，props.children不完全是数据类型？下面就来回答以上这两个疑问。 分析 从入口文件看，ReactElement.js源码中会暴露createElement、cloneElement、createFactory、isValidElement，这里只做createElement详细介绍 需要弄清楚，return 出来的字符串到底被转成什么样的形式，例如下面的转换前和转换后的代码： 123456789101112131415// 转换前&lt;div data-set=\"111\"&gt; &lt;span ref='span'&gt;aaa&lt;/span&gt; &lt;span key='1'&gt;bbb&lt;/span&gt; &lt;span&gt;ccc&lt;/span&gt;&lt;/div&gt;// 转换后React.createElement(\"div\", &#123; \"data-set\": \"111\"&#125;, React.createElement(\"span\", &#123; ref: \"span\"&#125;, \"aaa\"), React.createElement(\"span\", &#123; key: \"1\"&#125;, \"bbb\"), React.createElement(\"span\", null, \"ccc\")) 这里故意增加了data-set、ref、key几个属性 其实很好理解，就是转换成了React.createElement函数去执行，那么可以打开/react/src/ReactElement.js源码，只需要关注两个方法createElement和ReactElement，源码片段如下： 可以不考虑DEV包含的代码，这里主要是开发模式下使用的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const ReactElement = function(type, key, ref, self, source, owner, props) &#123; const element = &#123; $$typeof: REACT_ELEMENT_TYPE, type: type, key: key, ref: ref, props: props, _owner: owner, &#125;; // 省略了__DEV__代码块 return element;&#125;export function createElement(type, config, children) &#123; let propName; const props = &#123;&#125;; let key = null; let ref = null; let self = null; let source = null; if (config != null) &#123; if (hasValidRef(config)) &#123; ref = config.ref; &#125; if (hasValidKey(config)) &#123; key = '' + config.key; &#125; self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; for (propName in config) &#123; if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) &#123; props[propName] = config[propName]; &#125; &#125; &#125; const childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; // 省略了__DEV__代码块 props.children = childArray; &#125; if (type &amp;&amp; type.defaultProps) &#123; const defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; // 省略了__DEV__代码块 return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, );&#125; 配合上面的示例代码，可以很清晰的看出，createElement 接受的三个参数： type，可以是原生标签（div、span）；可以是自定义组件（Component）；可以是原生组件（Fragment）；函数组件（function） config，代表的是标签或者组件上附带的属性（data-set、key、ref等等） children，代表嵌套包含的组件或者子组件React.createElement整个返回值 从源码中可以看出，会对ref和key这两种特殊的属性都遍历出来，统一赋值给当前的reactElement上。 这里定义const childrenLength = arguments.length - 2;主要是因为可以支持嵌套多级组件，通过arguments.length - 2就能获取到除了前两个参数剩下参数的个数，当childrenLength === 1时，props.children就是包含的一个子组件，并不是数组，可以理解为一个reactElement对象，但是childrenLength &gt; 1的时候，props.children就是个数组，所以之前说props.children可能是对象，可能是数组。 type &amp;&amp; type.defaultProps这个if语句代码块主要是在设置默认值使用的，比较简单。 最终会调用ReactElement函数，然后返回一个代表是ReactElement的对象（通过$$typeof属性判断） 其实createElement和ReactElement只是将props、ref、key做了赋值操作，并没有之前想的那样会有很复杂的逻辑，解决了最开始的两个问题。 遗留的问题通过以上分析，可以解释开篇最开始的两个疑问，但是又会有新的疑问： 源码中ReactCurrentOwner是什么东东？ 在createElement的函数中type是如何判断是哪种类型的，在源码中并没有这样的逻辑？ 以上就是全部的内容，如果有什么不对的地方，欢迎提issues","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"}]},{"title":"react源码分析之基础API简要分析(-)","date":"2019-05-15T03:35:12.000Z","path":"2019-05-15-react-basic/","text":"开场白团队是从今年年初开始使用react技术栈，之前都是使用vue开发，其实团队更换技术栈还是需要有一定的魄力的，因为团队在之前使用vue开发的时候，积累了一套组件库和项目构建工具，开发项目解决问题相对比较成熟了，贸然的更换技术栈这些基本就是从零开始，对个人和团队都是不小的挑战，当然，结果是坚持更换，主要是也能体会react的编写风格以及理解它的设计思想，再一个，公司大部分其他端的产品也基本都是沿袭react的技术栈，为了更好的迎合公司前端技术的发展，所以还是下定决心了。 到现在为止，其实react使用了快大半年了，经历了4个项目，单纯从使用上已经不成问题了，因为我们直接使用的是reactv16.8.6+的版本，其实很多新的功能并没有用上，也许是react的官方文档跟vue的相比，简直弱爆了。所以在空闲之余尝试的去读读源码，理解react到底是怎么实现这些功能的。 这次主要是进行react源码的分析，所以我们先从入口文件开始阅读吧 这次分析的是reactv16.8.6版本，其他版本未阅读 基础分析打开入口文件，以下是react源码入口文件的片段代码，可以很清晰的看出，对外暴露的以下这些API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// react/src/React.jsconst React = &#123; Children: &#123; map, forEach, count, toArray, only, &#125;, createRef, Component, PureComponent, createContext, forwardRef, lazy, memo, error, warn, useCallback, useContext, useEffect, useImperativeHandle, useDebugValue, useLayoutEffect, useMemo, useReducer, useRef, useState, Fragment: REACT_FRAGMENT_TYPE, Profiler: REACT_PROFILER_TYPE, StrictMode: REACT_STRICT_MODE_TYPE, Suspense: REACT_SUSPENSE_TYPE, createElement: __DEV__ ? createElementWithValidation : createElement, cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement, createFactory: __DEV__ ? createFactoryWithValidation : createFactory, isValidElement: isValidElement, version: ReactVersion, unstable_ConcurrentMode: REACT_CONCURRENT_MODE_TYPE, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,&#125; Children主要是处理props.children上渲染的内容，当props.children是多个的时候，在createElement的时候会将它转化成数组，如果props.children只有一个的时候，其实就是一个dom字符串，这里的map、forEach等方法是自定义的遍历方法，后面会单独介绍ReactChildren是如何实现这些的。 createRef新的ref用法，React会废弃在标签上直接使用ref来定义，例如：这种string ref的用法，将来你只能使用两种方式来使用ref，基本代码如下： 12345678910111213class App extends React.Component&#123; constructor() &#123; this.ref = React.createRef() // &#123;current: null&#125; &#125; render() &#123; return &lt;div ref=&#123;this.ref&#125; /&gt; // or return &lt;div ref=&#123;(node) =&gt; this.funRef = node&#125; /&gt; &#125;&#125; 其实createRef源码非常简单，，显而易见，就是返回了{current: null}这个对象，全部如下： 1234567891011// react/src/ReactCreateRef.jsimport type &#123;RefObject&#125; from 'shared/ReactTypes';export function createRef(): RefObject &#123; const refObject = &#123; current: null, &#125;; if (__DEV__) &#123; Object.seal(refObject); &#125; return refObject;&#125; Component/PureComponent一般Component用的会比较多，PureComponent在早期的版本是没有的，PureComponent主要功能就是在使用过程中，自动判断shouldComponentUpdate是否需要更新，而Component往往需要自己去判断下，PureComponent可以说能提高一部分组件的渲染性能，个人其实还是觉得Component好用，最起码可以自定义是否更新。 打开react/src/ReactBaseClasses.js查看源码文件，其实PureComponent是继承了Component，只是会多一个pureComponentPrototype.isPureReactComponent这个字段来区分是否是PureComponent。 这里大家应该会觉得我们经常使用的Component类的源码应该非常复杂，但是实际却很是以为，源码加上注释才145行代码，以下贴出Component的片段源码： 123456789101112131415161718192021// react/src/ReactBaseClasses.jsfunction Component(props, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125;Component.prototype.isReactComponent = &#123;&#125;;Component.prototype.setState = function(partialState, callback) &#123; invariant( typeof partialState === 'object' || typeof partialState === 'function' || partialState == null, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.', ); this.updater.enqueueSetState(this, partialState, callback, 'setState');&#125;;Component.prototype.forceUpdate = function(callback) &#123; this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');&#125;; 你会发现，我们经常使用的setState和forceUpdate(告诉react组件执行render方法)的更新逻辑并没有写在Component中，而是分别交给了this.updater.enqueueSetState和this.updater.enqueueForceUpdate来执行，这里会有个疑问，updater是在什么时候挂在到this上的？ createContext跨组件传递的内容组件，该组件导出两个对象Provider提供数据，Consumer消费数据，有效的解决组件嵌套过深导致的，数据层层传递的噩梦。 基本使用如下： 123456789101112131415161718192021222324import React from 'react'const &#123; Provider, Consumer &#125; = React.createContext(&#123; background: 'red', color: 'white'&#125;)console.log(Provider, Consumer)const ConsumerComp = () =&gt; ( &lt;Consumer&gt; &#123;(context) =&gt; &#123; return &lt;p style=&#123;&#123;background: context.background, color: context.color&#125;&#125;&gt;111111&lt;/p&gt; &#125;&#125; &lt;/Consumer&gt;)const ProviderComp = (props) =&gt; ( &lt;Provider value=&#123;&#123;background: 'green', color: 'white'&#125;&#125;&gt; &lt;ConsumerComp/&gt; &lt;/Provider&gt;)export default ProviderComp 打开react/src/ReactContext.js文件可以查看源码，片段如下： 12345678910111213141516171819const context: ReactContext&lt;T&gt; = &#123; $$typeof: REACT_CONTEXT_TYPE, _calculateChangedBits: calculateChangedBits, _currentValue: defaultValue, _currentValue2: defaultValue, _threadCount: 0, Provider: (null: any), Consumer: (null: any), &#125;; context.Provider = &#123; $$typeof: REACT_PROVIDER_TYPE, _context: context, &#125;; // 中间省略很多代码 context.Consumer = context; return context; 这里能看出，使用React.createContext定义的数据会保存两份，分别是_currentValue和_currentValue，同时context默认的$$typeof是REACT_CONTEXT_TYPE，只是context.Provider会重新覆盖$$typeof为REACT_PROVIDER_TYPE，最后context.Consumer = context，这样写Provider和Consumer相互就是对方的引用，对象上存储的数据都是共享的，主要通过这样实现共享数据。 forwardRef通过class来定义的组件是可以通过ref获取当前组件的实例，但是如果仅仅通过函数创建的组件，如果还用之前ref形式创建的话，则组件内部是拿不到该组件的实例的，所以这里就衍生了forwardRef这个api了，基本使用如下： 1234567891011121314const MyButton = React.forwardRef((props, ref) =&gt; ( &lt;button ref=&#123;ref&#125; className=\"MyButton\"&gt; &#123;props.children&#125; &lt;/button&gt;));// 通过ref可以直接操作&lt;button&gt;元素:const ref = React.createRef();&lt;MyButton ref=&#123;ref&#125;&gt;Click me!&lt;/MyButton&gt;;// 可以理解渲染结果如下&lt;button ref=&#123;ref&#125; className=\"MyButton\"&gt; Click me!&lt;/button&gt; 打开源码react/src/forwardRef.js可以看到，其实调用forwardRef只是返回了一个对象： 1234return &#123; $$typeof: REACT_FORWARD_REF_TYPE, render&#125; 这里的render就是外层传进来渲染组件的方法，这里涉及到组件更新的过程，后面会详细介绍。 lazy使用React.lazy()等待组件加载的时候 暂停渲染，基本使用如下： 1234567891011const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));function MyComponent() &#123; return ( &lt;React.Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt; &lt;div&gt; &lt;OtherComponent /&gt; &lt;/div&gt; &lt;/React.Suspense&gt; );&#125; 打开源码react/src/ReactLazy.js可以看到，其实就是返回了一个对象，片段代码如下： 1234567lazyType = &#123; $$typeof: REACT_LAZY_TYPE, _ctor: ctor, // React uses these fields to store the result. _status: -1, _result: null,&#125; _status记录组件渲染的状态，默认是-1，1就是渲染完成。 memo说实话，我是没用过这个，通过源码能看出接受两个参数，第一个参数是组件，第二个参数则是个boolean值，片段代码如下： 1234567891011121314151617181920export default function memo&lt;Props&gt;( type: React$ElementType, compare?: (oldProps: Props, newProps: Props) =&gt; boolean,) &#123; if (__DEV__) &#123; if (!isValidElementType(type)) &#123; warningWithoutStack( false, 'memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type, ); &#125; &#125; return &#123; $$typeof: REACT_MEMO_TYPE, type, compare: compare === undefined ? null : compare, &#125;;&#125; 通过查询其他资料了解到，这个api类似于shouldcomponentupdate，第二个boolean主要判断组件是否更新，基本使用如下： 123456789101112131415import React from \"react\";function Child(&#123;seconds&#125;)&#123; console.log('I am rendering'); return ( &lt;div&gt;I am update every &#123;seconds&#125; seconds&lt;/div&gt; )&#125;;function areEqual(prevProps, nextProps) &#123; if(prevProps.seconds===nextProps.seconds)&#123; return true &#125;else &#123; return false &#125;&#125;export default React.memo(Child,areEqual) use开头的api主要是跟Hooks相关，后面详细介绍 其他这几个api其实就是一个Symbol类型，这里需要说明下为什么会用Symbol.for()，而不是直接使用Symbol来创建。 Symbol.for它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。如果你调用Symbol.for(“cat”)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”)30 次，会返回 30 个不同的 Symbol 值。 1234Fragment: REACT_FRAGMENT_TYPE,Profiler: REACT_PROFILER_TYPE,StrictMode: REACT_STRICT_MODE_TYPE,Suspense: REACT_SUSPENSE_TYPE, 以下这四个api都是来自ReactElement.js中的，createElement用来创建ReactElement的；cloneElement克隆一个ReactElement；createFactory是用来创建专门用来创建某一类ReactElement的工厂的；isValidElement用来验证是否是一个ReactElement。其中createElement是最终要的api，会单独详细介绍它。 1234createElement: __DEV__ ? createElementWithValidation : createElement,cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,createFactory: __DEV__ ? createFactoryWithValidation : createFactory,isValidElement: isValidElement, 遗留的问题 就是在创建Component的时候，this.updater在什么时候被挂在上的？ memo如果通过第二个参数进行判断组件是否该渲染？（一般用的很少，索性先提出来） forwardRef最后返回的一个对象，里面的render函数如何渲染更新的？ lazy通过内部定义的_status来判断组件是否渲染，在哪里_status被改变了？（一般用的很少，索性先提出来） createElement到底如何创建的？ Hooks是什么？ ReactChildren是如何实现的？ 以上就是全部的内容，如果有什么不对的地方，欢迎提issues","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"}]},{"title":"利用babel实现简易版打包工具函数","date":"2019-05-10T02:51:36.000Z","path":"2019-05-10-bundler/","text":"简要唠几句webpack4.0+相比webpack2.0+不但是在打包性能上提高了不少，而且在配置打包参数上也简化了很多，例如webpack4+就废弃了CommonsChunkPluginapi，转而新增加了optimization配置项，专门解决chunk相关打包配置的问题；NoEmitOnErrorsPlugin、ModuleConcatenationPlugin早期都是通过插件的形式进行使用，在webpack4+都改成optimization对象下的一个子属性配置项来解决，并且optimization有默认配置项，就是如果在使用中不配置这个，默认也能进行压缩打包，极大的方便了开发者的使用。 那么使用简单了，它具体是如何实现的呢？比如说，loader和plugins是如何实现的呢？，该如何写一个自己的loader和plugins呢？webpack具体是怎么讲相互依赖的代码打包成浏览器能够识别的es5代码呢？下面就来简要的介绍下如果完成以上几个问题。 以下示例代码可以访问源码查看 自定义loaderloader可以理解就是对javascript做定制化打包需要做的事情，比如常见的将es6转化成es5、批量删除代码中的注释代码块等等操作，通过在webpack.config文件中定义相应loader的options可以作为参数传入自定义的loader函数中进行处理，具体使用也可以参考官方文档 同步loader实现一个基本的try,catch代码块，通过laoder统一加上，基本代码形式如下： 注意：这里在编写loader不能使用箭头函数 12345678910111213141516171819202122232425262728293031323334// loader代码const loaderUtils = require('loader-utils')module.exports = function(source) &#123; const options = loaderUtils.getOptions(this) let result = '' if (options.tryCatch) &#123; result = `try &#123; $&#123;source&#125; &#125; catch(err) &#123; console.log(err.name) console.log(err.message) console.log(err.stack) &#125;` &#125; return result || source&#125;// config 代码resolveLoader: &#123; modules: ['node_modules', './loaders/'] &#125;,module: &#123; rules: [ &#123; test: /\\.js$/, use: [ &#123; loader: 'loaderDemo', options: &#123; tryCatch: true &#125; &#125; ] &#125; ]&#125; source就是需要打包的代码块 可以通过一个loader-utils工具来快速获取外层传进来的options上的参数，例如上面获取tryCatch配置 resolveLoader主要是为了方便在module中使用自定义的loader写法，具体含义是会在’node_modules’和’./loaders/‘文件夹下去寻找定义的loader 异步loader异步loader其实就是使用了官方提供的一个this上的async方法，含义就是等待执行结果，然后在会返回以callback，其实这个callback也就是调用了this.callback，所以得保证参数传入一致，基本代码如下： 12345678910111213141516// this.async返回的callback其实就是this.callback// this.callback(// err: Error | null,// content: string | Buffer,// sourceMap?: SourceMap,// meta?: any// )module.exports = function(source) &#123; const options = loaderUtils.getOptions(this) const callback = this.async() setTimeout(() =&gt; &#123; const result = source.replace('wq', options.flag) callback(null, result) &#125;, 1000)&#125; 自定义plugins插件其实就是可以理解在js打包过程中需要执行的任务，例如将某些打包好的文件插入的页面模版中，在最终打包的项目中增加一个额外的静态文件，在打包项目之前先删除上一次打包的文件等等这些操作。也会有同步执行和异步执行的，具体可以参考插件编写规范例如下面的代码就是实现在最终打包文件夹中生成一个md文件，代码如下： 插件就是一个类，在使用的时候需要通过new关键字来实例化apply方法来触发同步方法使用compiler.hooks.compile.tap写法异步方法使用compiler.hooks.emit.tapAsync写法 1234567891011121314151617181920212223242526272829303132class ExampleWebpackPlugin &#123; constructor(opts) &#123;&#125; apply(compiler) &#123; compiler.hooks.compile.tap('ExampleWebpackPlugin', compilation =&gt; &#123; console.log('同步complie时刻') &#125;) compiler.hooks.emit.tapAsync('ExampleWebpackPlugin', (compilation, cb) =&gt; &#123; let filelist = 'In this build:\\n\\n' for (const filename in compilation.assets) &#123; filelist += '- ' + filename + '\\n' &#125; // 新定义一个filelist.md文件，并且插入到最终打包的目录中 compilation.assets['filelist.md'] = &#123; source() &#123; // 返回文件的内容 return filelist &#125;, size() &#123; // 返回文件的大小 return filelist.length &#125; &#125; cb() &#125;) &#125;&#125;module.exports = ExampleWebpackPlugin 自定义打包函数以上只是简单的介绍下loader和plugin基本写法的规范，具体其实还有很多官方提供的api可以尝试去使用，写出更加强大的loader及plugin，下面主要介绍下如果利用babel编写一个打包js的函数，需要打包的js源码如下： 123456789101112// index.jsimport msg from './msg.js'console.log(msg)// msg.jsimport word from './word.js'const msg = `say $&#123;word&#125;`export default msg// word.jsconst word = 'wangqi'export default word 以上代码中，假设index.js是入口文件，msg.js和word.js是其他模块代码，如果打包以上这些代码，必须得解决以下几个问题： imort引入浏览器不识别，export default浏览器不识别，es6语法糖解析 import嵌套层数过深怎么解决依赖问题 1、分析单文件 需要用到以下几个库来配合处理： @babel/parser，将javascript生成AST树结构 @babel/traverse ，遍历生成好的AST数结构 @babel/core，其中的transformFromAstSync方法就是将AST数按照@babel/preset-env这个最新的javascript准则去解析 通过node原生fsAPI来读取入口文件，并且配合以上说的几个babel的插件，最终输出单个文件解析的对象。片段代码如下： 12345678910111213141516171819202122 const content = fs.readFileSync(filename, 'utf-8') const ast = parser.parse(content, &#123; sourceType: 'module' &#125;) const dependencies = &#123;&#125; traverse(ast, &#123; ImportDeclaration(&#123; node &#125;) &#123; const dirname = path.dirname(filename) const newFile = './' + path.join(dirname, node.source.value) dependencies[node.source.value] = newFile &#125; &#125;) const &#123; code &#125; = babel.transformFromAstSync(ast, null, &#123; presets: ['@babel/preset-env'] &#125;) return &#123; filename, dependencies, code &#125;&#125; 2、生成所有依赖的对象树 定义一个graphArray收集moduleAnalyser函数分析文件输出的对象树结构，这里在遍历graphArray数组的时候，会通过判断是否存在dependencies则继续遍历对象树的子依赖，并且将子依赖对应的js文件再次交给moduleAnalyser函数处理，最后又被push到graphArray数组中，然后跳出内层循环，继续外层循环，直到dependencies不存在了，就把所有的依赖都遍历完成了。 将第一次遍历得到的graphArray结果，转变成对象的形式输出，方便最终将代码转成浏览器识别做准备，基本代码如下： 123456789101112131415161718192021const makeDependenciesGraph = entry =&gt; &#123; const entryModule = moduleAnalyser(entry) const graphArray = [entryModule] for (let i = 0; i &lt; graphArray.length; i++) &#123; const item = graphArray[i] const &#123; dependencies &#125; = item if (dependencies) &#123; for (let j in dependencies) &#123; graphArray.push(moduleAnalyser(dependencies[j])) &#125; &#125; &#125; const graph = &#123;&#125; graphArray.forEach(item =&gt; &#123; graph[item.filename] = &#123; dependencies: item.dependencies, code: item.code &#125; &#125;) return graph&#125; 3、所有依赖对象树生成浏览器执行代码 在完成以上两步，可以尝试打包，看看运行结果，片段代码如下： 12var _msg = _interopRequireDefault(require(\\\"./msg.js\\\"));exports[\\\"default\\\"] = _default; 你会发现会出现require和exports，这两个都不是浏览器全局提供的api，因此在解析这段代码需要自行实现这两个api，否则浏览器无法直接运行，并且为了打包后的函数块不会影响到全局的环境，因此可以使用闭包将需要打包的代码块包裹住，最终使用eval来执行字符串代码块，代码如下： 12345678910111213141516171819const generateCode = entry =&gt; &#123; const graph = JSON.stringify(makeDependenciesGraph(entry)) return ` (function(graph)&#123; function require(module) &#123; function localRequire(path) &#123; return require(graph[module].dependencies[path]) &#125;; var exports = &#123;&#125;; (function(require, exports, code)&#123; eval(code) &#125;)(localRequire, exports, graph[module].code); return exports; &#125; require('$&#123;entry&#125;') &#125;)($&#123;graph&#125;) `&#125; 4、生成文件夹及dist文件 其实完成以上三步就能将最开始定义的三个文件打包成浏览器识别的代码，这一步主要是能够自动的生成文件夹并且生成最终打包的文件，主要是使用了node原生的操作文件的api，代码如下： 123456789101112131415161718192021const mkDist = (path, name, codeInfo) =&gt; &#123; fs.readdir(path, (error, data) =&gt; &#123; if (error) &#123; fs.mkdirSync(path) &#125; if (data &amp;&amp; data.length) &#123; fs.unlink(`$&#123;path&#125;/$&#123;name&#125;`, error =&gt; &#123; if (error) &#123; console.log(error) return false &#125; &#125;) &#125; fs.writeFile(`$&#123;path&#125;/$&#123;name&#125;`, codeInfo, 'utf8', error =&gt; &#123; if (error) &#123; console.log(error) return false &#125; &#125;) &#125;)&#125; 5、具体调用 12const codeInfo = generateCode('./src/index.js')mkDist('./dist', 'dist.js', codeInfo) 最终打包的完整结果如下： 1234567891011121314(function(graph)&#123; function require(module) &#123; function localRequire(path) &#123; return require(graph[module].dependencies[path]) &#125;; var exports = &#123;&#125;; (function(require, exports, code)&#123; eval(code) &#125;)(localRequire, exports, graph[module].code); return exports; &#125; require('./src/index.js')&#125;)(&#123;\"./src/index.js\":&#123;\"dependencies\":&#123;\"./msg.js\":\"./src/msg.js\"&#125;,\"code\":\"\\\"use strict\\\";\\n\\nvar _msg = _interopRequireDefault(require(\\\"./msg.js\\\"));\\n\\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; \\\"default\\\": obj &#125;; &#125;\\n\\nconsole.log(_msg[\\\"default\\\"]);\"&#125;,\"./src/msg.js\":&#123;\"dependencies\":&#123;\"./word.js\":\"./src/word.js\"&#125;,\"code\":\"\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", &#123;\\n value: true\\n&#125;);\\nexports[\\\"default\\\"] = void 0;\\n\\nvar _word = _interopRequireDefault(require(\\\"./word.js\\\"));\\n\\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; \\\"default\\\": obj &#125;; &#125;\\n\\nvar msg = \\\"say \\\".concat(_word[\\\"default\\\"]);\\nvar _default = msg;\\nexports[\\\"default\\\"] = _default;\"&#125;,\"./src/word.js\":&#123;\"dependencies\":&#123;&#125;,\"code\":\"\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", &#123;\\n value: true\\n&#125;);\\nexports[\\\"default\\\"] = void 0;\\nvar word = 'wangqi';\\nvar _default = word;\\nexports[\\\"default\\\"] = _default;\"&#125;&#125;) 总结其实webpack官网对于loader和plugin都有很详细的分析，自定义一个属于自己的loader和plugin并不难，再一个就是babel的强大，省去了我们对ast树的生成以及ast树的分析工作，其实现在市面上很多这种代码转换工具都是依托于babel的强大工具函数，例如Taro肯定是使用了。以上介绍的内容只是简要的介绍了下相关的内容，如果需要深入还得时刻关注官方网站的更新及变化。以上的内容都附有源码 。 以上就是全部的内容，如果有什么不对的地方，欢迎提issues","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"http://www.iwangqi.com/tags/webpack/"},{"name":"babel","slug":"babel","permalink":"http://www.iwangqi.com/tags/babel/"}]},{"title":"从零开始构建react项目脚手架","date":"2019-05-02T07:43:48.000Z","path":"2019-05-02-reactCli/","text":"基本介绍关于react项目开发，官方有比较成熟的工程脚手架create-react-app，但是为了能更好的学习webpack，其实还是建议从零开始搭建工程脚手架，也能更好的根据项目的特殊要求来做定制化的打包方案，并且能对项目做相应的扩展。 团队在实际项目中也是使用该脚手架进行开发，并没有使用官方的，目前支持了 4 个 react 项目。另外该脚手架并没有做成node包进行一键下载安装，所以在使用上，需要先下载，再复制到自己的项目中，其实这样安排也只是把它作为一个参考，开发这在使用的时候可以根据实际的需求进行增减，话不多说，源码访问传送门 这里主要基于webpack4.16.0+开发 基本需要实现的功能大致如下： 基础配置 css、静态资源 相关 loader 添加 es6 语法兼容 基础 plugins 支持，主要是 htmlWepackPlugin，copyWebpackPlugin、FriendlyErrorsPlugin 等 sourceMap 配置支持 webpackDevServer 使用 &amp; HMR 功能添加 react 语法支持 高级配置 Tree Shaking 设置 Code Splitting 设置 Preload, Prefetch 设置 Shimming 设置 实战配置 PWA 配置 proxy 设置 Eslint 配置 性能优化配置 jest 自动化测试配置 基础配置基本 loader 配置因为实际项目中我们采用放入是less，所以这里对于样式文件的打包会采用style-loader、css-loader、less-loader、postcss-loader，主要是在module.rules下添加，可以查看项目脚手架中的build/webpack.base.conf.js文件代码，基本代码片段如下： 这里MiniCssExtractPlugin.loader主要是对css做分割使用；因为我把所有的样式loader放在公共的 webpack基本配置中，所以添加了一个env来判断是dev还是production环境，主要是通过cross-env来传入变量环境来区分的；注意： 这里的use可以配置多个loader，执行顺序是从下到上，从右到左。 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; test: /\\.css$/, use: [env === 'dev' ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader']&#125;,&#123; test: /\\.less$/, exclude: [/src/], use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, &#123; loader: 'less-loader', options: &#123; modifyVars: &#123; 'primary-color': '#213BD6' &#125;, javascriptEnabled: true &#125; &#125; ]&#125;,&#123; test: /\\.less$/, exclude: [/node_modules/], use: [ env === 'dev' ? 'style-loader' : MiniCssExtractPlugin.loader, &#123; loader: 'css-loader', options: &#123; modules: true, // 开启模块化打包，避免样式全局影响 例：import styles form 'index.less' localIdentName: '[local]_[hash:base64:8]' &#125; &#125;, 'less-loader', 'postcss-loader' ]&#125; postcss-loader主要是为了能自动处理有兼容性配置的 css 文件，同时需要在项目根目录添加.postcssrc.js文件，同时需要配合autoprefixer包进行使用，基本配置如下： 123module.exports = &#123; plugins: [require('autoprefixer')]&#125; 增加了postcss-loader测试运行结果如下: 123-webkit-box-sizing: border-box;-moz-box-sizing: border-box;box-sizing: border-box; 静态资源主要采用的是url-loader来实现，基本代码片段如下： utils.assetsPath主要是通过path的join方法合并路径用处，可以在build/utils.js查看；url-loader会依赖file-loader通过设置limit把小文件转换为 base64 格式的 URL，从而减少网络请求次数 12345678910111213141516&#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125;&#125;,&#123; test: /\\.(woff2?|eot|ttf|otf|ttc)(\\?.*)?$/, loader: 'url-loader', options: &#123; limit: 800000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125;&#125; es6 语法兼容目前基本会采用es6语法进行开发，主要使用babel相关的插件，大致有如下几种： babel-corebabel 的核心包 babel-loader 主要是打包 js 使用 babel-plugin-import 编译过程中将 import 的写法自动转换为按需引入的方式 @babel/plugin-syntax-dynamic-import 编译 import 方法的模块 代码片段如下： 这里没有兼容jsx文件，如果有需要可以自行兼容babel-plugin-import和@babel/plugin-syntax-dynamic-import主要在.babelrc中进行配置了，具体可以查看项目根目录下的.babelrc文件 123456&#123; test: /\\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test')], exclude: '/node_modules/'&#125; 基础 plugins htmlWebpackPlugin 插件主要是将打包好的 css 和 js 插入指定的 html 模版文件中 copyWebpackPlugin 拷贝项目静态目录 static 到 dist 文件夹下 FriendlyErrorsPlugin 识别某些类别的 webpack 错误，主要是在配置 webpack 错误时会出现提示，有更好的开发体验 CleanWebpackPlugin 每次构建时先清空上一次打包的文件，防止由于更改打包逻辑产生的冗余文件 这里主要介绍下htmlWebpackPlugin的使用，更多配置可以参考官网其余几个比较简单，直接通过new实例化就能使用，代码片段如下： 1234567891011new HtmlWebpackPlugin(&#123; filename: 'index.html', // 要将HTML写入的文件 template: 'index.html', // 模板的相对或绝对路径 inject: true, // 将所有资产注入给定template，传递true或'body'所有javascript资源将被放置在body元素的底部。'head'将脚本放在head元素中 minify: &#123; removeComments: true, // 移除HTML中的注释 collapseWhitespace: true, // 删除空白符与换行符 removeAttributeQuotes: true // 删除多余的属性 &#125;, chunksSortMode: 'dependency' // 允许控制在将块包含到HTML之前应如何对块进行排序，我这里选择的是依赖排序&#125;) sourceMap 配置支持其实就是配置devtool选项，我想大部分同学都会直接配置成source-map这个，当然这样配置是没有太大的问题，但是这里其实还有更多的配置可供选择，以下是官网关于devtool所有配置 devtool build rebuild production quality (none) +++ +++ yes bundled code eval +++ +++ no generated code cheap-eval-source-map + ++ no transformed code (lines only) cheap-module-eval-source-map o ++ no original source (lines only) eval-source-map – + no original source cheap-source-map + o yes transformed code (lines only) cheap-module-source-map o - yes original source (lines only) inline-cheap-source-map + o no transformed code (lines only) inline-cheap-module-source-map o - no original source (lines only) source-map – – yes original source inline-source-map – – no original source hidden-source-map – – yes original source nosources-source-map – – yes without source content +++ super fast, ++ fast, + pretty fast, o medium, - pretty slow, -- slow 在实际应用中我主要是用了以下两种： cheap-module-eval-source-map 开发环境使用。cheap的意思是只定位代码错误的行数，并且只针对业务代码定位错误；module的意思是同时也定位第三方模块的错误；eval通过 eval 函数来执行 sourceMap 来映射错误位置，但是会显示错误不完整。所以这里建议这种组合使用。 cheap-module-source-map 线上环境使用。 webpackDevServer 使用 &amp; HMR 功能添加早期主要使用express配合webpack-dev-middleware和webpack-hot-middleware实现启动本地服务以及代码热更新，查看项目中build/webpack.dev.conf.js文件代码，片段如下： 12345678910111213141516171819202122232425devServer: &#123; clientLogLevel: 'none', historyApiFallback: &#123; // 主要实现路由的跳转规则，如果在不使用react或者vue等库的时候这个比较实用，一般很少用到 rewrites: [ &#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') &#125; ] &#125;, hot: true, // 开启hmr功能 // hotOnly: true, // 即便hmr功能没生效，防止浏览器自动刷新 contentBase: false, // 对外提供的访问内容的路径 compress: true, // 是否启用gzip压缩 host: HOST || config.dev.host, // 设置主机域名 port: PORT || config.dev.port, // 设置端口 open: config.dev.autoOpenBrowser, // 默认是否自动打开浏览器 overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, // 在浏览器上全屏显示编译的errors或warnings publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, // 配置代理 quiet: true, // 当启用该配置，除了初始化信息会被写到console中，其他任何信息都不会被写进去。errors和warnings也不会被写到console中。 watchOptions: &#123; poll: config.dev.poll // webpack基于文件系统来获取文件的改变。在某些场景下，是不起作用的。比如，当使用NFS或Vagrant。针对这种情况使用polling进行监控。 &#125;&#125; 这里配置了hot: true其实依然不能开启热更新的功能，还需要在插件中添加new webpack.HotModuleReplacementPlugin()配合使用才行；hotOnly根据个人需要自行选择配置，之前我是配了，但是发现更改代码不会触发更新，所以这里我暂时取消配置 react 语法支持主要也是使用babel相关的插件进行打包实现，目前主要使用的是@babel/preset-react、@babel/preset-env，相关配置主要在.babelrc文件中，代码如下： 12345678910111213141516171819202122&#123; \"presets\": [ [\"@babel/preset-env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125;, \"useBuiltIns\": \"usage\" // 只加载使用的polyfill的内容 &#125;], \"@babel/react\" ], \"plugins\": [\"@babel/plugin-transform-runtime\", \"@babel/plugin-syntax-dynamic-import\", [\"import\", &#123; \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": true // `style: true` 会加载 less 文件 &#125;]], \"env\": &#123; \"test\": &#123; \"plugins\": [\"transform-es2015-modules-commonjs\"] &#125; &#125;&#125; @babel/plugin-transform-runtime会自动 polyfill es5 不支持的特性，同时有以下几个好处： 不会污染全局变量 多次使用只会打包一次 依赖统一按需引入,无重复引入,无多余引入 当然也有@babel/plugin-transform-runtime无法兼容的 es 新的语法糖，在早期大家可能会在项目入口文件引入babel-polyfill，但是这里的@babel/preset-env插件已经帮我做了这件事，只需要加上&quot;useBuiltIns&quot;: &quot;usage&quot;这个配置，它会只加载你使用的 polyfill 的内容。 高级配置Tree Shaking 设置 TreeShaking 只支持 ES Module 形式的，不支持 commonjs 规范。 TreeShaking 只会作用于每个模块的已使用并导出，例如像以下这样的，如果开启了 TreeShaking 就会自动被忽略掉。你可以在package.json中sideEffects配置不需要做 TreeShaking 的文件 1234import 'babel-polyfill'// package.jsonsideEffects: ['babel-polyfill'] 但是在实际使用中很难去手动一个个去配置，因此对于webpack4.16.0+打包而言，当你使用mode:production默认是开启 TreeShaking 功能，如果你使用mode:development需要开启 TreeShaking 功能的话，需要在optimization中配置usedExports:true、providedExports: true、sideEffects: true，按照以下这样配置就不需要在手动去配置了，代码片段如下： 1234567optimization: &#123; providedExports: true, usedExports: true, // 开启tree shaking // 识别package.json中的sideEffects以剔除无用的模块，用来做tree-shake // 依赖于optimization.providedExports和optimization.usedExports sideEffects: true&#125; Code Splitting 设置主要也是optimization.splitChunks这个配置项，更多用法可以参考官网,代码片段如下： 1234567891011121314151617181920212223242526optimization: &#123; splitChunks: &#123; chunks: 'all', minSize: 30000, // 超过最小的限制大小则进行代码分割处理 maxSize: 0, minChunks: 1, // 判断库被引用多少次才进行打包分割 maxAsyncRequests: 5, // 最大异步请求数， 默认1，只会对前5个库文件代码分割打包 maxInitialRequests: 3, // 最大初始化请求数，默认1，对项目入口文件的前3个库文件进行代码分割 automaticNameDelimiter: '~', // 代码分割名称的分割符 name: true, // cacheGroups中的设置名称有效 cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; priority: -20, reuseExistingChunk: true // 如果一个模块已经被打包了，则忽略该模块打包 &#125; &#125; &#125;, // 打包提取公共的关联关系代码（vendors和default）的关联关系代码 runtimeChunk: &#123; name: 'manifest' &#125;&#125; chunks有all, async, initial三种配置，all对于同步代码和异步代码都会进行代码分割处理，其余两个分别只正对异步代码和同步代码 minSize超过最小的限制大小则进行代码分割处理 minChunks 判断库被引用多少次才进行打包分割 maxAsyncRequests 最大异步请求数， 默认 1，只会对前 5 个库文件代码分割打包 maxInitialRequests 最大初始化请求数，默认 1，对项目入口文件的前 3 个库文件进行代码分割 automaticNameDelimiter 代码分割名称的分割符 name cacheGroups 中的设置名称有效，一般不会直接使用 cacheGroups 配置中的 filename，一般会使用 output 配置中的 chunkFilename 设置的名称 cacheGroups缓存打包配置，主要是在打包的过程中，判断需要打包的文件是打在vendors还是default中，会根据test的正则，把符合规则的打包在一起，否则就打包到default中。priority 代码打包优先级，值越大优先级越高 reuseExistingChunk 如果一个模块已经被打包了，则忽略该模块打包 runtimeChunk 打包提取公共的关联关系代码（vendors 和 default）的关联关系代码 针对chunks配置举例说明，编写一段异步引入的代码，基本如下： 1234567891011function getLodash() &#123; return import('lodash').then((&#123; default: _ &#125;) =&gt; &#123; const element = document.createElement('div') element.innerHTML = _.join(['wq', '123'], '-') return element &#125;)&#125;getLodash().then(element =&gt; &#123; document.body.appendChild(element)&#125;) 因为这里的lodash是异步调用的，如果你在chunks配置的是initial，其实是不会被分割打包的，因为 wenbpack 默认splitChunks.chunks配置是async，所以一般这里会配置成all Preload, Prefetch 设置 被标记为 prefetch 的资源，将会被浏览器在空闲时间加载。 preload 通常用于本页面要用到的关键资源，包括关键 js、字体、css 文件。preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度。 所以对于异步加载的资源建议可以使用prefetch做标记，这样就不会影响关键资源的下载。通过下载preload-webpack-plugin插件，在安装的时候需要安装beta版本，可以执行以下语句： 1npm i preload-webpack-plugin@next -D 可以查看build/webpack.prod.conf.js代码，基本配置如下： 123456789101112new PreloadWebpackPlugin(&#123; rel: 'prefetch'&#125;),new PreloadWebpackPlugin(&#123; rel: 'preload', as(entry) &#123; if (/\\.css$/.test(entry)) return 'style' if (/\\.woff$/.test(entry)) return 'font' if (/\\.png$/.test(entry)) return 'image' return 'script' &#125;&#125;), Shimming 设置主要通过new webpack.ProvidePlugin()去实现，配置示例如下： 123new webpack.ProvidePlugin(&#123; $: 'jquery'&#125;) 如果在插件选项中配置了，则在代码逻辑中就不需要在写import $ from &#39;jquery&#39;这样的代码，可以减少书写的代码量，其实个人不太喜欢这样配置，所以在最终的源码中并未加这样的配置，具体根据项目实际需求可自行添加。 其实到这里，一个基本的react构建工具就可以正常运行了，能满足基本的业务需求了，但是为了更好的提高开发效率，还需做一些其他的配置，大致内容基本如下： 实战配置PWA 配置PWA其实也是一种缓存策略，通俗的说，就是你能在断网的情况下正常访问网页的内容，或者能够正常访问被宕机的网页内容，主要目的就是提高用户体验，主要依赖workbox-webpack-plugin插件实现，片段代码如下： 123456789// 配置PWAnew WorkboxPlugin.GenerateSW(&#123; cacheId: 'webpack-pwa', // 设置前缀 skipWaiting: true, // 强制等待中的 Service Worker 被激活 clientsClaim: true, // Service Worker 被激活后使其立即获得页面控制权 swDest: 'service-worker.js', // 输出 Service worker 文件 globPatterns: ['**/*.&#123;html,js,css,png.jpg&#125;'], // 匹配的文件 globIgnores: ['service-worker.js'] // 忽略的文件&#125;) 项目模版文件index.html需要加入以下代码： 123456789101112131415&lt;script&gt; // 进行 service-wroker 注册 if ('serviceWorker' in navigator) &#123; window.addEventListener('load', () =&gt; &#123; navigator.serviceWorker .register('./service-worker.js') .then(registration =&gt; &#123; console.log('SW registered: ', registration) &#125;) .catch(registrationError =&gt; &#123; console.log('SW registration failed: ', registrationError) &#125;) &#125;) &#125;&lt;/script&gt; 经过以上配置，就能实现 PWA 的功能，具体测试可以下载源码直接运行测试，可以先执行npm run build然后再执行npm run start然后再断开服务，直接刷新网页就能看到 PWA 的效果了。 proxy 设置 最终源码中这里没有做设置，开发这可根据需要自行配置 代理主要是在前后端进行接口调试时候比较好用，因为前端在本地调试服务端的接口的时候默认是跨域的，一般有两种解决方案，一种是关闭浏览器跨域设置，mac 中的谷歌可以在 iterm2 只运行以下代码： 1open -a /Applications/Google\\ Chrome.app --args --disable-web-security --user-data-dir 另外一种就是配置proxy，片段代码如下： 123456789devServer: &#123; proxy: &#123; '/api/users': &#123; target: 'https://localhost:3000', secure: false, pathRewrite: &#123;'/user' : '/mockUser'&#125; &#125; &#125;&#125; 如果接口路径是https://localhost:3000/api/users，那么经过上面配置就会代理到(假设本地启动的服务端口是 8080)https://localhost:8080/api/mockUser，这样就不会出现跨域的问题；secure: false针对https有效的配置。更多配置可以参考官网 Eslint 配置这个配置主要越是多人开发书写的代码风格保持一致，增强代码的可读性，基本按照 eslint 相关的库文件即可，大致如下： babel-eslint eslint eslint-config-standard eslint-friendly-formatter eslint-loader eslint-plugin-import eslint-plugin-node eslint-plugin-promise eslint-plugin-react eslint-plugin-standard 只需要在module.rules中增加关于eslint-loader的配置，片段代码如下： 1234567891011&#123; test: /\\.js[x]?$/, loader: 'eslint-loader', enforce: 'pre', include: [resolve('src')], exclude: [/node_modules/], options: &#123; formatter: require('eslint-friendly-formatter'), emitWarning: !config.dev.showEslintErrorsInOverlay &#125;&#125; 同时在项目的根目录中新建.eslintignore和.eslintrc.js文件，具体内容可以直接去源码中查看即可。 其实可以在项目commit的时候进行eslint检测，这样也能进一步保证提交的代码风格保持一致，主要依赖pre-commit这个包，然后可以在package.json中如下配置，以下是片段代码，具体请查看项目源码： 123456\"scripts\": &#123; \"lint\": \"eslint --ext .js src\"&#125;,\"pre-commit\": [ \"lint\"] 这样配置之后就会在commit的时候主动触发lint的命令，来检测代码风格是否符合规范。 性能优化配置这里的性能优化配置主要介绍的是 dll 的配置，至于HappyPack多进程打包源码中已经做了配置，直接使用即可。 首先可以新建一个 webpack 的配置文件，将你需要打包成dll.js添加到入口文件中，然后使用webpack.DllPlugin插件生成打包后的映射文件，完整代码如下： 1234567891011121314151617181920212223242526const path = require('path')const webpack = require('webpack')module.exports = &#123; mode: 'production', entry: &#123; vendors: ['lodash', 'moment'], react: ['react', 'react-dom', 'redux', 'react-redux'] &#125;, output: &#123; filename: '[name].dll.js', path: path.resolve(__dirname, '../dll'), library: '[name]' &#125;, plugins: [ // 解决moment语言包问题 new webpack.ContextReplacementPlugin( /moment[\\\\\\/]locale$/, /^\\.\\/(zh-cn)$/ ), new webpack.DllPlugin(&#123; name: '[name]', path: path.resolve(__dirname, '../dll/[name].manifest.json') &#125;) ]&#125; 具体在webpack.prod.conf.js使用需要用到AddAssetHtmlWebpackPlugin和webpack.DllReferencePlugin，一个是将dll.js添加到打包的dist目录下，一个是判断在打包过程中如果遇到以上设置的模块，会通过映射去dll文件夹中寻找生成的dll.js，这样就不会从node_modules中去寻找，提高打包效率。以下是使用的片段代码： 123456new AddAssetHtmlWebpackPlugin(&#123; filepath: path.resolve(__dirname, '../dll', 'vendors.dll.js')&#125;),new webpack.DllReferencePlugin(&#123; manifest: path.resolve(__dirname, '../dll', 'vendors.manifest.json')&#125;), 源码中是通过使用node原生的fs模块读取dll文件夹，动态加入需要设置dll的相关配置 jest 自动化测试配置主要使用的是jest和enzyme配合进行使用，需要下载相关的包有以下这些： jest enzyme enzyme-adapter-react-16 babel-plugin-transform-es2015-modules-commonjs 然后在package.json中添加test命令，并且设置环境变量cross-env BABEL_ENV=test，这样设置，在运行npm run test的时候就会去执行.babelrc下的env.test下面的内容。 .babelrc完整配置如下： 12345678910111213141516171819202122&#123; \"presets\": [ [\"@babel/preset-env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125;, \"useBuiltIns\": \"usage\" // 只加载使用的polyfill的内容 &#125;], \"@babel/react\" ], \"plugins\": [\"@babel/plugin-transform-runtime\", \"@babel/plugin-syntax-dynamic-import\", [\"import\", &#123; \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": true // `style: true` 会加载 less 文件 &#125;]], \"env\": &#123; \"test\": &#123; \"plugins\": [\"transform-es2015-modules-commonjs\"] &#125; &#125;&#125; 注意：如果需要运行npm run test请先注释外层的plugins，目前发现的原因是jest和@babel/plugin-transform-runtime不兼容。 总结其实搭建一个脚手架并不难，只熟悉webpack官方的文档基本需求都能解决，webpack的配置项有很多，可以根据业务需求自己进行进一步扩展，目前源码中还集成了antd、react-router、react-saga、redux、axios等常规前端开发使用的库，可以直接使用，直接运行源码有一个简单的示例页面。 以上就是全部的内容，如果有什么不对的地方，欢迎提issues","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://www.iwangqi.com/tags/webpack/"}]},{"title":"通过开发精简版的koa2了解其原理实现","date":"2018-11-24T07:43:48.000Z","path":"2018-11-24-koa2/","text":"Koa2号称是下一代的web框架，由Express幕后原版人马打造，据说更小、更快、更加精简，主要采用了es7的语法糖async和await，并且koa2摒弃了express中的回调函数机制，这么多特性不得不去学习下它的原理，因此，自己通过实现精简版的Qoa（koa2）来了解其原理实现，只是为了学习使用，欢迎来交流（github）。 介绍简单实现koa基本功能，仅供学习参考，了解koa的核心思想以及实现过程。 环境要求依赖 node v7.6.0 或 ES2015及更高版本和 async 方法支持。 实现功能主要依据koa官网介绍，实现简易核心功能，基本实现以下几个功能 [x] use [x] listen [x] callback [x] keys [x] context 上下文 [x] response [x] request [x] middleware use实现useAPI其实就是将定义的方法发push进入定义的中间件数组变量middleware中，核心代码如下：123use(cb) &#123; this.middleware.push(cb)&#125; listen主要是调用了node原生API中的http.createServer()方法，在这会运行两个方法，基本如下： 1、创建ctx2、定义fn变量，保存use中的push进去的方法，3、运行所有的fn中的方法，同时通过定义的next来触发fn中下一个中间件方法1234567const server = http.createServer(async (req, res) =&gt; &#123; const ctx = this.createCtx(req, res) const fn = compose(this.middleware) await fn(ctx) ctx.res.end(ctx.body)&#125;)return server.listen(...args) callback之前定义的listen中，使用http.createServer()起的端口服务，如果需要定义多个端口，或者定义https的话，你就可以使用callback这个API，并且将之前定义的中间件方法再次运行一次，然后挂在到新定义的服务上，代码如下：123456const fn = compose(this.middleware) const handleRequest = (req, res) =&gt; &#123; const ctx = this.createCtx(req, res) return this[_handleRequest](ctx, fn) &#125; return handleRequest 定义this[_handleRequest]主要是为了使用私有方法，这样外部就能被访问。 keys这个主要是为了设置签名的 Cookie 密钥使用的，跟koa2实现基本一致，片段代码如下：12345678910111213// context.jsget cookies() &#123; if (!this[COOKIES]) &#123; this[COOKIES] = new Cookies(this.req, this.res, &#123; keys: this.app.keys &#125;); &#125; return this[COOKIES];&#125;,set cookies(_cookies) &#123; this[COOKIES] = _cookies;&#125; context.js中能获取到this.app上定义的属性，主要是因为在application.js中创建上下文的时候将this赋值给当前context、request、response的app，片段代码如下：12// application.jscontext.app = request.app = response.app = this context这里并没有实现完整的context代码，主要是使用了get set来定义方法，这样能监听对上下文的改变，并没有按照koa实现完整逻辑，只是为了实现基本流程，完整代码如下：1234567891011121314151617181920212223242526// context.jsconst Cookies = require('cookies');const COOKIES = Symbol('context#cookies');module.exports = &#123; get url() &#123; return this.request.url &#125;, get body() &#123; return this.response.body &#125;, set body(val) &#123; this.response.body = val &#125;, get cookies() &#123; if (!this[COOKIES]) &#123; this[COOKIES] = new Cookies(this.req, this.res, &#123; keys: this.app.keys &#125;); &#125; return this[COOKIES]; &#125;, set cookies(_cookies) &#123; this[COOKIES] = _cookies; &#125;&#125; response和request为了实现基本流程，所以代码并不复杂，基本如下：12345678910// response.jsmodule.exports = &#123; get body() &#123; return this._body &#125;, set body(val) &#123; this._body = val &#125;&#125; 123456// request.jsmodule.exports = &#123; get url() &#123; return this.req.url &#125;&#125; middlewarekoa2的中间件其实就是洋葱结构，从上往下一层一层进来，再从下往上一层一层回去。实现简易版的中间件机制，完整代码如下：1234567891011121314151617// compose.jsfunction compose(middleware) &#123; return (context) =&gt; &#123; // 第一次出发use中的中间件的函数内容 return dispatch(0) function dispatch(i) &#123; let fn = middleware[i] if(!fn) return Promise.resolve() return Promise.resolve(fn(context, next =&gt; &#123; // 这里的next就是外层use中间件传入的next，用来确定执行下一个中间件的标记 return dispatch(i + 1) &#125;)) &#125; &#125;&#125;module.exports = compose 这个得结合示例代码以及application.js中的方法来读懂compose方法，以下是application.js中的use、listen、createCtx三个方法：123456789101112131415161718192021222324252627module.exports = class Application &#123; // 省略 use(cb) &#123; this.middleware.push(cb) &#125; listen(...args) &#123; const server = http.createServer(async (req, res) =&gt; &#123; const ctx = this.createCtx(req, res) const fn = compose(this.middleware) await fn(ctx) // 将上下文ctx传入compose.js中的compose方法中return出来的函数 ctx.res.end(ctx.body) &#125;) return server.listen(...args) &#125; createCtx(req, res) &#123; const ctx = Object.create(this.context) const request = ctx.request = Object.create(this.request) const response = ctx.response = Object.create(this.response) ctx.app = request.app = response.app = this ctx.req = request.req = response.req = req ctx.res = request.res = response.res = res return ctx &#125; // 省略&#125; 根据demo测试代码，你会发现最后浏览器预览输出的结果是123654，123好理解，根据上面的源码，发现use只是个同步代码，只有在触发next时会触发compose中的dispatch方法，继续执行下一个异步中间件逻辑操作，因此会接着拼出654，至于为什么不是123456可以查看关于node环境下的事件循环机制 再谈上下文这里主要看看入口文件，对于上下文到底做了什么，片段代码如下：123456789101112131415// application.js// 省略module.exports = class Application &#123; // 省略 createCtx(req, res) &#123; const ctx = Object.create(this.context) const request = ctx.request = Object.create(this.request) const response = ctx.response = Object.create(this.response) ctx.app = request.app = response.app = this ctx.req = request.req = response.req = req ctx.res = request.res = response.res = res return ctx &#125; // 省略&#125; 这里需要解释下，ctx.req、ctx.res、ctx.app、request.res、response.req： request - request继承于Request.js静态类，包含操作request的一些常用方法 response - response继承于Response.js静态类，包含操作response的一些常用方法 req - nodejs原生的request对象 res - nodejs原生的response对象 app - koa的原型对象 demo测试运行test文件夹下的js文件即可，基本实现以上几个简易的功能，测试代码如下：12345678910111213141516171819202122232425262728293031323334353637const Qoa = require('../core/application')const http = require('http')const https = require('https')const app = new Qoa()app.use(async (ctx, next) =&gt; &#123; ctx.body = '1' ctx.cookies.set('name', 'tobi', &#123; signed: true &#125;) await next() ctx.body += '4'&#125;)app.use(async (ctx, next) =&gt; &#123; ctx.body += '2' await next() ctx.body += '5'&#125;)app.use(async (ctx, next) =&gt; &#123; ctx.body += '3' await next() ctx.body += '6'&#125;)app.keys = ['im a newer secret', 'i like turtle']app.listen(3000, () =&gt; &#123; console.log('server start port 3000')&#125;)http.createServer(app.callback()).listen(1234, () =&gt; &#123; console.log('开启1234端口')&#125;);https.createServer(app.callback()).listen(443, () =&gt; &#123; console.log('开启443端口')&#125;); 总结Koa相关api介绍 最后如果有什么不对的地方，欢迎提issues","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"node","slug":"node","permalink":"http://www.iwangqi.com/tags/node/"},{"name":"koa2","slug":"koa2","permalink":"http://www.iwangqi.com/tags/koa2/"}]},{"title":"深入理解javascript事件循环机制（浏览器与nodejs环境）","date":"2018-11-20T06:01:23.000Z","path":"2018-11-20-EventLoop/","text":"浏览器端的事件循环了解js的同学都应该知道，说的最多的就是js是单线程，但是单线程的js同样能实现异步，通俗的讲，异步其实就是再另外开辟一个进程去执行相关操作，或许对于多线程来讲更能实现异步。那么js单线程是如何实现异步的呢？ js同步异步也是面试中常常被问到的。 js其实分同步异步，它们的处理方式也不同，同步任务是在主线程上排队执行，异步任务则会被放到异步任务队列中，若有多个任务（异步任务）则要在任务队列中排队等待，任务队列类似一个缓冲区，任务下一步会被移到调用栈（call stack），然后主线程执行调用栈的任务。 单线程是指js引擎中负责解析执行js代码的线程只有一个（主线程），即每次只能做一件事，例如我们最常用的ajax请求，主线程在等待响应返回结果的同时依然会去执行其他的方法，主要是因为浏览器先在事件表注册ajax的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，也就是ajax其实是个异步的。 这里说的ajax是浏览器原生的，而任何二次封装其实有配置项使得该ajax为同步。 在上面的概念中提到了两个词，栈（stack）、任务队列，js在执行主线程代码过程中，会去不断的检查栈中是否有事件需要去执行，哪些事件会被放入任务队列中以及什么时候会去执行任务队列中的事件。这其实就是事件循环需要去做的事情。 下图就是调用栈和任务队列的关系图（截图来自Philip Roberts的演讲《Help, I’m stuck in an event-loop》） 上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要主栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 宏任务和微任务根据上面的说明，可以确认一点，任务队列和栈是两个不同“线程”，例如上面讲的原生ajax异步请求，它就会被先放在任务队列中，等待响应之后，再被调用到栈中去执行。 事件循环至少包含两个队列，macrotask队列和microtask队列。 其实任务队列中包含两种类型：宏任务（macrotask） 、 微任务（microtask）。 浏览器端和node端对宏任务和微任务具体的分类还有所区别，后面会介绍到。 浏览器端： 宏任务（macrotask）：执行主线程js代码，事件回调，XHR回调，setTimeout，setInterval，requestAnimationFrame，I/O，UI render 微任务（microtask）：promise回调，Object.observe，async await，MutationObserver 再贴一张牛逼闪闪的解释图（截图来自《HTML系列：macrotask和microtask》） 事件循环有两个基本原则：1、同一时间只能执行一个任务。2、任务一直执行到完成，不能被其他任务抢断。 根据上图可以得出一次事件循环基本分以下几个步骤： 事件循环检查macrotask队列是否为空，非空则到2，为空则到3 执行macrotask中的一个任务 事件循环继续检查microtask队列是否为空，若有则到4，否则到5 取出microtask中的任务执行，执行完成返回到步骤3 执行视图更新，再次到1 根据上面5个步骤以及图示可以看出， 1、js在执行任何一个任务的时候是不会被中断的。2、单次事件循环中，只会执行一次宏任务，而会执行全部的微任务。3、当微任务为空时，事件循环检查是否需要执行UI重渲染，如果需要则重渲染UI。这样就结束了当次循环，继续从头开始检查宏任务。4、所有的微任务都应该在下次UI渲染前执行完，因为其目的就是在渲染前更新应用状态。 贴上一段代码再来一张牛逼闪闪的动图，这样就能更清楚的理解了：123456789101112131415console.log('start')setTimeout(() =&gt; &#123; console.log('setTimeout')&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log('promise1')&#125;).then(() =&gt; &#123; console.log('promise2')&#125;)console.log('end')// 浏览器执行顺序是：start end promise1 promise2 setTimeout 先输出start和end没啥问题，根据上面的分析，执行主线程js属于宏任务，因此接下来会执行微任务，所以会输出promise1和promise2，然后做是否UI更新操作，到此完成了一次事件循环，然后再次进行检测是否有宏任务，也就是输出了setTimeout，然后再次做是否UI更新操作，最终结束。 这里有一点需要注意下，promise中的then才是异步代码，下面代码在浏览器端运行结果可以证明这一点：123456789101112setTimeout(() =&gt; console.log(4))new Promise(resolve =&gt; &#123; resolve() console.log(1)&#125;).then(_ =&gt; &#123; console.log(3)&#125;)console.log(2)// 浏览器执行顺序是：1 2 3 4 UI视图渲染何时发生在上面的介绍中，一直都在说，判断是否需要进行UI视图渲染，那么到底这个东西什么时候会发生呢？根据之前定义的一次事件循环的5个步骤中解释到：UI视图渲染将会在所有微任务执行完之后执行。 主动可控的我们在使用vue开发过程中，肯定会使用nextTick这个API，这个就是使用这可以主动去更新视图，通常会在数据变化之后主动去更新视图。其实内部机制是通过原生Promise.then和MessageChannel（没听过）去实现的，对于低版本的浏览器会降级到使用setTimeout(fn, 0)去替代。具体可以查看vue中的异步更新队列介绍 小程序开发中也会有nextTick这个API，效果其实是一样的。 不可控的对于不可控的视图更新会想到使用这个requestAnimationFrameAPI，因为这是浏览器来判断是否需要进行视图更新操作，通过下面的示例代码可以验证这一点：1234567891011121314151617181920setTimeout(() =&gt; &#123;console.log('setTimeout1')&#125;, 0)requestAnimationFrame(() =&gt;&#123; console.log('requestAnimationFrame')&#125;)setTimeout(() =&gt; &#123;console.log('setTimeout2')&#125;, 0)new Promise((resolve) =&gt; &#123; console.log('promise 1') resolve() console.log('promise 2')&#125;).then(() =&gt; &#123; console.log('promise then')&#125;)console.log('end')// 谷歌浏览器端执行顺序： promise 1 promise 2 end promise then requestAnimationFrame setTimeout1 setTimeout2// 火狐浏览器执行顺序：promise 1 promise 2 end promise then setTimeout1 setTimeout2 requestAnimationFrame 不同的浏览器执行的结果不一样，如上图所示，requestAnimationFrame的执行时机与浏览器的渲染策略有关。 Node环境下的事件循环先运行下面的示例代码：12345678910111213141516setTimeout(()=&gt;&#123; console.log('timer1') Promise.resolve().then(() =&gt; &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(()=&gt;&#123; console.log('timer2') Promise.resolve().then(() =&gt; &#123; console.log('promise2') &#125;)&#125;, 0)// 浏览器端执行顺序：timer1 promise1 timer2 promise2// node环境执行顺序：timer1 timer2 promise1 promise2 根据上面的示例代码运行结果可以看出，node环境下的事件循环和浏览器端的运行机制还是有所不同的，先贴一张图（截图来自阮老师的《JavaScript 运行机制详解：再谈Event Loop》） 引用阮老师的解释，Node.js的运行机制如下： （1）V8引擎解析JavaScript脚本。 （2）解析后的代码，调用Node API。 （3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。 （4）V8引擎再将结果返回给用户。 再说事件循环之前，先列出node环境下的宏任务和微任务有哪些： 宏任务（macrotask）：执行主线程js代码，事件回调，XHR回调，setTimeout，setInterval，I/O， setImmediate 微任务（microtask）：promise回调，async await，process.nextTick libuv库是实现事件循环的关键，贴一段源码，片段如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; //判断事件循环是否存活。 r = uv__loop_alive(loop); //如果没有存活，更新时间戳 if (!r) uv__update_time(loop); //如果事件循环存活，并且事件循环没有停止。 while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; //更新当前时间戳 uv__update_time(loop); // timers阶段 uv__run_timers(loop); // 执行由于上个循环未执行完，并被延迟到这个循环的I/O 回调 ran_pending = uv__run_pending(loop); // idle阶段 内部调用 uv__run_idle(loop); // prepare阶段 内部调用 uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) // 计算距离下一个timer到来的时间差。 timeout = uv_backend_timeout(loop); // poll阶段，该阶段轮询I/O事件，有则执行，无则阻塞，直到超出timeout的时间。 uv__io_poll(loop, timeout); // check阶段 主要执行 setImmediate 回调。 uv__run_check(loop); // close callbacks阶段 uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; //更新当前时间戳 uv__update_time(loop); //再次执行timers回调。 uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; /* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; Node.js启动时会初始化事件循环, 每一个事件循环都会包含按如下顺序六个循环阶段： 123456789101112131415161718 ┌───────────────────────────┐┌─&gt;│ timers │ uv__run_timers(loop)│ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ I/O callbacks │ uv__run_pending(loop)│ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare │ uv__run_idle(loop)│ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, │ uv__io_poll()│ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check │ uv__run_check(loop)│ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ uv__run_prepare(loop) └───────────────────────────┘ timers 阶段: 这个阶段执行setTimeout(callback) and setInterval(callback)预定的callback; I/O callbacks 阶段: 执行除了close事件的callbacks、被timers(定时器，setTimeout、setInterval等)设定的callbacks、setImmediate()设定的callbacks之外的callbacks; 执行一些系统调用错误，比如网络通信的错误回调(目前这个阶段) idle, prepare 阶段: 仅node内部使用; poll 阶段: 获取新的I/O事件, 适当的条件下node将阻塞在这里; check 阶段: 执行setImmediate() 设定的callbacks; close callbacks 阶段: 比如socket.on(‘close’, callback)的callback会在这个阶段执行。 首先确定下，这个事件循环中涉及到的方法全是异步的，通过这个示意图可以确定在check阶段会去执行setImmediate中的callback函数，再之后就是内部调用uv__run_prepare，关闭callback函数，然后再次回到timers阶段，那么我们可以暂时把setImmediate作为下一次循环开始的标记，这个对后面理解运行顺序有很大的帮助。 timer阶段贴一段timer相关的源码片段12345678910111213141516171819202122232425262728293031323334353637383940414243static struct heap *timer_heap(const uv_loop_t* loop) &#123;#ifdef _WIN32 return (struct heap*) loop-&gt;timer_heap;#else return (struct heap*) &amp;loop-&gt;timer_heap;#endif&#125;int uv_timer_again(uv_timer_t* handle) &#123; if (handle-&gt;timer_cb == NULL) return UV_EINVAL; // 如果是repeat则重新创建定时器 if (handle-&gt;repeat) &#123; uv_timer_stop(handle); uv_timer_start(handle, handle-&gt;timer_cb, handle-&gt;repeat, handle-&gt;repeat); &#125; return 0;&#125;void uv__run_timers(uv_loop_t* loop) &#123; struct heap_node* heap_node; uv_timer_t* handle; for (;;) &#123; // 取出定时器堆中时间最近的定时器代码（setTimeout/setInterval） heap_node = heap_min(timer_heap(loop)); if (heap_node == NULL) break; handle = container_of(heap_node, uv_timer_t, heap_node); // 判断最近的定时器的时间是否大于当前时间，如果大于当前时间，说明还未超时，跳出循环。 if (handle-&gt;timeout &gt; loop-&gt;time) break; // 停止定时器 uv_timer_stop(handle); // 判断定时器句柄类型是否是repeat类型，如果是，重新创建一个定时器。 uv_timer_again(handle); // 执行定时器绑定的回调函数 handle-&gt;timer_cb(handle); &#125;&#125; 首先判断是否存在未超时的定时器，如果存在就会跳出，执行事件循环的下一个环节，这里会有个问题，就是判断是否未超时，在实际场景中，node是无法准确的根据定时器设定的时间来精准确定该定时器何时运行回调函数，也就是如果将setTimeout和setImmediate放在如下的代码示例中，就很难确定，setTimeout是在第一次循环中执行还是第二次循环中执行。123456789setTimeout(() =&gt; &#123; console.log('timeout')&#125;, 0)setImmediate(() =&gt; &#123; console.log('immediate')&#125;)// node 环境运行结果 timeout immediate 或者 immediate timeout 如果在主线程代码中再加入其他同步代码，可以保证setTimeout先执行，主要是因为在运行其他主线程代码时，给setTimeout预留的时间，示例代码如下：1234567891011setTimeout(() =&gt; &#123; console.log('timeout')&#125;, 0)setImmediate(() =&gt; &#123; console.log('immediate')&#125;)console.log('主线程代码')// node 环境运行结果 主线程代码 timeout immediate I/O callbacks阶段这个阶段执行一些系统操作的回调。比如TCP错误，如一个TCP socket在想要连接时收到ECONNREFUSED,类unix系统会等待以报告错误，这就会放到 I/O callbacks 阶段的队列执行。 idle, prepare为内部调用，不去关注它。 poll阶段贴一段源码片段：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124void uv__io_poll(uv_loop_t* loop, int timeout) &#123; // 省略变量初始化代码 if (loop-&gt;nfds == 0) &#123; // 判断观察者队列是否为空，如果为空，则返回 assert(QUEUE_EMPTY(&amp;loop-&gt;watcher_queue)); return; &#125; nevents = 0; // 观察者队列不为空 while (!QUEUE_EMPTY(&amp;loop-&gt;watcher_queue)) &#123; /* 取出队列头的观察者对象 取出观察者对象感兴趣的事件并监听。 */ w-&gt;events = w-&gt;pevents; &#125; pset = NULL; if (loop-&gt;flags &amp; UV_LOOP_BLOCK_SIGPROF) &#123; pset = &amp;set; sigemptyset(pset); sigaddset(pset, SIGPROF); &#125; assert(timeout &gt;= -1); // 如果有超时时间，将当前时间赋给base变量 base = loop-&gt;time; // 本轮执行监听事件的最大数量 count = 48; /* Benchmarks suggest this gives the best throughput. */ // 进入监听循环 for (;; nevents = 0) &#123; // 有超时时间的话，初始化spec if (timeout != -1) &#123; spec.tv_sec = timeout / 1000; spec.tv_nsec = (timeout % 1000) * 1000000; &#125; if (pset != NULL) pthread_sigmask(SIG_BLOCK, pset, NULL); // 监听内核事件，当有事件到来时，即返回事件的数量。 // timeout 为监听的超时时间，超时时间一到即返回。 // 我们知道，timeout是传进来得下一个timers到来的时间差，所以，在timeout时间内，event-loop会一直阻塞在此处，直到超时时间到来或者有内核事件触发。 nfds = kevent(loop-&gt;backend_fd, events, nevents, events, ARRAY_SIZE(events), timeout == -1 ? NULL : &amp;spec); if (pset != NULL) pthread_sigmask(SIG_UNBLOCK, pset, NULL); /* Update loop-&gt;time unconditionally. It's tempting to skip the update when * timeout == 0 (i.e. non-blocking poll) but there is no guarantee that the * operating system didn't reschedule our process while in the syscall. */ SAVE_ERRNO(uv__update_time(loop)); //如果内核没有监听到可用事件，且本次监听有超时时间，则返回。 if (nfds == 0) &#123; assert(timeout != -1); return; &#125; if (nfds == -1) &#123; if (errno != EINTR) abort(); if (timeout == 0) return; if (timeout == -1) continue; /* Interrupted by a signal. Update timeout and poll again. */ goto update_timeout; &#125; have_signals = 0; nevents = 0; //判断事件循环的观察者队列是否为空 assert(loop-&gt;watchers != NULL); loop-&gt;watchers[loop-&gt;nwatchers] = (void*) events; loop-&gt;watchers[loop-&gt;nwatchers + 1] = (void*) (uintptr_t) nfds; // 循环处理内核返回的事件，执行事件绑定的回调函数 for (i = 0; i &lt; nfds; i++) &#123; // ... &#125; if (have_signals != 0) loop-&gt;signal_io_watcher.cb(loop, &amp;loop-&gt;signal_io_watcher, POLLIN); loop-&gt;watchers[loop-&gt;nwatchers] = NULL; loop-&gt;watchers[loop-&gt;nwatchers + 1] = NULL; if (have_signals != 0) return; /* Event loop should cycle now so don't poll again. */ if (nevents != 0) &#123; if (nfds == ARRAY_SIZE(events) &amp;&amp; --count != 0) &#123; /* Poll for more events but don't block this time. */ timeout = 0; continue; &#125; return; &#125; if (timeout == 0) return; if (timeout == -1) continue;update_timeout: assert(timeout &gt; 0); diff = loop-&gt;time - base; if (diff &gt;= (uint64_t) timeout) return; timeout -= diff; &#125;&#125; poll 阶段有两个主要功能： 1、执行下限时间已经达到的timers的回调2、处理poll队列里的事件。 当event loop进入poll阶段，并且没有设定的timers，会发生下面两件事之一： 1、如果poll队列不空，event loop会遍历队列并同步执行回调，直到队列清空或执行的回调数到达系统上限； 2、如果poll队列为空，则发生以下两件事之一： 1、如果代码已经被setImmediate()设定了回调, event loop将结束poll阶段进入check阶段来执行check队列（里的回调）。 2、如果代码没有被setImmediate()设定回调，event loop将阻塞在该阶段等待回调被加入poll队列，并立即执行。 但是，当event loop进入poll阶段，并且有设定的timers，一旦poll队列为空（poll 阶段空闲状态）： event loop将检查timers,如果有1个或多个timers的下限时间已经到达，event loop将绕回 timers 阶段，并执行 timer 队列。 check阶段setImmediate()的回调会被加入check队列中， 从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后，只要有被setImmediate()设定了回调，一旦poll阶段空闲，那么程序将结束poll阶段并进入check阶段，而不是继续等待poll事件。 close callbacks如果一个socket或handle被突然关掉（比如 socket.destroy()），close事件将在这个阶段被触发，否则将通过process.nextTick()触发。 根据上面介绍，这是说明了宏任务的执行过程，那么对于node环境下的微任务呢？是不是跟在浏览器端一样，在一个宏任务执行完成之后会去执行所有的微任务，实际运行机制还是有区别的，node环境下在每次切换事件循环阶段的时候都会去清空微任务队列里面的任务。 浏览器端是这样的，如下图： node环境中时这样的，如下图： 这就能解释，为什么在最开始的示例中，浏览器和node环境执行结果不一样，这里解释下node环境下的结果： 首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2。 process.nextTick()首先process.nextTick()属于微任务，因此它只会在事件循环切换的过程才会运行，nextTick必须传入一个函数，当调用这个方法的时候，在node环境中，会将传入的事件塞入nextTickQueue中，并且立即会清空本阶段的所有nextTickQueue之后再次进入事件循环的下一个阶段。setImmediate()则是标志当前循环结束，进入下一次事件循环中。所以如果process.nextTick()使用不当会造成阻塞，示例代码如下：123456789101112131415161718192021222324const fs = require('fs')const starttime = Date.now()let endtimesetTimeout(() =&gt; &#123; endtime = Date.now() console.log('finish reading time: ', endtime - starttime)&#125;)let index = 0function handler () &#123; if (index++ &gt;= 1000) return console.log(`nextTick $&#123;index&#125;`) process.nextTick(handler)&#125;handler()// 运行结果如下：// nextTick 1// nextTick 2// ......// nextTick 999// nextTick 1000// finish reading time: 58 如果该用setImmediate()就不会造成阻塞，示例代码如下：1234567891011121314151617181920212223const fs = require('fs')const starttime = Date.now()let endtimesetTimeout(() =&gt; &#123; endtime = Date.now() console.log('finish reading time: ', endtime - starttime)&#125;)let index = 0function handler () &#123; if (index++ &gt;= 1000) return console.log(`setImmediate $&#123;index&#125;`) setImmediate(handler)&#125;handler()// 运行结构如下：// setImmediate 1// finish reading time: 4// setImmediate 2// ......// nextTick 1000 总结以上就是全部关于事件循环的介绍，能看到这里其实还是很蒙的感觉，所以最后总结一下： 浏览器端事件循环步骤 事件循环检查macrotask队列是否为空，非空则到2，为空则到3 执行macrotask中的一个任务 事件循环继续检查microtask队列是否为空，若有则到4，否则到5 取出microtask中的任务执行，执行完成返回到步骤3 执行视图更新，再次到1 几点注意： js在执行任何一个任务的时候是不会被中断的。 单次事件循环中，只会执行一次宏任务，而会执行全部的微任务。 当微任务为空时，事件循环检查是否需要执行UI重渲染，如果需要则重渲染UI。这样就结束了当次循环，继续从头开始检查宏任务。 所有的微任务都应该在下次UI渲染前执行完，因为其目的就是在渲染前更新应用状态。 UI视图更新分可控和非可控 node环境下的事件循环步骤 1、timer阶段 检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行。 检查是否有 process.nextTick 任务，如果有，全部执行。 检查是否有microtask，如果有，全部执行。 退出该阶段。 这个阶段主要环境会去判断当前的定时器是否到了该执行时候了，具体判定的时间跟定时器中的代码耗时长短有关，有可能这个阶段的定时器会在多个事件循环中运行。 2、IO callbacks阶段 检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段。 检查是否有 process.nextTick 任务，如果有，全部执行。 检查是否有microtask，如果有，全部执行。 退出该阶段。 3、idle，prepare阶段 内部运行，可以忽略 4、poll阶段 首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。 第一种情况： 如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调。 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出该阶段。第二种情况： 如果没有可用回调。 检查是否有immediate回调，如果有，退出poll阶段。如果没有，阻塞在此阶段，等待新的事件通知。如果不存在尚未完成的回调，退出poll阶段 5、check阶段 如果有immediate回调，则执行所有immediate回调。 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出check阶段 该阶段会执行immediate()回调，因此这也是事件循环进入下一次的一个标记 6、closing阶段 如果有socket或handle被突然关掉，close事件将在这个阶段被触发。 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出 closing 阶段 7、检查是否有活跃的handles（定时器、IO等事件句柄）。 如果有，继续下一轮循环。 如果没有，结束事件循环，退出程序。 最后以上内容大部分是参考其他文章和自己理解的内容，可以作为自身的学习积累，如果有什么不对的地方，欢迎提issues 参考文献http://lynnelv.github.io/js-event-loop-nodejshttps://juejin.im/post/5b73d7a6518825610072b42bhttp://javascript.ruanyifeng.com/dom/mutationobserver.htmlhttps://github.com/creeperyang/blog/issues/26https://juejin.im/post/5af1413ef265da0b851cce80https://cnodejs.org/topic/57d68794cb6f605d360105bf","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"node","slug":"node","permalink":"http://www.iwangqi.com/tags/node/"}]},{"title":"Web前端开发工程师必须了解的HTTP知识","date":"2018-09-23T08:30:57.000Z","path":"2018-09-23-HTTP/","text":"前言官方解释，HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。通俗来说，就是规定服务端和客户端通信的一种规则。更多的是基于浏览器环境下使用，那么从你浏览器输入地址开始到最终页面的呈现，到底经过了哪些过程呢？废话不多说，先贴一张图，如下： 如上图，就是http请求发起到返回的完证过程，本以为自己对http的了解还算可以，但是乍一看图还是很蒙的，比如说如果让你优化http过程，你该从何下手呢？我想大部分还是比较关心request和response，以及数据返回之后的DOMContentLoad和load，至于http中的一些配置并不是很清楚，其实通过优化配置，同样能够加速网页的打开速度，因此，我大致总结一些关于http中会经常使用的配置项，以及这些使用一般会在哪些场景中使用到。 注意：上图中的domContentLoadedEventEnd代表DOMContentLoaded事件完成的时间节点，也就是jQuery中的domready时间。load代表的是onload事件触发和结束的时间节点。 HTTP之跨域相关内容基本内容这里主要介绍JSONP和CORS跨域，现实场景中，以上两种使用居多，所以其他跨域方案不做详细介绍。造成跨域的主要原因主要是浏览器本身的同源策略引起的。 JSONP能够实现跨域主要是因为浏览器上允许标签上通过src/href加载外链路径，但是JSONP只支持GET请求，同时因为浏览器中url长度的限制，因此JSONP能传输的数据大小也有一定的限制。 CORS跨域能够支持的所有ajax的方法，当然，目前是支持ie9+，低版本暂时不支持，随时互联网的发展，相信低版本的浏览器会逐渐被淘汰。在只用CORS只需要服务端能够开启允许跨域的头设置即可，也就是Access-Control-Allow-Origin。 跨域大致的流程图如下： 注意：JSONP中的数据限制并不是GET请求本身的限制，而是浏览器中url本身有长度限制，GET方法是没有任何长度限制的；不管是JSONP还是CORS跨域，其实服务器都可以接收来自客户端的数据请求，并且也都成功返回了，只是浏览器本身有同源策略的限制，才会进一步判断返回的数据是否符合浏览器的限制。 这里有个题外话，Access-Control-Allow-Origin这个配置项默认支持配置单个域名或者，为了安全起见，不建议配置``，那么如何配置才能支持多个域名跨域呢？有一个简易的方法可以解决，主要思路是通过服务端定义可支持的跨域域名集合，通过循环判断当前请求是否支持即可，片段代码如下：1234567891011121314151617181920212223// 服务端代码，以下是node服务做测试const http = require('http')const allowDomains = [ 'http://www.a.com', 'http://www.b.com', 'http://www.c.com']const server = http.createServer((req, res) =&gt; &#123; let acao = '' for(let i = 0, l = allowDomains.length; i &lt; l; i++) &#123; if(allowDomains[i].indexOf(req.headers.host) &gt; -1) &#123; acao = allowDomains[i] break &#125; &#125; res.writeHead(200, &#123; 'Access-Control-Allow-Origin': acao &#125; ) res.end('Hello World\\n')&#125;).listen(3001)console.log('server listen 3001') CORS跨域限制 默认允许的方法有GET、HEAD、POST。 默认允许的Content-Type有text/plain、multipart/form-data、application/x-www-form-urlencoded。 HTTP的头信息包含Accept、Accept-Language、Content-Language、Last-Event-ID。 在请求包含以上内容的时候，其实就是简单请求，在跨域的情况下，浏览器默认是直接通过的，其余剩下的称之为复杂请求，浏览器会默认发送一次预请求作为验证，如果验证通过则代表请求成功。 因此需要对上图增加限制的修改，最终如下： 其实就是对于复杂请求做了一次校验，大致可以这样解释，如果在发送请求时，例如额外带了headers的配置项，如果需要验证通过就必须在服务端也要配置允许该headers的返回，这样预请求的验证才会通过。也可以通过代码做一下验证，基本如下： 12345678910111213141516171819202122232425262728293031323334// 后端服务代码const http = require('http')const server = http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Headers': 'aa' // 通过设置了这个，才能使得预请求验证通过 &#125; ) res.end('Hello World\\n')&#125;).listen(3001)console.log('server listen 3001')// 前端服务代码const http = require('http')const fs = require('fs')const server = http.createServer((req, res) =&gt; &#123;const html = fs.readFileSync('index.html', 'utf8') res.writeHead(200, &#123; 'Content-Type': 'text/html' &#125; ) res.end(html)&#125;).listen(3000)console.log('server listen 3000')// index.html主要代码如下fetch('http://localhost:3001', &#123; method: 'post', headers: &#123; aa:'123' &#125;&#125;) 以上测试代码主要是在发起post请求的时候额外携带了一个headers参数，只有在服务端配置了允许该headers传输才能使得浏览器预请求验证通过，反之则会失败。大家可以根据以上测试代码在自己的本机测试就能明白了。 注意：通过设置Access-Control-Request-Method可以配置其他的方法，例如PUT、DELETE等。 细心的同学可能会发现，根据以上代码的确可以通过预请求，但是如果再次刷新网页，会发现仍然还会存在预请求，对于第一次预请求已经通过了，为什么同样的请求还会再发送一次呢？其实这里可以做一个优化，减少预请求的发送。 通过设置Access-Control-Max-Age来确定预请求的有效时间，只要在有效时间内，就不会再次发送预请求了。 HTTP之Cache-ControlCache-Control包含很多特性，其中no-cache这个配置项肯定最熟悉，官方解释是在释放缓存副本之前，强制高速缓存将请求提交给原始服务器进行验证，其实就是代表没有缓存。但是其实它依然有很多特性，经过资料查询，大致分为以下几类， 介绍下一般常用的配置参数的文字解释： public代表http从请求到返回的整个路径上的都可以被缓存，例如客户端浏览器，经过的代理服务器等等。 private指发起的浏览器这一端才能进行缓存，也就是代理服务器是不能缓存的。 no-cache 是否使用缓存需要通过服务器验证后才能判断。 max-age=&lt;seconds&gt; 最大能缓存多少秒，过期之后，请求会再次发送到服务端，对于返回的数据会再次被缓存。 s-maxage=&lt;seconds&gt; 会覆盖max-age或者Expires头，应用于共享（如：代理服务器）缓存，并且在代理服务器生效，客户端不生效。 max-stale[=&lt;seconds&gt;] 表明客户端愿意接收一个已经过期的资源。即使max-age已经过期，同样会使用本地的过期缓存。 must-revalidate 如果max-age过期，必须通过服务端来验证返回的数据是否真的过期。 proxy-revalidate 主要使用在代理服务器端，对于过期的数据必须向服务端重新请求一遍。 no-store 本地和代理服务器都不允许存缓存。 no-transform 不得对资源进行转换或转变，主要使用在代理服务器上。 具体每个配置的官方解释参考具体说明 资源验证 Last-Modified表明请求的资源上次的修改时间，主要配合If-Modified-Since（客户端保留的资源上次的修改时间）进行使用，主要是在发送请求的时候带上。通过对比上次修改时间以验证资源是否更新。 Etag资源的内容标识。（不唯一，通常为文件的md5或者一段hash值，只要保证写入和验证时的方法一致即可），配合If-Match或者If-None-Match进行使用，对比资源的内容标识来判断是否使用缓存。 其实服务器可以通过Etag来区分返回哪些数据，具体可以参考下面的示例：12345678910111213141516171819202122232425262728293031323334353637383940414243// server.jsconst http = require('http')const fs = require('fs')const server = http.createServer((req, res) =&gt; &#123;const url = req.urlconst html = fs.readFileSync('index.html', 'utf8')const etag = req.headers['if-none-match']if(url === '/') &#123;res.writeHead(200, &#123; 'Content-Type': 'text/html', 'Cache-Control': 'max-age=2000, no-cache', 'Last-Modified': '123', 'Etag': '444' &#125;)res.end(html)&#125;if(url === '/aa.js') &#123;if(etag === '444') &#123; res.writeHead(304, &#123; 'Content-Type': 'text/javascript', 'Cache-Control': 'max-age=2000, no-cache', 'Last-Modified': '123', 'Etag': '444' &#125; ) res.end('888888')&#125; else &#123; res.writeHead(200, &#123; 'Content-Type': 'text/javascript', 'Cache-Control': 'max-age=2000, no-cache', 'Last-Modified': '123', 'Etag': '444' &#125; ) res.end('1111111111')&#125;&#125;&#125;).listen(3000)console.log('server listen 3000') 12345678910111213&lt;!-- html文件 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"/aa.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第一次刷新和第二次刷新截图如下：根据测试代码能得出，在服务端通过etag === &#39;444&#39;做了判断，但是最终返回的依然是1111111111，这是由于服务端选取了第一次的缓存数据作为返回。虽然发生了一次请求，但请求内容长度减少了，节省了带宽。 总结其实以上所有的概念基本可以用一个图来展示，大致分为2个主要部分： 1、本地缓存，其实也就是本地资源的缓存。2、服务器缓存，包含验证缓存和非验证缓存。 HTTP之cookie 通过Set-Cookie来设置cookie，下次请求的时候，会自动带上之前设置的cookie（同域情况下），取值类型是String/Array。 通过max-age和Expires设置过期时间。 通过Secure来设置只能在https的时候发送。 通过HttpOnly来设置无法通过document.cookie访问。 通过domain=来设置该cookie是否在同域下共享。 以上内容基本能汇总成一张图解释，如下： HTTP之keep-alive目前开发web网页，所有请求默认都是Connection: keep-alive，除非服务端手动去关闭配置（Connection: close），使用keep-alive可以复用之前的请求的信道，这样减少tcp三次握手的时间（同域情况下才能生效）。 HTTP之数据协商web服务请求会携带以下信息内容： Accept 想要的数据类型 Accept-Encoding 限制服务端数据的压缩方式（gzip、deflate、br） Accept-Language 服务端返回数据的语言类型 User-Agent浏览器头信息内容 服务端返回数据会携带以下信息内容： Content-type 返回的数据类型 Content-Encoding 对应的是 Accept-Encoding 代表数据压缩类型 Content-Language 对应的是 Accept-Language 代表数据语言类型 当然，web请求也可以自定义Content-type来传输数据，一般在form表单中比较常用，例如上传文件，会指定Content-type:multipart/form-data，这样服务端就能接收上传的文件信息内容。 HTTP之重定向浏览器能识别的重定向code码有两种，分别是301和302，两者在使用上会有一定的区别，大致如下： 301重定向是永久重定向，用户在访问资源的时候，浏览器默认是从缓存中获取之前指定的跳转信息； 302重定向可以随时取消，也就是用户在访问资源的时候，每次都会经过服务端并且在服务端通过跳转逻辑进行跳转； 可以使用一段代码来描述以上的不同之处，基本代码如下：1234567891011121314151617181920212223242526// 302跳转测试代码const http = require('http')const fs = require('fs')const server = http.createServer((req, res) =&gt; &#123;const url = req.urlconst html = fs.readFileSync('index.html', 'utf8')console.log(url)if(url === '/') &#123;res.writeHead(302, &#123; Location: '/wq' &#125;)res.end('')&#125;if(url === '/wq') &#123;res.writeHead(200, &#123; 'Content-Type': 'text/html', &#125;)res.end(html)&#125; &#125;).listen(3000)console.log('server listen 3000') 301测试代码跟上面基本一样，只要将302改成301即可，根据以上代码测试，你会发现，每次在刷新页面的时候，如果是302跳转，那么console.log(url)每次都会打印/ 和 /wq，如果是301的话，只会打印/wq，这就说明，302的跳转是从服务端指定跳转的，而301的跳转则是永久性的，除非清楚本地浏览器的缓存，要么无法改变。 HTTP之内容安全策略配置内容安全策略涉及到添加Content-Security-Policy，HTTP头部到一个页面，并配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。更多详细参考具体说明 常用示例如下：1234567891011121314// 一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)'Content-Security-Policy': default-src 'self'// 一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)'Content-Security-Policy': default-src 'self' *.trusted.com// 该服务器仅允许通过HTTPS方式并仅从onlinebanking.jumbobank.com域名来访问文档'Content-Security-Policy': default-src https://onlinebanking.jumbobank.com// 限制向百度请求'Content-Security-Policy': connect-src http://baidu.com// 通过设定report-uri来指定上报服务器地址'Content-Security-Policy': default-src 'self'; report-uri http://reportcollector.example.com/collector.cgi HTTP之HTTP2HTTP/2是HTTP协议自1999年HTTP1.1发布后的首个更新，主要基于SPDY协议。它由互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组进行开发。该组织于2014年12月将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。HTTP/2标准于2015年5月以RFC 7540正式发表。 大致总结有以下特性： 二进制分帧 多路复用：同域名下所有通信都在单个连接上完成；单个连接可以承载任意数量的双向数据流；数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装； 服务器推送：服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。 头部压缩：HTTP/2对消息头采用HPACK（专为http2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。 贴一张简图，可以更好的体现，更多详情可以参考： 为了能更好的体验实际场景中的效果，做了简单的测试，使用express配合node开启http2来测试具体效果，在这之前，需要生成一个SSL，生成代码如下：12// 直接在cmd中运行openssl req -x509 -nodes -newkey rsa:2048 -keyout example.com.key -out example.com.crt 编写基础的server.js代码，基本如下：12345678910111213141516171819202122232425262728293031323334353637383940const port = 3000const spdy = require('spdy')const express = require('express')const path = require('path')const fs = require('fs')const resolve = file =&gt; path.resolve(__dirname, file)const app = express()const serve = (path, cache) =&gt; express.static(resolve(path), &#123; maxAge: cache ? 1000 * 60 * 60 * 24 * 30 : 0&#125;)app.use('/html', serve('./html', true))app.get('/', (req, res) =&gt; &#123; res.status(200) res.send('hello world')&#125;)app.get('/timg.jpeg', (req, res) =&gt; &#123; const img = fs.readFileSync('/html/timg.jpeg') res.writeHead(200, &#123;\"Content-Type\": 'image/jpeg' &#125;); res.send(img)&#125;)const options = &#123; key: fs.readFileSync(__dirname + '/example.com.key'), cert: fs.readFileSync(__dirname + '/example.com.crt')&#125;spdy .createServer(options, app) .listen(port, (error) =&gt; &#123; if (error) &#123; console.error(error) return process.exit(1) &#125; else &#123; console.log('Listening on port: ' + port + '.') &#125; &#125;) 根目录的静态文件定义fetch方法来请求100张图片，这样来测试请求的信道以及加载时长，基本代码如下：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;http2测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; for(let i = 0; i &lt; 100; i++) &#123; fetch('//localhost:3000/html/timg.jpeg') &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 按照以上代码运行，并且对比HTTP/1.1的效果如下（图1是HTTP/1.1，图2是HTTP2）： 从图1和图2就能看出，图2中Connection ID只有一个，而图1中Connection ID会随着请求的增加而增加，每增加一个信道，就会创建一次TCP链接，也就是需要经过三次握手，并且还受限浏览器本身的并发数，所以才会出现等待的情况；从Size那一列能看出，HTTP2中的请求数据也会小（因为本身数据就小，所以不明显），这样能够减少带宽；从最终的Finsh时间能看出，同样是100张图片的请求，HTTP2耗时更少。 总结以上内容主要是和HTTP相关的内容，由于比较简单，就不提供测试代码压缩包，基本从示例中直接复制粘贴就能本地测试运行，如果有什么不正确的地方，欢迎提Issues。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"HTTP","slug":"HTTP","permalink":"http://www.iwangqi.com/tags/HTTP/"}]},{"title":"canvas学习API总结","date":"2018-09-22T08:30:57.000Z","path":"2018-09-22-canvasAPI/","text":"Canvas学习API总结如下","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"canvas","slug":"canvas","permalink":"http://www.iwangqi.com/tags/canvas/"}]},{"title":"vue-cli中的webpack4一步到位填坑记","date":"2018-07-14T07:19:49.000Z","path":"2018-07-14-wpk/","text":"基础介绍Webpack也在不断的优化迭代；截至目前，已经更新至 v4.16.0；在Webpack4这个版本，它在原有基础上，做了很多优化，也引入了颇多的新特性。在新的版本中，将获得更多模块类型及对.mjs的支持，更好的默认值、更为简洁的模式设置、更加智能的来分割Chunk，还新增的splitChunks来自定义分割代码块，诸此等等。在升级至新版Webpack的项目中，在包的构建速度、代码块体积&amp;数量、以及运行效率，都会有一个质的飞跃。 因此面对Webpack4优越的功能，将本地项目中从原先的2.7.0一步到位升级至4.16.0，并且相关依赖包以及配置文件需要做相应的修改。 webpack4.0升级流程node环境不再支持Node4，建议使用高版本node，以下做升级使用的\b是node v8.11.1和npm v5.6.0 模块类型webpack 4之前，js 是 webpack 中的唯一模块类型，因而不能有效地打包其它类型的文件。而 webpack 4 则提供了 5 种模块类型： javascript/auto: (webpack 3中的默认类型)支持所有的JS模块系统：CommonJS、AMD、ESM javascript/esm: EcmaScript 模块，在其他的模块系统中不可用（默认 .mjs 文件） javascript/dynamic: 仅支持 CommonJS &amp; AMD，EcmaScript 模块不可用 json: 可通过 require 和 import 导入的 JSON 格式的数据(默认为 .json 的文件) webassembly/experimental: WebAssembly 模块(处于试验阶段，默认为 .wasm 的文件) 此外，webpack 4 中会默认解析 .wasm, .mjs, .js 和 .json 为后缀的文件。 webpack-cli升级完webpack4然后直接运行项目打包命令npm run build，会提示你需要安装webpack-cli/webpack-command，可以根据自己的需要选择安装，本人选择的是webpack-cli。 配置更新mode添加webpack4默认是通过mode来设置是生产环境还是开发环境，所以需要在webpack.dev.conf.js和webpack.prod.conf.js增加相应的mode配置项，并且删除之前设置环境变量的代码process.env.NODE_ENV = &#39;production&#39;以及插件配置中设置环境变量的方法，片段代码如下：123456789101112131415161718192021// webpack.dev.conf.jsmodule.exports = merge(baseWebpackConfig, &#123; mode: 'development', // 省略 plugins: [ new webpack.DefinePlugin(&#123; 'process.env': config.dev.env &#125;), ]&#125; // webpack.prod.conf.jsvar webpackConfig = merge(baseWebpackConfig, &#123; mode: 'production', // 省略 plugins: [ new webpack.DefinePlugin(&#123; 'process.env': env &#125;), ] &#125; 注意：new webpack.DefinePlugin是保证浏览器脚本中能够访问process.env变量，以便做相应的逻辑操作 development 模式： 1.主要优化了增量构建速度和开发体验 2.process.env.NODE_ENV 的值不需要再定义，默认是 development 3.开发模式下支持注释和提示，并且支持 eval 下的 source maps production 模式： 1.生产环境默认开启了很多代码优化（minify，splite等） 2.开发时开启注视和验证，并且自动加上了eval devtool 3.生产环境不支持watching，开发环境优化了重新打包的速度 4.默认开启了Scope hoisting和Tree-shaking（原ModuleConcatenationPlugin） 5.自动设置process.env.NODE_ENV到不同环境，也就是不需要DefinePlugin来做这个了 6.如果你给mode设置为none，所有默认配置都去掉了 7.如果不加这个配置webpack会出现提醒，所以还是加上吧 mini-css-extract-plugin使用因为extract-text-webpack-plugin的最新正式版还没有对webpack4.x进行支持，即使是使用extract-text-webpack-plugin@next版本依然会出现报contenthash错误，所以还是建议使用mini-css-extract-plugin，当然这也是官方推荐的。 主要需要修改webpack.prod.conf.js中的插件配置以及loaders加载的工具函数utils.js，修改片段代码如下：1234567891011121314151617181920212223// webpack.dev.conf.jsmodule.exports = merge(baseWebpackConfig, &#123; // 省略 plugins: [ new MiniCssExtractPlugin(&#123; filename: utils.assetsPath('css/[name].[contenthash].css') &#125;), ]&#125; // utils.jsif (options.extract) &#123;return [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: '../../' &#125; &#125; ].concat(loaders)&#125; else &#123; return ['vue-style-loader'].concat(loaders)&#125; 注意：其中utils.js中配置publicPath主要解决css中引用图片出现路径错误问题。 optimization配置项再次运行相关打包命令你会发现有如下提示错误，片段代码如下：12Error: webpack.optimize.CommonsChunkPlugin has been removed, please use config.optimization.splitChunks instead. at Object.get [as CommonsChunkPlugin] (/data/test/node_modules/webpack/lib/webpack.js:159:10) 主要是因为webpack4中删除了webpack.optimize.CommonsChunkPlugin，并且使用optimization中的splitChunk来替代 主要需要修改webpack.prod.conf.js文件，并且删除所有webpack.optimize.CommonsChunkPlugin相关代码，片段代码如下：1234567891011121314151617181920212223242526272829303132333435var webpackConfig = merge(baseWebpackConfig, &#123; mode: 'production', entry: &#123; charts: ['echarts'], vendors: ['vue', 'vuex', 'vue-router', 'moment'], iconfonts: ['ga-iconfont'] &#125;, // 省略 optimization: &#123; // minimizer: true, // [new UglifyJsPlugin(&#123;...&#125;)] providedExports: true, usedExports: true, //识别package.json中的sideEffects以剔除无用的模块，用来做tree-shake //依赖于optimization.providedExports和optimization.usedExports sideEffects: true, //取代 new webpack.optimize.ModuleConcatenationPlugin() concatenateModules: true, //取代 new webpack.NoEmitOnErrorsPlugin()，编译错误时不打印输出资源。 noEmitOnErrors: true, splitChunks: &#123; // maxAsyncRequests: 1, // 最大异步请求数， 默认1 // maxInitialRequests: 1, // 最大初始化请求数，默认1 cacheGroups: &#123; // 抽离第三方插件 commons: &#123; // test: path.resolve(__dirname, '../node_modules'), chunks: 'all', minChunks: 2, maxInitialRequests: 5, // The default limit is too small to showcase the effect minSize: 0, name: 'common' &#125; &#125; &#125;,&#125; test主要是通过正则来匹配entry中配置第三方库，当然这里也可以写成path.resolve(__dirname, &#39;../node_modules&#39;)来匹配项目中node_modules引入的库文件。 chunks形式有三种取值（如果配置了entry，那么默认从入口文件中抽离，如果没有配置entry配置了test，默认按照test中的正则去匹配）个人比较推荐使用all或者async： 当取值all的时候，效果是不管是异步还是同步，都会将入口entry配置的包公共部分抽离出来，好处就是其他文件很小，公共文件会只加载一次，不优雅的就是如果enrty配置的包过多会导致一个文件很大。效果基本如下： 当取值async的时候，效果是将入口entry配置的包抽离异步的公共部分，主要是看entry中包的引入方式是不是异步的。效果基本如下： 当取值initial的时候，其实效果不如all和async，就是在初始化的时候，将每个页面涉及到的包从各自页面中的js中抽离出来，并且会根据页面加载这些分离出来的js文件，对于各页面公共的js会打包多份。效果基本如下： sideEffects开启时可以剔除无用的模块，用来做tree-shake。当模块的package.json中添加该字段时，表明该模块没有副作用，也就意味着webpack可以安全地清除被用于重复导出(re-exports)的代码。 concatenateModules取代了webpack.optimize.ModuleConcatenationPlugin()插件 noEmitOnErrors取代了new webpack.NoEmitOnErrorsPlugin()插件。 minChunks是split前，有共享模块的chunks的最小数目 ，默认值是1，但示例里的代码在default里把它重写成2了，从常理上讲，minChunks = 2应该是一个比较合理的选择吧 注意：webpack.optimize.UglifyJsPlugin现在也不需要了，只需要使用optimization.minimize为true就行，production mode下面自动为true，当然如果想使用第三方的压缩插件也可以在optimization.minimizer的数组列表中进行配置 html-webpack-plugin升级建议升级至最新版本@4.0.0-alpha，这里需要把默认的chunksSortMode: dependency\b删除，主要是因为webpack4已经删除相关的CommonsChunkPluginAPI了。 vue-loader升级其实这个可以不需要升级，但是如果升级至15.x版本以上，在使用中需要执行VueLoaderPlugin插件\b方法，其他用法跟之前保持一致，片段代码如下：123456// webpack.prod.conf.jsconst &#123; VueLoaderPlugin &#125; = require('vue-loader')// 省略plugins: [ new VueLoaderPlugin(),] 需要开启sourceMapwebpack4会默认提示需要开启sourceMap，因此只要在相关loader配置中的options配置sourceMap：true即可。 其他相关包升级建议把相关loader统一做一次升级，基本升级如下： babel-loader 7.1.5 css-loader 1.0.0 file-loader 1.1.11 less-loader 4.1.0 url-loader 1.0.1 vue-style-loader 4.1.0 vue-template-compiler 2.5.16 完整配置webpack.dev.conf.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const HtmlWebpackPlugin = require('html-webpack-plugin')const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')const &#123; VueLoaderPlugin &#125; = require('vue-loader')// add hot-reload related code to entry chunksObject.keys(baseWebpackConfig.entry).forEach(function (name) &#123; baseWebpackConfig.entry[name] = ['./build/dev-client'].concat(baseWebpackConfig.entry[name])&#125;)baseWebpackConfig.output.chunkFilename = '[name].[chunkhash].js'; // 路由js命名 这个拆分路由 模块依赖脚本文件module.exports = merge(baseWebpackConfig, &#123; mode: 'development', module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap &#125;) &#125;, devtool: '#cheap-module-eval-source-map', optimization: &#123; // minimizer: true, providedExports: true, usedExports: true, //识别package.json中的sideEffects以剔除无用的模块，用来做tree-shake //依赖于optimization.providedExports和optimization.usedExports sideEffects: true, //取代 new webpack.optimize.ModuleConcatenationPlugin() concatenateModules: true, //取代 new webpack.NoEmitOnErrorsPlugin()，编译错误时不打印输出资源。 noEmitOnErrors: true, splitChunks: &#123; chunks: 'initial', //'all'|'async'|'initial'(全部|按需加载|初始加载)的chunks &#125;, //提取webpack运行时的代码 runtimeChunk: &#123; name: 'manifest' &#125; &#125;, plugins: [ new VueLoaderPlugin(), new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true &#125;), new FriendlyErrorsPlugin() ]&#125;) webpack.prod.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125const path = require('path')const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const CopyWebpackPlugin = require('copy-webpack-plugin')const HtmlWebpackPlugin = require('html-webpack-plugin')const MiniCssExtractPlugin = require('mini-css-extract-plugin')const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')const &#123; VueLoaderPlugin &#125; = require('vue-loader')var webpackConfig = merge(baseWebpackConfig, &#123; mode: 'production', entry: &#123; charts: ['echarts'], vendors: ['vue', 'vuex', 'vue-router', 'moment'], iconfonts: ['ga-iconfont'] &#125;, module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true &#125;) &#125;, devtool: config.build.productionSourceMap ? '#source-map' : false, output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[chunkhash].js'), chunkFilename: utils.assetsPath('js/[id].[chunkhash].js'), publicPath: './' &#125;, optimization: &#123; // minimizer: true, providedExports: true, usedExports: true, //识别package.json中的sideEffects以剔除无用的模块，用来做tree-shake //依赖于optimization.providedExports和optimization.usedExports sideEffects: true, //取代 new webpack.optimize.ModuleConcatenationPlugin() concatenateModules: true, //取代 new webpack.NoEmitOnErrorsPlugin()，编译错误时不打印输出资源。 noEmitOnErrors: true, splitChunks: &#123; // maxAsyncRequests: 1, // 最大异步请求数， 默认1 // maxInitialRequests: 1, // 最大初始化请求书，默认1 cacheGroups: &#123; // test: path.resolve(__dirname, '../node_modules'), commons: &#123; chunks: 'all', minChunks: 2, maxInitialRequests: 5, // The default limit is too small to showcase the effect minSize: 0, name: 'common' &#125; &#125; &#125;, //提取webpack运行时的代码 runtimeChunk: &#123; name: 'manifest' &#125; &#125;, plugins: [ new VueLoaderPlugin(), // 解决moment语言包问题 new webpack.ContextReplacementPlugin( /moment[\\\\\\/]locale$/, /^\\.\\/(zh-cn)$/ ), new MiniCssExtractPlugin(&#123; filename: utils.assetsPath('css/[name].[contenthash].css') &#125;), new OptimizeCSSPlugin(&#123; cssProcessorOptions: &#123; safe: true, discardComments: &#123; removeAll: true &#125; &#125; &#125;), new HtmlWebpackPlugin(&#123; filename: config.build.index, template: 'index.html', inject: true, hash:true,// 防止缓存 minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125; &#125;), new webpack.HashedModuleIdsPlugin(), new CopyWebpackPlugin([&#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125;]) ]&#125;)if (config.build.productionGzip) &#123; var CompressionWebpackPlugin = require('compression-webpack-plugin') webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp( '\\\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, minRatio: 0.8 &#125;) )&#125;if (config.build.bundleAnalyzerReport) &#123; var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())&#125;module.exports = webpackConfig 注意事项preload插件报错如果在项目中使用了preload-webpack-plugin插件，必须升级至3.0.0-beta.1版本，可以运行以下命令：1npm i preload-webpack-plugin@next -D 同时需要把html-webpack-plugin插件版本回退到3.2.0才行，然后在配置文件\b按照以下先后顺序\b添加，片段代码如下：1234567891011121314151617181920// 省略plugins: [ new HtmlWebpackPlugin(&#123; filename: config.build.index, template: 'index.html', inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, &#125;), new PreloadWebpackPlugin(&#123; rel: 'prefetch', &#125;), new PreloadWebpackPlugin(&#123; rel: 'preload' &#125;), // 省略] html-webpack-plugin-after-emit\b升级webpack4之后，在dev环境下，你会发现修改任何代码会导致整个网页刷新，而且会报cb is not a function，造成这个原因是html-webpack-plugin-after-emit插件针对高版本的webpack4和html-webpack-plugin3.2.0已经被弃用了，暂时没找到替代的插件，可以暂时先注释掉这段代码，代码在build/dev-server.js中，片段代码如下：123456compiler.plugin('compilation', function(compilation) &#123; compilation.plugin('html-webpack-plugin-after-emit', function(data, cb) &#123; hotMiddleware.publish(&#123; action: 'reload' &#125;) cb() &#125;)&#125;) 总结按照以上修改基本可以完成webpack4的升级，升级完之后，个人感觉配置更加简单，删除了以前很多繁琐的插件配置，很多功能webpack4默认就是自带，\b经过测试打包速度有了50%多的提升，修改之前打包时间为143894ms左右，升级完之后，用时基本在58080ms左右，效果基本如下： 再次打包的话，用时基本在27534ms左右，效果基本如下： 2018-07-21补充关于entry和optimization配置上文介绍了如何在optimization\b通过定义配合entry进行打包，如果按照以上配置最终打包的确会\b生成charts、vendors、iconfonts三个js文件，但是对于js大小会有所怀疑，因为大小基本在199 bytes以下，这似乎有点奇怪，直接打开这三个js看看，代码如下：1234567891011// charts.js(window.webpackJsonp=window.webpackJsonp||[]).push([[24],&#123;21:function(n,o,p)&#123;n.exports=p(\"K8M1\")&#125;&#125;,[[21,1,0]]]);//# sourceMappingURL=charts.2e5cbbfa2a894d2bb5aa.js.map// iconfonts.js(window.webpackJsonp=window.webpackJsonp||[]).push([[22],&#123;19:function(n,o,p)&#123;n.exports=p(\"t+cQ\")&#125;&#125;,[[19,1,0]]]);//# sourceMappingURL=iconfonts.e90fd0507d501ef81b69.js.map// vendors.js(window.webpackJsonp=window.webpackJsonp||[]).push([[23],&#123;20:function(n,o,w)&#123;w(\"oCYn\"),w(\"L2JU\"),w(\"jE9Z\"),n.exports=w(\"wd/R\")&#125;&#125;,[[20,1,0]]]);//# sourceMappingURL=vendors.5c535f00ba89522ba93b.js.map 其实这三段js\b都被一起打成common.js了，所以从项目加载资源的角度来说，以上这三段似乎是多余js，那么该如何删除这没用的js呢，\b其实可以把entry配置的代码全部注释掉，基本如下：12345entry: &#123; // charts: ['echarts'], // vendors: ['vue', 'vuex', 'vue-router', 'moment'], // iconfonts: ['ga-iconfont']&#125; 按照以上修改，就能少打包三个似乎没用的js，这个问题感谢我们前端组的小伙伴发现的。 那么问题来了，如何才能按照入口文件配置的那样打成三个js包呢，可以遵循以下配置，片段代码如下：123456789101112131415161718192021222324252627282930313233// 前提是不注释entry中的代码// 省略optimization: &#123; // 省略 splitChunks: &#123; cacheGroups: &#123; charts: &#123; chunks: 'async', minChunks: 2, maxInitialRequests: 5, minSize: 0, name: 'charts' &#125;, vendors: &#123; chunks: 'async', minChunks: 2, maxInitialRequests: 5, minSize: 0, name: 'vendors' &#125;, iconfonts: &#123; chunks: 'async', minChunks: 2, maxInitialRequests: 5, minSize: 0, name: 'iconfonts' &#125; &#125; &#125;, // 省略&#125;// 省略 重点看cacheGroups里面的配置，将原先的commons改成了三个了，同时chunks需要改成async，按照这样打包结果基本如下： 打包速度相关 以下测试速度的项目页面数是26个页面，十多个业务组件，一整套组内开发的ui组件库，以及多个第三方库。实际时间会受各自项目文件多少影响。 \b使用HappyPack插件能够提高打包编译速度，可以参照以下修改，基本修改如下：12345678910111213141516171819202122232425262728293031// webpack.base.conf.js// 在rules中的babel-loader改用happypack中的loader// 省略module: &#123; rules: [&#123; test: /\\.js$/, loader: 'happypack/loader', // 增加新的HappyPack构建loader include: [resolve('src')], exclude: /node_modules/, options: &#123; sourceMap: true, &#125; &#125;&#125; // 省略// webpack.prod.conf.js// 省略plugins: [ new HappyPack(&#123; loaders: [&#123; loader: 'babel-loader', options: &#123; babelrc: true, cacheDirectory: true &#125; &#125;], threadPool: happyThreadPool &#125;)] // 省略 以下是未修改之前打包的所需的时间是26831ms： 修改之后打包速度是20387ms，相比之前减少了近6.5s左右： 通过设置babel-loader中的cacheDirectory属性也能提高编译速度，网上很多都是如下设置，但是\b会报错，片段代码如下：12345678910// 这是错误用法，我实测发现报错&#123; test: /\\.js$/, loader: 'babel-loader?cacheDirectory=true', // 或者loader: 'babel-loader?cacheDirectory' include: [resolve('src')], exclude: /node_modules/, options: &#123; sourceMap: true, &#125;&#125; 其实可以把cacheDirectory当作一个属性配置在options中，基本代码如下：12345678910&#123; test: /\\.js$/, loader: 'babel-loader', include: [resolve('src')], exclude: /node_modules/, options: &#123; sourceMap: true, cacheDirectory: true &#125;&#125; 增加如上修改，打包速度是20593ms，似乎跟之前没有多大变化: 最终经过测试，对于本人项目而言，HappyPack和cacheDirectory效果并不能叠加，使用任意其一，\b都可以能达到20s所有的时间。 以上就是全部内容，如果有什么不对的地方，欢迎提issues","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"http://www.iwangqi.com/tags/webpack/"}]},{"title":"Vue源码阅读前必须知道javascript的基础内容","date":"2018-06-30T07:16:04.000Z","path":"2018-06-30-vue/","text":"前言 vue目前是前端使用频率较高的一套前端mvvm框架之一，提供了数据的响应式、watch、computed等极为方便的功能及api，那么，vue到底是如何实现这些功能的呢？在探究vue源码之前，必须了解以下几点javascript的基本内容，通过了解这些内容，你可以更加轻松的阅读vue源码。 flow 类型检测 Flow就是JavaScript的静态类型检查工具，由Facebook团队于2014年的Scale Conference上首次提出。该库的目标在于检查JavaScript中的类型错误，开发者通常不需要修改代码即可使用，故使用成本很低。同时，它也提供额外语法支持，使得开发者能更大程度地发挥Flow的作用。总结一句话：将javascript从弱类型语言变成了强类型语言。 基础检测类型 Flow支持原始数据类型，其中void对应js中的undefined，基本有如下几种： 12345booleannumberstringnullvoid 在定义变量的同时，只需要在关键的地方声明想要的类型，基本使用如下： 123456let str:number = 1;let str1:string = 'a';// 重新赋值str = 'd' // errorstr1 = 3 // error 复杂类型检测 Flow支持复杂类型检测，基本有如下几种： 1234ObjectArrayFunction自定义Class 基本使用如下示例代码： 1234567891011121314151617181920212223// Object 定义let o:Object = &#123; key: 123&#125;//声明了Object的keylet o2:&#123;key:string&#125; = &#123; key: '111'&#125;// Array 定义//基于基本类似的数组，数组内都是相同类型let numberArr:number[] = [12,3,4,5,2];//另一个写法let numberAr2r:Array&lt;number&gt; = [12,3,2,3];let stringArr:string[] = ['12','a','cc'];let booleanArr:boolean[] = [true,true,false];let nullArr:null[] = [null,null,null];let voidArr:void[] = [ , , undefined,void(0)];//数组内包含各个不同的类型数据//第4个原素没有声明，则可以是任意类型let arr:[number,string,boolean] = [1,'a',true,function()&#123;&#125;,]; Function定义写法如下，vue源码中出现频率最多的： 12345678910111213141516171819202122/** * 声明带类型的函数 * 这里是声明一个函数fn，规定了自己需要的参数类型和返回值类型。 */function fn(arg:number,arg2:string):Object&#123; return &#123; arg, arg2 &#125;&#125;/** * vue源码片段 * src/core/instance/lifecycle.js */export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; // 省略&#125; 自定义的class，声明一个自定义类，然后用法如同基本类型，基本代码如下： 123456789101112/** * vue源码片段 * src/core/observer/index.js */export class Observer &#123; value: any; dep: Dep; vmCount: number; constructor (value: any) &#123; // 省略 &#125;&#125; 直接使用flow.js，javascript是无法在浏览器端运行的，必须借助babel插件，vue源码中使用的是babel-preset-flow-vue这个插件，并且在babelrc进行配置，片段代码如下： 1234567891011121314151617181920212223242526272829// package.json 文件// 省略\"devDependencies\": &#123; \"@types/node\": \"^8.0.33\", \"@types/webpack\": \"^3.0.13\", \"acorn\": \"^5.2.1\", \"babel-core\": \"^6.25.0\", \"babel-eslint\": \"^8.0.3\", \"babel-helper-vue-jsx-merge-props\": \"^2.0.2\", \"babel-loader\": \"^7.0.0\", \"babel-plugin-istanbul\": \"^4.1.4\", \"babel-plugin-syntax-dynamic-import\": \"^6.18.0\", \"babel-plugin-syntax-jsx\": \"^6.18.0\", \"babel-plugin-transform-vue-jsx\": \"^3.4.3\", \"babel-preset-es2015\": \"^6.24.1\", \"babel-preset-flow-vue\": \"^1.0.0\"&#125; // 省略// babelrc 文件&#123; \"presets\": [\"es2015\", \"flow-vue\"], \"plugins\": [\"transform-vue-jsx\", \"syntax-dynamic-import\"], \"ignore\": [ \"dist/*.js\", \"packages/**/*.js\" ]&#125; 对象 这里只对对象的创建、对象上的属性操作相关、getter/setter方法、对象标签等进行再分析，对于原型链以及原型继承原理不是本文的重要内容。 创建对象 一般创建对象有以下三种写法，基本代码如下： 12345678910111213// 第一种 最简单的写法let obj = &#123; a: 1 &#125;obj.a // 1typeof obj.toString // 'function'// 第二种let obj2 = Object.create(&#123; a: 1 &#125;)obj2.a // 1typeof obj2.toString // 'function'// 第三种let obj3 = Object.create(null)typeof obj3.toString // 'undefined' 图解基本如下： Object.create可以理解为继承一个对象，它是ES5的一个新特性，对于旧版浏览器需要做兼容，基本代码如下（vue使用ie9+浏览器，所以不需要做兼容处理）： 1234567if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; //定义了一个隐式的构造函数 F.prototype = o; return new F(); //其实还是通过new来实现的 &#125;;&#125; 其中，在vue源码中会看见使用Object.create(null)来创建一个空对象，其好处不用考虑会和原型链上的属性重名问题，vue代码片段如下： 123456// src/core/global-api/index.js// 再Vue上定义静态属性options并且赋值位空对象，ASSET_TYPES是在vue上定义的'component','directive','filter'等属性 Vue.options = Object.create(null) ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + 's'] = Object.create(null) &#125;) 属性操作相关 其实在创建对象的同时，对象上会默认设置当前对象的枚举类型值，如果不设置，默认所有枚举类型均为false，那么如何定义对象并且设置枚举类型值呢？主要使用到的是ES5的新特性Object.defineProperty。 Object.defineProperty(obj,prop,descriptor)中的descriptor有如下几种参数： configurable 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false enumerable 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。 get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为 undefined。 set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined 注意：在 descriptor 中不能同时设置访问器 (get 和 set) 和 value。 完整示例代码如下： 123456789101112Object.defineProperty(obj,prop, configurable: true, enumerable: true, writable: true, value: '', get: function() &#123; &#125;, set: function() &#123; &#125;) 通过使用Object.getOwnPropertyDescriptor来查看对象上属性的枚举类型值，具体使用相关示例代码如下： 12345678910111213141516// 如果不设置枚举类型，默认都是falselet obj = &#123;&#125;Object.defineProperty(obj, 'name', &#123; value : \"wqzwh\"&#125;)Object.getOwnPropertyDescriptor(obj, 'name')// &#123;value: \"wqzwh\", writable: false, enumerable: false, configurable: false&#125;let obj2 = &#123;&#125;Object.defineProperty(obj2, 'name', &#123; enumerable: true, writable: true, value : \"wqzwh\"&#125;)Object.getOwnPropertyDescriptor(obj2, 'name')// &#123;value: \"wqzwh\", writable: true, enumerable: true, configurable: false&#125; 通过Object.keys()来获取对象的key，必须将enumerable设置为true才能获取，否则返回是空数组，代码如下： 123456let obj = &#123;&#125;Object.defineProperty(obj, 'name', &#123; enumerable: true, value : \"wqzwh\"&#125;)Object.keys(obj) // ['name'] 通过propertyIsEnumerable可以判断定义的对象是否可枚举，代码如下： 123456789101112let obj = &#123;&#125;Object.defineProperty(obj, 'name', &#123; value : \"wqzwh\"&#125;)obj.propertyIsEnumerable('name') // falselet obj = &#123;&#125;Object.defineProperty(obj, 'name', &#123; enumerable: true, value : \"wqzwh\"&#125;)obj.propertyIsEnumerable('name') // true 通过hasOwnProperty来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。代码如下： 123456789101112131415161718192021222324252627282930// 使用Object.defineProperty创建对象属性let obj = &#123;&#125;Object.defineProperty(obj, 'name', &#123; value : \"wqzwh\", enumerable: true&#125;)let obj2 = Object.create(obj)obj2.age = 20for (key in obj2) &#123; console.log(key); // age, name&#125;for (key in obj2) &#123; if (obj2.hasOwnProperty(key)) &#123; console.log(key); // age &#125;&#125;// 普通创建属性let obj = &#123;&#125;obj.name = 'wqzwh'let obj2 = Object.create(obj)obj2.age = 20for (key in obj2) &#123; console.log(key); // age, name&#125;for (key in obj2) &#123; if (obj2.hasOwnProperty(key)) &#123; console.log(key); // age &#125;&#125; 注意：如果继承的对象属性是通过Object.defineProperty创建的，并且enumerable未设置成true，那么for in依然不能枚举出原型上的属性。 getter/setter方法 通过get/set方法来检测属性变化，基本代码如下： 123456789101112function foo() &#123;&#125;Object.defineProperty(foo.prototype, 'z', &#123; get: function()&#123; return 1 &#125; &#125;)let obj = new foo();console.log(obj.z) // 1obj.z = 10console.log(obj.z) // 1 这个是z属性是foo.prototype上的属性并且有get方法，对于第二次通过obj.z = 10并不会在obj本身创建z属性，而是直接原型触发上的get方法。 图解基本如下： 如果在创建当前对象上定义z属性，并且设置writable和configurable为true，那么就可以改变z属性的值，并且删除z属性后再次访问obj.z仍然是1，测试代码如下： 12345678910111213141516171819202122function foo() &#123;&#125;Object.defineProperty(foo.prototype, 'z', &#123; get: function()&#123; return 1 &#125; &#125;)let obj = new foo();console.log(obj.z) // 1Object.defineProperty(obj, 'z', &#123; value: 100, writable: true, configurable: true &#125;)console.log(obj.z) // 100obj.z = 300console.log(obj.z) // 300delete obj.zconsole.log(obj.z) // 1 图解基本如下： Object.defineProperty中的configurable、enumerable、writable、value、get、set几个参数相互之间的关系到底如何呢？可以用一张图来清晰说明： 对象标签 其实创建对象的同时都会附带一个__proto__的原型标签，除了使用Object.create(null)建立对象以外，代码如下： 123let obj = &#123;x: 1, y: 2&#125;obj.__proto__.z = 3console.log(obj.z) // 3 Object.preventExtensions方法用于锁住对象属性，使其不能够拓展，也就是不能增加新的属性，但是属性的值仍然可以更改，也可以把属性删除，Object.isExtensible用于判断对象是否可以被拓展，基本代码如下： 12345678let obj = &#123;x : 1, y : 2&#125;;Object.isExtensible(obj); // trueObject.preventExtensions(obj);Object.isExtensible(obj); // falseobj.z = 1;obj.z; // undefined, add new property failedObject.getOwnPropertyDescriptor(obj, 'x');// Object &#123;value: 1, writable: true, enumerable: true, configurable: true&#125; Object.seal方法用于把对象密封，也就是让对象既不可以拓展也不可以删除属性（把每个属性的configurable设为false）,单数属性值仍然可以修改，Object.isSealed由于判断对象是否被密封，基本代码如下： 12345let obj = &#123;x : 1, y : 2&#125;;Object.seal(obj);Object.getOwnPropertyDescriptor(obj, 'x');// Object &#123;value: 1, writable: true, enumerable: true, configurable: false&#125;Object.isSealed(obj); // true Object.freeze完全冻结对象，在seal的基础上，属性值也不可以修改（每个属性的wirtable也被设为false），Object.isFrozen判断对象是否被冻结，基本代码如下： 12345let obj = &#123;x : 1, y : 2&#125;;Object.freeze(obj);Object.getOwnPropertyDescriptor(obj, 'x');// Object &#123;value: 1, writable: false, enumerable: true, configurable: false&#125;Object.isFrozen(obj); // true DOM自定义事件 在介绍这个命题之前，先看一段vue源码中的model的指令，打开platforms/web/runtime/directives/model.js，片段代码如下： 1234567891011121314151617/* istanbul ignore if */if (isIE9) &#123; // http://www.matts411.com/post/internet-explorer-9-oninput/ document.addEventListener('selectionchange', () =&gt; &#123; const el = document.activeElement if (el &amp;&amp; el.vmodel) &#123; trigger(el, 'input') &#125; &#125;)&#125;// 省略function trigger (el, type) &#123; const e = document.createEvent('HTMLEvents') e.initEvent(type, true, true) el.dispatchEvent(e)&#125; 其中document.activeElement是当前获得焦点的元素，可以使用document.hasFocus()方法来查看当前元素是否获取焦点。 对于标准浏览器，其提供了可供元素触发的方法：element.dispatchEvent(). 不过，在使用该方法之前，我们还需要做其他两件事，及创建和初始化。因此，总结说来就是： 123document.createEvent()event.initEvent()element.dispatchEvent() createEvent()方法返回新创建的Event对象，支持一个参数，表示事件类型，具体见下表： 1234参数 事件接口 初始化方法HTMLEvents HTMLEvent initEvent()MouseEvents MouseEvent initMouseEvent()UIEvents UIEvent initUIEvent() initEvent()方法用于初始化通过DocumentEvent接口创建的Event的值。支持三个参数：initEvent(eventName, canBubble, preventDefault). 分别表示事件名称，是否可以冒泡，是否阻止事件的默认操作。 dispatchEvent()就是触发执行了，上文vue源码中的el.dispatchEvent(e), 参数e表示事件对象，是createEvent()方法返回的创建的Event对象。 那么这个东东具体该怎么使用呢？例如自定一个click方法，代码如下： 1234567891011// 创建事件.let event = document.createEvent('HTMLEvents');// 初始化一个点击事件，可以冒泡，无法被取消event.initEvent('click', true, false);let elm = document.getElementById('wq')// 设置事件监听.elm.addEventListener('click', (e) =&gt; &#123; console.log(e)&#125;, false);// 触发事件监听elm.dispatchEvent(event); 数组扩展方法every方法/some方法 接受两个参数，第一个是函数（接受三个参数：数组当前项的值、当前项在数组中的索引、数组对象本身），第二个参数是执行第一个函数参数的作用域对象，也就是上面说的函数中this所指向的值，如果不设置默认是undefined。 这两种方法都不会改变原数组 every()： 该方法对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回true。 some()： 该方法对数组中的每一项运行给定函数，如果该函数对任何一项返回 true，则返回true。 示例代码如下： 123456789let arr = [ 1, 2, 3, 4, 5, 6 ]; console.log( arr.some( function( item, index, array )&#123; console.log( 'item=' + item + ',index='+index+',array='+array ); return item &gt; 3; &#125;)); console.log( arr.every( function( item, index, array )&#123; console.log( 'item=' + item + ',index='+index+',array='+array ); return item &gt; 3; &#125;)); some方法是碰到一个返回true的值时候就返回了，并没有继续往下运行，而every也一样，第一个值就是一个false,所以后面也没有进行下去的必要了，就直接返回结果了。 getBoundingClientRect 该方法返回一个矩形对象，其中四个属性：left、top、right、bottom，分别表示元素各边与页面上边和左边的距离，x、y表示左上角定点的坐标位置。 通过这个方法计算得出的left、top、right、bottom、x、y会随着视口区域内滚动操作而发生变化，如果你需要获得相对于整个网页左上角定位的属性值，那么只要给top、left属性值加上当前的滚动位置。 为了跨浏览器兼容，请使用 window.pageXOffset 和 window.pageYOffset 代替 window.scrollX 和 window.scrollY。不能访问这些属性的脚本可以使用下面的代码： 123456// For scrollX(((t = document.documentElement) || (t = document.body.parentNode)) &amp;&amp; typeof t.scrollLeft == 'number' ? t : document.body).scrollLeft// For scrollY(((t = document.documentElement) || (t = document.body.parentNode)) &amp;&amp; typeof t.scrollTop == 'number' ? t : document.body).scrollTop 在IE中，默认坐标从(2,2)开始计算，导致最终距离比其他浏览器多出两个像素，代码如下： 123456789101112131415document.documentElement.clientTop; // 非IE为0，IE为2document.documentElement.clientLeft; // 非IE为0，IE为2// 所以为了保持所有浏览器一致，需要做如下操作functiongGetRect (element) &#123; let rect = element.getBoundingClientRect(); let top = document.documentElement.clientTop; let left= document.documentElement.clientLeft; return&#123; top: rect.top - top, bottom: rect.bottom - top, left: rect.left - left, right: rect.right - left &#125;&#125; performance vue中片段源码如下： 12345678910111213141516171819if (process.env.NODE_ENV !== 'production') &#123; const perf = inBrowser &amp;&amp; window.performance /* istanbul ignore if */ if ( perf &amp;&amp; perf.mark &amp;&amp; perf.measure &amp;&amp; perf.clearMarks &amp;&amp; perf.clearMeasures ) &#123; mark = tag =&gt; perf.mark(tag) measure = (name, startTag, endTag) =&gt; &#123; perf.measure(name, startTag, endTag) perf.clearMarks(startTag) perf.clearMarks(endTag) perf.clearMeasures(name) &#125; &#125;&#125; performance.mark方法在浏览器的性能条目缓冲区中创建一个具有给定名称的缓冲区，performance.measure在浏览器的两个指定标记（分别称为起始标记和结束标记）之间的性能条目缓冲区中创建一个命名，测试代码如下： 123456789101112131415161718let _uid = 0const perf = window.performancefunction testPerf() &#123; _uid++ let startTag = `test-mark-start:$&#123;_uid&#125;` let endTag = `test-mark-end:$&#123;_uid&#125;` // 执行mark函数做标记 perf.mark(startTag) for(let i = 0; i &lt; 100000; i++) &#123; &#125; // 执行mark函数做标记 perf.mark(endTag) perf.measure(`test mark init`, startTag, endTag)&#125; 测试结果可以在谷歌浏览器中的Performance中监测到，效果图如下： 浏览器中performance处理模型基本如下（更多具体参数说明）： Proxy相关get方法 get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。 拦截对象属性的读取，比如proxy.foo和proxy[‘foo’] 基本使用如下： 12345678910111213141516let person = &#123; name: \"张三\"&#125;;let proxy = new Proxy(person, &#123; get: (target, property) =&gt; &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(\"Property \\\"\" + property + \"\\\" does not exist.\"); &#125; &#125;&#125;);proxy.name // \"张三\"proxy.age // 抛出一个错误 如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。示例代码如下： 1234567891011121314const target = Object.defineProperties(&#123;&#125;, &#123; foo: &#123; value: 123, writable: false, configurable: false &#125;,&#125;);const handler = &#123; get(target, propKey) &#123; return 'abc'; &#125;&#125;;const proxy = new Proxy(target, handler);proxy.foo // TypeError: Invariant check failed has方法 此方法可以接受两个参数，分别是目标对象、需查询的属性名，主要拦截如下几种操作： 属性查询: foo in proxy 继承属性查询: foo in Object.create(proxy) with 检查: with(proxy) { (foo); } Reflect.has() 如果原对象不可配置或者禁止扩展，这时has拦截会报错。基本示例代码如下： 12345678let obj = &#123; a: 10 &#125;;Object.preventExtensions(obj);let p = new Proxy(obj, &#123; has: function(target, prop) &#123; return false; &#125;&#125;);'a' in p // TypeError is thrown has拦截只对in运算符生效，对for...in循环不生效。基本示例代码如下： 12345678910111213141516171819202122232425262728let stu1 = &#123;name: '张三', score: 59&#125;;let stu2 = &#123;name: '李四', score: 99&#125;;let handler = &#123; has(target, prop) &#123; if (prop === 'score' &amp;&amp; target[prop] &lt; 60) &#123; console.log(`$&#123;target.name&#125; 不及格`); return false; &#125; return prop in target; &#125;&#125;let oproxy1 = new Proxy(stu1, handler);let oproxy2 = new Proxy(stu2, handler);'score' in oproxy1// 张三 不及格// false'score' in oproxy2// truefor (let a in oproxy1) &#123; console.log(oproxy1[a]);&#125;// 张三// 59for (let b in oproxy2) &#123; console.log(oproxy2[b]);&#125;// 李四// 99 使用with关键字的目的是为了简化多次编写访问同一对象的工作，基本写法如下： 123456789let qs = location.search.substring(1);let hostName = location.hostname;let url = location.href;with (location)&#123; let qs = search.substring(1); let hostName = hostname; let url = href;&#125; 使用with关键字会导致代码性能降低，使用let定义变量相比使用var定义变量能提高一部分性能，示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243// 不使用withfunction func() &#123; console.time(\"func\"); let obj = &#123; a: [1, 2, 3] &#125;; for (let i = 0; i &lt; 100000; i++) &#123; let v = obj.a[0]; &#125; console.timeEnd(\"func\");// 1.310302734375ms&#125;func();// 使用with并且使用let定义变量function funcWith() &#123; console.time(\"funcWith\"); const obj = &#123; a: [1, 2, 3] &#125;; with (obj) &#123; let a = obj.a for (let i = 0; i &lt; 100000; i++) &#123; let v = a[0]; &#125; &#125; console.timeEnd(\"funcWith\");// 14.533935546875ms&#125;funcWith();// 使用withfunction funcWith() &#123; console.time(\"funcWith\"); var obj = &#123; a: [1, 2, 3] &#125;; with (obj) &#123; for (var i = 0; i &lt; 100000; i++) &#123; var v = a[0]; &#125; &#125; console.timeEnd(\"funcWith\");// 52.078857421875ms&#125;funcWith(); js引擎在代码执行之前有一个编译阶段，在不使用with关键字的时候，js引擎知道a是obj上的一个属性，它就可以静态分析代码来增强标识符的解析，从而优化了代码，因此代码执行的效率就提高了。使用了with关键字后，js引擎无法分辨出a变量是局部变量还是obj的一个属性，因此，js引擎在遇到with关键字后，它就会对这段代码放弃优化，所以执行效率就降低了。 使用has方法拦截with关键字，示例代码如下： 12345678910111213141516171819let stu1 = &#123;name: '张三', score: 59&#125;;let handler = &#123; has(target, prop) &#123; if (prop === 'score' &amp;&amp; target[prop] &lt; 60) &#123; console.log(`$&#123;target.name&#125; 不及格`); return false; &#125; return prop in target; &#125;&#125;let oproxy1 = new Proxy(stu1, handler);function test() &#123; let score with(oproxy1) &#123; return score &#125;&#125;test() // 张三 不及格 在使用with关键字时候，主要是因为js引擎在解析代码块中变量的作用域造成的性能损失，那么我们可以通过定义局部变量来提高其性能。修改示例代码如下： 123456789101112131415// 修改后function funcWith() &#123; console.time(\"funcWith\"); const obj = &#123; a: [1, 2, 3] &#125;; with (obj) &#123; let a = obj.a for (let i = 0; i &lt; 100000; i++) &#123; let v = a[0]; &#125; &#125; console.timeEnd(\"funcWith\");// 1.7109375ms&#125;funcWith(); 但是在实际使用的时候在with代码块中定义局部变量不是很可行，那么删除频繁查找作用域的功能应该可以提高代码部分性能，经测试运行时间几乎相同，修改代码如下： 12345678910111213141516171819202122function func() &#123; console.time(\"func\"); let obj = &#123; a: [1, 2, 3] &#125;; let v = obj.a[0]; console.timeEnd(\"func\");// 0.01904296875ms&#125;func();// 修改后function funcWith() &#123; console.time(\"funcWith\"); const obj = &#123; a: [1, 2, 3] &#125;; with (obj) &#123; let v = a[0]; &#125; console.timeEnd(\"funcWith\");// 0.028076171875ms&#125;funcWith(); 配上has函数后执行效果如何呢，片段代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 第一段代码其实has方法没用，只是为了对比使用console.time(\"测试\");let stu1 = &#123;name: '张三', score: 59&#125;;let handler = &#123; has(target, prop) &#123; if (prop === 'score' &amp;&amp; target[prop] &lt; 60) &#123; console.log(`$&#123;target.name&#125; 不及格`); return false; &#125; return prop in target; &#125;&#125;let oproxy1 = new Proxy(stu1, handler);function test(oproxy1) &#123; return &#123; render: () =&gt; &#123; return oproxy1.score &#125; &#125;&#125;console.log(test(oproxy1).render()) // 张三 不及格console.timeEnd(\"测试\"); // 0.719970703125msconsole.time(\"测试\");let stu1 = &#123;name: '张三', score: 59&#125;;let handler = &#123; has(target, prop) &#123; if (prop === 'score' &amp;&amp; target[prop] &lt; 60) &#123; console.log(`$&#123;target.name&#125; 不及格`); return false; &#125; return prop in target; &#125;&#125;let oproxy1 = new Proxy(stu1, handler);function test(oproxy1) &#123; let score return &#123; render: () =&gt; &#123; with(oproxy1) &#123; return score &#125; &#125; &#125;&#125;console.log(test(oproxy1).render()) // 张三 不及格console.timeEnd(\"测试\"); // 0.760009765625ms vue中使用with关键字的片段代码如下，主要通过proxy来拦截AST语言树中涉及到的变量以及方法，并且判断是否AST语言树中是否存在为定义的变量及方法，至于为什么vue会使用with关键字，具体可以点击查看 1234567891011export function generate ( ast: ASTElement | void, options: CompilerOptions): CodegenResult &#123; const state = new CodegenState(options) const code = ast ? genElement(ast, state) : '_c(\"div\")' return &#123; render: `with(this)&#123;return $&#123;code&#125;&#125;`, staticRenderFns: state.staticRenderFns &#125;&#125; outerHTML 打开platforms/web/entry-runtime-width-compile.js，查看getOuterHTML方法，片段代码如下： 123456789function getOuterHTML (el: Element): string &#123; if (el.outerHTML) &#123; return el.outerHTML &#125; else &#123; const container = document.createElement('div') container.appendChild(el.cloneNode(true)) return container.innerHTML &#125;&#125; 由于在IE9-11中SVG标签元素是没有innerHTML和outerHTML这两个属性，所以会有else之后的语句 2018-07-17补充这里针对proxy和Object.defineProperty在vue源码中使用做一次补充说明下。vue中的定义的data其实是通过Object.defineProperty来进行监听变化的，如果定义的data单纯是对象，按照Object.definePropertyapi介绍是合理的，但是如果是数组呢？这个是如何实现的呢? 注意：Object.defineProperty有一定的缺陷：只能针对obj中的属性进行数据劫持，如果对象层级过深，那么需要深度遍历整个对象；对于数组不能监听到数据的变化 这里想说明的是Object.defineProperty无法监听数组的变化，带着这个疑问查看源码，先查看src/core/instance/state.js中的initData方法，片段代码如下：1234567891011121314151617181920212223242526272829303132333435363738export function proxy (target: Object, sourceKey: string, key: string) &#123; sharedPropertyDefinition.get = function proxyGetter () &#123; return this[sourceKey][key] &#125; sharedPropertyDefinition.set = function proxySetter (val) &#123; this[sourceKey][key] = val &#125; Object.defineProperty(target, key, sharedPropertyDefinition)&#125;// 省略function initData (vm: Component) &#123; // 省略 while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; 这里重要的是proxy和observe，那么问题来了，为什么proxy已经监听了，为什么还需要observe再次监听呢，继续打开src/core/observer/index.js，片段代码如下：123456789101112131415161718192021export function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; 这里就判断了value的类型，如果value是对象那么直接return，如果是数组，那么会继续执行ob = new Observer(value)，其实就是再次监听。然后根据方法最终找到了，打开src/core/observer/array.js核心代码如下:1234567891011121314151617181920212223242526272829303132333435363738const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 这里为什么会将Array.prototype赋值给arrayProto，并且重新定义一个变量arrayMethods继承arrayProto，个人觉得这是一个小技巧，这样methodsToPatch方法中的def(src/core/util/lang.js文件中的方法，其实就是Object.defineProperty)的第一个参数就是个对象了，并且将数组的几个方法全部使用Object.defineProperty再包装一次，这样就能尊崇Object.definePropertyapi规范了。 话题转回来，其实如果是数组，那么vue中需要通过vm.$set才能及时更新试图，经过测试发现调用vm.$set改变数组，其实是触发了数组的splice方法，而splice方法又被监听了，所以才能实现最开始的疑问数组也能被监听，测试代码如下：12345678910111213&lt;div&gt;&#123;&#123;arr&#125;&#125;&lt;/div&gt;let vm = new Vue(&#123; el: &apos;#app&apos;, data() &#123; return &#123; arr: [1, 2] &#125; &#125;&#125;)// 只能通过vm.$set来更新试图vm.$set(vm.arr, 0, 31) 这种实现感觉存在性能问题，就是数组需要遍历并且调用Object.defineProperty方法。 再说回proxy，其实这个也有get和set方法，proxy其实是优越Object.defineProperty，因为它可以拦截数组类型的数据，测试代码如下：12345678910111213141516// 因为proxy肯定能拦截对象，所以这里只用数组来做测试const handler = &#123; get (target, key) &#123; console.log('----get-----') return target[key]; &#125;, set (target, key, value) &#123; console.log('----set-----') target[key] = value; return true; &#125;&#125;;const target = [1,2];const arr = new Proxy(target, handler);arr[0] = 3 // '----set-----' 因此我觉得，vue完全可以使用proxy来替代Object.defineProperty，性能也能得到一定的提升。 以上是我对proxy和Object.defineProperty做的一个补充，如果有什么不对的地方，希望能够指出来。 总结以上主要是在阅读源码时，发现不是很明白的api以及一些方法，每个人可以根据自己的实际情况选择性阅读，以上就是全部内容，如果有什么不对的地方，欢迎提issues","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"剖析使用javascirpt实现算法--排序算法（CArray）","date":"2018-04-08T06:02:36.000Z","path":"2018-4-8-CArray/","text":"基本排序算法冒泡排序它是最慢的排序算法之一，但也是一种最容易实现的排序算法。数据值会像气泡一样从数组的一端漂 浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小 的值则会浮动到数组的左侧。之所以会产生这种现象是因为算法会多次在数组中移动，比 较相邻的数据，当左侧值大于右侧值时将它们进行互换。 根据规则实现片段代码如下：1234567891011// 冒泡排序bubbleSort() &#123; let numElements = this.dataStore.length for (let outer = numElements; outer &gt;= 2; --outer) &#123; for (let inner = 0; inner &lt;= outer - 1; inner++) &#123; if (this.dataStore[inner] &gt; this.dataStore[inner + 1]) &#123; this.swap(this.dataStore, inner, inner + 1) &#125; &#125; &#125;&#125; 运行效果图如下： 通过运行图，发现冒泡排序算法会产生多余的循环排序过程，因此可以通过定义一个flag变量来判断是否已经排序完成从而跳出循环，提交性能，优化后代码如下：123456789101112131415// 冒泡排序优化bubbleSort2() &#123; let flag let numElements = this.dataStore.length for (let outer = numElements; outer &gt;= 2; --outer) &#123; flag = true for (let inner = 0; inner &lt;= outer - 1; inner++) &#123; if (this.dataStore[inner] &gt; this.dataStore[inner + 1]) &#123; flag = false this.swap(this.dataStore, inner, inner + 1) &#125; &#125; if(flag) break &#125;&#125; 选择排序选择排序从数组的开头开始，将第一个元素和其他元素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。 根据规则实现片段代码如下：12345678910111213// 选择排序selectionSort() &#123; let min, l = this.dataStore.length for (let outer = 0; outer &lt;= l - 1; outer++) &#123; min = outer for (let inner = outer + 1; inner &lt;= l; inner++) &#123; if (this.dataStore[inner] &lt; this.dataStore[min]) &#123; min = inner &#125; &#125; this.swap(this.dataStore, outer, min) &#125;&#125; 运行效果图如下： 插入排序插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数组元素会向右移动，为内循环中的这个元素腾出位置。 根据规则实现片段代码如下：12345678910111213// 插入排序insertionSort() &#123; let temp, inner, l = this.dataStore.length for (let outer = 1; outer &lt;= l - 1; outer++) &#123; temp = this.dataStore[outer]; inner = outer; while (inner &gt; 0 &amp;&amp; (this.dataStore[inner - 1] &gt;= temp)) &#123; this.dataStore[inner] = this.dataStore[inner - 1]; --inner; &#125; this.dataStore[inner] = temp; &#125;&#125; 运行效果图如下： 基本排序耗时比较测试片段代码如下：123456789101112var start = new Date().getTime();mynums.bubbleSort2();var stop = new Date().getTime();console.log('冒泡',stop - start)var start = new Date().getTime();mynums.selectionSort();var stop = new Date().getTime();console.log('选择',stop - start)var start = new Date().getTime();mynums.insertionSort();var stop = new Date().getTime();console.log('插入',stop - start) 经过测试，当初始定义的数据达到1000个的时候，选择排序和插入排序要比冒泡 排序快，插入排序是这三种算法中最快的。 高级排序希尔排序希尔排序的核心理念与插入排序 不同，它会首先比较距离较远的元素，而非相邻的元素。和简单地比较相邻元素相比，使 用这种方案可以使离正确位置很远的元素更快地回到合适的位置。当开始用这个算法遍历 数据集时，所有元素之间的距离会不断减小，直到处理到数据集的末尾，这时算法比较的 就是相邻元素了。 原理：通过定义一个间隔序列来表示在排序过程中进行比较的元素之 间有多远的间隔。 根据规则实现片段代码如下：123456789101112131415161718// 希尔排序算法shellsort() &#123; let j for (let g = 0; g &lt; this.gaps.length; g++) &#123; for (let i = this.gaps[g]; i &lt; this.dataStore.length; i++) &#123; let temp = this.dataStore[i]; for (j = i; j &gt;= this.gaps[g] &amp;&amp; this.dataStore[j - this.gaps[g]] &gt; temp; j -= this.gaps[g]) &#123; this.dataStore[j] = this.dataStore[j - this.gaps[g]]; &#125; if(JSON.stringify(this.dataStore[j]) !== JSON.stringify(temp)) this.dataStore[j] = temp; &#125; &#125;&#125;// 希尔排序算法设置间隔序列定义的方法setGaps(arr) &#123; this.gaps = arr;&#125; 运行效果图如下： 以上片段代码是通过先执行setGaps方法来确定间隔数，也可以根据本身数组的长度来动态定义间隔，基本片段代码如下：12345678910111213141516// 动态计算间隔序列shellsort1() &#123; let N = this.dataStore.length; let h = 1; while (h &lt; N / 3) &#123; h = 3 * h + 1; &#125; while (h &gt;= 1) &#123; for (let i = h; i &lt; N; i++) &#123; for (let j = i; j &gt;= h &amp;&amp; this.dataStore[j] &lt; this.dataStore[j - h]; j -= h) &#123; this.swap(this.dataStore, j, j - h); &#125; &#125; h = (h - 1) / 3; &#125;&#125; 归并排序把一系列排好序的子序列合并成一个大的完整有序序 列。 以下是采用非递归的模式自底向上的归并排序片段代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 归并排序 自底向上的归并排序算法 非递归mergeSort(arr) &#123; if (arr.length &lt; 2) &#123; return; &#125; let step = 1; let left, right; while (step &lt; arr.length) &#123; left = 0; right = step; while (right + step &lt;= arr.length) &#123; this.mergeArrays(arr, left, left + step, right, right + step); left = right + step; right = left + step; &#125; if (right &lt; arr.length) &#123; this.mergeArrays(arr, left, left + step, right, arr.length); &#125; step *= 2; &#125;&#125;mergeArrays(arr, startLeft, stopLeft, startRight, stopRight) &#123; let rightArr = new Array(stopRight - startRight + 1); let leftArr = new Array(stopLeft - startLeft + 1); let k = startRight; for (let i = 0; i &lt; (rightArr.length - 1); ++i) &#123; rightArr[i] = arr[k]; ++k; &#125; k = startLeft; for (let i = 0; i &lt; (leftArr.length - 1); ++i) &#123; leftArr[i] = arr[k]; ++k; &#125; rightArr[rightArr.length - 1] = Infinity; // 哨兵值 leftArr[leftArr.length - 1] = Infinity; // 哨兵值 let m = 0; let n = 0; for (let k = startLeft; k &lt; stopRight; ++k) &#123; if (leftArr[m] &lt;= rightArr[n]) &#123; arr[k] = leftArr[m]; m++; &#125; else &#123; arr[k] = rightArr[n]; n++; &#125; &#125; console.log(\"left array - \", leftArr); console.log(\"right array - \", rightArr); console.log(\"array - \", arr);&#125; 运行效果图如下： 快速排序快速排序是处理大数据集最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。 这个算法首先要在列表中选择一个元素作为基准值(pivot)。数据排序围绕基准值进行， 将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。 实现基本步骤如下： (1) 选择一个基准元素，将列表分隔成两个子序列; (2) 对列表重新排序，将所有小于基准值的元素放在基准值的前面，所有大于基准值的元素放在基准值的后面; (3) 分别对较小元素的子序列和较大元素的子序列重复步骤 1 和 2。 根据规则实现的片段代码如下：1234567891011121314151617// 快速排序qSort(arr) &#123; if (arr.length == 0) &#123; return []; &#125; let left = []; let right = []; let pivot = arr[0]; for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return this.qSort(left).concat(pivot, this.qSort(right));&#125; 最终完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206class CArray &#123; constructor(numElements) &#123; this.dataStore = [] this.pos = 0 this.numElements = numElements for (let i = 0; i &lt; numElements; i++) &#123; this.dataStore[i] = i; &#125; this.gaps = [] &#125; setData() &#123; for (let i = 0; i &lt; this.numElements; i++) &#123; this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1)); &#125; &#125; clear() &#123; for (let i = 0; i &lt; this.dataStore.length; i++) &#123; this.dataStore[i] = 0; &#125; &#125; insert(element) &#123; this.dataStore[this.pos++] = element; &#125; toString() &#123; let retstr = \"\"; for (let i = 0; i &lt; this.dataStore.length; i++) &#123; retstr += this.dataStore[i] + \" \"; if (i &gt; 0 &amp; i % 10 == 0) &#123; retstr += \"\\n\"; &#125; &#125; return retstr; &#125; swap(arr, index1, index2) &#123; let temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; &#125; // 冒泡排序 bubbleSort() &#123; let numElements = this.dataStore.length for (let outer = numElements; outer &gt;= 2; --outer) &#123; for (let inner = 0; inner &lt;= outer - 1; inner++) &#123; if (this.dataStore[inner] &gt; this.dataStore[inner + 1]) &#123; this.swap(this.dataStore, inner, inner + 1) &#125; &#125; &#125; &#125; // 冒泡排序优化 bubbleSort2() &#123; let flag let numElements = this.dataStore.length for (let outer = numElements; outer &gt;= 2; --outer) &#123; flag = true for (let inner = 0; inner &lt;= outer - 1; inner++) &#123; if (this.dataStore[inner] &gt; this.dataStore[inner + 1]) &#123; flag = false this.swap(this.dataStore, inner, inner + 1) &#125; &#125; if(flag) break &#125; &#125; // 选择排序 selectionSort() &#123; let min, l = this.dataStore.length for (let outer = 0; outer &lt;= l - 1; outer++) &#123; min = outer for (let inner = outer + 1; inner &lt;= l; inner++) &#123; if (this.dataStore[inner] &lt; this.dataStore[min]) &#123; min = inner &#125; &#125; this.swap(this.dataStore, outer, min) &#125; &#125; // 插入排序 insertionSort() &#123; let temp, inner, l = this.dataStore.length for (let outer = 1; outer &lt;= l - 1; outer++) &#123; temp = this.dataStore[outer]; inner = outer; while (inner &gt; 0 &amp;&amp; (this.dataStore[inner - 1] &gt;= temp)) &#123; this.dataStore[inner] = this.dataStore[inner - 1]; --inner; &#125; this.dataStore[inner] = temp; &#125; &#125; // 希尔排序算法 shellsort() &#123; let j for (let g = 0; g &lt; this.gaps.length; g++) &#123; for (let i = this.gaps[g]; i &lt; this.dataStore.length; i++) &#123; let temp = this.dataStore[i]; for (j = i; j &gt;= this.gaps[g] &amp;&amp; this.dataStore[j - this.gaps[g]] &gt; temp; j -= this.gaps[g]) &#123; this.dataStore[j] = this.dataStore[j - this.gaps[g]]; &#125; if(JSON.stringify(this.dataStore[j]) !== JSON.stringify(temp)) this.dataStore[j] = temp; &#125; &#125; &#125; // 希尔排序算法设置间隔序列定义的方法 setGaps(arr) &#123; this.gaps = arr; &#125; // 动态计算间隔序列 shellsort1() &#123; let N = this.dataStore.length; let h = 1; while (h &lt; N / 3) &#123; h = 3 * h + 1; &#125; while (h &gt;= 1) &#123; for (let i = h; i &lt; N; i++) &#123; for (let j = i; j &gt;= h &amp;&amp; this.dataStore[j] &lt; this.dataStore[j - h]; j -= h) &#123; this.swap(this.dataStore, j, j - h); &#125; &#125; h = (h - 1) / 3; &#125; &#125; // 归并排序 自底向上的归并排序算法 非递归 mergeSort(arr) &#123; if (arr.length &lt; 2) &#123; return; &#125; let step = 1; let left, right; while (step &lt; arr.length) &#123; left = 0; right = step; while (right + step &lt;= arr.length) &#123; this.mergeArrays(arr, left, left + step, right, right + step); left = right + step; right = left + step; &#125; if (right &lt; arr.length) &#123; this.mergeArrays(arr, left, left + step, right, arr.length); &#125; step *= 2; &#125; &#125; mergeArrays(arr, startLeft, stopLeft, startRight, stopRight) &#123; let rightArr = new Array(stopRight - startRight + 1); let leftArr = new Array(stopLeft - startLeft + 1); let k = startRight; for (let i = 0; i &lt; (rightArr.length - 1); ++i) &#123; rightArr[i] = arr[k]; ++k; &#125; k = startLeft; for (let i = 0; i &lt; (leftArr.length - 1); ++i) &#123; leftArr[i] = arr[k]; ++k; &#125; rightArr[rightArr.length - 1] = Infinity; // 哨兵值 leftArr[leftArr.length - 1] = Infinity; // 哨兵值 let m = 0; let n = 0; for (let k = startLeft; k &lt; stopRight; ++k) &#123; if (leftArr[m] &lt;= rightArr[n]) &#123; arr[k] = leftArr[m]; m++; &#125; else &#123; arr[k] = rightArr[n]; n++; &#125; &#125; &#125; // 快速排序 qSort(arr) &#123; if (arr.length == 0) &#123; return []; &#125; let left = []; let right = []; let pivot = arr[0]; for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return this.qSort(left).concat(pivot, this.qSort(right)); &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://www.iwangqi.com/tags/ECMAScript-6/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.iwangqi.com/tags/algorithm/"}]},{"title":"剖析使用javascirpt实现算法--无向图（Graph）（一）","date":"2018-03-18T12:46:23.000Z","path":"2018-3-18-Graph/","text":"图的定义图有顶点和边组成的图形，图基本有以下4中类型： 无向图（简单链接） 有向图（链接有方向性） 加权图（链接带有权值） 加权有向图（连接既有方向又带有权值） 一般创建图有两种方法：邻接链表示法和邻接矩阵表示法 示例主要以邻接链表示法来创建图 以下是使用邻接链表示法创建的图，基本如下： 通过创建邻接链表，此处主要使用二维数组的方法，序号代表顶点，值代表与该顶点链接的顶点。 如果图不复杂的情况下，同样可以使用对象数组结合的形式，但是如果图复杂到一定程度，对象表示的图效率底下，推荐使用数组。 无向图无向图为4中类型中最简单形式的图，该种图只是通过边链接相邻的顶点即可，根据邻接链表创建的图的原理，构建基本的图的类，基本代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 构建图类class Graph &#123; constructor(v) &#123; this.vertices = v this.vertexList = [] this.edges = 0 this.adj = [] for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; this.adj[i] = [] &#125; &#125; // 添加顶点 addEdge(v, w) &#123; this.adj[v].push(w) this.adj[w].push(v) this.edges++ &#125; // 用于显示符号名字而非数字的新函数 showGraph() &#123; for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; console.log(i + \" -&gt; \") for (let j = 0, k = this.vertices; j &lt; k; j++) &#123; if (this.adj[i][j] != undefined) &#123; console.log(this.adj[i][j] + ' ') &#125; &#125; &#125; &#125;&#125;// 测试let g = new Graph(5); g.addEdge(0,1); g.addEdge(0,2); g.addEdge(1,3); g.addEdge(2,4); g.showGraph();// 输出结果如下：// 0 -&gt; 1 2// 1 -&gt; 0 3// 2 -&gt; 0 4// 3 -&gt; 1// 4 -&gt; 2 深度优先搜索深度优先搜索包括从一条路径的起始顶点开始追溯，直到到达最后一个顶点，然后回溯， 继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止。以下为图解。 因此，我们需要定义一个数组记录图中顶点是否被访问过，然后递归的执行遍历顶点的方法即可。改造后的基本代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 构建图类class Graph &#123; constructor(v) &#123; this.vertices = v this.vertexList = [] this.edges = 0 this.adj = [] for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; this.adj[i] = [] &#125; // 记录已经访问过的顶点，初始化全部未访问 this.marked = [] for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; this.marked[i] = false; &#125; &#125; // 添加顶点 addEdge(v, w) &#123; this.adj[v].push(w) this.adj[w].push(v) this.edges++ &#125; // 用于显示符号名字而非数字的新函数 showGraph() &#123; for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; console.log(i + \" -&gt; \") for (let j = 0, k = this.vertices; j &lt; k; j++) &#123; if (this.adj[i][j] != undefined) &#123; console.log(this.adj[i][j] + ' ') &#125; &#125; &#125; &#125; dfs(v) &#123; this.marked[v] = true if (this.adj[v] != undefined) &#123; console.log(\"访问点: \" + v) &#125; for (let w of this.adj[v]) &#123; if (!this.marked[w]) &#123; this.dfs(w) &#125; &#125; &#125;&#125;let g = new Graph(7);g.addEdge(0, 1);g.addEdge(0, 2);g.addEdge(1, 3);g.addEdge(2, 4);g.addEdge(0, 5);g.addEdge(3, 6);g.dfs(0) 测试结果如下： 广度优先搜索广度优先搜索通过利用队列的先进先出特性，将即将访问的点挨个进入队列中，然后再挨个取出，并且再将取出的顶点对应的链接点再次进行入队操作，如此反复即可，其保证访问尽可能靠近它的顶点。也就是逐层进行访问。基本图解如下： 基本原理如下： (1) 查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中; (2) 从图中取出下一个顶点 v，添加到已访问的顶点列表; (3) 将所有与 v 相邻的未访问顶点添加到队列。 实现基本代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 构建图类class Graph &#123; constructor(v) &#123; this.vertices = v this.vertexList = [] this.edges = 0 this.adj = [] for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; this.adj[i] = [] &#125; // 记录已经访问过的顶点，初始化全部未访问 this.marked = [] for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; this.marked[i] = false; &#125; &#125; // 添加顶点 addEdge(v, w) &#123; this.adj[v].push(w) this.adj[w].push(v) this.edges++ &#125; // 用于显示符号名字而非数字的新函数 showGraph() &#123; for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; console.log(i + \" -&gt; \") for (let j = 0, k = this.vertices; j &lt; k; j++) &#123; if (this.adj[i][j] != undefined) &#123; console.log(this.adj[i][j] + ' ') &#125; &#125; &#125; &#125; // 广度优先算法 bfs(s) &#123; let queue = [] this.marked[s] = true queue.unshift(s) while (queue.length &gt; 0) &#123; let v = queue.shift() if (v !== undefined) &#123; console.log(\"访问点: \" + v) &#125; // 获取与该定点相邻的顶点 let adjacentDot = this.adj[v] for (let w of adjacentDot) &#123; if (!this.marked[w]) &#123; this.marked[w] = true queue.push(w) &#125; &#125; &#125; &#125;&#125;let g = new Graph(7);g.addEdge(0, 1);g.addEdge(0, 2);g.addEdge(1, 3);g.addEdge(2, 4);g.addEdge(0, 5);g.addEdge(3, 6);g.bfs(0) 测试结果如下： 查找最短路径问题图最常见的操作之一就是寻找从一个顶点到另一个顶点的最短路径。因此需要在原有的图类上再定义一个数组，用来记录当前顶点与上一个相连访问过的顶点的集合，这样可以通过数组的下标以及对应的值来计算出最优路径。 使用深度优先搜索改造后的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 构建图类class Graph &#123; constructor(v) &#123; this.vertices = v this.vertexList = [] this.edges = 0 this.adj = [] for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; this.adj[i] = [] // this.adj[i].push('') &#125; // 记录已经访问过的顶点，初始化全部未访问 this.marked = [] for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; this.marked[i] = false; &#125; // 数组序号代表访问的顶点，值代表与当前点链接的点且是上一个访问过的点 this.edgeTo = [] &#125; // 添加顶点 addEdge(v, w) &#123; this.adj[v].push(w) this.adj[w].push(v) this.edges++ &#125; // 用于显示符号名字而非数字的新函数 showGraph() &#123; for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; console.log(i + \" -&gt; \") for (let j = 0, k = this.vertices; j &lt; k; j++) &#123; if (this.adj[i][j] != undefined) &#123; console.log(this.adj[i][j] + ' ') &#125; &#125; &#125; &#125; dfs(v) &#123; this.marked[v] = true if (this.adj[v] != undefined) &#123; console.log(\"访问点: \" + v) &#125; for (let w of this.adj[v]) &#123; if (!this.marked[w]) &#123; this.edgeToDfs[w] = v this.dfs(w) &#125; &#125; &#125; pathToDfs(s, v) &#123; if (!this.hashPathTo(v)) &#123; return undefined; &#125; let path = []; // 在相邻边数组中寻找 while(v !== s) &#123; path.push(v) v = this.edgeToDfs[v] &#125; path.push(s); //将起始节点加进最短路径数组 return path; &#125; hashPathTo(v) &#123; return this.marked[v] &#125;&#125;// 测试代码let g = new Graph(7);g.addEdge(0, 1);g.addEdge(0, 2);g.addEdge(1, 3);g.addEdge(2, 4);g.addEdge(0, 5);g.addEdge(3, 6);g.dfs(0)// 测试最短路径var paths = g.pathToDfs(0, 4);while (paths.length &gt; 0) &#123; if (paths.length &gt; 1) &#123; console.log(paths.pop() + '-'); &#125; else &#123; console.log(paths.pop()); &#125;&#125;// 测试结果 0-2-4 基本图解如下： 看似似乎没什么问题，但是如果创建带环的图，测试结果就不是正确的结果，修改测试代码：12345678910111213141516171819let g = new Graph(7);g.addEdge(0, 1);g.addEdge(0, 2);g.addEdge(1, 3);g.addEdge(2, 4);g.addEdge(0, 5);g.addEdge(3, 6);g.addEdge(6, 4);g.dfs(0)// 测试最短路径var paths = g.pathToDfs(0, 4);while (paths.length &gt; 0) &#123; if (paths.length &gt; 1) &#123; console.log(paths.pop() + '-'); &#125; else &#123; console.log(paths.pop()); &#125;&#125;// 0-1-3-6-4 测试结果是0-1-3-6-4而并非是0-2-4，这是由于深度优先搜索的原理导致的，它的原理是从一个顶点一直访问到最末节点，然后再回溯，从相邻的顶点继续向下访问。所以在初次遍历的时候，记录的完整访问路径是：0-1-3-6-4-2-5，因此深度优先搜索不能完全解决。 使用广度优先搜索改造后的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 构建图类class Graph &#123; constructor(v) &#123; this.vertices = v this.vertexList = [] this.edges = 0 this.adj = [] for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; this.adj[i] = [] // this.adj[i].push('') &#125; // 记录已经访问过的顶点，初始化全部未访问 this.marked = [] for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; this.marked[i] = false; &#125; // 数组序号代表访问的顶点，值代表与当前点链接的点且是上一个访问过的点 this.edgeTo = [] &#125; // 添加顶点 addEdge(v, w) &#123; this.adj[v].push(w) this.adj[w].push(v) this.edges++ &#125; // 用于显示符号名字而非数字的新函数 showGraph() &#123; for (let i = 0, l = this.vertices; i &lt; l; i++) &#123; console.log(i + \" -&gt; \") for (let j = 0, k = this.vertices; j &lt; k; j++) &#123; if (this.adj[i][j] != undefined) &#123; console.log(this.adj[i][j] + ' ') &#125; &#125; &#125; &#125; // 广度优先算法 bfs(s) &#123; let queue = [] this.marked[s] = true queue.unshift(s) while (queue.length &gt; 0) &#123; let v = queue.shift() if (v !== undefined) &#123; console.log(\"访问点: \" + v) &#125; // 获取与该定点相邻的顶点 let adjacentDot = this.adj[v] for (let w of adjacentDot) &#123; if (!this.marked[w]) &#123; this.edgeTo[w] = v this.marked[w] = true queue.push(w) &#125; &#125; &#125; &#125; // 存储与指定顶点有共同边的所有顶点 pathTo(s, v) &#123; if (!this.hashPathTo(v)) &#123; return undefined; &#125; let path = []; // 在相邻边数组中寻找 while (v !== s) &#123; path.push(v) v = this.edgeTo[v] &#125; path.push(s); //将起始节点加进最短路径数组 return path; &#125; hashPathTo(v) &#123; return this.marked[v] &#125;&#125;// 测试代码let g = new Graph(7);g.addEdge(0, 1);g.addEdge(0, 2);g.addEdge(1, 3);g.addEdge(2, 4);g.addEdge(0, 5);g.addEdge(3, 6);g.bfs(0)// 测试最短路径var paths = g.pathTo(0, 4);while (paths.length &gt; 0) &#123; if (paths.length &gt; 1) &#123; console.log(paths.pop() + '-'); &#125; else &#123; console.log(paths.pop()); &#125;&#125;// 结果 0-2-4 基本图解如下： 我们可以按照测试深度优先搜索的形式更改测试代码，看看结果是否依然正确：12345678910111213141516171819let g = new Graph(7);g.addEdge(0, 1);g.addEdge(0, 2);g.addEdge(1, 3);g.addEdge(2, 4);g.addEdge(0, 5);g.addEdge(3, 6);g.addEdge(6, 4);g.bfs(0)// 测试最短路径var paths = g.pathToDfs(0, 4);while (paths.length &gt; 0) &#123; if (paths.length &gt; 1) &#123; console.log(paths.pop() + '-'); &#125; else &#123; console.log(paths.pop()); &#125;&#125;// 0-2-4 经过测试发现结果依然是0-2-4，说明对于图中是否有环并不会对最短路径搜索造成影响。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://www.iwangqi.com/tags/ECMAScript-6/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.iwangqi.com/tags/algorithm/"}]},{"title":"再剖析数据结构与算法javascript描述--二叉树（BST）","date":"2018-03-11T01:50:45.000Z","path":"2018-3-11-BST/","text":"二叉树和二叉查找树的定义二叉树每个节点的子节点不允许超过两个。通过将子节点的个数限定为2，可以写出高效的程序在树中插入、查找和删除数据 二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得 查找的效率很高。如下图就是一个二叉树： 遍历二叉树的类型中序中序遍历按照节点上的键值，从一个树中的最小的节点开始，直至最大的数为止排序，升序访问树中所有节点。基本节点访问路径如下图（3 16 22 23 37 45 99）： 先序先序遍历先访问根节点，然后以同样方式访问左子树和右子树。基本节点访问路径如下图（23 16 3 22 45 37 99）： 后序后序 遍历先访问叶子节点，从左子树到右子树，再到根节点。基本节点访问路径如下图（3 22 16 37 99 45 23）： 实现二叉查找树类根据以上基本内容，实现二叉查找树基本类，其中包含inOrder中序遍历方法，preOrder先序遍历方法，postOrder后序遍历方法。 定义Node类保存树节点信息，基本代码如下：1234567891011class Node &#123; constructor(data, left, right) &#123; this.data = data this.left = left this.right = right &#125; show() &#123; return this.data &#125;&#125; 定义BST树类，基本代码如下：123456789101112131415161718192021222324252627282930313233class BST &#123; constructor() &#123; this.root = null &#125; // 中序遍历方法 inOrder(node) &#123; if (!(node === null)) &#123; this.inOrder(node.left) console.log(node.show() + '') this.inOrder(node.right) &#125; &#125; // 先序遍历方法 // 先序遍历先访问根节点，然后以同样方式访问左子树和右子树 preOrder(node) &#123; if (!(node === null)) &#123; console.log(node.show() + '') this.preOrder(node.left) this.preOrder(node.right) &#125; &#125; // 后序遍历方法 postOrder(node) &#123; if (!(node === null)) &#123; this.postOrder(node.left) this.postOrder(node.right) console.log(node.show() + '') &#125; &#125;&#125; insert插入方法插入节点相对比较复杂，基本步骤如下： 1、对于空树而言，插入节点即为根节点。2、如果待插入节点保存的数据小于当前节点，则设新的当前节点为原节点的左节点;反之，执行第4步。3、如果当前节点的左节点为null，就将新的节点插入这个位置，退出循环;反之，继续执行下一次循环。4、设新的当前节点为原节点的右节点。5、如果当前节点的右节点为null，就将新的节点插入这个位置，退出循环;反之，继续执行下一次循环。 基本代码如下：1234567891011121314151617181920212223242526// 向树中插入新节点 insert(data) &#123; let n = new Node(data, null, null) if (this.root === null) &#123; this.root = n &#125; else &#123; let current = this.root let parent while (true) &#123; parent = current if (data &lt; current.data) &#123; current = current.left if (current === null) &#123; parent.left = n break &#125; &#125; else &#123; current = current.right if (current === null) &#123; parent.right = n break &#125; &#125; &#125; &#125; &#125; 查找最小值，最大值，查找定植在BST的基础上，再定义getMin,getMax,find方法，基本代码如下： 最小值，树的左节点肯定比右节点的元素值小，所以只要遍历左节点直至最后即可最大值，树的右节点肯定比左节点的元素值大，所以只要遍历右节点直至最后即可找定值，遍历树节点，如果发现相等及返回当前节点，如果发现小于当前节点，则在左子树上继续查找，否则在右子树上查找 1234567891011121314151617181920212223242526272829303132// 查找最小值 getMin() &#123; let current = this.root while (!(current.left === null)) &#123; current = current.left &#125; return current.data &#125; // 查找最大值 getMax() &#123; let current = this.root while (!(current.right === null)) &#123; current = current.right &#125; return current.data &#125; // 查找给定值 find(data) &#123; let current = this.root while (current !== null) &#123; if (current.data === data) &#123; return current &#125; else if (data &lt; current.data) &#123; current = current.left &#125; else &#123; current = current.right &#125; &#125; return null &#125; 删除节点删除节点基本步骤如下： 1、判断当前节点是否包含待删除的数据，如果包含，则删除该节点；2、如果不包含，则比较当前节点上的数据和待删除的数据。如果待删除数据小于当前节点上的数据，则移至当前节点的左子节点继续比较;3、如果删除数据大于当前节点上的数据，则移至当前节点的右子节点继续比较；4、如果待删除节点是叶子节点(没有子节点的节点)，那么只需要将从父节点指向它的链接 指向 null。5、如果待删除节点只包含一个子节点，那么原本指向它的节点指向它的子节点。6、如果待删除节点包含两个子节点，正确的做法有两种:要么查找待删除节点左子树上的最大值，要么查找其右子树上的最小值。 基本实现代码如下：1234567891011121314151617181920212223242526272829303132333435// 删除节点方法 remove(data) &#123; let root = this.removeNode(this.root, data) return root &#125; removeNode(node, data) &#123; if (node === null) &#123; return null &#125; if (data === node.data) &#123; // 没有子节点的节点 if (node.left === null &amp;&amp; node.right === null) &#123; return null &#125; // 没有左子节点的节点 if (node.left === null) &#123; return node.right &#125; // 没有右子节点的节点 if (node.right === null) &#123; return node.left &#125; let tempNode = this.getSmallest(node.right); node.data = tempNode.data; node.right = this.removeNode(node.right, tempNode.data); return node; &#125; else if (data &lt; node.data) &#123; node.left = this.removeNode(node.left, data); return node; &#125; else &#123; node.right = this.removeNode(node.right, data); return node; &#125; &#125; 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149class Node &#123; constructor(data, left, right) &#123; this.data = data this.left = left this.right = right &#125; show() &#123; return this.data &#125;&#125;class BST &#123; constructor() &#123; this.root = null &#125; // 向树中插入新节点 insert(data) &#123; let n = new Node(data, null, null) if (this.root === null) &#123; this.root = n &#125; else &#123; let current = this.root let parent while (true) &#123; parent = current if (data &lt; current.data) &#123; current = current.left if (current === null) &#123; parent.left = n break &#125; &#125; else &#123; current = current.right if (current === null) &#123; parent.right = n break &#125; &#125; &#125; &#125; &#125; // 中序遍历方法 inOrder(node) &#123; if (!(node === null)) &#123; this.inOrder(node.left) console.log(node.show() + '') this.inOrder(node.right) &#125; &#125; // 先序遍历方法 // 先序遍历先访问根节点，然后以同样方式访问左子树和右子树 preOrder(node) &#123; if (!(node === null)) &#123; console.log(node.show() + '') this.preOrder(node.left) this.preOrder(node.right) &#125; &#125; // 后序遍历方法 postOrder(node) &#123; if (!(node === null)) &#123; this.postOrder(node.left) this.postOrder(node.right) console.log(node.show() + '') &#125; &#125; // 查找最小值 getMin() &#123; let current = this.root while (!(current.left === null)) &#123; current = current.left &#125; return current.data &#125; // 查找最大值 getMax() &#123; let current = this.root while (!(current.right === null)) &#123; current = current.right &#125; return current.data &#125; // 查找给定值 find(data) &#123; let current = this.root while (current !== null) &#123; if (current.data === data) &#123; return current &#125; else if (data &lt; current.data) &#123; current = current.left &#125; else &#123; current = current.right &#125; &#125; return null &#125; // 删除节点方法 remove(data) &#123; let root = this.removeNode(this.root, data) return root &#125; removeNode(node, data) &#123; if (node === null) &#123; return null &#125; if (data === node.data) &#123; // 没有子节点的节点 if (node.left === null &amp;&amp; node.right === null) &#123; return null &#125; // 没有左子节点的节点 if (node.left === null) &#123; return node.right &#125; // 没有右子节点的节点 if (node.right === null) &#123; return node.left &#125; let tempNode = this.getSmallest(node.right); node.data = tempNode.data; node.right = this.removeNode(node.right, tempNode.data); return node; &#125; else if (data &lt; node.data) &#123; node.left = this.removeNode(node.left, data); return node; &#125; else &#123; node.right = this.removeNode(node.right, data); return node; &#125; &#125;&#125;var nums = new BST();nums.insert(23);nums.insert(45);nums.insert(16);nums.insert(37);nums.insert(3);nums.insert(99);nums.insert(22);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://www.iwangqi.com/tags/ECMAScript-6/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.iwangqi.com/tags/algorithm/"}]},{"title":"再剖析数据结构与算法javascript描述--散列（HashTable）","date":"2018-02-25T12:00:30.000Z","path":"HashTable-2018-2-25/","text":"散列的介绍散列使用的数据 结构叫做散列表。在散列表上插入、删除和取用数据都非常快，但是查找操作效率底下。 使用散列表存储数据时，通过一个散列函数将键映射为一个数 字，这个数字的范围是 0 到散列表的长度。当出现两个键映射同一个值的时候，这种现象称为 碰撞(collision)，可以通过定义一个固定的质数，开链法以及线性探测法来解决冲突问题。 散列类的简单实现 属性/方法 描述 table(属性) 定义散列表数据存放 simpleHash(属性) 创建散列表中数据对应的散列值 showDistro(属性) 显示散列表中的数据 put(方法) 将数据存入散列表 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class HashTable &#123; constructor() &#123; this.table = new Array(137) &#125; // 创建散列表中数据对应的散列值 simpleHash(data) &#123; let total = 0; for (let i = 0; i &lt; data.length; ++i) &#123; total += data.charCodeAt(i) &#125; console.log(\"Hash value: \" + data + \" -&gt; \" + total) return total % this.table.length &#125; // 显示散列表中的数据 showDistro() &#123; for (let i = 0; i &lt; this.table.length; ++i) &#123; if (this.table[i] != undefined) &#123; console.log(i + \": \" + this.table[i]) &#125; &#125; &#125; // 将数据存入散列表 put(data) &#123; let pos = this.simpleHash(data) this.table[pos] = data &#125;&#125;// 测试let someNames = [\"David\", \"Jennifer\", \"Donnie\", \"Raymond\", \"Cynthia\", \"Mike\", \"Clayton\", \"Danny\", \"Jonathan\"]let hTable = new HashTable();for (let i = 0; i &lt; someNames.length; ++i) &#123; hTable.put(someNames[i]);&#125;hTable.showDistro()// Hash value: David -&gt; 488// Hash value: Jennifer -&gt; 817// Hash value: Donnie -&gt; 605// Hash value: Raymond -&gt; 730// Hash value: Cynthia -&gt; 720// Hash value: Mike -&gt; 390// Hash value: Clayton -&gt; 730// Hash value: Danny -&gt; 506// Hash value: Jonathan -&gt; 819 通过以上代码测试，发现通过simpleHash生成的值可能会有相同的情况，这个时候就说明发生了碰撞，因此对该方法做一定的修改，通过定义一个固定的质数解决，基本代码如下：12345678910111213// 避免碰撞的创建散列的方法 betterHash(string) &#123; const H = 37; let total = 0; for (let i = 0; i &lt; string.length; ++i) &#123; total += H * total + string.charCodeAt(i); &#125; total = total % this.table.length; if (total &lt; 0) &#123; total += this.table.length - 1; &#125; return parseInt(total); &#125; 新增散列表取值方法片段代码如下：123get(key) &#123; return this.table[this.betterHash(key)];&#125; 碰撞处理当散列函数对于多个输入产生同样的输出时，就产生了碰撞。 开链法将原先的散列值存放在一个二维数组中，即使两个键散列后的值相同，依然被保存在同样的位置，只不过它们在第二个数组中的位 置不一样罢了。完整代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class HashTable &#123; constructor() &#123; this.table = new Array(137) &#125; // 创建二维数组 buildChains() &#123; for (let i = 0; i &lt; this.table.length; ++i) &#123; this.table[i] = new Array(); &#125; &#125; // 显示散列表中的数据 showDistro() &#123; for (let i = 0; i &lt; this.table.length; ++i) &#123; if (this.table[i][0] !== undefined) &#123; console.log(i + \": \" + this.table[i]); &#125; &#125; &#125; // 避免碰撞的创建散列的方法 betterHash(string) &#123; const H = 37; let total = 0; for (let i = 0; i &lt; string.length; ++i) &#123; total += H * total + string.charCodeAt(i); &#125; total = total % this.table.length; if (total &lt; 0) &#123; total += this.table.length - 1; &#125; return parseInt(total); &#125; // 将数据存入散列表 put(data) &#123; let index = 0 let pos = this.betterHash(data); if (this.table[pos][index] === undefined) &#123; this.table[pos][index] = data; &#125; else &#123; while (this.table[pos][index] !== undefined) &#123; ++index; &#125; this.table[pos][index] = data; &#125; &#125; get(key) &#123; let index = 0 let pos = this.betterHash(key); if (this.table[pos][index] === key) &#123; return &#123; elm: this.table[pos][index], key: pos &#125;; &#125; else &#123; while (this.table[pos][index] !== key) &#123; index += 1; &#125; return &#123; elm: this.table[pos][index], key: pos &#125;; &#125; return undefined; &#125;&#125;// 测试let hTable = new HashTable();hTable.buildChains();let someNames = [\"David\", \"Jennifer\", \"Donnie\", \"Raymond\", \"Cynthia\", \"Mike\", \"Clayton\", \"Danny\", \"Jonathan\"];for (let i = 0; i &lt; someNames.length; ++i) &#123; hTable.put(someNames[i]);&#125;hTable.showDistro();// 12: Jennifer// 22: Raymond// 55: Donnie// 58: Clayton// 80: David,Jonathan// 82: Mike// 103: Cynthia// 110: DannyhTable.get('David')// &#123;elm: \"David\", key: 80&#125; 线性探测法当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空。如果为空， 就将数据存入该位置;如果不为空，则继续检查下一个位置，直到找到一个空的位置为 止。该技术是基于这样一个事实:每个散列表都会有很多空的单元格，可以使用它们来存 储数据。 如果数组的大小是待存储数据个数的 1.5 倍， 那么使用开链法;如果数组的大小是待存储数据的两倍及两倍以上时，那么使用线性探 测法。 根据开链法只需要对put和get做一下更改即可，修改之后的完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class HashTable &#123; constructor() &#123; this.table = new Array(137) this.values = [] &#125; // 显示散列表中的数据 showDistro() &#123; for (let i = 0; i &lt; this.table.length; ++i) &#123; if (this.table[i] !== undefined) &#123; console.log(i + \": \" + this.table[i]); &#125; &#125; &#125; // 避免碰撞的创建散列的方法 betterHash(string) &#123; const H = 37; let total = 0; for (let i = 0; i &lt; string.length; ++i) &#123; total += H * total + string.charCodeAt(i); &#125; total = total % this.table.length; if (total &lt; 0) &#123; total += this.table.length - 1; &#125; return parseInt(total); &#125; // 将数据存入散列表 put(data) &#123; let pos = this.betterHash(data); if (this.table[pos] === undefined) &#123; this.table[pos] = data; this.values[pos] = data &#125; else &#123; while (this.table[pos] !== undefined) &#123; pos++ &#125; this.table[pos] = data; this.values[pos] = data &#125; &#125; get(key) &#123; let hash = -1; hash = this.betterHash(key); if (hash &gt; -1) &#123; for (let i = hash; this.table[hash] !== undefined; i++) &#123; if (this.table[hash] == key) &#123; return &#123; elm: this.values[hash], key: hash &#125;; &#125; &#125; &#125; return undefined; &#125;&#125;// 测试let hTable = new HashTable();let someNames = [\"David\", \"Jennifer\", \"Donnie\", \"Raymond\", \"Cynthia\", \"Mike\", \"Clayton\", \"Danny\", \"Jonathan\"];for (let i = 0; i &lt; someNames.length; ++i) &#123; hTable.put(someNames[i]);&#125;hTable.showDistro();// 12: Jennifer// 22: Raymond// 55: Donnie// 58: Clayton// 80: David,Jonathan// 82: Mike// 103: Cynthia// 110: DannyhTable.get('David')// &#123;elm: \"David\", key: 80&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://www.iwangqi.com/tags/ECMAScript-6/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.iwangqi.com/tags/algorithm/"}]},{"title":"再剖析数据结构与算法javascript描述--链表（LList）","date":"2018-02-24T12:00:30.000Z","path":"LList-2018-2-24/","text":"链表的定义链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一个节点的引用叫做链。 链表的实现都在链表最前面有一个特殊节 点，叫做头节点。遍历链表，就是跟着 链接，从链表的首元素一直走到尾元素(但这不包含链表的头节点，头节点常常用来作为 链表的接入点)。链表的尾元素指向一个 null 节点。 单向链表链表中的元素都会又一个前驱，通过前驱的指向来操作链表元素的添加和删除。一个完整的单项链表操作如下图： 定义单向链表类根据以上图解，一个链表基本有两个类组成，节点类和链表的操作类，可以大致总结该链表所包含的属性和方法，基本如下： 节点类（Node类） 属性/方法 描述 element(属性) 节点类的元素 next(属性) 节点类的前驱指向 操作类（Llist类） 属性/方法 描述 head(属性) 继承节点类并且创建头节点 find(方法) 查找节点方法 insert(方法) 插入节点方法 remove(方法) 删除节点的方法 findPrevious(方法) 找到待删除节点前面的节点方法 display(方法) 显示链表的方法 在添加节点的时候，只要判断当前节点的next属性指向你需要添加的节点，并且新添加的节点的next属性指向上一个节点原先指向的属性。核心代码如下：123456insert(newElement, item) &#123; let newNode = new Node(newElement) let current = this.find(item) newNode.next = current.next current.next = newNode&#125; 删除节点操作与添加节点类似，原理基本一样，核心代码如下：1234567891011121314151617// 找到待删除节点前面的节点 findPrevious(item) &#123; let currNode = this.head; while (!(currNode.next === null) &amp;&amp; (currNode.next.element !== item)) &#123; currNode = currNode.next; &#125; return currNode; &#125; // 删除节点的方法 remove(item) &#123; let prevNode = this.findPrevious(item); if (!(prevNode.next === null)) &#123; prevNode.next = prevNode.next.next; &#125; &#125; 此单向链表完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// node类，保存节点的数据以及下一个节点的连接class Node &#123; constructor(element) &#123; this.element = element this.next = null &#125;&#125;// LList类，插入，删除等方法class LList &#123; constructor() &#123; this.head = new Node(\"head\") &#125; // 查找节点方法 find(item) &#123; let currNode = this.head while (currNode.element !== item) &#123; currNode = currNode.next &#125; return currNode &#125; // 插入节点方法 insert(newElement, item) &#123; let newNode = new Node(newElement) let current = this.find(item) newNode.next = current.next current.next = newNode &#125; // 显示链表的方法 display() &#123; let currNode = this.head while (!(currNode.next === null)) &#123; console.log(currNode.next.element) currNode = currNode.next &#125; &#125; // 找到待删除节点前面的节点 findPrevious(item) &#123; let currNode = this.head; while (!(currNode.next === null) &amp;&amp; (currNode.next.element !== item)) &#123; currNode = currNode.next; &#125; return currNode; &#125; // 删除节点的方法 remove(item) &#123; let prevNode = this.findPrevious(item); if (!(prevNode.next === null)) &#123; prevNode.next = prevNode.next.next; &#125; &#125;&#125; 双向链表从链表的头节点遍历到尾节点很简单，但反过来，从后向前遍历则没那么简单。通过 给 Node对象增加一个属性，该属性存储指向前驱节点的链接，这样就容易多了。此时向链 表插入一个节点需要更多的工作，我们需要指出该节点正确的前驱和后继。但是在从链表 中删除节点时，效率提高了，不需要再查找待删除节点的前驱节点了。基本操作如下图： 定义双向链表类通过上图可以了解到，双向链表中，对于Node类增加了一个previous属性作为后继的定义，对于添加和删除节点还需要只想相应节点的后继指向，修改片段代码如下：12345678910111213141516171819202122232425262728class Node &#123; constructor(element) &#123; this.element = element this.next = null this.previous = null &#125;&#125;// 将一下代码放入之前的Llist类中// 插入节点方法insert(newElement, item) &#123; let newNode = new Node(newElement) let current = this.find(item) newNode.next = current.next newNode.previous = current current.next = newNode&#125;// 删除节点的方法 remove(item) &#123; let currNode = this.find(item) if (!(currNode.next === null)) &#123; currNode.next = currNode.next.next currNode.next.previous = currNode.previous currNode.next = null currNode.previous = null &#125; &#125; 扩展双向链表类找出了链表中的最后一个节点findLast方法反序显示双向链表中的元素dispReverse方法显示当前节点方法show方法向前移动n个节点advance方法向后移动n个节点back方法 扩展后的链表完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// node类，保存节点的数据以及下一个节点的连接class Node &#123; constructor(element) &#123; this.element = element this.next = null this.previous = null &#125;&#125;// LList类，插入，删除等方法class LList &#123; constructor() &#123; this.head = new Node(\"head\") this.currNode = null &#125; // 查找节点方法 find(item) &#123; let currNode = this.head while (currNode.element !== item) &#123; currNode = currNode.next &#125; return currNode &#125; // 插入节点方法 insert(newElement, item) &#123; let newNode = new Node(newElement) let current = this.find(item) newNode.next = current.next newNode.previous = current current.next = newNode &#125; // 显示链表的方法 display() &#123; let currNode = this.head while (!(currNode.next === null)) &#123; console.log(currNode.next.element) currNode = currNode.next &#125; &#125; // 找出了链表中的最后一个节点 findLast() &#123; let currNode = this.head; while (!(currNode.next == null)) &#123; currNode = currNode.next; &#125; return currNode; &#125; // 反序显示双向链表中的元素 dispReverse() &#123; let currNode = this.head; currNode = this.findLast(); while (!(currNode.previous == null)) &#123; print(currNode.element); currNode = currNode.previous; &#125; &#125; // 删除节点的方法 remove(item) &#123; let currNode = this.find(item) if (!(currNode.next === null)) &#123; currNode.next = currNode.next.next currNode.next.previous = currNode.previous currNode.next = null currNode.previous = null &#125; &#125; // 显示当前节点方法 show() &#123; return this.currNode &#125; // 向前移动n个节点 advance(n) &#123; let currNode = this.head let idx = 0 while (!(currNode.next === null) &amp;&amp; idx &lt; n) &#123; ++idx currNode = currNode.next &#125; this.currNode = currNode return currNode &#125; // 向后移动n个节点 back(n) &#123; let currNode = this.findLast() let idx = 0 while (!(currNode.next === null) &amp;&amp; idx &lt; n) &#123; ++idx currNode = currNode.next &#125; this.currNode = currNode return currNode &#125;&#125; 循环链表基本与单向链表和双向链表类似，唯一的区别是，在创建循环链表时，让其头节点的 next 属性指向它本身，片段代码如下：1head.next = head 基本图解如下： 因此只需根据单项链表做如下修改，基本代码如下：12345678910111213141516class LList &#123; constructor() &#123; this.head = new Node(\"head\") this.head.next = this.head &#125; // 显示链表的方法 display() &#123; let currNode = this.head while (!(currNode.next == null) &amp;&amp; !(currNode.next.element == \"head\")) &#123; console.log(currNode.next.element) currNode = currNode.next &#125; &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://www.iwangqi.com/tags/ECMAScript-6/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.iwangqi.com/tags/algorithm/"}]},{"title":"再剖析数据结构与算法javascript描述--队列（Queue）","date":"2018-02-23T12:00:30.000Z","path":"queue-2018-2-23/","text":"队列的定义队列是一种列表，不同的是队列只能在队尾插入元素，在队首删除元素。队列用于存储按 顺序排列的数据，先进先出。 队列的操作 入队：向队列中插入新元素，入队操作在队尾插入新元素 出队：删除队列中的元素，出队操作删除队头的元素 属性/方法 描述 dataStore(属性) 队列的元素个数 count(方法) 返回队列中元素的个数 enqueue(方法) 入队操作 front(方法) 读取队首元素 back(方法) 读取队尾元素 toString(方法) 显示队内所有元素 empty(方法) 判断队列是否为空 基本操作如下图： Queue类实现通过数组来实现队列操作，其中数组的push()方法和shift()方法很好的实现了入队和出队的操作，实现类的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Queue &#123; constructor() &#123; this.dataStore = [] &#125; // 队尾添加一个元素 enqueue(element) &#123; this.dataStore.push(element) &#125; // 删除队首的元素 dequeue() &#123; return this.dataStore.shift() &#125; // 读取队首和队尾的元素 front() &#123; return this.dataStore[0] &#125; back() &#123; return this.dataStore[this.dataStore.length - 1] &#125; // 显示队列内的所有元素 toString() &#123; let retStr = \"\"; for (let i = 0; i &lt; this.dataStore.length; ++i) &#123; retStr += this.dataStore[i] + \"\\n\" &#125; return retStr; &#125; // 判断队列是否为空 empty() &#123; if (this.dataStore.length == 0) &#123; return true &#125; else &#123; return false &#125; &#125; // 显示数量 count() &#123; return this.dataStore.length &#125;&#125; 实际使用方块舞的舞伴分配问题当男男女女来到舞池，他们按照自己的性别排成两队。当舞池中有地方空出来时，选两个队 列中的第一个人组成舞伴。他们身后的人各自向前移动一位，变成新的队首。当一对舞伴 迈入舞池时，主持人会大声喊出他们的名字。当一对舞伴走出舞池，且两排队伍中有任意 一队没人时，主持人也会把这个情况告诉大家。 定义一个类保存舞者信息，基本代码如下：1234567891011121314151617181920let dancerArray = [ 'F Allison', 'M Frank', 'M Mason', 'M Clayton', 'F Cheryl', 'M Raymond', 'F Jennifer', 'M Bryan', 'M David', 'M Danny', 'F Aurora']class Dancer &#123; constructor(name, sex) &#123; this.name = name this.sex = sex &#125;&#125; 定义区分舞者的方法和舞伴宣布结果方法，基本代码如下：1234567891011121314151617181920212223// 区分男女跳舞者function getDancers(m, f) &#123; for (let v of dancerArray) &#123; let dancer = v.split(' ') let sex = dancer[0] let name = `$&#123;dancer[1]&#125; $&#123;dance[2]&#125;` if (sex === 'F') &#123; f.enqueue(new Dancer(name, sex)) &#125; else &#123; m.enqueue(new Dancer(name, sex)) &#125; &#125;&#125;// 舞伴宣布结果function dance(m, f) &#123; let person while (!f.empty() &amp;&amp; !m.empty()) &#123; person = f.dequeue(); console.log(\"Female dancer is: \" + person.name); person = m.dequeue(); console.log(\" and the male dancer is: \" + person.name); &#125;&#125; 运行测试代码如下：12345// 测试程序let maleDancers = new Queue();let femaleDancers = new Queue();getDancers(maleDancers, femaleDancers);dance(maleDancers, femaleDancers); 优先队列问题从优先队列中删除元素时，需要考虑优先权的限制。比如医院急诊科(Emergency Department)的候诊室，就是一个采取优先队列的例子。假定code越小，优先级越高。 由于需要根据队列中元素的权重值的大小来判断是否出队，所以需要修改下dequeue()方法，z最终显示的toString()方法，基本修改代码如下：12345678910111213141516171819// 修改出队方法dequeue() &#123; let priority = this.dataStore[0].code for(let i = 0, l = this.dataStore.length; i &lt; l; i++) &#123; if(this.dataStore[i].code &lt;= priority) &#123; priority = i &#125; &#125; return this.dataStore.splice(priority,1)&#125;// 显示队列内的所有元素toString() &#123; let retStr = \"\"; for (let i = 0; i &lt; this.dataStore.length; ++i) &#123; retStr += this.dataStore[i].name + \" code: \" + this.dataStore[i].code + \"\\n\" &#125; return retStr&#125; 定义一个类来存储队列元素，基本代码如下：123456class Patient &#123; constructor(name, code) &#123; this.name = name this.code = code &#125;&#125; 最终完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Queue &#123; constructor() &#123; this.dataStore = [] &#125; // 队尾添加一个元素 enqueue(element) &#123; this.dataStore.push(element) &#125; // 修改出队方法 dequeue() &#123; let priority = this.dataStore[0].code for(let i = 0, l = this.dataStore.length; i &lt; l; i++) &#123; if(this.dataStore[i].code &lt;= priority) &#123; priority = i &#125; &#125; return this.dataStore.splice(priority,1) &#125; // 显示队列内的所有元素 toString() &#123; let retStr = \"\"; for (let i = 0; i &lt; this.dataStore.length; ++i) &#123; retStr += this.dataStore[i].name + \" code: \" + this.dataStore[i].code + \"\\n\" &#125; return retStr &#125; // 读取队首和队尾的元素 front() &#123; return this.dataStore[0] &#125; back() &#123; return this.dataStore[this.dataStore.length - 1] &#125; // 判断队列是否为空 empty() &#123; if (this.dataStore.length == 0) &#123; return true &#125; else &#123; return false &#125; &#125; // 显示数量 count() &#123; return this.dataStore.length &#125;&#125;class Patient &#123; constructor(name, code) &#123; this.name = name this.code = code &#125;&#125;let p = new Patient(\"Smith\",5)let ed = new Queue()ed.enqueue(p)p = new Patient(\"Jones\", 4)ed.enqueue(p)p = new Patient(\"Fehrenbach\", 6)ed.enqueue(p)ed.dequeue() // [&#123;\"name\":\"Jones\",\"code\":4&#125;] 在上个示例基础上增加三种状态方法，分别是患者进入候诊室，患者就诊，显示等待就诊患者名单，基本片段代码如下：1234567891011121314151617181920212223242526272829303132333435class Queue &#123; constructor() &#123; this.person = [] // 储存候诊室人信息 this.seePerson = null // 正在看就诊人信息 &#125; // 患者进入候诊室 enterWaitingRoom() &#123; let per = this.dequeue()[0] this.person.unshift(&#123; name: per.name, code: per.code &#125;) return this.person &#125; // 患者就诊 seeDoctor() &#123; if(this.person.length) &#123; this.seePerson = this.person.shift() return this.seePerson &#125; else &#123; return '候诊室正在候诊请先排队' &#125; &#125; // 显示等待就诊患者名单 waitingPerson() &#123; if(!this.person.length) return '请先进入候诊室' for(let v of this.person) &#123; if(this.seePerson &amp;&amp; (this.seePerson.name === v.name)) &#123; return this.seePerson.name &#125; else &#123; return this.person[0] &#125; &#125; &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://www.iwangqi.com/tags/ECMAScript-6/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.iwangqi.com/tags/algorithm/"}]},{"title":"再剖析数据结构与算法javascript描述--栈（Stack）","date":"2018-02-22T12:00:30.000Z","path":"stack-2018-2-22/","text":"栈的定义栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元 素，必须先拿掉上面的元素。栈是一种高 效的数据结构，因为数据只能在栈顶添加或删除，所以这样的操作很快，而且容易实现。 栈被称为一种后入先出(LIFO，last-in-first-out)的数据结构。 两种操作：将一个元素压入栈(push())和将一个元素弹出栈(pop()) 栈的基本操作 上溢：当栈满之后如果再将元素压入栈则会上溢下溢：当栈空之后如果再将元素弹出栈则会下溢 属性/方法 描述 dataStore(属性) 栈的元素个数 top(属性) 栈的计数器 length(属性) 返回栈中元素的个数 push(方法) 入栈方法 pop(方法) 出栈方法 peek(方法) 查看栈顶部元素方法 clear(方法) 清空栈方法 基本操作如下图： Stack类实现主要选用数组来作为存储栈元素的容器，通过数组的原生方法来实现栈的基本操作，基本代码如下：123456789101112131415161718192021222324252627282930313233class Stack &#123; constructor() &#123; this.dataStore = [] this.top = 0 &#125; // push push(elm) &#123; this.dataStore[this.top++] = elm &#125; // pop pop() &#123; if (this.top === 0 ) return '站内无元素' let popv = this.dataStore[--this.top] this.dataStore.pop() return popv &#125; // peek peek() &#123; return this.dataStore[this.top - 1] &#125; length() &#123; return this.top &#125; clear() &#123; this.top = 0 this.dataStore = [] &#125;&#125; 实际使用回文回文是指这样一种现象:一个单词、短语或数字，从前往后写和从后往前写都是一样的。 比如，单词“dad”、“racecar”就是回文;如果忽略空格和标点符号，下面这个句子也是回 文，“A man, a plan, a canal: Panama”;数字 1001 也是回文。 以racecar单词为例子，可以将字符串挨个压入定义好的栈中，然后再挨个从栈中取出元素，最终得到的值和原始值正好相反，如果相等，则是回文，反之则不是，基本图示如下： demo代码如下：1234567891011121314function isPalindrome(word) &#123; let rword = '' let s = new Stack() for(let i = 0, l = word.length; i &lt; l; i++) &#123; s.push(word[i]) &#125; while(s.length() &gt; 0) &#123; rword += s.pop() &#125; if(rword === word) return true return false&#125;isPalindrome('racecar') // trueisPalindrome('hello') // false 计算阶乘 避免使用递归的形式 123456789101112function fact(n) &#123; let s = new Stack(); while (n &gt; 1) &#123; s.push(n--); &#125; let product = 1; while (s.length() &gt; 0) &#123; product *= s.pop(); &#125; return product;&#125;fact(5) // 120 佩兹糖果盒问题要求：想象一下你有一盒佩兹糖果，里面塞满了红 色、黄色和白色的糖果，但是你不喜欢黄色的糖果。使用栈(有可能用到多个栈)写一 段程序，在不改变盒内其他糖果叠放顺序的基础上，将黄色糖果移出。 最终代码如下：1234567891011121314151617181920212223242526272829let candys = new Stack()candys.push('red')candys.push('yellow')candys.push('white')candys.push('yellow')candys.push('white')candys.push('red')candys.push('white')candys.push('red')candys.push('yellow')function getColor(elm, stack) &#123; let filterCandys = new Stack() let newCandys = new Stack() for(let v of stack.dataStore) &#123; if(v === elm) &#123; newCandys.push(v) &#125; else &#123; filterCandys.push(v) &#125; &#125; stack.clear() while(filterCandys.length() &gt; 0) &#123; stack.push(filterCandys.pop()) &#125; return newCandys&#125;getColor('yellow', candys)","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://www.iwangqi.com/tags/ECMAScript-6/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.iwangqi.com/tags/algorithm/"}]},{"title":"再剖析数据结构与算法javascript描述--列表（List）","date":"2018-02-21T12:00:30.000Z","path":"list-2018-2-21/","text":"列表的定义列表是一组有序的数据，每个列表中的数据项称为元素。在 JavaScript 中，列表中的元素 可以是任意数据类型。列表中可以保存多少元素并没有事先限定，实际使用时元素的数量 受到程序内存的限制。 当不需要在一个很 长的序列中查找元素，或者对其进行排序时，列表显得尤为有用。反之，如果数据结构非 常复杂，列表的作用就没有那么大了。 完整列表数据类型 属性/方法 描述 listSize(属性) 列表的元素个数 pos(属性) 列表的当前位置 length(属性) 返回列表中元素的个数 clear(方法) 清空列表中的所有元素 toString(方法) 返回列表的字符串形式 getElement(方法) 返回当前位置的元素 insert(方法) 在现有元素后插入新元素 append(方法) 在列表的末尾添加新元素 remove(方法) 从列表中删除元素 front(方法) 将列表的当前位置设移动到第一个元素 end(方法) 将列表的当前位置移动到最后一个元素 prev(方法) 将当前位置后移一位 next(方法) 将当前位置前移一位 currPos(方法) 返回列表的当前位置 moveTo(方法) 将当前位置移动到指定位置 List类实现根据以上定义的方法，实现自己的列表类，定义一个基本类List，基本代码如下：1234567class List &#123; constructor() &#123; this.listSize = 0 this.pos = 0 this.dataStore = [] &#125;&#125; 定义添加元素的append方法，该方法给列表的下一个位置增加一个新的元素，这 个位置刚好等于变量 listSize 的值，片段代码如下：1234// 给列表增加元素append(elm) &#123; this.dataStore[this.listSize++] = elm&#125; 定义查找元素位置的find方法，返回值为元素的位置，如果不存在则返回-1，片段代码如下：123456789// 从列表查找某一元素find(elm) &#123; for (let v of Object.keys(this.dataStore)) &#123; if (elm === this.dataStore[v]) &#123; return Number(v) &#125; &#125; return -1&#125; 定义删除remove方法，先根据上面定义的find方法找出元素的位置，然后通过splice来删除，片段代码如下：12345678910// 从列表中删除元素remove(elm) &#123; let foundAt = this.find(elm) if (foundAt &gt; -1) &#123; this.dataStore.splice(foundAt, 1) --this.listSize return true &#125; return false&#125; 定义列表计算多少个元素length方法以及显示列表中的元素toString方法，片段代码如下：123456789// 列表中有多少个元素length() &#123; return this.listSize&#125;// 显示列表中的元素toString() &#123; return this.dataStore&#125; 定义向列表插入一个元素的insert方法，主要也是先通过find方法找到元素位置，然后根据splice来插入元素，片段代码如下：12345678910// 向列表中插入一个元素insert(elm, after) &#123; var insertPos = this.find(after) if (insertPos &gt; -1) &#123; this.dataStore.splice(insertPos + 1, 0, elm) ++this.listSize return true &#125; return false&#125; 定义清空列表的clear方法，主要将初始化定义的变量全部清空，片段代码如下：12345// 清空列表中所有的元素clear() &#123; this.dataStore = [] this.listSize = this.pos = 0&#125; 判断给定值是否在列表中，通过定义contains方法来区分，片段代码如下：123456789// 判断给定值是否在列表中contains(elm) &#123; for (let v of Object.keys(this.dataStore)) &#123; if (elm === this.dataStore[v]) &#123; return true &#125; &#125; return false&#125; 定义一组方便用户遍历列表的方法，可以访问列表中任意位置的元素，片段代码如下：1234567891011121314151617181920212223242526272829303132333435363738// 将列表的当前位置设移动到第一个元素front() &#123; this.pos = 0&#125;// 将列表的当前位置移动到最后一个元素end() &#123; this.pos = this.listSize - 1&#125;// 将当前位置后移一位prev() &#123; if (this.pos &gt; 0) &#123; --this.pos &#125;&#125;// 将当前位置前移一位next() &#123; if (this.pos &lt; this.listSize - 1) &#123; ++this.pos &#125;&#125;// 返回列表的当前位置currPos() &#123; return this.pos&#125;// 将当前位置移动到指定位置moveTo(position) &#123; this.pos = position&#125;// 返回当前位置的元素getElement() &#123; return this.dataStore[this.pos]&#125; 以下是具体使用代码：12345678910111213141516// 示例如下let names = new List()names.append(\"Clayton\")names.append(\"Raymond\")names.append(\"Cynthia\")names.append(\"Jennifer\")names.append(\"Bryan\")names.append(\"Danny\")names.length() // 6names.toString() // [\"Clayton\", \"Raymond\", \"Cynthia\", \"Jennifer\", \"Bryan\", \"Danny\"]names.contains('wq') // falsenames.getElement() // Claytonnames.next()names.getElement() // Raymond 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class List &#123; constructor() &#123; this.listSize = 0 this.pos = 0 this.dataStore = [] &#125; // 给列表增加元素 append(elm) &#123; this.dataStore[this.listSize++] = elm &#125; // 从列表查找某一元素 find(elm) &#123; for (let v of Object.keys(this.dataStore)) &#123; if (elm === this.dataStore[v]) &#123; return Number(v) &#125; &#125; return -1 &#125; // 从列表中删除元素 remove(elm) &#123; let foundAt = this.find(elm) if (foundAt &gt; -1) &#123; this.dataStore.splice(foundAt, 1) --this.listSize return true &#125; return false &#125; // 列表中有多少个元素 length() &#123; return this.listSize &#125; // 显示列表中的元素 toString() &#123; return this.dataStore &#125; // 向列表中插入一个元素 insert(elm, after) &#123; var insertPos = this.find(after) if (insertPos &gt; -1) &#123; this.dataStore.splice(insertPos + 1, 0, elm) ++this.listSize return true &#125; return false &#125; // 清空列表中所有的元素 clear() &#123; this.dataStore = [] this.listSize = this.pos = 0 &#125; // 判断给定值是否在列表中 contains(elm) &#123; for (let v of Object.keys(this.dataStore)) &#123; if (elm === this.dataStore[v]) &#123; return true &#125; &#125; return false &#125; // 将列表的当前位置设移动到第一个元素 front() &#123; this.pos = 0 &#125; // 将列表的当前位置移动到最后一个元素 end() &#123; this.pos = this.listSize - 1 &#125; // 将当前位置后移一位 prev() &#123; if (this.pos &gt; 0) &#123; --this.pos &#125; &#125; // 将当前位置前移一位 next() &#123; if (this.pos &lt; this.listSize - 1) &#123; ++this.pos &#125; &#125; // 返回列表的当前位置 currPos() &#123; return this.pos &#125; // 将当前位置移动到指定位置 moveTo(position) &#123; this.pos = position &#125; // 返回当前位置的元素 getElement() &#123; return this.dataStore[this.pos] &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://www.iwangqi.com/tags/ECMAScript-6/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.iwangqi.com/tags/algorithm/"}]},{"title":"webpack优化入门详解","date":"2017-12-30T09:06:58.000Z","path":"webpack-2017-12-30/","text":"以下测试中，均在webpack版本3.5以上，如有不对的地方请指出，谢谢。 新特性优化Scope Hoisting-作用域提升,将模块都放到一个闭包函数中，通过减少闭包函数数量从而加快JS的执行速度。基本配置如下：123plugins: [ new webpack.optimize.ModuleConcatenationPlugin()] 配置后，自定义的两个模块函数被放在一个必包函数体中，打包结果如下： 配置前，自定义的两个模块函数分别在不同的必包函数体中，通过行数就能看出来，打包结果如下： 配置项优化externals配置优化设置externals配置项分离不需要打包的库文件，然后在模版文件中使用script引入即可，配置代码片段如下：123externals: &#123; 'jquery': 'jquery'&#125;, alias配置优化 可以选择对应的需要打包文件的大小规格 通过定义全局路径，减少webpack编译过程中的搜索硬盘时间 基本配置代码片段如下： 1234567resolve: &#123; extensions: ['.js', '.json'], alias: &#123; 'jquery': 'jquery/dist/jquery.slim.min.js', '@': resolve('src'), &#125;&#125;, 插件使用优化内链css减少请求webpack插件配置片段代码如下：12345plugins: [ new StyleExtHtmlWebpackPlugin(&#123; minify: true &#125;)] 最终打包可以将css文件直接以内链的形式插入网页中，进而可以减少网页请求。 preload插件使用webpack插件配置片段代码如下：1234567plugins: [ new PreloadWebpackPlugin(&#123; rel: 'preload', as: 'script', include: 'all' &#125;)] 最终打包生成的页面在head上会生成preload的link标签，代码片段如下：1234&lt;link rel=\"preload\" as=\"script\" href=\"app.8898b6c9e3b39f7a1c9d.js\"&gt;&lt;link rel=\"preload\" as=\"script\" href=\"common.6ecc97ec2b5dceebbd5e800322c2a3c0.css\"&gt;&lt;link rel=\"preload\" as=\"script\" href=\"vendor.dcd374ee43fd57d2365b.js\"&gt;&lt;link rel=\"preload\" as=\"script\" href=\"manifest.f3e58576762e216d8867.js\"&gt; 更多配置参考这里详细更多 缓存优化与分析css打包优化contenthash使用webpack打包css用的是extract-text-webpack-plugin插件，由于hash是webpack的module identifier计算的，不变内容的情况下每次打包也会产生不同的hash，因此选用chunkhash，它是根据文件内容计算的，因此比较符合实际使用，基本配置片段代码如下： 123456789101112131415161718192021222324252627282930313233module: &#123; rules: [&#123; test: /\\.(less|scss|css)$/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: [ &#123; loader:\"css-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;, &#123; loader:\"less-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;, &#123; loader:\"sass-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;] &#125;) &#125;]&#125;,plugins: [ new ExtractTextPlugin(&#123; filename: 'common.[chunkhash].css', allChunks: true &#125;),] 单纯改变css文件 12345678910// a.less.ac &#123; .bc &#123; font-size: 12px; &#125; .cc &#123; font-weight: 700; border: 1px solid #ccc; &#125;&#125; module文件中的a.js引入了a.less文件 12// module/a.jsrequire('../style/a.less'); 多次打包发现hash值未改变，不但依赖的js文件hash未改变，就连css文件的hash也未改变，最终使用webpack打包如下： 这显然不是想要的结果，希望改变css文件内容，js文件的hash不会改变，只有相应的css文件的hash值改变，因此再ExtractTextPlugin插件中应该使用contenthash，这也是官方特别注明的，直到再次看到文档才发现。 设置contenthash之后，再次打包发现只有css文件hash变了，并且改变js代码依然不影响css文件的打包，最终打包结果如下： js打包优化HashedModuleIdsPluginwebpack插件基本配置片段代码如下： 123456789101112131415161718192021222324252627282930313233343536373839entry: &#123; app: './src/app.js', vendor: ['lodash']&#125;,plugins: [ new CleanWebpackPlugin(['cdist']), new HtmlWebpackPlugin(&#123; template: './src/index.template.html', //html模板路径 filename: 'wq.html', //生成的html存放路径，相对于path favicon: './src/favicon.ico', //favicon路径，通过webpack引入同时可以生成hash值 inject: 'body', //js插入的位置，true/'head'/'body'/false // chunks: ['app', 'vendor'], //hash: true ,//为静态资源生成hash值 minify: &#123; //压缩HTML文件 removeComments: true, //移除HTML中的注释 collapseWhitespace: false //删除空白符与换行符 &#125; &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor' &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest' &#125;), new ExtractTextPlugin(&#123; filename: 'common.[contenthash].css', allChunks: true &#125;), new webpack.optimize.UglifyJsPlugin(&#123; beautify: false, comments: false, compress: &#123; warnings: false, drop_console: true, collapse_vars: true, reduce_vars: true, &#125; &#125;) ] 项目入口文件为app.js 12345678910111213import _ from 'lodash';import a from './module/a';// import b from './module/b';require(\"babel-polyfill\")require('./style/lib.css')function fn () &#123; // let aa = _.clone(&#123;key:4&#125;) // aa.key = 2; return aa&#125;fn() 第一次打包生成的文件如下： 修改入口文件app.js代码如下：12345678910111213import _ from 'lodash';import a from './module/a';import b from './module/b';require(\"babel-polyfill\")require('./style/lib.css')function fn () &#123; let aa = _.clone(&#123;key:4&#125;) aa.key = 2; return aa&#125;fn() 再次使用webpack打包，最后显示如下： 从打包结果来看，不但入口文件app.js哈希值变了，第三方库vendor.js的哈希值也变了，这当然不是我想要的，因为我更本没有改变第三方库文件。为了解决这个问题可以引入HashedModuleIdsPlugin这个配置项，这样就可以解决以上遇到的问题。 将插件配置做如下修改，代码片段如下： 123456789plugins: [ new webpack.HashedModuleIdsPlugin(), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor' &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest' &#125;), ] 在经过以上两个步骤，再次使用webpack打包，结果如下： webpack3中tree-shaking分析tree-shaking其实是webpack2中就有的功能特性，但是会因模块函数定义的形式，会有失效的概率，因此，我想用webpack3来测试下，看看是否官网有优化这部分特性。 tree-shaking必须有UglifyJsPlugin这个配置项才能生效，否则统一不生效。 常规定义方法module/a.js代码如下： 12345require('../style/a.less');function a() &#123; return 'aaaaaa'&#125;export &#123;a&#125;; module/b.js代码如下： 12345require('../style/b.scss');function b() &#123; return 'bbbbbbb'&#125;export &#123;b&#125;; 入口文件代码如下： 12345678910// app.jsimport _ from 'lodash';import &#123; a &#125; from './module/a';import &#123;b&#125; from './module/b';require(\"babel-polyfill\")require('./style/lib.css')function wq() &#123; return a()&#125;wq() 最后使用webpack打包，在压缩的文件中发现bbbbbbb被删除了，因此可以得出一个结论，webpack会动态判断引入的包是否被使用从而再次精简打包文件大小。 原型定义方法这次我改写a.js和b.js的形式，再其原型链上定义方法，基本代码如下： 123456789// module/a.jsrequire('../style/a.less');function a() &#123; return 'aaaaaa'&#125;a.prototype.fn = () =&gt; &#123; return 'aaaaaa'&#125;export &#123;a&#125;; 123456789// module/b.jsrequire('../style/b.scss');function b() &#123; return 'bbbbbbb'&#125;b.prototype.fn = () =&gt; &#123; return 'bbbbbbb'&#125;export &#123;b&#125;; 入口文件代码如下： 123456789101112// app.jsimport _ from 'lodash';import &#123; a &#125; from './module/a';import &#123;b&#125; from './module/b';require(\"babel-polyfill\")require('./style/lib.css')function wq() &#123; return a.prototype.fn()&#125;wq() 最后使用webpack打包，在压缩的文件中发现bbbbbbb没有被删除，只是调用函数的方法不一样，导致tree-shaking并没有生效。 class类编写模式我再次使用es6中类的概念改写a、b的定义方法，基本代码如下： 12345678// module/a.jsrequire('../style/a.less');class a &#123; fn() &#123; return 'aaaaaaa' &#125;&#125;export &#123;a&#125;; 12345678// module/b.jsrequire('../style/b.scss');class b &#123; fn() &#123; return 'bbbbbb' &#125;&#125;export &#123;b&#125;; 最后使用webpack打包，在压缩的文件中发现bbbbbbb依然没有被删除，tree-shaking并没有生效。 let定义形式最后我使用最简单的定义形式改写，基本代码如下： 12345// module/a.jsrequire('../style/a.less');let a = 'aaaaaaa'export &#123;a&#125;; 12345// module/b.jsrequire('../style/b.scss');let b = 'bbbbbbb'export &#123;b&#125;; 最后使用webpack打包，在压缩的文件中发现bbbbbbb被删除，tree-shaking生效。 分析原型定义写法不会被删除很好理解，就是这些原型方法，因为原型方法可能会将要被调用，是一个未知情况，如果直接删除，那么一旦其他模块会动态调用原型方法，那就会造成代码报错，这样是不合理的。 class类的写法似乎不会产生副作用，类中的函数似乎也不是将来可能被调用，再来看最后webpack打包生成的代码，片段如下：12345678910111213141516/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(\"Zrlr\");/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);var b = function () &#123; function b() &#123; __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, b); &#125; __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(b, [&#123; key: 'fn', value: function fn() &#123; return 'bbbbbb'; &#125; &#125;]); return b;&#125;(); 首先b是一个自运行函数，并且最终还调用了webpack_require(“Zrlr”)这个模块，因此就类似prototype，会产生一点有副作用的函数，所以不能直接删除。 最后贴上完整的webpack配置项，这里并没有加上vue/react的相关配置，如需要可以自己安装相应插件，通过配合babel-loader进行编译打包，.babelrc配置入门详解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110const webpack = require('webpack'); //to access built-in pluginsconst path = require('path');const CleanWebpackPlugin = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npmconst ExtractTextPlugin = require('extract-text-webpack-plugin')const StyleExtHtmlWebpackPlugin = require('style-ext-html-webpack-plugin')const PreloadWebpackPlugin = require('preload-webpack-plugin')const config = &#123; entry: &#123; app: './src/app.js', vendor: ['lodash'] &#125;, output: &#123; path: path.resolve(__dirname, 'cdist'), filename: '[name].[chunkhash].js' &#125;, externals: &#123; 'jquery': 'jquery' &#125;, // resolve: &#123; // extensions: ['.js', '.json'], // alias: &#123; // 'jquery': 'jquery/dist/jquery.slim.min.js', // '@': resolve('src'), // &#125; // &#125;, module: &#123; rules: [&#123; test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.(less|scss|css)$/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: [ &#123; loader:\"css-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;, &#123; loader:\"less-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;, &#123; loader:\"sass-loader\", options:&#123; minimize: true //css压缩 &#125; &#125;] &#125;) &#125; ] &#125;, plugins: [ new webpack.optimize.ModuleConcatenationPlugin(), new CleanWebpackPlugin(['cdist']), new HtmlWebpackPlugin(&#123; template: './src/index.template.html', //html模板路径 filename: 'wq.html', //生成的html存放路径，相对于path favicon: './src/favicon.ico', //favicon路径，通过webpack引入同时可以生成hash值 inject: 'body', //js插入的位置，true/'head'/'body'/false // chunks: ['app', 'vendor'], //hash: true ,//为静态资源生成hash值 minify: &#123; //压缩HTML文件 removeComments: true, //移除HTML中的注释 collapseWhitespace: false //删除空白符与换行符 &#125; &#125;), new PreloadWebpackPlugin(&#123; rel: 'preload', as: 'script', include: 'all' &#125;), // 解决第三方打包文件hash值不变，最大化缓存 new webpack.HashedModuleIdsPlugin(), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor' &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest' &#125;), new ExtractTextPlugin(&#123; filename: 'common.[contenthash].css', allChunks: true &#125;), new webpack.optimize.UglifyJsPlugin(&#123; beautify: false, comments: false, compress: &#123; warnings: false, drop_console: true, collapse_vars: true, reduce_vars: true, &#125; &#125;), new StyleExtHtmlWebpackPlugin(&#123; minify: true &#125;) ]&#125;;module.exports = config;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"http://www.iwangqi.com/tags/webpack/"}]},{"title":"babel之配置文件.babelrc入门详解","date":"2017-12-23T09:06:58.000Z","path":"babelrc-2017-12-23/","text":"什么是Babel官方解释,是下一代JavaScript 语法的编译器。 既然是下一代Javascript的标准，浏览器因版本的不同对此会有兼容性问题，JavaScript的新的方法都不能使用，但是目前我们在项目开发一直提倡使用最新的语法糖编写，不但能减少代码量，而且async,await等新特性还解决了回调的编写机制，减轻了代码维护成本。 Babel就因此而生，它可以让你放心使用大部分的JavaScript的新的标准的方法，然后编译成兼容绝大多数的主流浏览器的代码。在项目工程脚手架中，一般会使用.babelrc文件，通过配置一些参数配合webpack进行打包压缩。也通过网上了解，写法各有不同，参数也大不相同，因此，我重新整理一份资料，详细的介绍下各个配置项的意义所在，以便清晰了解如果使用。 以下配置主要正对webpack3+写法。 Babel转译器在.babelrc配置文件中，主要是对预设（presets）和插件（plugins）进行配置，因此不同的转译器作用不同的配置项，大致可分为以下三项： 1.语法转义器。主要对javascript最新的语法糖进行编译，并不负责转译javascript新增的api和全局对象。例如let/const就可以被编译，而includes/Object.assign等并不能被编译。常用到的转译器包有，babel-preset-env、babel-preset-es2015、babel-preset-es2016、babel-preset-es2017、babel-preset-latest等。在实际开发中可以只选用babel-preset-env来代替余下的，但是还需要配上javascirpt的制作规范一起使用，同时也是官方推荐 123456&#123; \"presets\": [\"env\", &#123; \"modules\": false &#125;], \"stage-2\"&#125; 2.补丁转义器。主要负责转译javascript新增的api和全局对象，例如babel-plugin-transform-runtime这个插件能够编译Object.assign,同时也可以引入babel-polyfill进一步对includes这类用法保证在浏览器的兼容性。Object.assign 会被编译成以下代码： 1__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default() 3.jsx和flow插件，这类转译器用来转译JSX语法和移除类型声明的，使用Rect的时候你将用到它，转译器名称为babel-preset-react 创建预设(presets)主要通过npm安装babel-preset-xx插件来配合使用，例如通过 npm install babel-preset-stage-2 babel-preset-env –save-dev 安装，会有相应如下配置。 123456&#123; \"presets\": [ [\"env\", options], \"stage-2\" ]&#125; stage-2配置babel主要提供以下几种转义器包,括号里面是对应配置文件的配置项 babel-preset-stage-0(stage-0) babel-preset-stage-1(stage-1) babel-preset-stage-2(stage-2) babel-preset-stage-3(stage-3)不同阶段的转译器之间是包含的关系，preset-stage-0转译器除了包含了preset-stage-1的所有功能还增加了transform-do-expressions插件和transform-function-bind插件，同样preset-stage-1转译器除了包含preset-stage-2的全部功能外还增加了一些额外的功能。 options配置介绍官方推荐使用babel-preset-env来替代一些插件包的安装（es2015-arrow-functions，es2015-block-scoped-functions等等），并且有如下几种配置信息,介绍几个常用的，更多配置可以参考官网https://babeljs.io/docs/plugins/preset-env/12345678&#123; \"targets\": &#123; \"chrome\": 52, \"browsers\": [\"last 2 versions\", \"safari 7\"], \"node\":\"6.10\" &#125; \"modules\": false&#125; targets可以制定兼容浏览器版本，如果设置了browsers，那么就会覆盖targets原本对浏览器的限制配置。 targets.node正对node版本进行编译 modules通常都会设置为false，因为默认都是支持CommonJS规范，同时还有其他配置参数：”amd” | “umd” | “systemjs” | “commonjs”，systemjs我还不知道规范写法是什么，amd和umd以及commonjs相对比较熟悉，下面简要列举下书写规范。 amd代码规范，在ng1中会用到比较多，主要用于依赖注入：1234567define(['jquery'], function ($) &#123; // 方法 function myFunc()&#123;&#125;; // 暴露公共方法 return myFunc;&#125;) commonjs规范，也是node环境中尊崇的一种规范：123456var $ = require('jquery');// 方法function myFunc()&#123;&#125;; // 暴露公共方法（一个）module.exports = myFunc; umd规范，兼容amd以及commonjs规范，目前在第三方插件编写使用比较多：123456789101112131415161718(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['jquery'], factory); &#125; else if (typeof exports === 'object') &#123; // Node, CommonJS之类的 module.exports = factory(require('jquery')); &#125; else &#123; // 浏览器全局变量(root 即 window) root.returnExports = factory(root.jQuery); &#125;&#125;(this, function ($) &#123; // 方法 function myFunc()&#123;&#125;; // 暴露公共方法 return myFunc;&#125;)); 插件（plugins）插件配置项同预设配置项一样，需要搭配babel相应的插件进行配置，可以选择配置插件来满足单个需求，例如早期我们会有如下配置：12345678&#123; \"plugins\": [ \"check-es2015-constants\", \"es2015-arrow-functions\", \"es2015-block-scoped-functions\", // ... ]&#125; 但是这些插件从维护到书写极为麻烦，后来官方统一推荐使用env，全部替代了这些单一的插件功能，可以简化配置如下，也就是我前面提到了babel-preset-env：12345&#123; \"presets\": [ \"es2015\" ]&#125; 这里主要介绍两款常用插件，分别是babel-plugin-transform-runtime，babel-plugin-syntax-dynamic-import。 基本配置代码如下：12345&#123; \"plugins\": [ \"syntax-dynamic-import\",[\"transform-runtime\"] ]&#125; transform-runtime为了解决这种全局对象或者全局对象方法编译不足的情况，才出现了transform-runtime这个插件，但是它只会对es6的语法进行转换，而不会对新api进行转换。如果需要转换新api，也可以通过使用babel-polyfill来规避兼容性问题。 对Object.assign进行编译，配置与未配置经过webpack编译后的代码片段如下： 1234567891011121314// 未设置代码片段：__webpack_require__(\"ez/6\");var aaa = 1;function fna() &#123; var dd = 33333; var cc = Object.assign(&#123; key: 2 &#125;); var xx = String.prototype.repeat.call('b', 3); if (\"foobar\".String.prototype.includes(\"foo\")) &#123; var vv = 1; &#125; return dd;&#125; 12345678910111213141516// 设置代码片段：/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);__webpack_require__(\"ez/6\");var aaa = 1;function fna() &#123; var dd = 33333; var cc = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(&#123; key: 2 &#125;); var xx = String.prototype.repeat.call('b', 3); if (\"foobar\".String.prototype.includes(\"foo\")) &#123; var vv = 1; &#125; return dd;&#125; 对class定义类会进行编译，配置与未配置经过webpack编译后的代码片段如下： 12345678910111213141516// 未设置代码片段：function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125; &#125;var Canvas = function Canvas(height, width) &#123; _classCallCheck(this, Canvas); this.height = height; this.width = width;&#125;;var Canvas2 = function Canvas2(height, width) &#123; _classCallCheck(this, Canvas2); this.height = height; this.width = width;&#125;; 12345678910111213141516// 设置代码片段：/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);var Canvas = function Canvas(height, width) &#123; __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Canvas); this.height = height; this.width = width;&#125;;var Canvas2 = function Canvas2(height, width) &#123; __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Canvas2); this.height = height; this.width = width;&#125;; 对Generator函数也有同上的编译效果，目前项目中使用该函数较小，一般使用promise替代，以及async await所以未对该函数做测试。 官方说对promise也会产生编译，但是实际测试结果却没有效果 经过webpack打包最终测试，引入transform-runtime该配置项后，打包入口js文件大小会略微增大，并不像官方说的能够缩小文件体积 未配置的最终打包效果： 配置后的最终打包效果： 虽然文件大小会有所增大，但是解决一些兼容性的问题，同时，从以上给出的测试代码例子来看，使用transform-runtime后，可以减少内部全局函数的定义，从结构上看尊崇了webpack的模块化思想，所以还是建议使用该插件。 syntax-dynamic-import这个插件主要解决动态引入模块的问题123456789function nDate() &#123; import('moment').then(function(moment) &#123; console.log(moment.default().format()); &#125;).catch(function(err) &#123; console.log('Failed to load moment', err); &#125;);&#125;nDate(); 如果.babelrc配置项中使用了”stage-2”，也可以不实用该插件，同样支持动态模块引入。 不然就会报以下错误： Module build failed: SyntaxError: ‘import’ and ‘export’ may only appear at the top level, or (import 和 export只能在最外层，也就是不能用在函数或者块中) Module build failed: SyntaxError: Unexpected token, expected { 其他配置项ignore主要作用就是可以指定不编译那些代码123&#123; \"ignore\":[\"./module/a.js\"]&#125; let,Object.assign,class定义都未编译，编译效果如下：12345678910111213141516171819202122232425262728293031__webpack_require__(\"ez/6\");const aaa = 1;function fna () &#123; let dd = 33333 let cc = Object.assign(&#123;key:2&#125;) let xx = String.prototype.repeat.call('b', 3) if (\"foobar\".String.prototype.includes(\"foo\")) &#123; let vv = 1 &#125; return dd&#125;function fna2 () &#123; return fna() + aaa + __WEBPACK_IMPORTED_MODULE_0__b__[\"a\" /* default */]&#125;class Canvas &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125;class Canvas2 &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125; minified主要设置编译后是否是压缩，boolean类型，如果使用babel-cli进行打包编译文件这个配置项能够起到作用，但是目前大部分还是会依赖第三方打包工具，例如webpack，所以这个配置参数一般不用设置，webpack插件中的UglifyJsPlugin做了压缩的工作。 comments在生成的文件中，不产生注释，boolean类型，webpack插件中的UglifyJsPlugin也同样集成了这个功能。 env基本配置如下： 12345678910&#123; \"env\": &#123; // test 是提前设置的环境变量，如果没有设置BABEL_ENV则使用NODE_ENV，如果都没有设置默认就是development \"test\": &#123; \"presets\": [\"env\", \"stage-2\"], // instanbul是一个用来测试转码后代码的工具 \"plugins\": [\"istanbul\"] &#125; &#125;&#125; 再谈兼容性问题Babel默认只转换新的JavaScript语法，而不转换新的API，比如Iterator、Generator、Set、Maps、Promise等等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码，具体的可以参考babel-plugin-transform-runtime模块的definitions.js文件。 这里主要涉及到babel编译后依然会存在浏览器兼容性问题，一般会使用transform-runtime和babel-polyfill配合使用，对于后者只需要在项目入口文件require引入即可。 当然在使用类似Object.assign函数功能时，可以使用lodash库来替代，promise可以使用Q.js替代等等方案，这样依赖可以不需要引入以上插件，具体可以根据项目具体安排 总结.babelrc配置文件主要还是以presets和plugins组成，通过和webpack配合进行使用，分享下我们在项目中常用的配置。以上都是通过学习总结出来的，有什么不对的地方希望指出。 vue项目开发使用的配置如下：12345678910111213141516171819&#123; \"presets\": [ [\"env\", &#123; \"modules\": false &#125;], \"stage-2\" ], // 下面指的是在生成的文件中，不产生注释 \"comments\": false, \"plugins\": [\"transform-runtime\",\"syntax-dynamic-import\"], \"env\": &#123; // test 是提前设置的环境变量，如果没有设置BABEL_ENV则使用NODE_ENV，如果都没有设置默认就是development \"test\": &#123; \"presets\": [\"env\", \"stage-2\"], // instanbul是一个用来测试转码后代码的工具 \"plugins\": [\"istanbul\"] &#125; &#125;&#125; react项目开发使用的配置如下：123456789101112131415&#123; \"presets\": [ [\"env\", &#123; \"modules\": false &#125;], \"stage-2\", \"react\" ], \"plugins\": [\"transform-runtime\"], \"comments\": false, \"env\": &#123; \"test\": &#123; \"presets\": [\"env\", \"stage-2\"], \"plugins\": [ \"istanbul\" ] &#125; &#125;&#125; 2018-11-18 关于stage-x介绍的补充stage-3包括以下插件： transform-async-to-generator 支持async/await transform-exponentiation-operator 支持幂运算符语法糖 stage-2包括stage-3的所有插件，额外还包括以下插件： syntax-trailing-function-commas 支持尾逗号函数，额…很鸡肋 transform-object-reset-spread 支持对象的解构赋值 stage-1包括stage-2所有插件，额外还包括以下插件： transform-class-constructor-call 支持class的构造函数 transform-class-properties 支持class的static属性 transform-decorators 支持es7的装饰者模式即@，这其实是很有用的特性，对于HOC来说这是一个不错的语法糖 transform-export-extensions 支持export方法 stage-0包括stage-1所有插件，额外还包括以下插件： transform-do-expressions 支持在jsx中书写if/else transform-function-bind 支持::操作符来切换上下文，类似于es5的bind 2018-12-10 关于babel-plugin-syntax-dynamic-import 使用补充感谢@丹哥一号同学提出问题，经过测试当使用webpack版本4.20.2及以上的时候(4以上的其他版本暂时没测)，不需要这个插件，同时也不需要stage-2的配置，同样可以支持import以及动态import，基本用法根参考以下示例：123456789function nDate() &#123; import('moment').then(function(moment) &#123; console.log(moment.default().format()); &#125;).catch(function(err) &#123; console.log('Failed to load moment', err); &#125;);&#125;nDate();","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"http://www.iwangqi.com/tags/webpack/"},{"name":"babel","slug":"babel","permalink":"http://www.iwangqi.com/tags/babel/"}]},{"title":"Three.js系列教程--动画和相机","date":"2017-07-19T13:09:11.000Z","path":"webgl-2017-07-19/","text":"动画基础 setTimeout / setInterval 存在弊端 window.requestAnimationFrame 性能更高 通过递归循环实现 相机分类 FirstPersonControls 第一人称控件,类似于使用鼠标使相机移动 FlyControls 飞行控件,通过键盘或者鼠标使相机移动 RollControls 翻滚控件,飞行控件的简化版本，绕着z轴旋转 TrackballControls 轨迹球控件,最常用的控件，可以用鼠标轻松的平移和缩放场景 OrbitControls 轨迹控件，用于特定场景，模拟轨道中的卫星等等 PathControls 路径控件，相机可以按照特定的路径进行移动，例如过山车等等 完整示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var scene = new THREE.Scene();var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, .1, 1000);var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0xEEEEEE,1.0));renderer.setSize(window.innerWidth,window.innerHeight);// 定义一个几何体var planeGeometry = new THREE.PlaneGeometry(60,20,1,1);var planeMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;);var plane = new THREE.Mesh(planeGeometry,planeMaterial);plane.position.set(15,0,0);plane.rotation.x = -0.5 * Math.PI;scene.add(plane);// 定义一个立方体 var cubeGeometry = new THREE.BoxGeometry(4,4,4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;); var cube = new THREE.Mesh(cubeGeometry,cubeMaterial); cube.position.set(-9,3,0); scene.add(cube); // 定义一个圆柱体 var cylinderGeometry = new THREE.CylinderGeometry(2,2,20); var cylinderMaterial = new THREE.MeshLambertMaterial(&#123;color:0x77ff78&#125;); var cylinder = new THREE.Mesh(cylinderGeometry,cylinderMaterial); cylinder.position.set(0,0,1); scene.add(cylinder); camera.position.set(-30,40,30); camera.lookAt(scene.position); // 定义环境光 var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight); // 定义聚光灯 var spotLight = new THREE.SpotLight(0xffffff); spotLight.position.set(-40,60,-10); scene.add(spotLight); document.body.appendChild(renderer.domElement); render(); function render()&#123; requestAnimationFrame(render); cube.rotation.x += 0.01; cube.rotation.y += 0.01; cube.rotation.z += 0.01; cylinder.rotation.x += 0.01; cylinder.rotation.y += 0.01; cylinder.rotation.z += 0.01; renderer.render(scene,camera) &#125; 最终效果如下图： 轨迹球控件属性 THREE.TrackballControls(camera)创建 rotateSpeed 转速 zoomSpeed 变焦速度 panSpeed 平移速度 完整示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var clock = new THREE.Clock();var scene = new THREE.Scene();var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, .1, 1000);var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0xEEEEEE,1.0));renderer.setSize(window.innerWidth,window.innerHeight);// 定义一个几何体var planeGeometry = new THREE.PlaneGeometry(60,20,1,1);var planeMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;);var plane = new THREE.Mesh(planeGeometry,planeMaterial);plane.position.set(15,0,0);plane.rotation.x = -0.5 * Math.PI;scene.add(plane);// 定义一个立方体function addCube(x,y,z)&#123; var cubeGeometry = new THREE.BoxGeometry(4,4,4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color:0xff00ff&#125;); var cube = new THREE.Mesh(cubeGeometry,cubeMaterial); cube.position.set(x,y,z); scene.add(cube);&#125;addCube(3,10,5);addCube(13,2,5);addCube(33,8,5);var trackballControls = new THREE.TrackballControls(camera);trackballControls.rotateSpeed = 1.0;trackballControls.zoomSpeed = 1.0;trackballControls.panSpeed = 1.0;trackballControls.staticMoving = true; camera.position.set(-30,40,30); camera.lookAt(scene.position); // 定义环境光 var ambientLight = new THREE.AmbientLight(0x0c0c0c); scene.add(ambientLight);// 定义聚光灯var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40,60,-10);scene.add(spotLight); document.body.appendChild(renderer.domElement); render(); function render()&#123; requestAnimationFrame(render); var delta = clock.getDelta(); trackballControls.update(delta); renderer.render(scene,camera) &#125; 最终效果如下图： 飞行控件属性 THREE.FlyControls(camera)创建 movementSpeed 移动速度 rollSpeed 转速 autoForward 自动前进 完整示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 var clock = new THREE.Clock();var scene = new THREE.Scene();var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, .1, 1000);var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0xEEEEEE,1.0));renderer.setSize(window.innerWidth,window.innerHeight);// 定义一个几何体var planeGeometry = new THREE.PlaneGeometry(60,20,1,1);var planeMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;);var plane = new THREE.Mesh(planeGeometry,planeMaterial);plane.position.set(15,0,0);plane.rotation.x = -0.5 * Math.PI;scene.add(plane);var cylinderMaterial = new THREE.MeshLambertMaterial(&#123;color:0x77ff78&#125;);// 定义一个立方体function addCyliner(x,y,z)&#123; // 定义一个圆柱体 var cylinderGeometry = new THREE.CylinderGeometry(2,2,20); var cylinder = new THREE.Mesh(cylinderGeometry,cylinderMaterial); cylinder.position.set(x,y,z); scene.add(cylinder);&#125;addCyliner(3,10,5);addCyliner(13,2,5);addCyliner(33,8,5);camera.position.set(-30,40,30);camera.lookAt(scene.position);// 定义环境光var ambientLight = new THREE.AmbientLight(0x0c0c0c);scene.add(ambientLight);// 定义聚光灯var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40,60,-10);scene.add(spotLight);document.body.appendChild(renderer.domElement);// 创建飞行控件var flyControls = new THREE.FlyControls(camera);flyControls.movementSpeed = 25;flyControls.domElement = document.body;flyControls.rollSpeed = Math.PI / 24;flyControls.autoForward = true;render();function render()&#123; requestAnimationFrame(render); var d = clock.getDelta(); flyControls.update(d); renderer.render(scene,camera)&#125; 最终效果如下图： 翻滚控件属性 THREE.RollControls(camera) 创建 movementSpeed 移动速度 lookSpeed 观看速度 核心示例代码如下： 12345678910111213// 创建翻滚控件var rollControls = new THREE.RollControls(camera);rollControls.movementSpeed = 25;rollControls.lookSpeed = 3;render();function render()&#123; requestAnimationFrame(render); var d = clock.getDelta(); rollControls.update(d); renderer.render(scene,camera)&#125; 最终效果如下图： 第一人称控件属性 THREE.FirstPersonControls(camera) 创建 movementSpeed 移动速度 noFly 非飞行模式 lon／lat定位相机位置 核心示例代码如下： 1234567891011121314151617181920// 创建控件var controls = new THREE.FirstPersonControls(camera);controls.movementSpeed = 25;controls.lookSpeed = 0.4;controls.noFly = true;controls.lookVertical = true;controls.constrainVertical = true;controls.verticalMax = 2.0;controls.verticalMin = 2.0;controls.lon = -150;controls.lat = 120;render();function render()&#123; requestAnimationFrame(render); var d = clock.getDelta(); controls.update(d); renderer.render(scene,camera)&#125; 最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/18","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"Three.js系列教程--粒子","date":"2017-07-18T13:09:11.000Z","path":"webgl-2017-07-18/","text":"粒子与粒子系统创建基本粒子 使用 THREE.Particle 构建粒子 使用 CanvasRenderer 渲染器 WebGLRenderer 需要 THREE.ParticleSystem 配合 常用属性 color 粒子的颜色 map 粒子的材质 size 粒子的大小 完整示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var shareObj = share(false);shareObj.camera.position.set(0, 0, 115);shareObj.camera.lookAt(shareObj.scene.position);createSprites();var cloud;// 创建粒子的方法function createSprites()&#123; var geom = new THREE.Geometry(); var material = new THREE.PointsMaterial(&#123; size:5, vertexColors:true, opacity:.5, transparent:true, sizeAttenuation:true, color:0xffffff &#125;); for(var x = -5;x&lt;5;x++)&#123; for(var y = -5;y&lt;5;y++)&#123; var particle = new THREE.Vector3(x*10,y*10,0); geom.vertices.push(particle); var color = new THREE.Color(0x00ffff); color.setHSL(color.getHSL().h,color.getHSL().s,Math.random() * color.getHSL().l); geom.colors.push(color); &#125; &#125; cloud = new THREE.Points(geom,material); shareObj.scene.add(cloud);&#125;var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; cloud.rotation.x += 0.01; cloud.rotation.y += 0.01; cloud.rotation.z += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 格式化粒子ParticleCanvasMaterial 的属性 color 粒子的颜色 program 该函数在渲染粒子时调用 opacity 粒子的透明度 transparent 粒子是否透明 WebGLRenderer 中使用画布 不可使用 ParticleCanvasMaterial 只能使用 ParticleBasicMaterial 用 map 属性加载纹理，纹理可以是canvas 使用纹理格式化粒子 ImageUtils.loadTexture 加载纹理 为 map 属性设置纹理 设置 blending 属性 采用canvas作为纹理的完整示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var shareObj = share(false);shareObj.camera.position.set(0, 0, 65);shareObj.camera.lookAt(shareObj.scene.position);// 创建纹理的方法function getTexture()&#123; var canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32; var ctx = canvas.getContext('2d'); ctx.translate(-81,-84); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(91,96); ctx.bezierCurveTo(88,96,87,99,87,101); ctx.bezierCurveTo(87,103,88,106,91,106); ctx.bezierCurveTo(94,106,95,103,95,101); ctx.bezierCurveTo(95,99,94,96,91,96); ctx.moveTo(103,96); ctx.bezierCurveTo(100,96,99,99,99,101); ctx.bezierCurveTo(99,103,100,106,103,106); ctx.bezierCurveTo(106,106,107,103,107,101) ctx.bezierCurveTo(107,99,106,96,103,96); ctx.fill(); var texture = new THREE.Texture(canvas); texture.needsUpdate = true; return texture;&#125;createSprites();var cloud;// 创建粒子的方法function createSprites()&#123; var geom = new THREE.Geometry(); var material = new THREE.PointsMaterial(&#123; size:5, vertexColors:true, opacity:.5, transparent:true, sizeAttenuation:true, color:0xffffff, map: getTexture() &#125;); for(var x = -5;x&lt;5;x++)&#123; for(var y = -5;y&lt;5;y++)&#123; var particle = new THREE.Vector3(x*10,y*10,0); geom.vertices.push(particle); var color = new THREE.Color(0x00ffff); color.setHSL(color.getHSL().h,color.getHSL().s,Math.random() * color.getHSL().l); geom.colors.push(color); &#125; &#125; cloud = new THREE.Points(geom,material); shareObj.scene.add(cloud);&#125;var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; cloud.rotation.x += 0.01; cloud.rotation.y += 0.01; cloud.rotation.z += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 采用png图片作为纹理的完整示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var shareObj = share(false);shareObj.camera.position.set(0, 0, 65);shareObj.camera.lookAt(shareObj.scene.position);createSprites();var cloud;// 创建粒子的方法function createSprites()&#123; if(cloud)&#123; shareObj.scene.remove(cloud); &#125; var texture = new THREE.ImageUtils.loadTexture('./yudi.png'); var geom = new THREE.Geometry(); var material = new THREE.PointsMaterial(&#123; size:10, transparent:true, opacity : 0.3, map:texture, // blending:THREE.AdditiveBlending, sizeAttenuation:true, color:0xffffff &#125;); var range = 600; for(var i = 0;i&lt;1000;i++)&#123; var particle = new THREE.Vector3( Math.random() * range - range/2, Math.random() * range - range/2, Math.random() * range - range/2 ); particle.velocityY = 0.1 + Math.random() /5; particle.velocityX = (Math.random()-0.5) / 3; geom.vertices.push(particle); &#125; cloud = new THREE.Points(geom,material); cloud.sortParticles = true; shareObj.scene.add(cloud);&#125;var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();var startTime = Date.now();function render() &#123; if(Date.now() - startTime &gt; 80)&#123; createSprites(); startTime = Date.now(); &#125; requestAnimationFrame(render); // 得到顶点 var vertices = cloud.geometry.vertices; vertices.forEach(function(v)&#123; v.y = v.y - v.velocityY; v.x = v.x - v.velocityX; if(v.y &lt;= 0 ) v.y = 60; if(v.x &lt;= -20 || v.x &gt;= 20) v.velocityX = v.velocityX -1; &#125;); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 精灵使用 THREE.Sprit 类的目的 创建基于屏幕坐标移动、缩放和定位的对象，可以用它来创建一个平视显示器，就好像三维场景上蒙上一层薄膜，简称 HUD。 创建类似粒子的，在三维空间移动的物体。 常用属性 color 粒子颜色 map 精灵所用的纹理 blending 渲染精灵时所用的融合模式 useScreenCoordinates 精灵的位置是否绝对定位 完整示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var shareObj = share(false);shareObj.camera.position.set(0, 0, 65);shareObj.camera.lookAt(shareObj.scene.position);createSprites();var group;// 创建粒子的方法function createSprites()&#123; group = new THREE.Object3D(); var range = 200; for(var i=0;i&lt;500;i++)&#123; group.add(createSprite(10,false,0.6,0xffffff,i%5,range)); &#125; shareObj.scene.add(group);&#125;function getTexture()&#123; return new THREE.ImageUtils.loadTexture('./yudi.png');&#125;function createSprite(size,transparent,opacity,color,spriteNumber,range)&#123; var spriteMaterial = new THREE.SpriteMaterial(&#123; opacity:opacity, color:color, transparent:transparent, map:getTexture() &#125;); spriteMaterial.map.offset = new THREE.Vector2(0.2 * spriteNumber, 0 ); spriteMaterial.map.repeat = new THREE.Vector2(1/5,1); spriteMaterial.depthTest = false; // spriteMaterial.blending = THREE.AdditiveBlending; // 创建精灵类 var sprite = new THREE.Sprite(spriteMaterial); // 对精灵进行裁剪 sprite.scale.set(size,size,size); sprite.position.set( Math.random() * range - range/2, Math.random() * range - range/2, Math.random() * range - range/2 ); sprite.velocityX = 5; return sprite;&#125;var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render()&#123; group.rotation.x += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene,shareObj.camera);&#125; 最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/17","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"Three.js系列教程--几何体","date":"2017-07-17T13:09:11.000Z","path":"webgl-2017-07-17/","text":"二位几何体二维矩形的属性 PlaneGeometry width 宽度 height 高度 wSegments 宽度段数 hSegments 高度段数 完整示例代码如下： 12345678910111213141516171819202122232425262728293031323334var shareObj = share();shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;var plane = createMesh(new THREE.PlaneGeometry(12, 15, 10, 15));shareObj.scene.add(plane);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; plane.rotation.x += 0.01; plane.rotation.z += 0.01; plane.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 二维圆的属性 CircleGeometry radius 圆半径 segments 所用面的数量 start 画圆起始位置 length 定义圆要画多大 完整示例代码如下： 12345678910111213141516171819202122232425262728293031323334var shareObj = share();shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;var circle = createMesh(new THREE.CircleGeometry(4,10,0.3 * Math.PI, 0.3 * Math.PI));shareObj.scene.add(circle);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; circle.rotation.x += 0.01; circle.rotation.z += 0.01; circle.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 球面几何体三维球体的属性 SphereGeometry radius 球体的半径 widthSegments 垂直方向上的分段数 heightSegments 水平方向上的分段数 phistart 定义 x 轴的绘制位置 thetaStart 定义 y 轴的绘制位置 theLength 定义绘制多大 完整示例代码如下： 1234567891011121314151617181920212223242526272829303132333435var shareObj = share();shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;// 定义一个球面体var sphere = createMesh(new THREE.SphereGeometry(10,50,50,0,2 * Math.PI));shareObj.scene.add(sphere);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; sphere.rotation.x += 0.01; sphere.rotation.z += 0.01; sphere.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 最终效果如下图： 圆柱体的属性 CylinderGeometry radiusTop 顶部尺寸 radiusBottom 底部尺寸 height 高度 segmentsX 指定 x 轴分段数 segmentsY 指定 y 轴分段数 segmentsZ 指定 z 轴分段数 openEnded 指定网格顶部和底部是否封闭 TorusGeometry 的属性 radius 圆环的尺寸 tube 半径 radialSegments 长度分段数 tubularSegments 宽度分段数 arc 控制绘制的长度 环面纽结的属性 TorusKnotGeometry radius 圆环的尺寸 tube 半径 radialSegments 长度分段数 tubularSegments 宽度分段数 detail 为环面增加额外细节 完整示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879var shareObj = share();shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;var mesh;var sphere = createMesh(new THREE.SphereGeometry(10,50,50,0, 2 * Math.PI));var cylinder = createMesh(new THREE.CylinderGeometry(20,20,20,20,100))var torus = createMesh(new THREE.TorusGeometry(10,2,20,10,Math.PI * 2));var knot = createMesh(new THREE.TorusKnotGeometry(10,1,64,8,2,9,1))mesh = sphere;$('#sphere').click(function()&#123; shareObj.scene.remove(mesh); mesh = sphere; shareObj.scene.add(mesh);&#125;);$('#cylinder').click(function()&#123; shareObj.scene.remove(mesh); mesh = cylinder; shareObj.scene.add(mesh);&#125;);$('#torus').click(function()&#123; shareObj.scene.remove(mesh); mesh = torus; shareObj.scene.add(mesh);&#125;);$('#knot').click(function()&#123; shareObj.scene.remove(mesh); mesh = knot; shareObj.scene.add(mesh);&#125;);shareObj.scene.add(mesh);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);$(\"#webgl-scene\").append(shareObj.renderer.domElement)render();function render() &#123; sphere.rotation.y += 0.01; cylinder.rotation.y += 0.01; torus.rotation.y += 0.01; knot.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 通过按钮切换不同的形状，最终效果如下图： 多面几何体多面体的属性 PolyhedronGeometry vertices 多面体的顶点 faces 多面体的面 radius 多面体的大小 detail 为多面体添加额外细节 完整示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var shareObj = share();shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;var vertices = [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];var faces = [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];// 定义一个球面体var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices,faces,10));shareObj.scene.add(polyhedron);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; polyhedron.rotation.x += 0.01; polyhedron.rotation.z += 0.01; polyhedron.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 通过按钮切换不同的形状，最终效果如下图： 其他多面体 IcosahedronGeometry 正二十面体 TetrahedronGeometry 正四面体 Octahedron 正八面体 完整示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var shareObj = share(false);shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);// 创建网格对象的方法function createMesh(geom) &#123; var meshMaterial = new THREE.MeshNormalMaterial(); var wireFrameMaterial = new THREE.MeshBasicMaterial(); wireFrameMaterial.wireframe = true; return THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMaterial]);&#125;var mesh = null;var size = 10;var z20 = createMesh(new THREE.IcosahedronGeometry(size));var z4 = createMesh(new THREE.TetrahedronGeometry(size));var z8 = createMesh(new THREE.OctahedronGeometry(size));mesh = z20;$(\"#z4\").click(function(e)&#123; shareObj.scene.remove(mesh); mesh = z4; shareObj.scene.add(mesh);&#125;)$(\"#z8\").click(function(e)&#123; shareObj.scene.remove(mesh); mesh = z8; shareObj.scene.add(mesh);&#125;)$(\"#z20\").click(function(e)&#123; shareObj.scene.remove(mesh); mesh = z20; shareObj.scene.add(mesh);&#125;)shareObj.scene.add(mesh);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;shareObj.scene.add(spotLight);$(\"#webgl-scene\").append(shareObj.renderer.domElement);render();function render() &#123; z4.rotation.y += 0.01; z8.rotation.y += 0.01; z20.rotation.y += 0.01; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125; 通过按钮切换不同的形状，最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/16","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"Three.js系列教程--材质","date":"2017-07-16T13:09:11.000Z","path":"webgl-2017-07-16/","text":"分类 基础材质，赋予几何体简单的颜色或者几何体的线框，也就是结构 深度材质，根据网格到相机的距离来决定如何绘制 法向材质，根据物体表面向量的计算来得到物体的颜色，并且对表面进行渲染 网格面材质，是一个容器，并且在容器里面为物体的各个表面制定不同的色彩 朗伯材质，考虑到光照的影响，适合创造光亮暗淡的物体 Phong 式材质，创造光亮的物体，比如说钻石等 着色器材质 共有属性 id 用来识别材质的标识符。 name 可以通过这个属性赋予材质名称。 opacity 物体的透明度。 transparent 是否透明。 overdraw 过度描绘。 visible 是否可见。 needsUpdate 是否刷新。 融合属性 深度测试 简单材质 不受光照影响。 使用这种材质的网格会被渲染成一些简单的多变形。 可以显示出几何体的线框。 常用属性 color 材质的颜色 wireframe 设置为 true ，可以显示出线框。 fog 指定当前材质是否会受全局雾化效果的影响。 完整示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var shareObj = share();var cubeGeometry = new THREE.BoxGeometry(5, 5, 5);var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xff0000 &#125;);var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);cube.castShadow = true;var sphereGeometry = new THREE.SphereGeometry(5, 20, 20);var sphereMaterial = new THREE.MeshLambertMaterial(&#123; color: 0x770077,wireframe:true &#125;);var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);sphere.position.set(0,3,2);cube.position = sphere.position;sphere.castShadow = true;shareObj.scene.add(sphere);shareObj.scene.add(cube);shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);var ambiLight = new THREE.AmbientLight('#1c1c1c');shareObj.scene.add(ambiLight);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40,60,10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; shareObj.renderer.render(shareObj.scene, shareObj.camera); cube.rotation.y += 0.01; sphere.rotation.y += 0.01; requestAnimationFrame(render);&#125; 最终效果如下图： 深度材质 外观不由光照和材质决定。 外观由物体到相机的距离决定。 可以与其他材质组合使用。 基本属性 wireframe 是否显示线框。 writeframeLinewidth 线框线的宽度。 完整示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var scene = new THREE.Scene;scene.overrideMaterial = new THREE.MeshDepthMaterial();var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 10, 130);var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0x000000, 1.0));renderer.setSize(window.innerWidth, window.innerHeight);camera.position.set(-50, 40, 50);camera.lookAt(scene.position);// 创建立方体的方法function addCube() &#123; var cubeSize = Math.ceil(3 + (Math.random() * 3)); var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize); var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: Math.random() * 0xffffff &#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.castShadow = true; cube.position.set( -60 + Math.round(Math.random() * 100), Math.round(Math.random() * 10), -100 + Math.round(Math.random() * 150) ); scene.add(cube)&#125;for (var i = 0; i &lt; 100; i++) &#123; addCube();&#125;document.body.appendChild(renderer.domElement);render();function render() &#123; requestAnimationFrame(render); scene.traverse(function(e) &#123; if (e instanceof THREE.Mesh) &#123; e.rotation.x += 0.02; e.rotation.y += 0.02; e.rotation.z += 0.02; &#125; &#125;); renderer.render(scene, camera);&#125; 最终效果如下图： 联合材质 联合多个材质，产生综合渲染效果。 联合材质创建方法 THREE.SceneUtils.createMultiMaterialObject 完整示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var scene = new THREE.Scene;var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 10, 130);var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0x000000, 1.0));renderer.setSize(window.innerWidth, window.innerHeight);camera.position.set(-50, 40, 50);camera.lookAt(scene.position);// 创建立方体的方法function addCube() &#123; var cubeSize = Math.ceil(3 + (Math.random() * 3)); var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize); // 深度材质 var cubeMaterial = new THREE.MeshDepthMaterial(); // 基础材质 var colorMaterial = new THREE.MeshBasicMaterial(&#123; color:0x00ff00, transparent:true, blending:THREE.MultiplyBlending &#125;); var cube = new THREE.SceneUtils.createMultiMaterialObject(cubeGeometry,[ colorMaterial,cubeMaterial ]); cube.children[1].scale.set(0.99,0.99,0.99); cube.castShadow = true; cube.position.set( -60 + Math.round(Math.random() * 100), Math.round(Math.random() * 10), -100 + Math.round(Math.random() * 150) ); scene.add(cube);&#125;for (var i = 0; i &lt; 100; i++) &#123; addCube();&#125;document.body.appendChild(renderer.domElement);render();function render() &#123; requestAnimationFrame(render); scene.traverse(function(e) &#123; if (e instanceof THREE.Mesh) &#123; e.rotation.x += 0.02; e.rotation.y += 0.02; e.rotation.z += 0.02; &#125; &#125;); renderer.render(scene, camera);&#125; 最终效果如下图： 法向材质 MeshNormalMaterial 材质是通过法向计算颜色的。 法向量是与面垂直的向量。 基本属性 wireframe 该属性指定是否显示线框。 wireframeLineWidth 指定线框线的宽度。 shading 设置着色方法。 完整示例代码如下： 1234567891011121314151617181920212223242526272829303132var shareObj = share();var cubeGeometry = new THREE.BoxGeometry(5, 5, 5);// 定义法向材质var cubeMaterial = new THREE.MeshNormalMaterial(&#123; color: 0x7777ff &#125;);var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);shareObj.scene.add(cube);shareObj.camera.position.set(-25, 30, 25);shareObj.camera.lookAt(shareObj.scene.position);var ambiLight = new THREE.AmbientLight('#1c1c1c');shareObj.scene.add(ambiLight);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40,60,10);spotLight.castShadow = true;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);render();function render() &#123; shareObj.renderer.render(shareObj.scene, shareObj.camera); cube.rotation.y += 0.01; requestAnimationFrame(render);&#125; 最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/15","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"Three.js系列教程--光源","date":"2017-07-15T13:09:11.000Z","path":"webgl-2017-07-15/","text":"概述光源分类 AmbientLight 环境光源 PointLight 点光源 SpotLight 聚光灯光源 DirectionalLight 方向光 HemisphereLight 半球光 AreaLight 面光源 LensFlare 镜头眩光 影响整个场景的光源 影响整个场景的光源，也叫 AmbientLight 环境光。 没有特定来源，不会影响阴影的产生。 不能将环境光作为场景中唯一的光源。 three.color 函数 add(color) 添加到当前颜色上。 clone() 复制当前颜色。 示例核心代码如下： 12// 加入环境光shareObj.scene.add(new THREE.AmbientLight('#f00')) 最终效果如下图，环境光会作用在所有的几何图形上： 照射所有方向的光源 照射所有方向的光源，也叫 PointLight 点光源。 点光源是单点发光方式。 点光源不会产生阴影，是为了减少 GPU 的负担。 属性 color 光源颜色。 intensity 光照强度。 distance 光源照射的距离。 position 光源所在的位置。 示例核心代码如下： 1234567891011121314151617// 加入点光源var pointLight = new THREE.PointLight(0xffffff);pointLight.position.set(-40,60,10);shareObj.scene.add(pointLight);document.body.appendChild(shareObj.renderer.domElement);render();function render()&#123; requestAnimationFrame(render); pointLight.position.z += 0.2; shareObj.renderer.render(shareObj.scene,shareObj.camera);&#125; 最终效果如下图，点光源离物体越来越远： 锥形效果光源 具有锥形效果的光源，也叫做 SpotLight 。 最常用到的光源，它可以产生阴影。 锥形效果，类似电筒光照效果。 属性 castShadow 如果设置为 true ， 这个光源就会生成阴影。 target 决定光照的方向。 angle 光照的角度。 示例核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, 10);spotLight.castShadow = true;spotLight.target = cube;spotLight.angle = Math.PI / 10;shareObj.scene.add(spotLight);document.body.appendChild(shareObj.renderer.domElement);var angleNUM = 3;document.onkeydown = function(event) &#123; console.log(event.keyCode); switch (event.keyCode) &#123; case 38: angleNUM += 1; break; case 40: angleNUM -= 1; if (angleNUM &lt; 1) &#123; angleNUM = 1; &#125; break; case 37: spotLight.position.x += 0.2; break; case 39: spotLight.position.x -= 0.2; break; &#125;&#125;;function render() &#123; spotLight.angle = Math.PI / angleNUM; requestAnimationFrame(render); shareObj.renderer.render(shareObj.scene, shareObj.camera);&#125;render(); 最终效果如下图： 太阳的光源 模拟远处太阳的光源，也叫做 DirectinalLight 方向光。 方向光是一种平行光。 属性 它和平行光源的属性一样，常用的属性castShadow、target 和 angle 。 不常用的属性有 shadowCameraVisible 、shadowDarkness、shadowMapWidth 和 shadowMapHeight 等，这些属性很少会被用到。 示例核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344var ambiLight = new THREE.AmbientLight('#1c1c1c');shareObj.scene.add(ambiLight);var target = new THREE.Object3D();target.position.set(5, 0, 0);var directionalLight = new THREE.DirectionalLight('#ff5818');directionalLight.position.set(-40, 60, -11);directionalLight.castShadow = true;directionalLight.shadowCameraFar = 200;directionalLight.shadowCameraNear = 3;directionalLight.intensity = 0.5;directionalLight.shadowMapWidth = 1000;directionalLight.shadowMapHeight = 2000;directionalLight.target = target;document.body.appendChild(shareObj.renderer.domElement);shareObj.scene.add(directionalLight);document.onkeydown = function(event) &#123; switch (event.keyCode) &#123; case 37: directionalLight.intensity += .1; break; case 39: directionalLight.intensity -= .1; if (directionalLight.intensity &gt; 0) &#123; directionalLight.intensity = .1; &#125; break; &#125;&#125;;render();function render() &#123; shareObj.renderer.render(shareObj.scene, shareObj.camera); requestAnimationFrame(render);&#125; 最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/14","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"Three.js系列教程--基础组件","date":"2017-07-14T13:09:11.000Z","path":"webgl-2017-07-14/","text":"场景必备组件 相机：决定哪些东西将被显示在屏幕上。 光源：生成阴影与改变物体表面显示效果。 物体：相机透视图里主要的渲染对象。 基本功能 scene.add() 在场景中添加物体。 scene.remove() 从场景中移除物体。 scene.getChildByName() 获得场景中所有对象的列表。 属性 fog 通过该属性可以设置场景的雾化效果。 overrideMaterial 通过这个属性可以让场景中的所有物体都使用相同材质。 children 返回所有对象的列表，包括相机和光源对象。 创建场景，相机，绘制函数等对象，设置画布背景，开启阴影模式： 123456789101112131415// 创建场景var scene = new THREE.Scene();// 创建相机var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, .1, 1000);// 创建渲染器var renderer = new THREE.WebGLRenderer();renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));renderer.setSize(window.innerWidth, window.innerHeight);// 开启阴影效果renderer.shadowMapEnabled = true; 创建一个舞台，承载绘制的物体，并且将舞台加载到场景中： 123456789101112131415// 顶点着色器var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1);// 材质var planeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xffffff &#125;);var plane = new THREE.Mesh(planeGeometry, planeMaterial);plane.receiveShadow = true;plane.rotation.x = -.5 * Math.PI;plane.position.x = 16;plane.position.y = 0;plane.position.z = 0;scene.add(plane); 定义一个相机的位置1234camera.position.x = -30;camera.position.y = 40;camera.position.z = 30;camera.lookAt(scene.position); 添加环境光和电光源： 12345678// 创建环境光源var ambientLight = new THREE.AmbientLight(0x0c0c0c);scene.add(ambientLight);var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, -10);spotLight.castShadow = true;scene.add(spotLight); 创建节点，并且渲染场景： 123document.body.appendChild(renderer.domElement);renderer.render(scene, camera); 创建添加立方体的方法： 123456789101112131415function addCube() &#123; // 创建立方体 var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xff0000 &#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); // cube.castShadow = true; cube.position.x = -4 + Math.round(Math.random() * planeGeometry.parameters.width); cube.position.y = 3 + Math.round(Math.random() * 5); cube.position.z = 0 + Math.round(Math.random() * planeGeometry.parameters.height); scene.add(cube);&#125; 最终效果如下图： 几何与网络对象几何对象的属性和函数 THREE.Geometry 是所有几何对象的基类（ 我们简称 geom ）。 geom.vertices 表示几何体的顶点，是一个数组。 geom.faces 表示几何体的侧面。 网格对象的属性和函数 position 决定该对象相对于父对象的位置。 rotation 设置对象绕任何一个轴的旋转弧度。 scale 沿 x , y和 z 轴缩放对象。 translateX x 轴平移。 translateY y 轴平移。 translateZ z 轴平移。 通过顶点和面来创建一个几何体，，创建场景、相机、渲染器等基本组件和之前保持一致，核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 绘制顶点var vertices = [ new THREE.Vector3(1, 3, 1), new THREE.Vector3(1, 3, -1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, -1, -1), new THREE.Vector3(-1, 3, -1), new THREE.Vector3(-1, 3, 1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(-1, -1, 1)];// 绘制面var faces = [ new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1), new THREE.Face3(4, 6, 5), new THREE.Face3(6, 7, 5), new THREE.Face3(4, 5, 1), new THREE.Face3(5, 0, 1), new THREE.Face3(7, 6, 2), new THREE.Face3(6, 3, 2), new THREE.Face3(5, 7, 0), new THREE.Face3(7, 2, 0), new THREE.Face3(1, 3, 4), new THREE.Face3(3, 6, 4)];var geom = new THREE.Geometry();geom.vertices = vertices;geom.faces = faces;geom.computeFaceNormals();var materials = [ new THREE.MeshLambertMaterial(&#123; opacity: 0.5, color: 0x44ff44, transparent: true &#125;), new THREE.MeshBasicMaterial(&#123; color: 0x000000, wireframe: true &#125;)];var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, materials);mesh.children.forEach(function(e) &#123; e.castShadow = true;&#125;);scene.add(mesh);document.body.appendChild(renderer.domElement);renderer.render(scene, camera); 最终效果如下图： 相机透视相机（PerspectiveCamera） fov 视野宽度 。 aspect 长宽比，推荐使用 window.innerWidth / window.innerHeight 。 near 近裁面，推荐值 0.1 。 far 远裁面，推荐值 1000 ， 值太大会影响性能，值太小场景显示不全。 正射投影相机（OrthographicCamera） left 左边界。 right 右边界。 top 上边界。 bottom 下边界。 near 近裁面。 far 远裁面。 camera.lookAt 设置目标点。 增加雾化效果的核心代码： 123// 增加雾化处理scene.fog = new THREE.Fog( 0xffffff, .005, 100 ); 最终结果如下图： 示例代码来区分透视投影和正射投影的区别： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var cubeGeometry = new THREE.BoxGeometry(4, 4, 4);for (var j = 0; j &lt; planeGeometry.parameters.height / 5; j++) &#123; for (var i = 0; i &lt; planeGeometry.parameters.width / 5; i++) &#123; var rnd = Math.random() * 0.75 + 0.25; var cubeMaterial = new THREE.MeshLambertMaterial(); cubeMaterial.color = new THREE.Color(rnd, 0, 0); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.position.z = -(planeGeometry.parameters.height / 2) + 2 + (j * 5); cube.position.x = -(planeGeometry.parameters.width / 2) + 2 + (i * 5); cube.position.y = 2; scene.add(cube); &#125;&#125;// 定义相机切换的方法var controls = new function() &#123; this.perspective = 'Perspective'; this.switchCamera = function() &#123; if (camera instanceof THREE.PerspectiveCamera) &#123; camera = new THREE.OrthographicCamera( window.innerWidth / -16, window.innerWidth / 16, window.innerHeight / 16, window.innerHeight / -16, -200, 500 ); camera.position.x = -20; camera.position.y = 60; camera.position.z = 50; camera.lookAt(scene.position); this.perspective = 'Orthographic'; &#125; else &#123; this.perspective = 'Perspective'; camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.x = -20; camera.position.y = 60; camera.position.z = 50; camera.lookAt(scene.position); &#125; &#125;&#125;;setInterval(function()&#123;controls.switchCamera();&#125;,2000)function render() &#123; renderer.render(scene, camera);&#125;render(); 最终效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/13","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"},{"name":"three.js","slug":"three-js","permalink":"http://www.iwangqi.com/tags/three-js/"}]},{"title":"WebGL系列教程--绘制立方体","date":"2017-07-13T13:09:11.000Z","path":"webgl-2017-07-13/","text":"顶点索引绘制立方体 正方体只有8个顶点。 压缩36个顶点到8个顶点。 顶点索引是减少顶点的解决之道。 使用 new Uint8Array( … ) 创建顶点索引数据。 运用到的绘制方法 gl.drawElements(mode , count , type , offset) mode 绘制方式。 count 绘制顶点的数量。 type 索引数据类型。 offset 指定索引数组中开始绘制的位置，以字节为单位。 核心代码如下： 定义8个顶点的数据，并且将数据添加到buffer对象上： 12345678910111213141516var buffer_data = new Float32Array([ // 设置顶点和颜色（偷的顶点代码位置） 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, // v0 White -1.0, 1.0, 1.0, 1.0, 0.0, 1.0, // v1 Magenta -1.0, -1.0, 1.0, 1.0, 0.0, 0.0, // v2 Red 1.0, -1.0, 1.0, 1.0, 1.0, 0.0, // v3 Yellow 1.0, -1.0, -1.0, 0.0, 1.0, 0.0, // v4 Green 1.0, 1.0, -1.0, 0.0, 1.0, 1.0, // v5 Cyan -1.0, 1.0, -1.0, 0.0, 0.0, 1.0, // v6 Blue -1.0, -1.0, -1.0, 0.0, 0.0, 0.0 // v7 Black]);var buffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, buffer);gl.bufferData(gl.ARRAY_BUFFER, buffer_data, gl.STATIC_DRAW); 同理，简历存放索引的buffer数据，并且将其添加到buffer对象上： 123456789101112var indices = new Uint8Array([ 0, 1, 2, 0, 2, 3, // 前 0, 3, 4, 0, 4, 5, // 右 0, 5, 6, 0, 6, 1, // 上 1, 6, 7, 1, 7, 2, // 左 7, 4, 3, 7, 3, 2, // 下 4, 7, 6, 4, 6, 5 // 后]);var indexBuffer = gl.createBuffer();gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,indices,gl.STATIC_DRAW); 建立透视投影矩阵和视图矩阵： 123456789// 透视投影矩阵var tsMX = getTS(30,1,1,100);// 视图矩阵var vMX = getVMatrix(3,3,7,0,0,0);var mx = multiplyMatrix(tsMX,vMX);gl.uniformMatrix4fv(mxLocation,false,mx); 使用gl.drawElements方法来绘制立方体： 1gl.drawElements(gl.TRIANGLES, indices.length,gl.UNSIGNED_BYTE,0); 最终效果如下： 添加颜色 顶点着色器进行的是逐顶点运算。 创建多个具有相同顶点坐标的原点。 为立方体每个面设置不同颜色。 立方体如下图： 123456789// Create a cube// v6----- v5// /| /|// v1------v0|// | | | |// | |v7---|-|v4// |/ |/// v2------v3 基本实现原理如下图： 定义顶点的数据有所更改： 12345678var buffer_data = new Float32Array([ 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0,-1.0, 1.0, 1.0,-1.0, 1.0, // v0-v1-v2-v3 front 1.0, 1.0, 1.0, 1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0, // v0-v3-v4-v5 right 1.0, 1.0, 1.0, 1.0, 1.0,-1.0, -1.0, 1.0,-1.0, -1.0, 1.0, 1.0, // v0-v5-v6-v1 up -1.0, 1.0, 1.0, -1.0, 1.0,-1.0, -1.0,-1.0,-1.0, -1.0,-1.0, 1.0, // v1-v6-v7-v2 left -1.0,-1.0,-1.0, 1.0,-1.0,-1.0, 1.0,-1.0, 1.0, -1.0,-1.0, 1.0, // v7-v4-v3-v2 down 1.0,-1.0,-1.0, -1.0,-1.0,-1.0, -1.0, 1.0,-1.0, 1.0, 1.0,-1.0 // v4-v7-v6-v5 back]); 单独定义颜色数据： 12345678var color_data = new Float32Array([ 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, // v0-v1-v2-v3 front(blue) 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, // v0-v3-v4-v5 right(green) 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, // v0-v5-v6-v1 up(red) 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, // v1-v6-v7-v2 left 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, // v7-v4-v3-v2 down 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0 // v4-v7-v6-v5 back]); 在绘制前需要开启深度测试代码： 12// 开启深度测试gl.enable(gl.DEPTH_TEST); 如果不开启则效果如下图： 开启后效果如下图： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/12","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--着色器语言","date":"2017-07-12T13:09:11.000Z","path":"webgl-2017-07-12/","text":"概述 运行在建立在OpenGL基础上，删除和简化了一部分形成的。 运行在小型设备 与 C 语言语法类似 执行顺序 从main主方法 void关键字 void main(){…}，没有函数返回值 基本写法如下：123void main()&#123; ...&#125; 基本类型 数值类型 布尔值类型 123456bool a;init b;float c;void main()&#123; ...&#125; 变量 a-z , A-Z , 0-9 , _ 首字母不能为数字 不能用关键字和保留字作变量名 不能以 gl_ , webgl 开头 基本运算符 / + - ++ — = += -= *= /= &lt; &gt; &lt;= &gt;= == != ! &amp;&amp; || ^^ 三元运算 123456789float a;float b;float c = a + b;++a/a++true ^^ true // falsefalse ^^ false // falsefalse ^^ true // true 复杂类型结构体struct bright{ vec4 color; vec3 position;} 在赋值过程中必须按照保证类型一样，因为着色器语言是强类型。 1234567891011struct user &#123; float gezi; vec3 book;&#125;user wq;float a = 12.0;vec3 b = vec3(1.2,3.3,5.0);wq = user(a,b)wq = user(12.0,vec3(2.1,3.3,5.0)); 数组 只支持一维数组 长度必须大于 0 的整型常量表达式 不可用 const 修饰数组 float floatArr[4]; 取样器 通过取样器类型访问纹理 sampler2D 只能是 uniform 变量 纹理单元编号，至少支持8个单元变量 程序流程控制判断语句if (条件表达式1){ 如果条件语句为 true，执行这里。}else if(条件表达式1){ 如果条件语句1为 false，并且条件语句2为 true，执行这里。}else{ 如果条件语句1和2都为 false ， 执行这里。} 123456789101112varying vec4 vpos;if(vpos.x &gt;= 0.0 &amp;&amp; vpos.y &gt;= 0.0)&#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0); //红色&#125;else if(vpos.x &gt;= 0.0 &amp;&amp; vpos.y &lt; 0.0)&#123; gl_FragColor = vec4(0.0,1.0,0.0,1.0); //绿色&#125;else if(vpos.x &lt; 0.0 &amp;&amp; vpos.y &gt;= 0.0)&#123; gl_FragColor = vec4(0.0,0.0,1.0,1.0); //蓝色&#125;else&#123; gl_FragColor = vec4(1.0,1.0,0.0,1.0); //黄色&#125; 循环语句for ( 初始化表达式 ; 条件表达式 ; 循环步进表达式 ) { 反复执行这里} 1234567891011init sum = 0;for(init i = 0; i&lt;10;i++)&#123; sum += 1;&#125;// sum = 10;float sum = 0.0;for(init i = 0; i&lt;10;i++)&#123; sum += float(i);&#125; 函数格式返回类型函数名 (type0 arg0 , type1 arg1 , …) { 函数运算 return 返回值;}1234init sum(int a,int b)&#123; return a + b;&#125; 声明 float bright(); // 必须提前声明 void main(){ bright(); } float bright(){ … } 内置函数 三角函数 指数函数 通用函数 几何函数 矩阵函数 矢量函数 纹理查询函数 12345678910111213141516171819202122232425262728293031323334353637383940414243//三角函数radians(float d);radians(vec2 d);radians(vec3 d);radians(vec4 d);degrees(float d);degrees(vec2 d);degrees(vec3 d);degrees(vec4 d);// cos tan ...sin(float d);sin(vec2 d);sin(vec3 d);sin(vec4 d);// 指数函数pow(float x,float y)pow(vec2 x,vec2 y)pow(vec3 x,vec3 y)pow(vec4 x,vec4 y)// 通用函数abc(float x);abc(vec2 x);abc(vec3 x);abc(vec4 x);floor(float x);floor(vec2 x);floor(vec3 x);floor(vec4 x);max(float x,float y);// 几何函数// 返回x轴的长度length(float x) // vec2 ,vec3, vec4... 限定字存储限定字 const 不可变的量 attribute 顶点着色器中使用 uniform 只读，必须是全局变量。 varying 顶点和片元着色器通信使用的，顶点着色器中赋给varying变量的值并不是直接传给了片元着色器的varying变量，这其中发生了光删化的过程，根据绘制的图形，对前者进行内插，然后再传递给后者。 精度限定字 highp 最高精度 mediump 中等精度 lowp 低精度 precision lowp float； // 定义精度","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--可视范围","date":"2017-07-11T13:09:11.000Z","path":"webgl-2017-07-11/","text":"可视范围基础盒状空间 长方体可是空间，也叫盒状空间，是由正射投影产生。 可视锥体空间，由透视投影产生。 在透视投影下，产生的三维场景看上去更是有深度感，更加自然，因为我们平时观察真实世界用的也是透视投影。在大多数情况下，比如三维射击类游戏中，我们都应该采用透视投影。相比之下，正射投影的好处是用户可以方便的比较场景中物体的大小，这是因为物体看上去的大小与其所在的位置没有关系。在建筑平面图等技术绘图的相关场合，应当使用这种投影。 盒状空间的工作原理盒状可视空间的由前后两个矩形表面确定，分别称近裁剪面和远裁剪面，前者的四个顶点为（right,top,-near）,(-left,top,-near),(-left,-bottom,-near),(right,-bottom,-near),而后者的四个顶点为(right,top,far),(-left,top,far),(-left,-bottom,far),(right,-bottom,far). 上显示的就是可视空间中物体在近裁剪面上的投。如果裁剪面的高宽比和不一样，那么画面就会被按照的高宽比进行压缩，物体会被扭曲。近裁剪面与远裁剪面之间的盒形空间就是可是空间，只有在此空间内的物体会被显示出来。如果某个物体一部分在可视空间内，一部分在其外，那就只显示可视空间内的部分。 正射投影矩阵函数 setOrtho(left , right , bottom , top , near , far) left / right / bottom / top 参数含义：定位范围。 near 参数含义：近裁切面。 far 参数含义：远裁切面。 基本方程式如下： 写一个正射投影实例代码，核心代码如下： 编写顶点着色器和片元着色器代码，定义一个uniform矩阵变量。12345678910111213141516171819var vertexShaderSource = ` attribute vec4 pos; uniform mat4 u_mx; attribute vec4 a_Color; varying vec4 v_Color; void main()&#123; gl_Position = u_mx * pos; v_Color = a_Color; &#125;`var fragmentShaderSource = ` precision lowp float; varying vec4 v_Color; void main()&#123; gl_FragColor = v_Color; &#125;` 定义一个正射矩阵的方法1234567891011121314151617function getOMX(left,right,bottom,top,near,far)&#123; return new Float32Array([ 2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, -2 / (far - near), 0, -(right + left) / (right - left), -(top + bottom) / (top - bottom), -(far + near) / (far - near), 1 ]);&#125;var near = 0.0;var far = .5;var omx = getOMX(-.5,.5, -.5,.5, near , far); 定义数据data类型化数组123456789var data = new Float32Array([ 0.0, 0.6, -.4, 0.4, 1.0, 0.4, -.45, -.4, -.51, .4, 1.0, .4, 0.5, -.4, -.4, 1.0, .4, .4, .5, .4, -.2, 1.0, .4, .4, -.5, .4, -.2, 1.0, 1.0, .3, .0, -.6, -.2, 1.0, 1.0, .4]); 由于定义的far为.5,而data类型化数组数据一个三角形的坐标为-.51，实际效果会产生一个缺角，可以根据改变三角形的顶点来看不同的效果，最终效果如下图： 缺角的修补 将远裁面移到距离视点更远的地方。 &lt;正射投影矩阵&gt; &lt;视图矩阵&gt; &lt;顶点坐标&gt; 代码效果如下： 透视投影基础 透视投影和正射投影基本一致，但存在一些参数差异。使得远处的物体看起来比较小，一般在游戏开发会用的比较多。 可视空间顶面和底面的夹角必须大于0。 指定近裁面的宽高比例。 后面的三角形会根据与视点的距离做相应的缩放，并且做相应的平移。 透视投影矩阵矩阵公式 通过一个示例来解释透视投影具体的效果。 定义着色器代码： 12345678910111213141516171819var vertexShaderSource = ` attribute vec4 pos; uniform mat4 u_mx; attribute vec4 a_Color; varying vec4 v_Color; void main()&#123; gl_Position = u_mx * pos; v_Color = a_Color; &#125;`var fragmentShaderSource = ` precision lowp float; varying vec4 v_Color; void main()&#123; gl_FragColor = v_Color; &#125;` 创建program代码： 123var gl = canvas.getContext('webgl');var program = initShader(gl,vertexShaderSource,fragmentShaderSource); 定义创建透视投影矩阵函数方法： 12345678910111213141516/** * 创建透视投影矩阵 * fov 指定垂直视角 * aspect 宽度 ／ 高度 * near 近裁切面 * far 远裁切面 */function getTS(fov,aspect,near,far)&#123; fov = fov * Math.PI / 180; // 弧度 return new Float32Array([ 1 / (aspect * Math.tan(fov / 2)), 0, 0, 0, 0, 1 / Math.tan(fov / 2), 0, 0, 0, 0, -(far + near) / (far - near), -1, 0, 0, -2 * (far * near) / (far - near), 0 ]);&#125; 创建ata，并且将data绑定到创建的buffer上： 1234567891011121314151617181920212223242526// 四个三角形var buffer_data = new Float32Array([ 0.75, 1.0, -.8, 1.0, 1.0, .4, .25, -1.0, -.8, 1.0, 1.0, .4, 1.0, -1.0, -.8, 1.0, .4, .4, .75, 1.0, 0.8, .4, .4, 1.0, .25, -1.0, .8, .4, .4, 1.0, 1.0, -1.0, .8, 1.0, .4, .4, // 第一个三角形 -.75, 1.0, -.8, 1.0, 1.0, .4, -1.0, -1.0, -.8, 1.0, 1.0, 0.4, -0.25, -1.0, -.8, 1.0, .4, .4, -.75, 1.0, .8, .4, .4, 1.0, -1.0, -1.0, .8, .4, .4, 1.0, -.25, -1.0, .8, 1.0, .4, .4]);var buffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, buffer);gl.bufferData(gl.ARRAY_BUFFER, buffer_data, gl.STATIC_DRAW); 得到Location，并且给其赋值： 12345678910var posLocation = gl.getAttribLocation(program, 'pos');var aColorLocation = gl.getAttribLocation(program, 'a_Color');var uMXLocation = gl.getUniformLocation(program, 'u_mx');var BYTES_SIZE = buffer_data.BYTES_PER_ELEMENT;gl.vertexAttribPointer(posLocation, 3, gl.FLOAT, false, BYTES_SIZE * 6, 0);gl.vertexAttribPointer(aColorLocation, 3, gl.FLOAT, false, BYTES_SIZE * 6, BYTES_SIZE * 3);gl.enableVertexAttribArray(posLocation);gl.enableVertexAttribArray(aColorLocation); 定义一个绘图函数方法，并且执行，其中getVMatrix和multiplyMatrix是lib库中的函数： 1234567891011121314function draw() &#123; gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); var mx = getTS(30, canvas.width / canvas.height, 1, 100); var vmx = getVMatrix(0,0,5,0,0,-100); gl.uniformMatrix4fv(uMXLocation,false,multiplyMatrix(mx,vmx)); gl.drawArrays(gl.TRIANGLES, 0, 12);&#125;draw(); 最终运行结果如下： 物体前后关系 默认情况下，WebGL 是按照顶点在缓冲区中的顺序绘制的。 后绘制的会遮挡先绘制的图形。 例如将上面的示例中的data数据顺序该下，就会出现以下的效果： 1234567891011121314151617181920// 四个三角形var buffer_data = new Float32Array([ .75, 1.0, 0.8, .4, .4, 1.0, .25, -1.0, .8, .4, .4, 1.0, 1.0, -1.0, .8, 1.0, .4, .4, 0.75, 1.0, -.8, 1.0, 1.0, .4, .25, -1.0, -.8, 1.0, 1.0, .4, 1.0, -1.0, -.8, 1.0, .4, .4, -.75, 1.0, .8, .4, .4, 1.0, -1.0, -1.0, .8, .4, .4, 1.0, -.25, -1.0, .8, 1.0, .4, .4, -.75, 1.0, -.8, 1.0, 1.0, .4, -1.0, -1.0, -.8, 1.0, 1.0, 0.4, -0.25, -1.0, -.8, 1.0, .4, .4,]); 但是实际情况中，可能很多图像并不知道出现的顺序，webgl提供了两个方法来解决这类问题。 解决方法 启动隐藏面消除 启动多边形偏移 核心代码如下： 12gl.enable(gl.DEPTH_TEST);gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 这样做之后，离视点远的对象会在后面展示。 深度冲突隐藏面消除是WebGL的一项复杂而又强大的特效，在绝大多数情况下，它都能很好地完成任务。然而，当几何图形或物体的两个表面极为接近时，就会出现新的问题，使得表面看上去斑斑驳驳的，这种现象被称为深度冲突（Z fighting） 当所有的三角形一起绘画的时候，似乎不会出现这种情况，但是如果分开画三角形，可能会出现深度冲突的问题，通过以下代码可以解决： 1234gl.enable(gl.POLYGON_OFFSET_FILL);gl.drawArrays(gl.TRIANGLES, 0, 3);gl.polygonOffset(1.0, 1.0); gl.drawArrays(gl.TRIANGLES, 3, 3); 最终效果如下： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/11","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--贴图","date":"2017-07-10T13:09:11.000Z","path":"webgl-2017-07-10/","text":"贴图概述图片类别 JPG 格式，24位的颜色储存单个的绘图，是有损的压缩，牺牲图像质量可以控制文件大小 GIF 格式，压缩比例能够达到40%到50%，无损压缩技术（必须保证256颜色的） PNG 格式，无损压缩 贴图开发流程 准备纹理图像 配置图像映射方式 加载纹理图像 纹理贴图 贴图核心技术纹理坐标 st坐标系 纹理对象 createTexture 创建纹理 deleteTexture(tex) 删除纹理 图片加载 确定图片加载后调用的函数 图片开始加载 向服务器请求图片 服务器查找图片 服务器返回图片数据 浏览器收到图片数据 调用回调函数 配置纹理 Y 轴反转 开启纹理单元 绑定纹理对象 配置纹理参数 配置纹理图形 将纹理传递给着色器 编写着色器代码，在片元着色器中定义贴图，基本如下 1234567891011121314151617181920// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; attribute vec2 texPos; varying vec2 v_texPos; void main() &#123; gl_Position = pos; v_texPos = texPos; &#125;` // 片元着色器程序 const fragmentShaderSource = ` precision lowp float; uniform sampler2D ss; varying vec2 v_texPos; void main() &#123; gl_FragColor = texture2D(ss,v_texPos); &#125;` 将加载的图片画在canvas上面，基本代码如下：12345678910111213141516171819202122function loadImg(url,callback)&#123; var img = new Image; img.src = url; img.onload = function () &#123; callback(img); &#125; &#125; loadImg('./img.png', function (img) &#123; var texture = cxt.createTexture(); cxt.pixelStorei(cxt.UNPACK_FLIP_Y_WEBGL,1); cxt.activeTexture(cxt.TEXTURE0); cxt.bindTexture(cxt.TEXTURE_2D,texture); cxt.texParameteri(cxt.TEXTURE_2D,cxt.TEXTURE_MIN_FILTER,cxt.LINEAR); cxt.texImage2D(cxt.TEXTURE_2D,0,cxt.RGB,cxt.RGB,cxt.UNSIGNED_BYTE,img); cxt.uniform1i(texLocation,0); cxt.drawArrays(cxt.TRIANGLE_STRIP,0,4); &#125;); 最终效果如下： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/10","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--视点与视线","date":"2017-07-09T13:09:11.000Z","path":"webgl-2017-07-09/","text":"视点、目标点和上方向 视点：观察者所在的三维世界中的位置。 目标点：被观察的目标所在的位置。 上方向：相机正上方的方向。 试图矩阵 默认情况下，视点位于坐标系原点 lookAt(out, eye, center, up) eye 指定视点 center 指定观察点 up 指定向上方向 定义顶点着色器和片元着色器代码，在定义着色器代码中，需要定义点的坐标，点的颜色，矩阵，和片元着色器通信的颜色变量1234567891011121314151617181920// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 a_Position; attribute vec4 a_Color; uniform mat4 u_vmatrix; varying vec4 v_Color; void main() &#123; gl_Position = u_vmatrix * a_Position; v_Color = a_Color;&#125;` // 片元着色器程序 const fragmentShaderSource = ` precision lowp float; varying vec4 v_Color; void main() &#123; gl_FragColor = v_Color; &#125;` 定义几个公共工具类函数，基本代码如下：1234567891011121314151617181920212223242526function normalize(v)&#123; var sum = 0; for (var i=0;i&lt; v.length;i++)&#123; sum += v[i] * v[i]; &#125; var result = Math.sqrt(sum); for(var j=0;j&lt; v.length; j++)&#123; v[i] = v[i] / result; &#125; &#125; function cross(a,b)&#123; var nX = a[1] * b[2] - a[2] * b[1]; var nY = a[2] * b[0] -a[0] * b[2]; var nZ = a[0] * b[1] - a[1] * b[0]; return new Float32Array([nX,nY,nZ]); &#125; function dot(a,b)&#123; return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; &#125; function minus(a , b)&#123; return new Float32Array([a[0] - b[0], a[1] - b[1] , a[2] - b[2]]); &#125; 通过工具类函数创建一个新的视图矩阵，基本代码如下：1234567891011121314151617181920212223function getVMatrix()&#123; var eye = new Float32Array([0.4,0.0,0.26]); var lookat = new Float32Array([0.0,0.0,0.0]); var up = new Float32Array([0,1,1]); var zA = minus(eye , lookat); normalize(zA); normalize(up); var xA = cross(up, zA); var yA = cross(zA,xA); return new Float32Array([ xA[0],yA[0],zA[0], 0, xA[1],yA[1],zA[1], 0, xA[2],yA[2],zA[2], 0, - dot(xA,eye), -dot(yA,eye),-dot(zA,eye),1 ]) &#125; 创建三角形类型化数组，基本代码如下：12345678910var data = new Float32Array([ 0.0, 0.5, -0.4, 0.4, 1.0, 0.4, -0.5, -0.5, -0.4, 0.4, 1.0, 0.4, 0.5, -0.5, -0.4, 1.0, 0.4, 0.4, 0.5, 0.4, -0.2, 1.0, 0.4, 0.4, -0.5, 0.4, -0.2, 1.0, 1.0, 0.4, 0.0, -0.6, -0.2, 1.0, 1.0, 0.4 ]); 视图矩阵数据添加，基本代码如下：123456var u_vmatrixLocation = cxt.getUniformLocation(program,'u_vmatrix');var mx = getVMatrix(); // 视图矩阵cxt.uniformMatrix4fv(u_vmatrixLocation,false,mx); 最终效果如下： 视点控制 旋转后顶点坐标 ＝ 旋转矩阵 * 原始顶点坐标 （从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 * 旋转后顶点坐标 （从观点观察的）旋转后顶点坐标 ＝ 视图矩阵 旋转矩阵 原始顶点坐标 视图矩阵 模型矩阵 原始顶点坐标 添加键盘控制视点位置，基本代码如下：123456789101112131415161718192021222324252627282930var eyeX = 0.25; function draw(eyeX)&#123; var mx = getVMatrix(eyeX); // 视图矩阵 cxt.uniformMatrix4fv(u_vmatrixLocation,false,mx); cxt.clearColor(1.0,1.0,1.0,1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.drawArrays(cxt.TRIANGLES,0,6); &#125; document.addEventListener('keydown', function (event) &#123; switch (event.keyCode)&#123; case 37: eyeX += .01; break; case 39: eyeX -= .01; break; &#125; draw(eyeX); &#125;); draw(eyeX); 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/09","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--着色器技术","date":"2017-07-08T13:09:11.000Z","path":"webgl-2017-07-08/","text":"数据传入顶点着色器创建多个缓冲区 例如上图显示的，创建点的坐标和创建点的大小两个缓冲区，就要在顶点着色器中创建两个attribute变量 在顶点着色器中定义两个attribute变量，分别是点和点的大小，基本代码如下：123456789// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; attribute float size; void main() &#123; gl_Position = pos; gl_PointSize = size;&#125;` 创建program变量，代码基本如下：1var program = initShader(cxt, vertexShaderSource, fragmentShaderSource); 使用lib库中的bindAttribute函数创建两个buffer相关代码，基本如下：12345678bindAttribute(cxt, 'pos', new Float32Array([ 0.0,0.0, 0.3,0.5, 0.2,1.0 ]), program, 2); bindAttribute(cxt, 'size', new Float32Array([ 10.0,20.0,30.0 ]), program, 1); 最后调用drawArrays直接画点即可，代码如下：1cxt.drawArrays(cxt.POINTS, 0, 3); 偏移参数 一个缓冲区多种用途 通过偏移参数划分数据类别 类数组定义方式有所变化，将点的位置和点的大小定义在一个数组中，前面两位代表点的位置，最后一位代表点的大小，基本代码如下：12345var data = new Float32Array([ 0.0, 0.0, 10.0, 0.5, 0.5, 30.0, 0.2, -.6, 50.0 ]); vertexAttribPointer函数的参数形式有所变化，data.BYTES_PER_ELEMENT代表偏移量单位，3代表每一组数据有三个，所以3，*2代表从偏移2两位开始计算，基本代码如下：12cxt.vertexAttribPointer(posLocation, 2, cxt.FLOAT, false, data.BYTES_PER_ELEMENT * 3, 0); cxt.vertexAttribPointer(sizeLocation, 1, cxt.FLOAT, false, data.BYTES_PER_ELEMENT * 3, data.BYTES_PER_ELEMENT * 2) 顶点着色器和片元着色器通信 通过 uniform 实现顶点和片元着色器共用数据，uniform是不可变的值 通过 varying 传递数据 着色器代码如下：12345678910111213141516171819// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; varying vec4 color; void main() &#123; gl_Position = pos; gl_PointSize = abs(pos.x) * 30.0; color = pos;&#125;` // 片元着色器程序 const fragmentShaderSource = ` precision lowp float; varying vec4 color; void main() &#123; gl_FragColor = color; &#125;` 最终效果是根据坐标的大小和坐标的位置，显示不同的颜色，基本效果如下： 编写一个渐变三角形的示例效果，使用一个buffer数据，分别定义坐标点和点的颜色值，着色器代码如下：12345678910111213141516171819// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; attribute vec4 vcolor; varying vec4 color; void main() &#123; gl_Position = pos; color = vcolor;&#125;` // 片元着色器程序 const fragmentShaderSource = ` precision lowp float; varying vec4 color; void main() &#123; gl_FragColor = color; &#125;` buffer数据data代码如下：123456var data = new Float32Array([ 0.0, .3, 1.0 ,0.0,0.0, -.5, -.5, 0.0, 1.0,0.0, .5, -.5 , 0.0, 0.0,1.0 ]); 最终效果效果如下： 制作一个旋转四边形，并且四边形四个坐标系分别是不同的颜色，首先初步定义着色器代码，基本代码如下： 12345678910111213141516171819// 顶点着色器程序 const vertexShaderSource = ` uniform mat4 xf; attribute vec4 pos; varying vec4 vpos; void main() &#123; gl_Position = xf * pos; vpos = gl_Position;&#125;` // 片元着色器程序 const fragmentShaderSource = ` precision lowp float; varying vec4 vpos; void main() &#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0); &#125;` 获取上下文和program示例代码，利用lib库中的initShader函数，基本如下： 123var cxt = document.getElementById('example06').getContext('webgl'); var program = initShader(cxt, vertexShaderSource, fragmentShaderSource); 定义一个四边形相关的buffer数据内容，基本代码如下： 123456789var data = new Float32Array([ -.3, .3, -0.5, -.3, .5, .3, .3, -.3 ]); bindAttribute(cxt,'pos',data,program); 定义着色器中定义的xf变量相关代码，并且创建旋转矩阵，定义旋转角度等，基本如下：12345678910var xfLocation = cxt.getUniformLocation(program,'xf');var angle = 0;run() function run() &#123; angle++ var xzm = createXZMatrix(angle); cxt.uniformMatrix4fv(xfLocation, false, xzm); cxt.drawArrays(cxt.TRIANGLE_STRIP, 0, 4); setTimeout(run, 100) &#125; 此时的效果是四边形可以旋转，但是颜色还是之前定义的红色，基本效果如下： 通过修改片元着色器中的代码实现不同象限中显示不同颜色，基本代码如下：12345678910111213141516// 片元着色器程序 const fragmentShaderSource = ` precision lowp float; varying vec4 vpos; void main() &#123; if(vpos.x &gt;= 0.0 &amp;&amp; vpos.y &gt;= 0.0)&#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0); &#125;else if(vpos.x &gt;0.0 &amp;&amp; vpos.y &lt; 0.0)&#123; gl_FragColor = vec4(0.0,1.0,0.0,1.0); &#125;else if(vpos.x &lt; 0.0 &amp;&amp; vpos.y &gt; 0.0)&#123; gl_FragColor = vec4(0.0,0.0,1.0,1.0); &#125;else&#123; gl_FragColor = vec4(0.2,0.2,0.2,1.0); &#125; &#125;` 修改完之后，最终效果如下： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/06","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--图形的变换","date":"2017-07-06T13:09:11.000Z","path":"webgl-2017-07-06/","text":"图形的移动原理 图形的移动，实际上就是定量改变顶点的位置。 在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。 可以使用setTimeout定时执行画点的方法，来逐一改变点的位置实现图形的移动。 先编写顶点着色器，需要单独定义a，b来分别改变点的x方向和y方向，基本代码如下：1234567891011const vertexShaderSource = ` attribute vec4 pos; uniform float a; uniform float b; void main() &#123; gl_Position.x = pos.x + a; gl_Position.y = pos.y + b; gl_Position.z = .0; gl_PointSize = 10.0;&#125;` 片元着色器代码和之前写法基本一致，基本代码如下：1234const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,0.5,0.0,1.0); &#125;` 给顶点着色器中的变量定义响应的location，基本代码如下：123var posLocation = cxt.getAttribLocation(program, 'pos');var aLocation = cxt.getUniformLocation(program, 'a');var bLocation = cxt.getUniformLocation(program, 'b'); 使用setTimeOut函数定义简单的平移效果，基本代码如下：1234567891011121314run(); function run() &#123; cxt.uniform1f(aLocation, a); cxt.uniform1f(bLocation, b); cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.drawArrays(cxt.TRIANGLES, 0, 3); a += .05; b += .05; setTimeout(run, 500) &#125; 图形的缩放原理 基于原点，基于定义的某一个点进行缩小和放大(其实还做了平移操作) 在着色器中，逐顶点乘以缩放的倍数，对x轴和y轴同时进行缩放 编写顶点着色器,定义一个cj变量，通过x轴和y轴同时乘以cj这个变量，来实现逐顶点缩放，基本代码如下： 1234567891011 const vertexShaderSource = ` attribute vec4 pos; uniform float cj; void main() &#123; gl_Position.x = pos.x * cj; gl_Position.y = pos.y * cj; gl_Position.z = .0; gl_Position.w = 1.0; gl_PointSize = 10.0;&#125;` 定义cjLocation，代码如下：1var cjLocation = cxt.getUniformLocation(program, 'cj'); 定义基本渲染函数render，再单独定义放大缩小函数，基本代码如下：1234567891011121314151617var cj = 1.0; render(); function render() &#123; cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.uniform1f(cjLocation, cj); cxt.drawArrays(cxt.TRIANGLES, 0, 3); &#125; function fangda() &#123; cj += .05; render() &#125; function suoxiao() &#123; cj -= .05; render() &#125; 利用w快速缩放修改着色器代码，将vec4改成vec2，基本意思就是pos存在x和y两个点，基本修改后如下： 1234567 const vertexShaderSource = ` attribute vec2 pos; uniform float w; void main() &#123; gl_Position = vec4(pos,0.0,w);&#125;` 该方法实现效果刚好和vec4的时候相反，基本原因是vec4(x/w,y/w,z/w,w),所以w越大，其实x和y轴会越小，所以最终放大效果和之前是相反的。 图形的旋转原理 基于原点，以一定的角度旋转 在顶点着色器中，更改gl.Position.x和gl.Position.y的值 旋转方程 x = r.cos(a) y = r.sin(a) x1 = r.cos(a+b) y1 = r.sin(a+b) x1 = x.cos(b) - y.sin(b) y1 = x.sin(b) + y.cos(b) z1 = z = 0.0 顶点着色器代码基本写法如下： 1234567891011const vertexShaderSource = ` attribute vec4 pos; uniform float cosB; uniform float sinB; void main() &#123; gl_Position.x = pos.x * cosB - pos.y * sinB; gl_Position.y = pos.x * sinB + pos.y * cosB; gl_Position.z = .0; gl_Position.w = 1.0;&#125;` 实现简单动画基本如下： 12345678910111213141516var angle = 10.0; function render() &#123; var t = Math.PI * angle / 180; var cosB = Math.sin(t); var sinB = Math.cos(t); cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.uniform1f(cosBLocation, cosB); cxt.uniform1f(sinBLocation, sinB); cxt.drawArrays(cxt.TRIANGLES, 0, 3); &#125; setInterval(() =&gt; &#123; angle += 1.0; render(); &#125;, 1000) 矩阵变换实现图形的移动原理 图形的移动，实际上就是定量改变顶点的位置。 在顶点着色器中，顶点修改是逐个进行的，且偏移值一致。 只要改变Tx,Ty,就能分别改变图形的x方向和y方向 在顶点着色器中定义一个xf举证变量，基本代码如下： 1234567const vertexShaderSource = ` attribute vec4 pos; uniform mat4 xf; void main() &#123; gl_Position = xf * pos;&#125;` 定义一个矩阵代码： 123456var xf = new Float32Array([ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, Tx, Ty, 0.0, 1.0 ]); 只需要通过改变Tx，Ty就能实现改变图形的移动，并不需要改变着色器代码，这样效率会很高，render函数基本如下：12345678910111213141516var Tx = 1.0, Ty = 0.0; function render() &#123; var xf = new Float32Array([ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, Tx, Ty, 0.0, 1.0 ]); cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.uniformMatrix4fv(xfLocation,false,xf); cxt.drawArrays(cxt.TRIANGLES, 0, 3); &#125; render() 矩阵变换实现图形的缩放原理 基于原点。 在着色器中，逐顶点乘以缩放倍数 Sx,Sy改变就会使得图形成比例的缩放 主要是矩阵函数不一样，其他基本一样，代码基本如下：123456789101112131415161718var sx = 1.0, sy = 1.0; function render() &#123; var xf = new Float32Array([ sx, 0.0, 0.0, 0.0, 0.0, sy, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ]); cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.uniformMatrix4fv(xfLocation, false, xf); cxt.drawArrays(cxt.TRIANGLES, 0, 3); &#125; render() 矩阵变换实现图形的旋转原理 基于原点，以一定的角度旋转。 在顶点着色器中，更改 gl_Position.x 和 gl_Position.y 值。 实现一个时钟指针的旋转，并且控制其速度和开关。 定义一个顶点着色器和片元着色器，基本代码如下：1234567891011121314// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; uniform mat4 xf; void main() &#123; gl_Position = xf * pos;&#125;` // 片元着色器程序 const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,.0,.0,1.0); &#125;` 最终render函数基本如下：123456789101112131415161718192021222324252627var time; function render() &#123; angle += zl; t = Math.PI * angle / 180; sinB = Math.sin(t); cosB = Math.cos(t); var xf = new Float32Array([ cosB, sinB, 0.0, 0.0, -sinB, cosB, 0.0, .0, 0.0, .0, 1.0, .0, 0.0, .0, .0, 1.0 ]); cxt.uniformMatrix4fv(xfLocation, false, xf); cxt.clearColor(.5, .5, .5, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.drawArrays(cxt.LINES, 0, 2); time = setTimeout(render, 500); if (!isOpen) &#123; clearTimeout(time); &#125; &#125; render() 最终效果如下图： WebGL动画原理原理 通过 setTimeout 定时渲染 每次渲染都用背景色刷屏 每次渲染都修改变换参数 变换矩阵A 变换矩阵B 原始顶点坐标矢量 ＝ 最终顶点坐标矢量 基本步骤 编写着色器代码 编写基础代码 编写平移和缩放代码 开发平移且缩放小动画 编写着色器代码，示例如下： 123456789101112131415// 顶点着色器程序 const vertexShaderSource = ` attribute vec4 pos; uniform mat4 xz; uniform mat4 py; void main() &#123; gl_Position = pos * xz * py;&#125;` // 片元着色器程序 const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,.0,.0,1.0); &#125;` 编写基础代码，上下文确定，buffer编写以及buffer数据加载等等，基本代码如下：1234567891011121314151617181920var cxt = document.getElementById('example08').getContext('webgl'); var buffer = cxt.createBuffer(); cxt.bindBuffer(cxt.ARRAY_BUFFER, buffer); var data = new Float32Array([ 0.0, 0.2, -.2, -.2, .2, -.2, ]); cxt.bufferData(cxt.ARRAY_BUFFER, data, cxt.STATIC_DRAW); var program = initShader(cxt, vertexShaderSource, fragmentShaderSource); var posLocation = cxt.getAttribLocation(program, 'pos'); var xzLocation = cxt.getUniformLocation(program, 'xz'); var pyLocation = cxt.getUniformLocation(program, 'py'); cxt.vertexAttribPointer(posLocation, 2, cxt.FLOAT, false, 0, 0); cxt.enableVertexAttribArray(posLocation); 定义平移矩阵和缩放矩阵代码：123456789101112131415var xz = new Float32Array([ cosB, sinB, 0.0, 0.0, -sinB, cosB, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ]); var py = new Float32Array([ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, tx, ty, 0.0, 1.0 ]); cxt.uniformMatrix4fv(xzLocation,false, xz); cxt.uniformMatrix4fv(pyLocation,false, py); 最终加入setTimeOut函数的run方法代码如下： 123456789101112131415161718192021222324252627282930313233343536function run() &#123; var t = Math.PI * ANGLE / 180; sinB = Math.sin(t); cosB = Math.cos(t); var xz = new Float32Array([ cosB, sinB, 0.0, 0.0, -sinB, cosB, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ]); tx += .005; ty += .005; ANGLE += 1; var py = new Float32Array([ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, tx, ty, 0.0, 1.0 ]); cxt.uniformMatrix4fv(xzLocation,false, xz); cxt.uniformMatrix4fv(pyLocation,false, py); cxt.clearColor(0.0, 0.0, 0.0, 1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.drawArrays(cxt.TRIANGLES, 0, 3); setTimeout(run, 500) &#125; run(); 矩阵复合变换 复合变换是多种变换同时进行，通过4 * 4 矩阵相乘得出来的结果，可以使用上面的示例，简化着色器中定义的矩阵变量。 开发一个矩阵运算方法，基本原理如下图： 完整方法代码如下：123456789101112function mix(a, b) &#123; var result = new Float32Array(16); for (var i = 0; i &lt; 4; i++) &#123; result[i] = a[i] * b[0] + a[i + 4] * b[1] + a[i + 8] * b[2] + a[i + 12] * b[3]; result[i + 4] = a[i] * b[4] + a[i + 4] * b[5] + a[i + 8] * b[6] + a[i + 12] * b[7]; result[i + 8] = a[i] * b[8] + a[i + 4] * b[9] + a[i + 8] * b[10] + a[i + 12] * b[11]; result[i + 12] = a[i] * b[12] + a[i + 4] * b[13] + a[i + 8] * b[14] + a[i + 12] * b[15]; &#125; return result; &#125; 简化着色器代码，基本如下：12345678910111213const vertexShaderSource = ` attribute vec4 pos; uniform mat4 xf; void main() &#123; gl_Position = pos * xf;&#125;` // 片元着色器程序 const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,.0,.0,1.0); &#125;` 简化Location和矩阵数据导入的函数方法，剩余代码和前面的动画原理示例一样，片段代码如下：12var xfLocation = cxt.getUniformLocation(program, 'xf');cxt.uniformMatrix4fv(xfLocation, false, mix(xz,py)); 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/05","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--基本图形绘制","date":"2017-07-04T13:09:11.000Z","path":"webgl-2017-07-04/","text":"点的绘制单点绘制 gl.drawArrays( gl.POINTS, start , count ) gl.POINTS，标示绘制点的 start 起始位置 count 绘制数量，绘制点的个数不能超过在buffer中存在点的个数 多点绘制 采用 javascript 循环，实现多点绘制 采用 WebGL 缓冲区对象，实现多点绘制 上一节代码示例中分别采用了循环绘制点和使用缓冲区对象绘制点，详细请查看上一节内容。 线段绘制绘制单线段 gl.drawArray( gl.LINES , start , count ) gl.LINES，可以绘制一条线，也可以绘制多条线 绘制一条线 绘制多条线 最重要的画线代码如下： 1cxt.drawArrays(cxt.LINES,0,4); 绘制多线段 gl.drawArray( gl.LINE_STRIP , start , count ) gl.LINE_STRIP 绘制线段带 例如绘制一个矩形框需要定义五个点才能绘制出来，线段带是没有绘路的概念 绘制一个矩形重要的相关代码如下： 1234567891011//类型化数组定义五个点var data = new Float32Array([ -.5,.5, .5,.5 , .5, -.5, -.5, -.5, -.5,.5]);// 最终绘制也是绘制5个点cxt.drawArrays(cxt.LINE_STRIP,0,5); 绘制回路线段 gl.drawArray( gl.LINE_LOOP , start , count ) gl.LINE_LOOP 自动闭合线段，例如绘制矩形只需要4个点即可，默认会将最后一个点和第一个开始的点连接起来 绘制一个矩形重要的相关代码如下： 1234567891011//类型化数组定义4个点var data = new Float32Array([ -.5,.5, .5,.5 , .5, -.5, -.5, -.5, -.5,.5]);// 最终绘制也是绘制5个点cxt.drawArrays(cxt.LINE_LOOP,0,4); 使用gl.LINE_LOOP绘制一个领结形状的图形，其实只是利用了LINE_LOOP自动闭合线段绘制出来的，核心片段代码如下：12345678910//类型化数组定义4个点var data = new Float32Array([ -.5, .5, .5, .5, -.5, -.5, .5, -.5]);// 最终绘制也是绘制5个点cxt.drawArrays(cxt.LINE_LOOP,0,4); 运行效果图如下： 多边形绘制绘制三角形 gl.drawArray( gl.TRIANGLES , start , count ) gl. TRIANGLES 核心代码片段如下：1234567var data = new Float32Array([ 0,0, -.5,-.5 , .5, -.5]);cxt.drawArrays(cxt.TRIANGLES,0,3); 运行效果图如下： 绘制三角带 gl.drawArray( gl.TRIANGLE_STRIP , start , count ) gl.TRIANGLE_STRIP 绘制一个平行四边形的核心代码如下：12345678var data = new Float32Array([ -.3,.3, .5,.3, -.5, -.3, .3, -.3 ]);cxt.drawArrays(cxt.TRIANGLE_STRIP,0,4); 运行效果图如下： 绘制三角扇 gl.drawArray( gl.TRIANGLE_FAN , start , count ) gl.TRIANGLE_FAN 绘制一个六边形的核心代码如下：123456789101112var data = new Float32Array([ .0,0, -.3,.5, -.6,.3, -.3, -.3, .3, -.3, .6, .3, .4,.5, -.3,.5 ]);cxt.drawArrays(cxt.TRIANGLE_FAN,0,8); 运行效果图如下： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/04","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--缓冲区对象","date":"2017-07-03T13:09:11.000Z","path":"webgl-2017-07-03/","text":"attribute 变量的使用主要职能是在顶点着色器当中使用的，只能被申明为全局变量，用来表示顶点的信息，比如一个图形中包含多个顶点，顶点着色器是针对逐顶点进行运算的，都会传导到attribute变量中，然而，两个顶点之间的部分是不会被传导到顶点着色器中的。 这个变量只能支持矢量和矩阵两种类型，attribute变量的个数限制和设备有关系，最小支持8个attribute变量。 在顶点着色器中，声明 attribute 变量 将 attribute 变量赋值给 gl_Position 变量 向 attribute 变量传递数据 首先创建顶点着色器的基本代码： 1234567// 顶点着色器程序const vertexShaderSource = `attribute vec4 apos; void main() &#123; gl_Position = apos; gl_PointSize = 10.0;&#125;` 书写基本的片元着色器的代码：12345// 片元着色器程序const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,0.5,0.0,1.0); &#125;` 获取webgl上下文代码：1var cxt = canvas.getContext('webgl'); 获得顶点着色器和片元着色器对象,并且把源代码写入到顶点着色器及片元着色器中去，然后进行编译，片段代码如下：123456var vertexShader = cxt.createShader(cxt.VERTEX_SHADER);var fragmentShader = cxt.createShader(cxt.FRAGMENT_SHADER);cxt.shaderSource(vertexShader,vertexShaderSource);cxt.shaderSource(fragmentShader,fragmentShaderSource);cxt.compileShader(vertexShader);cxt.compileShader(fragmentShader); 创建program，并且将顶点着色器和片元着色器附着在program上，代码如下12345var program = cxt.createProgram();cxt.attachShader(program,vertexShader);cxt.attachShader(program,fragmentShader);cxt.linkProgram(program);cxt.useProgram(program); 得到顶点着色器中的变量apos，片段代码如下：1var aposLocation = cxt.getAttribLocation(program,'apos'); 清屏处理，代码如下：12cxt.clearColor(0.2,0.2,0.2,1.0);cxt.clear(cxt.COLOR_BUFFER_BIT); 通过for循环来绘制多个点，代码如下：1234for(var i= 0,num = points.length;i&lt;num;i++)&#123; cxt.vertexAttrib4f(aposLocation,points[i].x,points[i].y,1.0,1.0); cxt.drawArrays(cxt.POINTS,0,1);&#125; 缓冲区对象的创建、绑定、写入数据缓冲区对象是什么 绘制面所必需的技术 一次性写入多个顶点数据 一块内存区域 创建缓冲区对象 创建缓冲区的方法 var buffer = gl.createBuffer() 根据返回值判断是否创建成功 绑定缓冲区方法 gl.bindBuffer(gl.ARRAY_BUFFER , buffer) 写入数据 gl.bufferData(gl.ARRAY_BUFFER , data , gl.STATIC_DRAW) data 是类型化数组 gl.STATIC_DRAW，一次写入多次绘制 gl.STREAM_DRAW，一次写入多次绘制，比第一次调用的少 gl.DYNAMIC_DRAW，多次写入多次绘制 类型化数组接口都是通过类型化数组来进行通信 Int8Array Uint8Array Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array 缓冲区数据导入 attribute 变量 vertexAttribPointer(location , size , type , normalized , stride , offset ) 错误信息 INVALID_OPERATION，表示没有可用的program对象 错误信息 INVALID_VALUE，表示attribute的最大值已经超出的范围 enableVertexAttribArray(location)，激活localtion 错误信息 INVALID_OPERATION，表示没有可用的program对象 代码分析创建类型化数组对象1234567var data = new Float32Array([ -1.0,1.0, 1.0,1.0, -1.0,-1.0, 1.0,-1.0, 0.0,0.0]); 创建buffer和绑定baffer片段代码如下：12var buf = cxt.createBuffer();cxt.bindBuffer(cxt.ARRAY_BUFFER,buf); 将类型化数组绑定到缓冲区中：1cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW); 将缓冲区数据导入attribute变量中：12cxt.vertexAttribPointer(aposLocation,2,cxt.FLOAT,false,0,0);cxt.enableVertexAttribArray(aposLocation); 开始绘制，代码如下：123cxt.clearColor(0.0,0.5,0.5,1.0);cxt.clear(cxt.COLOR_BUFFER_BIT);cxt.drawArrays(cxt.POINTS,0,5); 完整代码如下：1234567891011121314151617181920212223242526272829303132333435&lt;canvas id=\"e03\" width=\"500\" height=\"500\"&gt;&lt;/canvas&gt;&lt;script src=\"../lib.js\"&gt;&lt;/script&gt;&lt;script&gt; var canvas = document.getElementById('e03'); var cxt = canvas.getContext('webgl'); // 顶点着色器程序 const vertexShaderSource = `attribute vec4 apos; void main() &#123; gl_Position = apos; gl_PointSize = 10.0; &#125;` // 片元着色器程序 const fragmentShaderSource = `void main() &#123; gl_FragColor = vec4(1.0,0.5,0.0,1.0); &#125;` var program = initShader(cxt,vertexShaderSource,fragmentShaderSource); var aposLocation = cxt.getAttribLocation(program,'apos'); var buffer = cxt.createBuffer(); cxt.bindBuffer(cxt.ARRAY_BUFFER,buffer); var data = new Float32Array([ -1.0,1.0, 1.0,1.0, -1.0,-1.0, 1.0,-1.0, 0.0,0.0 ]); cxt.bufferData(cxt.ARRAY_BUFFER,data,cxt.STATIC_DRAW); cxt.vertexAttribPointer(aposLocation,2,cxt.FLOAT,false,0,0); cxt.enableVertexAttribArray(aposLocation); cxt.clearColor(0.0,0.5,0.5,1.0); cxt.clear(cxt.COLOR_BUFFER_BIT); cxt.drawArrays(cxt.POINTS,0,5);&lt;/script&gt; 运行效果图如下： 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/03","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--基本概述","date":"2017-07-02T13:09:11.000Z","path":"webgl-2017-07-02/","text":"WebGL是什么在浏览器绘制3D图形的的一门技术，是内嵌在浏览器中，目前支持高版本浏览器，因此不需要安装任何插件，同样也支持多平台运行，它是基于OpenGL ES 2.0技术。 优势 快速传播 维护简单 跨平台性 开放的标准 硬件加速 无需安装插件 充分利用浏览器功能 图形API模式即时模式，每一帧的场景不管是否发生了变化，都需要重新绘制，提供API的图形库并没有保存需要绘图场景的内部模型，但是应用程序需要在内存中用自己的方式表示场景，这种设计模式大大提高了应用程序的灵活性和控制的能力，但是需要应用程序执行更多的操作，如跟踪场景的模型，应用初始化等等，包括清除操作。webGL采用的是即时模式，非常灵活，但是相对而言手工代码会多一点。 保留模式，它的API保留了所有图形库的模型和场景，但应用程序调用保留模式API时需要更新内部的模型，图形库决定在什么时候执行实际的绘制方法，这意味着不需要为每一帧场景重新绘制命令，因此保留模式API似乎更容易使用。 图像硬件介绍 WebGL程序执行原理图形流水线 通过顶点来确定图形，具备形状之后内部时空的，通过光栅化进行“面积”的填充，然后进入片元着色器，进入“绘图”过程，类似上色过程，再次进逐片元操作 定点着色器 顶点着色器源代码，javascript字符串形式表示出来 内置变量，名字不可辨，区分大小写 自定义 Attribute 变量，表示每一个点的数据，可以定义多个 自定义 Uniform 变量，表示一个常量，是个恒定的，所有点的数据都是一样的 自定义 Varying 变量，定点着色器和片着色器传导数据用的 片元着色器 片元着色器源代码，javascript字符串形式表示出来 内置变量，名字不可辨，区分大小写 Uniform 和 Samplers，Samplers用来储存纹理 自定义 Varying 变量，定点着色器和片着色器传导数据用的 WebGL和HTML5及Javascript的关系 需要 HTML5 Canvas 元素，webgl和canvas画图都需要canvas这个api 用 Javascript 处理逻辑 可利用支持 HTML5 浏览器的一切功能 用 Javascript 字符串形式编写着色器源代码 基本示例代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body onload=\"main()\"&gt; &lt;canvas id=\"webgl\" width=\"500\" height=\"400\"&gt;&lt;/canvas&gt; &lt;script src=\"../lib/webgl-utils.js\"&gt;&lt;/script&gt; &lt;script src=\"../lib/webgl-debug.js\"&gt;&lt;/script&gt; &lt;script src=\"../lib/cuon-utils.js\"&gt;&lt;/script&gt; &lt;script&gt; // 顶点着色器程序 const VSHADER_SOURCE = `void main() &#123; gl_Position = vec4(1.0,0.0,0.0,1.0); gl_PointSize = 30.0; &#125;` // 片元着色器程序 const FSHADER_SOURCE = `void main() &#123; gl_FragColor = vec4(1.0,1.0,0.0,1.0); &#125;` function main() &#123; // 获取canvan元素 var canvas = document.getElementById(\"webgl\"); // 获取webgl绘图上下文 var gl = getWebGLContext(canvas, true); if (!gl) &#123; console.log('error'); return; &#125; // 初始化着色器 if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) &#123; console.log('error'); return; &#125; // 制定清空canvas的颜色 gl.clearColor(0.0, 0.0, 0.0, 1.0); // 清空canvas gl.clear(gl.COLOR_BUFFER_BIT); // 绘制一个点 gl.drawArrays(gl.POINTS, 0, 1); &#125; &lt;/script&gt;&lt;/body&gt; 源码链接请访问 https://github.com/wqzwh/webgl-code/tree/master/02","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"WebGL系列教程--3D图形学入门","date":"2017-07-01T13:09:11.000Z","path":"webgl-2017-07-01/","text":"3D的基本元素2D坐标系由x轴和y轴构成。其中，笛卡尔坐标系是最常见的2D坐标系。原点为（0.0），每个系统的坐标系不一样，有的系统y轴是正方向，有的是y轴的负方向为正方向。 HTML5 canvas2D坐标系,canvas坐标原点在左上角，从x为右是正方向，向下为y轴的正方向 示例代码片段：1234567891011121314151617&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;canvas id=\"canvas\"&gt;&lt;/canvas&gt;&lt;script&gt; var cxt = canvas.getContext('2d'); // 设置正方体左上角坐标（x，y） var x = 50; var y = 50; // 绘制正方形 cxt.fillRect(x,y,50,50);&lt;/script&gt; 效果如下： 修改x和y轴后展示效果如下：123// 设置正方体左上角坐标（x，y）var x = 0;var y = 0; 3D坐标系增加了表示深度的z轴，即3D物体离屏幕的深度。 WebGL坐标系的方向，向上为y轴的正方向，向右为x轴的正方向，从原点向外为z轴的正方向。绘图的可视范围是+1到-1之间 基本示例代码如下：12345 const VSHADER_SOURCE = `void main() &#123; gl_Position = vec4(1.0,0.0,0.0,1.0); gl_PointSize = 30.0;&#125;` webgl规定1.0为可视区域的最外层，不是像素值的意义。 三角形是基础图形，所有的图形都能根据三角形进行拼凑而成，也就是3D图形是由一个或者多个三角形组成；网格是由一个或者多个图形组成。 法线:始终垂直于某平面的虚线，在几何中，法线是指平面上垂直于曲线在某点切线的直线。法线和切线的交点称作切点，法线在3D绘图当中尤其在切图当中起到很大作用，通常的切图会失真，用法线切图方式算法的切图效果相对比较逼真。 3D的变换概念变换：变换的原理是对顶点的改变，变换的方式有三种，分别是缩放、平移、旋转。 旋转规定Z轴不变，定义初始旋转角度变量，示例代码我们先用着色器来计算顶点坐标位置，性能会比较低，在实际开发中，会定义矩阵来计算复杂的位置，示例代码片段如下：12345678910111213141516171819// 定义旋转角度var ANGLE = 30.0;const VSHADER_SOURCE = ` attribute vec4 a_Position; uniform float u_CosB,u_SinB; attribute float a_PointSize; void main() &#123; gl_Position.x = a_Position.x * u_CosB - a_Position.y * u_SinB; gl_Position.y = a_Position.x * u_SinB - a_Position.y * u_CosB; gl_Position.z = a_Position.z; gl_Position.w = 1.0; &#125;`// 片元着色器程序const FSHADER_SOURCE = ` precision mediump float; uniform vec4 u_FragColor; void main() &#123; gl_FragColor = vec4(1.0,1.0,0.0,1.0); &#125;` 矩阵：解决的复杂是针对着色器的，在实际开发中，应保证着色器的简单，因为着色器越复杂性能就越低。在webgl中矩阵可以理解为是一种数据类型，专门处理复杂的计算，可以进行乘法和加法的运算。代码片段如下：1234567891011121314// 定义矩阵的方式来处理变换效果// 定义旋转角度var ANGLE = 30.0;const VSHADER_SOURCE = ` attribute vec4 a_Position; uniform mat4 u_xformMatrix; //定义矩阵来变化 void main() &#123; gl_Position = u_xformMatrix * a_Position; &#125;`// 片元着色器程序const FSHADER_SOURCE = ` void main() &#123; gl_FragColor = vec4(1.0,1.0,0.0,1.0); &#125;` 网格表面纹理与材质：纹理可以定义网格表面的外观，例如在模型上贴一张图片；材质是网格表面的特性，也就是光滑度、透明度等等。光照原理：光线方向决定物体的明暗度与阴影,在着色过程中，需要考虑光源类型与反射类型。光照类型：平行光（从一个方向平行的打在一个物体上，有方向感的）、点光源光（由中心光源散发出来的光线，越往四周光线越弱）、环境光（在任何一个地方，光线的强弱都是一样的） 反射类型：漫反射光色由入射光色、表面漆色和入射角决定，环境反射由入射光色和表面漆色决定。 着色器代替传统的固定渲染管线，固定的渲染管线是不可变的；着色器具有可编程性的；着色器分为，顶点着色器和片元着色器。 顶点着色器：顶点着色器用来描述顶点的位置、颜色的程序，写法类似c语言，会定义一个主函数main，同时有系统变量，这个变量是不可以变的，变量对应的值是强类型，片段代码如下： 1234void main() &#123; gl_Position = vec4(0.0,0.0,0.0,1.0); gl_PointSize = 20.0;&#125; 片元着色器：对网格表面像素的处理程序，例如网格表面的贴图就需要用到片元着色器，系统变量对应的值是不能超过1.0的，片段代码如下： 123void main()&#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0);&#125; 3D世界相机、视口、投影：相机角度的不同，观察物力的景象就是不同的，远近决定观察看到物体的大小不同，图片中绿色的区域表示视口，也就是canvas决定的，它的大小决定了可视化的范围，红色部分表示场景显示最远能够到哪里，两者之间的可视化锥体，就代表可视化的范围，最终的影像会在视口中呈现出来，大小是由相机决定的。投影的概念就是物体投影在前方视口最终形成的影像。 这一节简要的介绍了以上几个概念的基本知识，下一节将介绍WebGL的基本概念。后期所有的例子都会提供源码供大家下载。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"webgl","slug":"webgl","permalink":"http://www.iwangqi.com/tags/webgl/"}]},{"title":"React深入浅出系列--如何设计高质量的React组件","date":"2017-06-12T13:09:11.000Z","path":"2017-06-12/","text":"组件的设计要素在项目开发初期，针对模块或者组件的分配是及其重要，基本会按照“分而治之”的思想去合理的设计组件的功能以及扩展它们的复用性等等。拆分组件最关键的就是确定组件功能的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的职责，那这两个组件本身就不该被拆分，作为同一个组件或许更加合理。 组件的划分需要满足两个基本原则：高内聚和低耦合 高内聚:把逻辑紧密相关的内容放在一个组件中。早期开发html、css、js基本会以三个不同的文件存放，这样其实是违背高聚合的原则，react正好提供将跟组件相关的css、js、html放在一起的语法结构，这样一来，组件的复用性能够达到极致。 低耦合:不同的组件之间的依赖关系要尽量弱化。也就是每个组件要尽量独立。保持整个系统的低耦合度，让不同的组件去实现不同的功能，复杂的功能是通过细分的组件组装起来完成的，这样设计的话，方便开发者写出低耦合的系统。 react组件的数据react组件的数据主要分两种：prop和state。无论prop、state的改变都可能引发组件的渲染，其实react有基本的规范，prop主要作为组件对外部的接口，负责接受其他组件传过来的数据参数等，state主要是组件内部定义的数据状态，仅仅属于当前组件内部使用，片段代码如下： 123456789101112131415161718192021222324252627282930// 定义一个子组件class Counter extends Component &#123; constructor(props) &#123; // 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props super(props); //使用state定义自己内部状态数据 this.state = &#123; text: 1 &#125; &#125; render() &#123; const &#123;caption&#125; = this.props; //通过this.props来获取父亲组件传进来的caption值 return ( &lt;div className=\"App\"&gt; &#123;this.state.text&#125; &lt;/div&gt; ); &#125;&#125;// 定义一个父组件class ControlPanel extends Component &#123; render() &#123; console.log('enter ControlPanel render'); return ( &lt;div style=&#123;style&#125;&gt; &lt;Counter caption=\"First\"/&gt; &lt;/div&gt; ); &#125;&#125;; React中的prop给prop赋值和读取prop的值，以下只是代码片段，主要为了解释那些是赋值那些是读取值1234567891011121314//在构造函数中读取父组件传过来的值constructor(props) &#123; // 在构造函数中定义super主要是为了接受父组件传进来的参数，保证内部正常使用this.props super(props); //使用state定义自己内部状态数据 this.state = &#123; text: 1 &#125; &#125;//在render函数中返回一个组件，并且带上要给该组件传递的数据 return ( &lt;Counter caption=\"First\"/&gt;); 如果一个组件需要定义自己的构造函数，一定要在构造函数的第一行通过super调用父级也就是React.Component的构造函数，只有这样才能通过this.props来获取父级传下来的数据。因此常常会在构造函数中绑定this的指向，避免在render中多次绑定而造成性能问题。 propTypes的检查通过propTypes属性来定义prop规格，在组件渲染运行和静态代码检查时，都可以根据propTypes判断外部传递数据的格式是否正确，基本代码片段如下： 1234Counter.propTypes = &#123; caption:PropTypes.string.isRequired, initValue:PropTypes.number&#125; 其中要求caption必须是string类型，initValue必须是number类型，isRequired代表该caption必须传递，不能缺失，而initValue可以不传。 所以在具体项目开发中，最好的方式是，在开发模式下带上propTypes，而在上线的时候可以去掉这些代码，可以用babel-react-optimize工具自动去除propTypes，这样部署到产品环境的代码就会更优。 React中的statestate代表组件内部状态，常常用来定义组件内部初始值。组件内部的state必须是一个对象，不能是string或者number这样简单的数据类型。基本使用如下： 123456constructor(props) &#123; this.state = &#123; text: 1, // 使用state定义自己内部状态数据 num:props.num || 1 // 接受父组件传来的参数 &#125; &#125; 在当前组件对象内部通过this.state来访问内部定义的变量，如果要改变状态千万不要直接通过this.state赋值改变，使用react提供的setState这个方法来改变状态，这样改变能够直接触发组件重新render使得界面绑定的相应的状态更新。 prop和state的对比 prop用于定义外部接口，state用于定义内部状态； prop的赋值在外部世界使用组件时，state的赋值在组件内部； 组件不应该改变prop的值，而state存在的目的就是让组件来改变的； 一个子组件去修改props中的值，就是违背react的设计初衷，如果必须修改，建议使用组件内部状态先保存props，然后通过改变组件内部状态变相改变了props。 使用prop建立组件间的通信应用示例如下： 使用prop建立组件间的通信原理就是在子组件内部定义改变内部状态的方法并且触发父组件改变父组件的方法，并且在自组件自定一个空函数作为父子组件通信的桥接。 具体实现代码如下，我们现在Counter子组件中定义需要改变状态的方法，除了触发改变内部状态的updateCount方法，同时也会触发父组件的this.props.onUpdate方法：123456789101112131415onClickIncrementButton() &#123; this.updateCount(true);&#125;onClickDecrementButton() &#123; this.updateCount(false);&#125;updateCount(isIncrement) &#123; const previousValue = this.state.count; const newValue = isIncrement ? previousValue + 1 : previousValue - 1; this.setState(&#123;count: newValue&#125;) this.props.onUpdate(newValue, previousValue)&#125; 接下来我们定义一个默认的空函数，来桥接父子组件通信，代码片段如下： 12345678910Counter.propTypes = &#123; caption: PropTypes.string.isRequired, initValue: PropTypes.number, onUpdate: PropTypes.func&#125;;Counter.defaultProps = &#123; initValue: 0, onUpdate: f =&gt; f //什么都不做的函数&#125;; 并且在父组件中建立相应的更新方法，并且在render将onCounterUpdate方法以onUpdate名字传递给子组件中，自组件定义onUpdate来接受父组件传递下来的方法，从而解决了父子组件的通信，代码片段如下： 123456789101112131415onCounterUpdate(newValue, previousValue) &#123; const valueChange = newValue - previousValue; this.setState(&#123; sum: this.state.sum + valueChange&#125;);&#125;render() &#123; return ( &lt;div style=&#123;style&#125;&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"First\" /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Second\" initValue=&#123;this.initValues[1]&#125; /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Third\" initValue=&#123;this.initValues[2]&#125; /&gt; &lt;hr/&gt; &lt;div&gt;Total Count: &#123;this.state.sum&#125;&lt;/div&gt; &lt;/div&gt; );&#125; 使用prop传递参数的局限从上面的示例不难看出，子组件和父组件都各自维护一套属于自己的状态，并且通过update来相互通信，如果update内部内部逻辑出现bug，这个时候，计数器的结果到底是子组件的对还是父组件的对呢，这个时候就需要共享状态的概念出现，通过一个全局状态来同步各个子组件内部的状态，开发者也只要关注共享全局状态走向就行。 组件状态不统一：全局状态同步状态： 如果一个系统中，存在多层嵌套组件，如果按照prop规则传递参数，岂不是非常麻烦，所以必须引入全局状态Redux，将在下节中为大家介绍基本的Redux思想及原理。 react生命周期介绍生命周期基本分成三个主要阶段： 装载过程，组件第一次渲染过程 更新过程，当组件重新渲染过程 卸载过程，组件从DOM中删除过程 装载过程依次调用一下生命周期函数方法(按照es6最新语法介绍)： constructor defaultProps componentWillMount render componentDidMount constructor这是es6中构造函数的写法，如果是无状态的React组件无需定义构造函数，因此定义构造函数基本的作用是： 初始化state，在组件定义个函数中需要访问state状态。 绑定函数的this上下文。 代码片段如下：12345constructor(props) &#123; super(props); this.onClickIncrementButton = this.onClickIncrementButton.bind(this); this.onClickDecrementButton = this.onClickDecrementButton.bind(this); &#125; defaultProps主要作用是给props定义初始值，基本写法如下：1234Counter.defaultProps = &#123; initValue: 0, onUpdate: f =&gt; f //什么都不做的函数&#125;; render主要作用返回一个JSX描述的结构，最终再交付给React来操作渲染，组件在有些情况下如果不需要返回JSX结构，可以通过返回null或者false来告诉React不渲染任何DOM元素。 注意：在render中不要操作对状态的改变，应该在自定义函数中改变 componentWillMount和componentDidMountcomponentWillMount在render函数之前调用，也就是DOM还没有挂载，这个时候如果调用this.setState修改状态也不会发生重新渲染，其实我们可以在创建构造函数中就做好在componentWillMount应该做的事情。此函数既可以在服务端被调用，也可以在浏览器端被调用。 componentDidMount在render之后调用，也就是挂载DOM的操作，如果一个父组件嵌套多个子组件，这个时候挂载DOM的顺序是等到子组件全部调用render函数之后再开始挂载相应子组件的DOM。该函数只能在浏览器端被调用。如果需要对DOM操作的话，建议可以在componentDidMount中定义函数进行操作。DOM挂载顺序结果如下： 更新过程 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate componentWillReceiveProps这个函数是根据新的props的值来计算出是不是要更新组件内部state状态。同同时，只要父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发componentWillReceiveProps函数运行。 在Counter组件中增加函数：123componentWillReceiveProps(nextProps) &#123; console.log('enter componentWillReceiveProps ' + this.props.caption) &#125; 在ControlPanel函数中定义强制更新函数：1234567891011121314render() &#123; console.log('enter ControlPanel render'); return ( &lt;div style=&#123;style&#125;&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"First\" /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Second\" initValue=&#123;this.initValues[1]&#125; /&gt; &lt;Counter onUpdate=&#123;this.onCounterUpdate&#125; caption=\"Third\" initValue=&#123;this.initValues[2]&#125; /&gt; &lt;button onClick=&#123; () =&gt; this.forceUpdate() &#125;&gt; Click me to re-render! &lt;/button&gt; &lt;hr/&gt; &lt;div&gt;Total Count: &#123;this.state.sum&#125;&lt;/div&gt; &lt;/div&gt; ); ControlPanel组件中触发了render函数，子组件中的componentWillReceiveProps都被触发了，但是并没有改变props的值，运行结果截图如下： 这个函数会接受nextProps参数，一般会用nextProps（这一次渲染传入的值）与this.props（上一次渲染传入的值）进行比较，只有两者有变化的时候才会调用this.setState更新内部状态。 shouldComponentUpdate主要作用根据nextProps, nextState接收的两个参数来判断组件是否需要执行render函数，react中这个函数如果不做任何设置，默认都是返回true，所以再做性能优化的时候，这个函数起到了至关重要的作用。在Counter组件中增加函数：1234shouldComponentUpdate(nextProps, nextState) &#123; return (nextProps.caption !== this.props.caption) || (nextState.count !== this.state.count); &#125; 改变任何一个值，只会触发当前这个组件调用render函数，运行结构如下： componentWillUpdate和componentDidUpdate只要shouldComponentUpdate函数返回为true，就会以此调用componentWillUpdate、render、componentDidUpdate这三个函数，同样这两个函数即可以在服务端调用也可以在浏览器端调用。 卸载过程这个过程主要是卸载不使用的组件DOM元素，或者使用非React方式创建的DOM元素，还是非常有作用的，例如，如果在componentDidMount中可以使用了js原生创建了DOM元素，但是在组件卸载过程中没有清楚，这个时候会造成内存泄露，所以在使用卸载组件的函数，必须确定相关的DOM都清除。 本篇简要的React组件的通信和基本的生命周期运行流程，在使用prop通信会有一定的局限，下节会引入Redux共享状态概念，来解决prop传递的局限，本篇涉及到的源码可以访问https://github.com/wqzwh/react-redux-demo/tree/master/src/demo/01","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"}]},{"title":"React深入浅出系列--React的工作方式","date":"2017-06-11T13:09:11.000Z","path":"2017-06-11/","text":"jQuery如何工作在讲解React的工作方式之前，先了解下jQuery的工作方式，我们使用jQuery给网页添加一个onclick事件基本写发如下：12345678910&lt;div&gt; &lt;button type=\"btn\" id=\"btn\"&gt;点击我&lt;/button&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $(\"#btn\").click(fucntion()&#123; // do some things &#125;) &#125;)&lt;/script&gt; 在jQuery的解决方案中，首先根据css规则找到id为btn的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。 但是对于庞大的项目，这种模式会造成代码结构复杂，难易维护，每个jQuery的使用者都会有这种体会。 React的理念react给dom添加事件并不是通过选择器选中某个dom，然后添加相应的事件，使用react开发，开发者不需要关心dom的组成结构，只需关注数据从哪里来，该去哪个组件中显示，也就是关心整个数据流的走向，通过render函数将相应的数据显示在界面上，如果需要更新界面，只需要找到相应的数据data更新即可，用户界面自然会做出响应，所以说react也是响应式编程。 Virtual DOM对于改变普通的html中的DOM会造成页面的重排和重绘，这也是前端性能优化主要的方面，就是尽量减少对DOM的操作。其实虚拟DOM说的简单点就是js动态生成的html标签在js内存中存储，并没有实际插入到页面当中。例如使用createElement（’Button’）和DocumentFragment创建虚拟的标签。简单的虚拟DOM代码示例如下，主要是方面从简单的层面理解虚拟DOM： 1234567var frag=document.createDocumentFragment();for(var i=0;i&lt;10;i++)&#123; var l=document.createElement(\"li\"); l.innerHTML=\"ss\"; frag.appendChild(l);&#125;document.getElementById(\"list\").appendChild(frag); 当然React中的虚拟DOM并没有像以上的例子这么简单，但是核心思想是这样的，相比直接操作DOM而言，通过操作js生成的DOM数结构改变映射到页面上的内容能提高不少性能。虚拟DOM就是对DOM树的抽象，仅仅是存在与javascript空间的树形结构，例如最简单的形式如下：1234567891011var a = &#123; type: 'a', props: &#123; children: 'React', className: 'link', href: 'facebook/react · GitHub' &#125;, _isReactElement: true&#125;React.render(a, document.body) 虚拟DOM中有个核心算法就是diff算法，主要实现以下三个步骤： 步骤一：用JS对象模拟DOM树 步骤二：比较两棵虚拟DOM树的差异 步骤三：把差异应用到真正的DOM树上react会根据diff算法计算出需要更新改变虚拟DOM，从而只更新页面中映射的那一小块DOM。对于diff算法以及react性能优化后期会单独用一节分析。 React工作方式的优点传统化的jquery的方式直观易懂，但是随着项目变得庞大时，用jquery写出的代码往往相互纠缠，难以维护。 使用react的方式，可以避免构建这样复杂的程序结构，无论何种事件，引发的都是react组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发这不需要关心。react利用函数式编程的思想来解决用户界面渲染问题，最大的优势能够提高开发效率，代码可维护性和可阅读性增强。 react会强制所有组件都按照这种由数据驱动渲染的模式来工作，无论应用多大，都让程序处于可控范围内。下一篇将为大家介绍如何设计高质量的React组件。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"}]},{"title":"React深入浅出系列--如何理解JSX","date":"2017-06-10T13:09:11.000Z","path":"2017-06-10/","text":"1、JSX介绍所谓JSX,是javascript的语法扩展，并不是一门新的编程语言，看起来有点像XML，让我们在javascript中可以编写像HTML一样的代码。例如以下示例代码：123456789101112class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;div className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;h2&gt;Welcome to React&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; JSX中的这几段代码看起来和HTML几乎一模一样，可以使用div,button之类的标签，但是，JSX和HTML之间还是有不同之处。 注意：React判断一个元素HTNML元素还是React组件的原则就是看第一个字母是否大写，小写的话，React会认为是HTML标签 12345678class App extends Component &#123; render() &#123; return ( &lt;hello/&gt; //默认认为是html标签，错误写法 &lt;Hello/&gt; //默认是自定义Hello组件 ); &#125;&#125; 2、事件绑定在早期时候绑定事件写法如下：1&lt;button onclick=\"checkAndSubmit(this.form)\"&gt;Submit&lt;/button&gt; 随着业务不断复杂，虽然这种写法便于阅读，但是复杂的业务加上复杂的DOM结构，为了html和js解耦，所以绑定事件写法有如下变化，通过获取DOM节点，通过代理机制来绑定事件：1$('#my-button').on('click', this.checkAndSubmit.bind(this)); 然而react中的JSX绑定事件的写法格式如下：1&lt;button onClick=&#123;this.checkAndSubmit.bind(this)&#125;&gt;Submit&lt;/button&gt; 大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。注意：在真正开发中，并不提倡给在组件添加事件中bind（this）这种写法，一般会在constructor的时候就绑定上下文this，这样在组件里面就不会因为多次绑定this而造成内存泄露。 3、JSX绑定事件和html绑定事件的区别 在html添加事件有如下问题： 1、在html中使用onclick添加的事件处理函数是在全局环境下执行的，这样会污染全局环境，很容易产生意料不到的后果。 2、给多个DOM添加onclick事件，可能会影响网页性能，毕竟，网页需要的事件处理函数越多，性能就会越低。 3、对于使用onclick的DOM元素，如果要动态地从DOM树中删掉的话，需要把对应的时间处理器注销，假如忘了注销，就可能造成内存泄露，这样的bug很难被发现。 以上说的这些问题在JSX中都不存在，其有如下特点： 1、JSX中添加onclick事件并没有直接在相应的html中添加事件，而是使用了事件委托的方式处理点击事件，无论有多少个onclick的出现，其实最后都只在DOM树上添加一个事件处理函数，并挂载在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定的函数，使用事件委托的性能比为每一个onclick都挂载一个事件函数要高。 2、jsx中同样可以添加自定义样式，外层定义一个样式对象，然后在jsx中将对象赋值给相应的dom上，这样真正意义上组件封装的思想（html，css，js在一起），提高复用性，大致写法如下：123456789101112class App extends Component &#123; render() &#123; const Style = &#123; margin:'10px' &#125; return ( &lt;div style=&#123;Style&#125;&gt; &lt;p&gt;测试文字&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 4、JSX编译JSX是一种新的语法，浏览器并不能直接运行，因此需要这种翻译器。这里我们推荐使用Babel编译JSX，打包编译建议使用Webpack，大致配置如下：12345module: &#123; loaders: [ &#123; test: /\\.jsx?$/, loaders: ['babel-loader']&#125; ]&#125; 本文主要介绍JSX优势所在，在添加事件上性能高于普通的html添加事件形式，组件方式的开发模式，更利于代码的通用性和维护性，下一篇将为大家介绍React的理念／Virtual DOM／工作方式的优点。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://www.iwangqi.com/tags/react/"}]},{"title":"如何使用vue-ssr做服务端渲染初体验(三)","date":"2017-06-05T12:09:11.000Z","path":"vue-ssr3/","text":"1、前言上一节大致介绍了服务端和客户端入口文件代码内容，现在已经可以正常运行你的后端渲染脚手架了，这一节，跟大家分享下如何使用axios做ajax请求，如何使用mockjs做本地假数据，跑通本地基本逻辑，为以后前后端连调做准备。 2、前期准备需要用npm安装axios，mockjs依赖包,由于mockjs只是代码开发的辅助工具，所以安装的时候我会加–save-dev来区分，具体可以根据自己的需求来定，当然，如果有mock服务平台的话，可以直接走mock平台造假数据，本地直接访问mock平台的接口，例如可以使用阿里的Rap平台管理工具生成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140npm install axios --savenpm install mockjs --save-dev``` &lt;!-- more --&gt;### 3、简要介绍axios&gt;其他请求方式，代码示例如下：``` javascriptaxios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]])``` &gt;具体详细可以点击查看&lt;a href=\"/2017-05-02/\" target=\"_blank\" &gt;axios基本使用介绍&lt;/a&gt;api.js完整代码如下：``` javascriptimport axios from 'axios'import qs from 'qs'import Q from 'q'/** * 兼容 不支持promise 的低版本浏览器 */require('es6-promise').polyfill();import C from '../conf'axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8'axios.defaults.withCredentials = truefunction ajax(url, type, options) &#123; return Q.Promise((resolve, reject) =&gt; &#123; axios(&#123; method: type, url: C.HOST + url, params: type === 'get' ? options : null, data: type !== 'get' ? qs.stringify(options) : null &#125;) .then((result) =&gt; &#123; if (result &amp;&amp; result.status === 401) &#123; // location.href = '/views/401.html' &#125; if (result &amp;&amp; result.status === 200) &#123; if (result.data.code === 200) &#123; resolve(result.data.data); &#125; else if (result.data.code === 401) &#123; reject(&#123; nopms: true, msg: result.data.msg &#125;); &#125; else &#123; reject(&#123; error: true, msg: result.data.msg &#125;); &#125; &#125; else &#123; reject(&#123; errno: result.errno, msg: result.msg &#125;); &#125; &#125;) .catch(function(error) &#123; console.log(error, url); &#125;); &#125;)&#125;const config = &#123; get(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'get', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, post(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'post', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, put(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'put', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, delete(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'delete', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;, jsonp(url, options) &#123; const _self = this; return Q.Promise((resolve, reject) =&gt; &#123; ajax(url, 'jsonp', options) .then((data) =&gt; &#123; resolve(data); &#125;, (error) =&gt; &#123; reject(error); &#125;); &#125;) &#125;&#125;;export default config; mockjs项目基本配置如下： 1、在public下新建conf.js全局定义请求url地址，代码如下：1234module.exports = &#123; HOST: \"http://www.xxx.com\", DEBUGMOCK: true&#125;; 2、在views/index根目录下新建conf.js，定义组件mock的请求路径，并且定义是否开始单个组件使用mock数据还是线上接口数据，代码如下：12345678910const PAGEMOCK = true;const MODULECONF = &#123; index: &#123; NAME: '首页', MOCK: true, API: &#123; GET: '/api/home', &#125; &#125;&#125;; 3、在组件内部定义mockjs来编写mock假数据，代码如下：1234567891011121314import Mock from 'mockjs';const mData = &#123; index: &#123; API: &#123; GET: &#123; \"code\": 200, \"data\": &#123; \"pin\": 'wangqi', \"name\": '王奇' &#125; &#125; &#125; &#125;&#125; 以上就是基本的流程，如果有更好更灵活的使用方案，希望能够参与沟通并且分享，项目工作流已经在github上分享，点击查看详情","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"如何使用vue-ssr做服务端渲染初体验(二)","date":"2017-06-02T12:09:11.000Z","path":"vue-ssr2/","text":"1、前言上一节我们大致讲了为什么需要使用vue后端渲染，以及vue后端渲染的基本原理，这节内容我们将从零开始搭建属于自己的vue后端渲染脚手架，当然不能不参考官方页面响应的实例vue-hackernews-2.0，从零开始搭建项目,源码在将在下节与大家共享。 2、前期准备基本环境要求：node版本6.10.1以上，npm版本3.10.10以上，本机环境是这样的，建议升级到官方最新版本。 使用的技术栈： 1、vue 2.4.22、vuex 2.3.13、vue-router 2.7.04、vue-server-renderer 2.4.25、express 4.15.46、axios 0.16.27、qs 6.5.08、q https://github.com/kriskowal/q.git9、webpack 3.5.010、mockjs 1.0.1-beta311、babel 相关插件 以上是主要是用的技术栈，在构建过程中会是用相应的插件依赖包来配合进行压缩打包，以下是npm init后package.json文件所要添加的依赖包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344\"dependencies\": &#123; \"axios\": \"^0.16.2\", \"es6-promise\": \"^4.1.1\", \"express\": \"^4.15.4\", \"lodash\": \"^4.17.4\", \"q\": \"git+https://github.com/kriskowal/q.git\", \"qs\": \"^6.5.0\", \"vue\": \"^2.4.2\", \"vue-router\": \"^2.7.0\", \"vue-server-renderer\": \"^2.4.2\", \"vuex\": \"^2.3.1\" &#125;, \"devDependencies\": &#123; \"autoprefixer\": \"^7.1.2\", \"babel-core\": \"^6.25.0\", \"babel-loader\": \"^7.1.1\", \"babel-plugin-syntax-dynamic-import\": \"^6.18.0\", \"babel-plugin-transform-runtime\": \"^6.22.0\", \"babel-preset-env\": \"^1.6.0\", \"babel-preset-stage-2\": \"^6.22.0\", \"compression\": \"^1.7.1\", \"cross-env\": \"^5.0.5\", \"css-loader\": \"^0.28.4\", \"extract-text-webpack-plugin\": \"^3.0.0\", \"file-loader\": \"^0.11.2\", \"friendly-errors-webpack-plugin\": \"^1.6.1\", \"glob\": \"^7.1.2\", \"less\": \"^2.7.2\", \"less-loader\": \"^2.2.3\", \"lru-cache\": \"^4.1.1\", \"mockjs\": \"^1.0.1-beta3\", \"style-loader\": \"^0.19.0\", \"sw-precache-webpack-plugin\": \"^0.11.4\", \"url-loader\": \"^0.5.9\", \"vue-loader\": \"^13.0.4\", \"vue-style-loader\": \"^3.0.3\", \"vue-template-compiler\": \"^2.4.2\", \"vuex-router-sync\": \"^4.2.0\", \"webpack\": \"^3.5.0\", \"webpack-dev-middleware\": \"^1.12.0\", \"webpack-hot-middleware\": \"^2.18.2\", \"webpack-merge\": \"^4.1.0\", \"webpack-node-externals\": \"^1.6.0\" &#125; 3、项目主目录搭建基本目录结构如下： ├── LICENSE├── README.md├── build│ ├── setup-dev-server.js│ ├── vue-loader.config.js│ ├── webpack.base.config.js│ ├── webpack.client.config.js│ └── webpack.server.config.js├── log│ ├── err.log│ └── out.log├── package.json├── pmlog.json├── server.js└── src ├── App.vue ├── app.js ├── assets │ ├── images │ ├── style │ │ └── css.less │ └── views │ └── index.css ├── components │ ├── Banner.vue │ ├── BottomNav.vue │ ├── FloorOne.vue │ └── Header.vue ├── entry-client.js ├── entry-server.js ├── index.template.html ├── public │ ├── conf.js │ └── utils │ ├── api.js │ └── confUtils.js ├── router │ └── index.js ├── static │ ├── img │ │ └── favicon.ico │ └── js │ └── flexible.js ├── store │ ├── actions.js │ ├── getters.js │ ├── index.js │ ├── modules │ │ └── Home.js │ ├── mutationtypes.js │ └── state.js └── views └── index ├── conf.js ├── index.vue ├── mock.js └── service.js 文件目录基本介绍： views文件夹下分模块文件，模块文件下下又分模块本身的.vue文件（模版文件），index.js文件（后台数据交互文件），mock.js（本模块的mock假数据），conf.js（配置本模块一些参数，请求路径，模块名称等信息） components 公共组件文件夹 router 主要存放前端路由配置文件，写法规范按照vue-router官方例子即可。 store 主要是存放共享状态文件，里面包含action.js,getter.js,mutationtype.js等，后期会根据模块再细分这些。 public 主要存放公共组件代码和项目使用的公共文件代码，例如后期我们将axios封装成公共的api库文件等等 static文件夹代表静态文件，不会被webpack打包的 app.js 是项目入口文件 App.vue 是项目入口文件 entry-client和entry-server分别是客户端入口文件和服务端的入口文件 index.template.html是整个项目的模版文件 开始编写app.js项目入口代码使用vue开发项目入口文件一般都会如下写法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import Vue from 'vue';import App from './index.vue';import router from './router'import store from './store';new Vue(&#123; el: '#app', store, router, render: (h) =&gt; h(App)&#125;);``` 这种写法是程序共享一个vue实例，但是在后端渲染中很容易导致交叉请求状态污染，导致数据流被污染了。&gt; 所以，避免状态单例,我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例，同样router和store入口文件也需要重新创建一个实例。为了配合webpack动态加载路由配置，这里会改写常规路由引入写法，这样可以根据路由路径来判断加载相应的组件代码：``` javascriptimport Home from '../views/index/index.vue'// 改写成component: () =&gt; ('../views/index/index.vue')``` 以下是路由的基本写法router，对外会抛出一个createRouter方法来创建一个新的路由实例：``` javascriptimport Vue from 'vue'import Router from 'vue-router';Vue.use(Router)export function createRouter() &#123; return new Router(&#123; mode: 'history', routes: [&#123; name:'Home', path: '/', component: () =&gt; import ('../views/index/index.vue') &#125;] &#125;)&#125;``` 以下是store状态管理的基本写法，对外暴露了一个createStore方法，方便每次访问创建一个新的实例：``` javascript// store.jsimport Vue from 'vue'import Vuex from 'vuex'import * as actions from './actions'import getters from './getters'import modules from './modules/index'Vue.use(Vuex)export function createStore() &#123; return new Vuex.Store(&#123; actions, getters, modules, strict: false &#125;)&#125;``` 结合写好的router和store入口文件代码来编写整个项目的入口文件app.js代码内容，同样最终也会对外暴露一个createApp方法，在每次创建app的时候保证router，store，app都是新创建的实例，这里还引入了一个vue路由插件vuex-router-sync，主要作用是同步路由状态(route state)到 store，以下是app.js完整代码：``` javascriptimport Vue from 'vue'import App from './App.vue'import &#123; createRouter &#125; from './router'import &#123; createStore &#125; from './store'import &#123; sync &#125; from 'vuex-router-sync'require('./assets/style/css.less');export function createApp () &#123; // 创建 router 和 store 实例 const router = createRouter() const store = createStore() // 同步路由状态(route state)到 store sync(store, router) // 创建应用程序实例，将 router 和 store 注入 const app = new Vue(&#123; router, store, render: h =&gt; h(App) &#125;) // 暴露 app, router 和 store。 return &#123; app, router, store &#125;&#125;``` #### entry-client.js代码编写：首页引入从app文件中暴露出来的createApp方法，在每次调用客户端的时候，重新创建一个新的app，router，store，部分代码如下：``` javascriptimport &#123; createApp &#125; from './app'const &#123; app, router, store &#125; = createApp() 这里我们会使用到onReady方法，此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染的时候，例子代码如下： 12345import &#123; createApp &#125; from './app'const &#123; app, router, store &#125; = createApp()router.onReady(() =&gt; &#123; app.$mount('#app')&#125;) 我们会调用一个新方法beforeResolve，只有在router2.5.0以上的版本才会有的方法，注册一个类似于全局路由保护router.beforeEach()，除了在导航确认之后，在所有其他保护和异步组件已解决之后调用。基本写法如下： 123456router.beforeResolve((to, from, next) =&gt; &#123; // to 和 from 都是 路由信息对象 // 返回目标位置或是当前路由匹配的组件数组（是数组的定义/构造类，不是实例）。通常在服务端渲染的数据预加载时时候。 const matched = router.getMatchedComponents(to) const prevMatched = router.getMatchedComponents(from)&#125;) 服务端把要给客户端的 state 放在了 window.INITIAL_STATE 这个全局变量上面。前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（INITIAL_STATE），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。基本代码如下：1234// 将服务端渲染时候的状态写入vuex中if (window.__INITIAL_STATE__) &#123; store.replaceState(window.__INITIAL_STATE__)&#125; 接下来贴出来完整的客户端代码，这里的Q也可以不用引入，直接使用babel就能编译es6自带的Promise，因为本人使用习惯了，这里可以根据自身的需求是否安装：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; createApp &#125; from './app'import Q from 'q'import Vue from 'vue'Vue.mixin(&#123; beforeRouteUpdate (to, from, next) &#123; const &#123; asyncData &#125; = this.$options if (asyncData) &#123; asyncData(&#123; store: this.$store, route: to &#125;).then(next).catch(next) &#125; else &#123; next() &#125; &#125;&#125;)const &#123; app, router, store &#125; = createApp()// 将服务端渲染时候的状态写入vuex中if (window.__INITIAL_STATE__) &#123; store.replaceState(window.__INITIAL_STATE__)&#125;router.onReady(() =&gt; &#123; router.beforeResolve((to, from, next) =&gt; &#123; const matched = router.getMatchedComponents(to) const prevMatched = router.getMatchedComponents(from) // 我们只关心之前没有渲染的组件 // 所以我们对比它们，找出两个匹配列表的差异组件 let diffed = false const activated = matched.filter((c, i) =&gt; &#123; return diffed || (diffed = (prevMatched[i] !== c)) &#125;) if (!activated.length) &#123; return next() &#125; // 这里如果有加载指示器(loading indicator)，就触发 Q.all(activated.map(c =&gt; &#123; if (c.asyncData) &#123; return c.asyncData(&#123; store, route: to &#125;) &#125; &#125;)).then(() =&gt; &#123; // 停止加载指示器(loading indicator) next() &#125;).catch(next) &#125;) app.$mount('#app')&#125;) entry-server.js代码编写：基本编写和客户端的差不多，因为这是服务端渲染，涉及到与后端数据交互定义的问题，我们需要在这里定义好各组件与后端交互使用的方法名称，这样方便在组件内部直接使用，这里根我们常规在组件直接使用ajax获取数据有些不一样，代码片段如下：1234567//直接定义组件内部asyncData方法来触发相应的ajax获取数据if (Component.asyncData) &#123; return Component.asyncData(&#123; store, route: router.currentRoute &#125;)&#125; 以下是完整的服务端代码：12345678910111213141516171819202122232425262728293031import &#123; createApp &#125; from './app'import Q from 'q'export default context =&gt; &#123; return new Q.Promise((resolve, reject) =&gt; &#123; const &#123; app, router, store &#125; = createApp() router.push(context.url) router.onReady(() =&gt; &#123; const matchedComponents = router.getMatchedComponents() if (!matchedComponents.length) &#123; return reject(&#123; code: 404 &#125;) &#125; // 对所有匹配的路由组件调用 `asyncData()` Q.all(matchedComponents.map(Component =&gt; &#123; if (Component.asyncData) &#123; return Component.asyncData(&#123; store, route: router.currentRoute &#125;) &#125; &#125;)).then(() =&gt; &#123; // 在所有预取钩子(preFetch hook) resolve 后， // 我们的 store 现在已经填充入渲染应用程序所需的状态。 // 当我们将状态附加到上下文， // 并且 `template` 选项用于 renderer 时， // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。 context.state = store.state resolve(app) &#125;).catch(reject) &#125;, reject) &#125;)&#125; 4、脚手架其他目录介绍：到这里src下面主要的几个文件代码已经编写完成，接下里介绍下整个项目的目录结构如下： 主要几个文件介绍如下： build 主要存放webpack打包配置文件 dist webpack打包后生成的目录 log 使用pm2监控进程存放的日志文件目录 server.js node服务器启动文件 pmlog.json pm2配置文件 server.js入口文件编写我们还需要编写在服务端启动服务的代码server.js，我们会使用到部分node原生提供的api，片段代码如下：1234567const Vue = require('vue')const express = require('express')const path = require('path')const LRU = require('lru-cache')const &#123; createBundleRenderer &#125; = require('vue-server-renderer')const fs = require('fs')const net = require('net') 大致思路是，引入前端模版页面index.template.html，使用express启动服务，引入webpack打包项目代码的dist文件，引入缓存模块（这里不做深入介绍，后期会单独详细介绍），判断端口是否被占用，自动启动其他接口服务。 引入前端模版文件并且设置环境变量为production，片段代码如下：12const template = fs.readFileSync('./src/index.template.html', 'utf-8')const isProd = process.env.NODE_ENV === 'production' vue-server-renderer插件的具体使用，通过读取dist文件夹下的目录文件，来创建createBundleRenderer函数，并且使用LRU来设置缓存的时间，通过判断是生产环境还是开发环境，调用不同的方法，代码片段如下：12345678910111213141516171819202122232425const resolve = file =&gt; path.resolve(__dirname, file)function createRenderer (bundle, options) &#123; return createBundleRenderer(bundle, Object.assign(options, &#123; template, cache: LRU(&#123; max: 1000, maxAge: 1000 * 60 * 15 &#125;), basedir: resolve('./dist'), runInNewContext: false &#125;))&#125;let renderer;let readyPromiseif (isProd) &#123; const bundle = require('./dist/vue-ssr-server-bundle.json') const clientManifest = require('./dist/vue-ssr-client-manifest.json') renderer = createRenderer(bundle, &#123; clientManifest &#125;)&#125; else &#123; readyPromise = require('./build/setup-dev-server')(server, (bundle, options) =&gt; &#123; renderer = createRenderer(bundle, options) &#125;)&#125; 使用express启动服务，代码片段如下：1234567891011121314151617181920const server = express()；//定义在启动服务钱先判断中间件中的缓存是否过期，是否直接调用dist文件。const serve = (path, cache) =&gt; express.static(resolve(path), &#123; maxAge: cache &amp;&amp; isProd ? 1000 * 60 * 60 * 24 * 30 : 0&#125;)server.use('/dist', serve('./dist', true))server.get('*', (req, res) =&gt; &#123; const context = &#123; title: 'hello', url: req.url &#125; renderer.renderToString(context, (err, html) =&gt; &#123; if (err) &#123; res.status(500).end('Internal Server Error') return &#125; res.end(html) &#125;)&#125;) 判断端口是否被占用，片段代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function probe(port, callback) &#123; let servers = net.createServer().listen(port) let calledOnce = false let timeoutRef = setTimeout(function() &#123; calledOnce = true callback(false, port) &#125;, 2000) timeoutRef.unref() let connected = false servers.on('listening', function() &#123; clearTimeout(timeoutRef) if (servers) servers.close() if (!calledOnce) &#123; calledOnce = true callback(true, port) &#125; &#125;) servers.on('error', function(err) &#123; clearTimeout(timeoutRef) let result = true if (err.code === 'EADDRINUSE') result = false if (!calledOnce) &#123; calledOnce = true callback(result, port) &#125; &#125;)&#125;const checkPortPromise = new Promise((resolve) =&gt; &#123; (function serverport(_port) &#123; let pt = _port || 8080; probe(pt, function(bl, _pt) &#123; // 端口被占用 bl 返回false // _pt：传入的端口号 if (bl === true) &#123; // console.log(\"\\n Static file server running at\" + \"\\n\\n=&gt; http://localhost:\" + _pt + '\\n'); resolve(_pt); &#125; else &#123; serverport(_pt + 1) &#125; &#125;) &#125;)()&#125;)checkPortPromise.then(data =&gt; &#123; uri = 'http://localhost:' + data; console.log('启动服务路径'+uri) server.listen(data);&#125;); 到这里，基本的代码已经编写完成，webpack打包配置文件基本和官方保持不变，接下来可以尝试启动本地的项目服务，这里简要的使用网易严选首页作为demo示例，结果如下： 下节，我将介绍下mockjs，axios怎么封装成公共函数便于使用","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"如何使用vue-ssr做服务端渲染初体验(-)","date":"2017-06-01T13:09:11.000Z","path":"vue-ssr/","text":"1、前言服务端渲染实现原理机制：在服务端拿数据进行解析渲染，直接生成html片段返回给前端。然后前端可以通过解析后端返回的html片段到前端页面，大致有以下两种形式： 1、服务器通过模版引擎直接渲染整个页面，例如java后端的vm模版引擎，php后端的smarty模版引擎。2、服务渲染生成html代码块, 前端通过AJAX获取然后使用js动态添加。 2、服务端渲染的优劣服务端渲染能够解决两大问题： 1、seo问题，有利于搜索引擎蜘蛛抓取网站内容，利于网站的收录和排名。2、首屏加载过慢问题，例如现在成熟的SPA项目中，打开首页需要加载很多资源，通过服务端渲染可以加速首屏渲染。 同样服务端渲染也会有弊端，主要是根据自己的业务场景来选择适合方式，由于服务端渲染前端页面，必将会给服务器增加压力。 3、SSR的实现原理客户端请求服务器，服务器根据请求地址获得匹配的组件，在调用匹配到的组件返回 Promise (官方是preFetch方法)来将需要的数据拿到。最后再通过 1&lt;script&gt;window.__initial_state=data&lt;/script&gt; 将其写入网页，最后将服务端渲染好的网页返回回去。 接下来客户端会将vuex将写入的 initial_state 替换为当前的全局状态树，再用这个状态树去检查服务端渲染好的数据有没有问题。遇到没被服务端渲染的组件，再去发异步请求拿数据。说白了就是一个类似React的 shouldComponentUpdate 的Diff操作。 Vue2使用的是单向数据流，用了它，就可以通过 SSR 返回唯一一个全局状态， 并确认某个组件是否已经SSR过了。 4、vue后端渲染主要插件：vue-server-renderer由于virtual dom的引入，使得vue的服务端渲染成为了可能，下面是官方 vue-server-renderer提供的渲染流程图: 可以看出vue的后端渲染分三个部分组成：页面的源码（source），node层的渲染部分和浏览器端的渲染部分。 source分为两种entry point,一个是前端页面的入口client entry,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口server entry,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象（经过测试，直接返回Vue对象也是可以的）; 前面的source部分就是业务开发的代码，开发完成之后通过 webpack 进行构建，生成对应的bundle，这里不再赘述client bundle,就是一个可在浏览器端执行的打包文件；这里说下server bundle, vue2提供 vue-server-renderer模块，模块可以提供两种render: rendererer/bundleRenderer ,下面分别介绍下这两种render。 renderer接收一个vue对象 ，然后进行渲染，这种对于简单的vue对象,可以这么去做，但是对于复杂的项目，如果使用这种直接require一个vue对象，这个对于服务端代码的结构和逻辑都不太友好，首先模块的状态会一直延续在每个请求渲染请求，我们需要去管理和避免这次渲染请求的状态影响到后面的请求,因此vue-server-renderer提供了另外一种渲染模式，通过一个 bundleRenderer去做渲染。 bundleRenderer是较为复杂项目进行服务端渲染官方推荐的方式，通过webpack以server entry按照一定的要求打包生成一个 server-bundle,它相当于一个可以给服务端用的app的打包压缩文件，每一次调用都会重新初始化 vue对象，保证了每次请求都是独立的，对于开发者来说，只需要专注于当前业务就可以，不用为服务端渲染开发更多的逻辑代码。renderer生成完成之后，都存在两个接口，分别是renderToString和renderToStream，一个是一次性将页面渲染成字符串文件，另外一个是流式渲染，适用于支持流的web服务器，可以是请求服务的速度更快。 如何从零开始搭建适合自己的vue后端渲染框架？","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.iwangqi.com/tags/vue/"}]},{"title":"浅谈webworker的使用场景","date":"2017-05-07T13:09:11.000Z","path":"2017-05-07/","text":"一、webWorker之初体验在”setTimeout那些事儿”中，说到JavaScript是单线程。也就是同一时间只能做同一事情。 也好理解，作为浏览器脚本语言，如果JavaScript不是单线程，那么就有点棘手了。比如，与用户交互或者对DOM进行操作时，在一个线程上修改某个DOM，另外的线程删除DOM，这时浏览器该如何抉择呢? 所以，JavaScript是单线程也是有背景的。 如下： 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;singleThread&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //添加到任务队列中，待同步任务所处的‘执行栈’执行完毕，1秒后执行任务队列中的这个匿名函数 setTimeout(function()&#123; console.log('come on'); &#125;,1000); //只要不关闭该alert，‘执行栈’就没结束，从而也就不会进入到任务队列中 alert('waiting'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 但，HTML5引入了一个工作线程（webWorker）的概念。它允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。 简而言之，就是允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。 从而，可以用webWorker来处理一些比较耗时的计算。 如下，主页面： 12345678910111213141516171819&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; //创建一个Worker对象，并向它传递将在新线程中执行的脚本url var worker = new Worker('worker.js'); //接收worker传递过来的数据 worker.onmessage = function(event)&#123; document.getElementById('result').innerHTML+=event.data+\"&lt;br/&gt;\" ; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 下面是worker.js的内容: 123456789101112131415var i = 0;function timedCount()&#123; for(var j = 0, sum = 0; j &lt; 100; j++)&#123; for(var i = 0; i &lt; 100000000; i++)&#123; sum+=i; &#125;; &#125;; //将得到的sum发送回主线程 postMessage(sum);&#125;;//将执行timedCount前的时间，通过postMessage发送回主线程postMessage('Before computing, '+new Date());timedCount();//结束timedCount后，将结束时间发送回主线程postMessage('After computing, ' +new Date()); 上面代码执行的流程是：创建的worker对象，并用onmessage方法接收worker.js里面postMessage传递过来的数据(event.data)，并将数据追加到div#result中。 所以，执行上面的代码结果如下： 待worker.js中的timedCount方法运算完后，执行postMessage操作，向主线程传数据，得图二。期间，并不影响主线程的运作。 二、webWorker之常用ＡＰＩ接下来，再来看看关于worker的常用API： 1、postMessage(data)子线程与主线程之间互相通信使用方法，传递的data为任意值。 123456//worker = new Worker('url');//worker.postMessage传递给子线程数据，对象worker.postMessage(&#123;first:1,second:2&#125;);//子线程中也可以使用postMessage，如传递字符串postMessage(‘test’); 2、terminate()主线程中终止worker，此后无法再利用其进行消息传递。注意：一旦terminate后，无法重新启用，只能另外创建。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//worker = new Worker('url');worker.terminate();``` 如，主页面：``` html&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; var worker = new Worker('worker.js'); //每隔100毫秒，向子线程传递&#123;name: 'monkey'&#125;信息 setInterval(function()&#123; worker.postMessage(&#123;name: 'monkey'&#125;); &#125;,100); //当主线程worker收到来自子线程的消息后，触发message事件 worker.onmessage = function(event)&#123; document.getElementById('result').innerHTML+=event.data+\"&lt;br/&gt;\" ; //主线程使用terminate方法中断与子线程来往，在浏览器中只能显示一次event.data worker.terminate(); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;``` 子线程worker.js代码：``` javascript&lt;script&gt;//当主线程发来信息后，触发该message事件onmessage = function(event)&#123; //向主线程发送event.data.name信息 postMessage(event.data.name);&#125;;&lt;/script&gt;``` #### 3、message当有消息发送时，触发该事件。且，消息发送是双向的，消息内容可通过data来获取。message使用，可见terminate中的demo#### 4、error出错处理。且错误消息可以通过e.message来获取。如下：``` javascript//worker = new Worker('url');worker.onerror = function(e)&#123; //打印出错消息 console.log(e.message); //中断与子线程的联系 worker.terminate();&#125;``` 另：worker线程从上到下同步运行它的代码，然后进入异步阶段来对事件及计时器响应，如果worker注册了message事件处理程序，只要其有可能触发，worker就一直在内存中，不会退出，所以通信完毕后得手动在主线程中terminate或者子线程中close掉，但如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，他就会退出。### 三、worker上下文先看下面这段代码：主页面：``` javascript&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;script&gt; function init()&#123; var worker = new Worker('worker.js'); //接收消息事件 worker.onmessage = function(event)&#123; console.log(event.data); &#125;; //错误信息事件 worker.onerror = function(e)&#123; console.log('erro: ' + e.message); //终止线程 worker.terminate(); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body onload = \"init()\"&gt; &lt;/body&gt;&lt;/html&gt; worker.js 123456//window对象的alert方法alert(1);onmessage = function(event)&#123; //向主线程发送event.data.name信息 postMessage(event.data.name);&#125;; 执行上面代码结果： 为什么会这样呢？原因是alert为window对象的方法，所以会报错undefined。 worker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做WorkerGlobalScope的东东，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。WorkerGlobalScope作用域下的常用属性、方法如下： 1、self 我们可以使用 WorkerGlobalScope 的 self 属性来或者这个对象本身的引用 2、location location 属性返回当线程被创建出来的时候与之关联的 WorkerLocation 对象，它表示用于初始化这个工作线程的脚步资源的绝对 URL，即使页面被多次重定向后，这个 URL 资源位置也不会改变。 3、close 关闭当前线程，与terminate作用类似 4、importScripts 我们可以通过importScripts()方法通过url在worker中加载库函数 5、XMLHttpRequest 有了它，才能发出Ajax请求 6、setTimeout/setInterval以及addEventListener/postMessage四、关于worker我们可以做什么： 1.可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信 2.可以在worker中通过importScripts(url)加载另外的脚本文件 3.可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval() 4.可以使用XMLHttpRequest来发送请求 5.可以访问navigator的部分属性 局限性： 1.不能跨域加载JS 2.worker内代码不能访问DOM 3.各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行 4.IE这个新特性","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"}]},{"title":"axios基本使用介绍","date":"2017-05-02T10:56:15.000Z","path":"2017-05-02/","text":"axios建议使用高版本浏览器，目前在手机端使用频繁，但是在低版本的安卓上其实是有兼容性问题的，安卓4.2就开始出问题了，主要是由于Promise不支持，需要额外引入兼容包来处理。并且axios也是vue官方推荐使用的库。 1require('es6-promise').polyfill(); 发送一个GET请求，代码示例如下： 1234567891011121314151617181920//通过给定的ID来发送请求axios.get('/user?ID=12345') .then(function(response)&#123; console.log(response); &#125;) .catch(function(err)&#123; console.log(err); &#125;);//以上请求也可以通过这种方式来发送axios.get('/user',&#123; params:&#123; ID:12345 &#125;&#125;).then(function(response)&#123; console.log(response);&#125;).catch(function(err)&#123; console.log(err);&#125;); 发送一个POST请求，代码示例如下： 12345678910axios.post('/user',&#123; firstName:'Fred', lastName:'Flintstone'&#125;).then(function(res)&#123; console.log(res);&#125;).catch(function(err)&#123; console.log(err);&#125;); 一次性并发多个请求，代码示例如下： 12345678910function getUserAccount()&#123; return axios.get('/user/12345');&#125;function getUserPermissions()&#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms)&#123; //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果 &#125;)) axios可以通过配置（config）来发送请求，代码示例如下： 123456789//发送一个`POST`请求axios(&#123; method:\"POST\", url:'/user/12345', data:&#123; firstName:\"Fred\", lastName:\"Flintstone\" &#125;&#125;); 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名,注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明 1234567axios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]]) 并发请求（concurrency）,即是帮助处理并发请求的辅助函数 1234//iterable是一个可以迭代的参数如数组等axios.all(iterable)//callback要等到所有请求都完成才会执行axios.spread(callback) 创建一个axios实例，并且可以自定义其配置 1、axios.create([config])12345var instance = axios.create(&#123; baseURL:\"https://some-domain.com/api/\", timeout:1000, headers: &#123;'X-Custom-Header':'foobar'&#125;&#125;); 2、实例的方法，注意已经定义的配置将和利用create创建的实例的配置合并1234567axios#request(config)axios#get(url[,config])axios#delete(url[,config])axios#head(url[,config])axios#post(url[,data[,config]])axios#put(url[,data[,config]])axios#patch(url[,data[,config]]) 请求的配置（request config），以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&#123; //`url`是请求的服务器地址 url:'/user', //`method`是请求资源的方式 method:'get'//default //如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面 //当`url`是相对地址的时候，设置`baseURL`会非常的方便 baseURL:'https://some-domain.com/api/', //`transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动 //该选项只适用于以下请求方式：`put/post/patch` //数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream` transformRequest:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动 transformResponse:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`headers`选项是需要被发送的自定义请求头信息 headers: &#123;'X-Requested-With':'XMLHttpRequest'&#125;, //`params`选项是要随请求一起发送的请求参数----一般链接在URL后面 //他的类型必须是一个纯对象或者是URLSearchParams对象 params: &#123; ID:12345 &#125;, //`paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化 //例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param) paramsSerializer: function(params)&#123; return Qs.stringify(params,&#123;arrayFormat:'brackets'&#125;) &#125;, //`data`选项是作为一个请求体而需要被发送的数据 //该选项只适用于方法：`put/post/patch` //当没有设置`transformRequest`选项时dada必须是以下几种类型之一 //string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams //仅仅浏览器：FormData/File/Bold //仅node:Stream data &#123; firstName:\"Fred\" &#125;, //`timeout`选项定义了请求发出的延迟毫秒数 //如果请求花费的时间超过延迟的时间，那么请求会被终止 timeout:1000, //`withCredentails`选项表明了是否是跨域请求 withCredentials:false,//default //`adapter`适配器选项允许自定义处理请求，这会使得测试变得方便 //返回一个promise,并提供验证返回 adapter: function(config)&#123; /*..........*/ &#125;, //`auth`表明HTTP基础的认证应该被使用，并提供证书 //这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息 auth: &#123; username:\"zhangsan\", password: \"s00sdkf\" &#125;, //返回数据的格式 //其可选项是arraybuffer,blob,document,json,text,stream responseType:'json',//default // xsrfCookieName: 'XSRF-TOKEN',//default xsrfHeaderName:'X-XSRF-TOKEN',//default //`onUploadProgress`上传进度事件 onUploadProgress:function(progressEvent)&#123; //下载进度的事件onDownloadProgress:function(progressEvent)&#123;&#125; &#125;, //相应内容的最大值 maxContentLength:2000, //`validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise //如果`validateStatus`返回true(或者设置为`null`或者`undefined`),那么promise的状态将会是resolved,否则其状态就是rejected validateStatus:function(status)&#123; return status &gt;= 200 &amp;&amp; status &lt;300;//default &#125;, //`maxRedirects`定义了在nodejs中重定向的最大数量 maxRedirects: 5,//default //`httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理 //keeyAlive在选项中没有被默认激活 httpAgent: new http.Agent(&#123;keeyAlive:true&#125;), httpsAgent: new https.Agent(&#123;keeyAlive:true&#125;), //proxy定义了主机名字和端口号， //`auth`表明http基本认证应该与proxy代理链接，并提供证书 //这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的`Proxy-Authorization` header proxy: &#123; host:'127.0.0.1', port: 9000, auth: &#123; username:'skda', password:'radsd' &#125; &#125;, //`cancelToken`定义了一个用于取消请求的cancel token //详见cancelation部分 cancelToken: new cancelToken(function(cancel)&#123; &#125;)&#125; 请求返回的内容 12345678910 &#123; data:&#123;&#125;, status:200, //从服务器返回的http状态文本 statusText:'OK', //响应头信息 headers: &#123;&#125;, //`config`是在请求的时候的一些配置信息 config: &#123;&#125;&#125; 默认配置 1、全局默认配置123axios.defaults.baseURL = 'http://api.exmple.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['content-Type'] = 'appliction/x-www-form-urlencoded'; 2、自定义的实例默认设置1234567//当创建实例的时候配置默认配置var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);//当实例创建时候修改配置instance.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN; 3、配置中的有优先级，config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。12345678910//创建一个实例的时候会使用libray目录中的默认配置//在这里timeout配置的值为0，来自于libray的默认值var instance = axios.create();//回覆盖掉library的默认值//现在所有的请求都要等2.5S之后才会发出instance.defaults.timeout = 2500;//这里的timeout回覆盖之前的2.5S变成5sinstance.get('/longRequest',&#123; timeout: 5000&#125;); 拦截器 1、你可以在请求、响应在到达then/catch之前拦截他们12345678910111213141516//添加一个请求拦截器axios.interceptors.request.use(function(config)&#123; //在请求发出之前进行一些操作 return config;&#125;,function(err)&#123; //Do something with request error return Promise.reject(error);&#125;);//添加一个响应拦截器axios.interceptors.response.use(function(res)&#123; //在这里对返回的数据进行处理 return res;&#125;,function(err)&#123; //Do something with response error return Promise.reject(error);&#125;) 2、取消拦截器12var myInterceptor = axios.interceptor.request.use(function()&#123;/*....*/&#125;);axios.interceptors.request.eject(myInterceptor); 3、给自定义的axios实例添加拦截器12var instance = axios.create();instance.interceptors.request.use(function()&#123;&#125;) 错误处理 12345678910111213axios.get('/user/12345') .catch(function(error)&#123; if(error.response)&#123; //请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.header); &#125;else &#123; //一些错误是在设置请求的时候触发 console.log('Error',error.message); &#125; console.log(error.config); &#125;); 取消,你可以通过一个cancel token来取消一个请求 1、你可以通过CancelToken.source工厂函数来创建一个cancel token123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345',&#123; cancelToken: source.token&#125;).catch(function(thrown)&#123; if(axios.isCancel(thrown))&#123; console.log('Request canceled',thrown.message); &#125;else &#123; //handle error &#125;&#125;);//取消请求（信息的参数可以设置的）source.cance(\"操作被用户取消\"); 2、你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:12345678910var cancelToken = axios.CancelToken;var cance;axios.get('/user/12345',&#123; cancelToken: new CancelToken(function(c)&#123; //这个executor函数接受一个cancel function作为参数 cancel = c; &#125;)&#125;)//取消请求cancel(); 使用 application/x-www-form-urlencoded 格式化,默认情况下，axios串联js对象为 JSON 格式。为了发送 application/x-wwww-form-urlencoded 格式数据，你可以使用一下的设置。在浏览器中你可以如下使用 URLSearchParams API: 1234var params = new URLSearchParams();params.append('param1','value1');params.append('param2','value2');axios.post('/foo',params); URLSearchParams 不支持所有的浏览器,polyfill可用（确保垫片在浏览器全局环境中）,同样还有其他方法，片段代码如下： 12var qs = require('qs');axios.post('/foo', qs.stringify(&#123;'bar':123&#125;)); 如果在node环境中，可以使用以下querystring方法，代码片段如下： 12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123;foo:'bar'&#125;)); axios 基于原生的ES6 Promise 实现。如果环境不支持请使用es6-promise这个库来处理。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://www.iwangqi.com/tags/ajax/"}]},{"title":"详解javascript对象方法Object.assign()痛点","date":"2017-04-11T13:55:28.000Z","path":"2017-04-11/","text":"函数原型首先看一下函数的定义：函数参数为一个目标对象（该对象作为最终的返回值）,源对象(此处可以为任意多个)。通过调用该函数可以拷贝所有可被枚举的自有属性值到目标对象中。 Object.assign(target, …sources) 这里我们需要强调的三点是： 可被枚举的属性 自有属性 string或者Symbol类型是可以被直接分配的 拷贝过程中将调用源对象的getter方法，并在target对象上使用setter方法实现目标对象的拷贝。 函数实例这里我们通过几个MDN上的例子来介绍一下使用方法： 实例一我们参考上面的原型函数说明即可知道其最开始的o1因为设置为target，则调用其setter方法设置了其他对象的属性到自身。 12345678var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed. 实例二我们自定义了一些对象，这些对象有一些包含了不可枚举的属性,另外注意使用 Object.defineProperty 初始化的对象默认是不可枚举的属性。对于可枚举的对象我们可以直接使用Object.keys()获得,或者使用for-in循环遍历出来. 对于不可枚举的属性，使用Object.assign的时候将被自动忽略。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124var obj = Object.create(&#123; foo: 1 &#125;, &#123; // foo is an inherit property. bar: &#123; value: 2 // bar is a non-enumerable property. &#125;, baz: &#123; value: 3, enumerable: true // baz is an own enumerable property. &#125;&#125;);var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; baz: 3 &#125; ``` ### 实例三对于只读的属性，当分配新的对象覆盖他的时候，将抛出异常:``` javascriptvar target = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 1, writable: false&#125;); Object.assign(target, &#123; bar: 2 &#125;)//&#123;bar: 2, foo: 1&#125;Object.assign(target, &#123; foo: 2 &#125;)//Uncaught TypeError: Cannot assign to read only property 'foo' of object '#&lt;Object&gt;'(…)``` ## Polyfill这里我们简单的看下如何实现es5版本的Object.assign：实现步骤：判断是否原生支持该函数，如果不存在的话创建一个立即执行函数，该函数将创建一个assign函数绑定到Object上。判断参数是否正确(目的对象不能为空，我们可以直接设置&#123;&#125;传递进去,但必须设置该值)使用Object在原有的对象基础上返回该对象，并保存为out使用for…in循环遍历出所有的可枚举的自有对象。并复制给新的目标对象(hasOwnProperty返回非原型链上的属性)源码如下：``` javascript if (typeof Object.assign != 'function') &#123; (function () &#123; Object.assign = function (target) &#123; 'use strict'; if (target === undefined || target === null) &#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; var output = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var source = arguments[index]; if (source !== undefined &amp;&amp; source !== null) &#123; for (var nextKey in source) &#123; if (source.hasOwnProperty(nextKey)) &#123; output[nextKey] = source[nextKey]; &#125; &#125; &#125; &#125; return output; &#125;;&#125;)();&#125;``` ## 扩展内容### 深度拷贝和前拷贝javascript中存储对象都是存地址的，所以浅拷贝是都指向同一块内存区块，而深拷贝则是另外开辟了一块区域，下面实例也可以看出这一点：``` javascript// 浅拷贝const a = &#123;t: 1, p: 'gg'&#125;;const b = a;b.t = 3;console.log(a); // &#123;t: 3, p: 'gg'&#125;console.log(b); // &#123;t: 3, p: 'gg'&#125;//深拷贝const c = &#123;t: 1, p: 'gg'&#125;;const d = deepCopy(c);d.t = 3;console.log(c); // &#123;t: 1, p: 'gg'&#125;console.log(d); // &#123;t: 3, p: 'gg'&#125;``` 可以明显看出，浅拷贝在改变其中一个值时，会导致其他也一起改变，而深拷贝不会。我需要的是深拷贝的方法，然后发现原来es6 中有Object.assign() 这个方法，感觉可以拿来用了。 贴一下两个官方例子：``` javascript// Cloning an objectvar obj = &#123; a: 1 &#125;;var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125;// Merging objectsvar o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, target object itself is changed. 是不是很完美，又可以clone又可以merge。在我这种情况下，我觉得我的代码量又可以减少了，比如： 1234567891011121314151617const defaultOpt = &#123; title: 'hello', name: 'oo', type: 'line'&#125;;// 原来可能需要这样const opt1 = deepCopy(a);opt1.title = 'opt1';opt1.type = 'bar';opt1.extra = 'extra'; // 额外增加配置// 现在只要这样const opt2 = Object.assign(&#123;&#125;, a, &#123; title: 'opt2', type: 'bar', extra: 'extra'&#125;); 不过，很快，问题出现了，那就是merge和我想象的不一样且看例子： 1234567891011121314151617181920212223242526272829const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125;&#125;;const opt = Object.assign(&#123;&#125;, defaultOpt, &#123; title: &#123; subtext: 'Yes, your world.' &#125;&#125;);console.log(opt);// 预期结果&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125;// 实际结果&#123; title: &#123; subtext: 'Yes, your world.' &#125;&#125; 原本想的是它只会覆盖subtext ，然而其实它直接覆盖了整个title ，这个让我比较郁闷，相当于它只merge根属性，下面的就不做处理了。代码只能重构成相对麻烦一点的： 12345678910111213141516171819const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125;&#125;;const opt = Object.assign(&#123;&#125;, defaultOpt);opt.title.subtext = 'Yes, your world.';console.log(opt);// 结果正常&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125; 这样用虽然麻烦一点，但是也还好，可以用了。不过。。。很快，又出现问题了，如下： 12345678910111213141516171819202122232425262728293031const defaultOpt = &#123; title: &#123; text: 'hello world', subtext: 'It\\'s my world.' &#125; &#125;;const opt1 = Object.assign(&#123;&#125;, defaultOpt);const opt2 = Object.assign(&#123;&#125;, defaultOpt);opt2.title.subtext = 'Yes, your world.';console.log('opt1:');console.log(opt1);console.log('opt2:');console.log(opt2);// 结果opt1:&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125;opt2:&#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125;&#125; 上面结果发现两个配置变得一模一样，而其实我们并没有去更改opt1 的subtext ，只是改了opt2 的。这说明一点：在title 这一层只是简单的浅拷贝 ，而没有继续深入的深拷贝。 Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。用的时候，还是要注意这个问题的。不过github上已经有很多好的解决方案，比如deep-merge 通过递归的方式逐层的去调用assign函数。Lodash提供了深拷贝的api方法，其实熟悉jquery的同学，extend这个api就能直接完美解决深拷贝的问题。 附发现一个可以简单实现深拷贝的方法，当然，有一定限制，如下： const obj1 = JSON.parse(JSON.stringify(obj)); 思路就是将一个对象转成json字符串，然后又将字符串转回对象。但是在使用中还是会存在问题，进过测试会把function替换掉，使用的时候还得注意。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://www.iwangqi.com/tags/es6/"}]},{"title":"理解JavaScript函数式编程","date":"2017-04-10T14:14:43.000Z","path":"2017-04-10/","text":"JavaScript 函数式编程是一个存在了很久的话题，但似乎从 2016 年开始，它变得越来越火热。这可能是因为 ES6 语法对于函数式编程更为友好，也可能是因为诸如 RxJS (ReactiveX) 等函数式框架的流行。 看过许多关于函数式编程的讲解，但是其中大部分是停留在理论层面，还有一些是仅针对 Haskell 等纯函数式编程语言的。而本文旨在聊一聊我眼中的函数式编程在 JavaScript 中的具体实践，之所以是 “我眼中的” 即我所说的仅代表个人观点，可能和部分 严格概念 是有冲突的。 本文将略去一大堆形式化的概念介绍，重点展示在 JavaScript 中到底什么是函数式的代码、函数式代码与一般写法有什么区别、函数式的代码能给我们带来什么好处以及常见的一些函数式模型都有哪些。 函数式编程我认为函数式编程可以理解为，以函数作为主要载体的编程方式，用函数去拆解、抽象一般的表达式 与命令式相比，这样做的好处在哪？主要有以下几点： 语义更加清晰 可复用性更高 可维护性更好 作用域局限，副作用少 基本的函数式编程下面例子是一个具体的函数式体现 123456789101112131415161718192021222324// 一般写法const arr = ['apple', 'pen', 'apple-pen'];for(const i in arr)&#123; const c = arr[i][0]; arr[i] = c.toUpperCase() + arr[i].slice(1);&#125;console.log(arr);// 函数式写法一function upperFirst(word) &#123; return word[0].toUpperCase() + word.slice(1);&#125;function wordToUpperCase(arr) &#123; return arr.map(upperFirst);&#125;console.log(wordToUpperCase(['apple', 'pen', 'apple-pen']));// 函数式写法二console.log(arr.map(['apple', 'pen', 'apple-pen'], word =&gt; word[0].toUpperCase() + word.slice(1))); 当情况变得更加复杂时，表达式的写法会遇到几个问题： 表意不明显，逐渐变得难以维护 复用性差，会产生更多的代码量 会产生很多中间变量 函数式编程很好的解决了上述问题。首先参看 函数式写法一，它利用了函数封装性将功能做拆解（粒度不唯一），并封装为不同的函数，而再利用组合的调用达到目的。这样做使得表意清晰，易于维护、复用以及扩展。其次利用 高阶函数，Array.map 代替 for…of 做数组遍历，减少了中间变量和操作。 而 函数式写法一 和 函数式写法二 之间的主要差别在于，可以考虑函数是否后续有复用的可能，如果没有，则后者更优。 链式优化从上面 函数式写法二 中我们可以看出，函数式代码在写的过程中，很容易造成 横向延展，即产生多层嵌套，下面我们举个比较极端点的例子。 // 计算数字之和 // 一般写法 console.log(1 + 2 + 3 - 4) // 函数式写法 function sum(a, b) { return a + b; } function sub(a, b) { return a - b; } console.log(sub(sum(sum(1, 2), 3), 4); 本例仅为展示 横向延展 的比较极端的情况，随着函数的嵌套层数不断增多，导致代码的可读性大幅下降，还很容易产生错误。 在这种情况下，我们可以考虑多种优化方式，比如下面的 链式优化 。 // 优化写法 (嗯，你没看错，这就是 lodash 的链式写法) const utils = { chain(a) { this._temp = a; return this; }, sum(b) { this._temp += b; return this; }, sub(b) { this._temp -= b; return this; }, value() { const _temp = this._temp; this._temp = undefined; return _temp; } }; console.log(utils.chain(1).sum(2).sum(3).sub(4).value()); 这样改写后，结构会整体变得比较清晰，而且链的每一环在做什么也可以很容易的展现出来。函数的嵌套和链式的对比还有一个很好的例子，那就是 回调函数 和 Promise 模式。 // 顺序请求两个接口 // 回调函数 import $ from 'jquery'; $.post('a/url/to/target', (rs) =&gt; { if(rs){ $.post('a/url/to/another/target', (rs2) =&gt; { if(rs2){ $.post('a/url/to/third/target'); } }); } }); // Promise import request from 'catta'; // catta 是一个轻量级请求工具，支持 fetch,jsonp,ajax，无依赖 request('a/url/to/target') .then(rs =&gt; rs ? $.post('a/url/to/another/target') : Promise.reject()) .then(rs2 =&gt; rs2 ? $.post('a/url/to/third/target') : Promise.reject()); 随着回调函数嵌套层级和单层复杂度增加，它将会变得臃肿且难以维护，而 Promise 的链式结构，在高复杂度时，仍能纵向扩展，而且层次隔离很清晰。 常见的函数式编程模型闭包（Closure）可以保留局部变量不被释放的代码块，被称为一个闭包 闭包的概念比较抽象，相信大家都或多或少知道、用到这个特性 那么闭包到底能给我们带来什么好处？ 先来看一下如何创建一个闭包： // 创建一个闭包 function makeCounter() { let k = 0; return function() { return ++k; }; } const counter = makeCounter(); console.log(counter()); // 1 console.log(counter()); // 2 makeCounter 这个函数的代码块，在返回的函数中，对局部变量 k ，进行了引用，导致局部变量无法在函数执行结束后，被系统回收掉，从而产生了闭包。而这个闭包的作用就是，“保留住“ 了局部变量，使内层函数调用时，可以重复使用该变量；而不同于全局变量，该变量只能在函数内部被引用。 换句话说，闭包其实就是创造出了一些函数私有的 ”持久化变量“。 所以从这个例子，我们可以总结出，闭包的创造条件是： 存在内、外两层函数 内层函数对外层函数的局部变量进行了引用 ###闭包的用途 闭包的主要用途就是可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等等。 // 简单的缓存工具 // 匿名函数创造了一个闭包 const cache = (function() { const store = {}; return { get(key) { return store[key]; }, set(key, val) { store[key] = val; } } }()); cache.set('a', 1); cache.get('a'); // 1 上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。 ###闭包的弊端 持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。 ##高阶函数 接受或者返回一个函数的函数称为高阶函数 听上去很高冷的一个词汇，但是其实我们经常用到，只是原来不知道他们的名字而已。JavaScript 语言是原生支持高阶函数的，因为 JavaScript 的函数是一等公民，它既可以作为参数又可以作为另一个函数的返回值使用。 我们经常可以在 JavaScript 中见到许多原生的高阶函数，例如 Array.map , Array.reduce , Array.filter 下面以 map 为例，我们看看他是如何使用的 ###map （映射） 映射是对集合而言的，即把集合的每一项都做相同的变换，产生一个新的集合 map 作为一个高阶函数，他接受一个函数参数作为映射的逻辑 // 数组中每一项加一，组成一个新数组 // 一般写法 const arr = [1,2,3]; const rs = []; for(const n of arr){ rs.push(++n); } console.log(rs) // map改写 const arr = [1,2,3]; const rs = arr.map(n =&gt; ++n); 上面一般写法，利用 for…of 循环的方式遍历数组会产生额外的操作，而且有改变原数组的风险 而 map 函数封装了必要的操作，使我们仅需要关心映射逻辑的函数实现即可，减少了代码量，也降低了副作用产生的风险。 ###柯里化（Currying） 给定一个函数的部分参数，生成一个接受其他参数的新函数 可能不常听到这个名词，但是用过 undescore 或 lodash 的人都见过他。 有一个神奇的 _.partial 函数，它就是柯里化的实现 // 获取目标文件对基础路径的相对路径 // 一般写法 const BASE = '/path/to/base'; const relativePath = path.relative(BASE, '/some/path'); // _.parical 改写 const BASE = '/path/to/base'; const relativeFromBase = _.partial(path.relative, BASE); const relativePath = relativeFromBase('/some/path'); 通过 _.partial ，我们得到了新的函数 relativeFromBase ，这个函数在调用时就相当于调用 path.relative ，并默认将第一个参数传入 BASE ，后续传入的参数顺序后置。 本例中，我们真正想完成的操作是每次获得相对于 BASE 的路径，而非相对于任何路径。柯里化可以使我们只关心函数的部分参数，使函数的用途更加清晰，调用更加简单。 ###组合（Composing） 将多个函数的能力合并，创造一个新的函数 同样你第一次见到他可能还是在 lodash 中，compose 方法（现在叫 flow） // 数组中每个单词大写，做 Base64 // 一般写法 (其中一种) const arr = ['pen', 'apple', 'applypen']; const rs = []; for(const w of arr){ rs.push(btoa(w.toUpperCase())); } console.log(rs); // _.flow 改写 const arr = ['pen', 'apple', 'applypen']; const upperAndBase64 = _.partialRight(_.map, _.flow(_.upperCase, btoa)); console.log(upperAndBase64(arr)); _.flow 将转大写和转 Base64 的函数的能力合并，生成一个新的函数。方便作为参数函数或后续复用。 ##自己的观点 我理解的 JavaScript 函数式编程，将可以复用的功能提取出来，用函数方法来代替其实就是基本的函数编程思想，其实到最后会面临两个问题，一个是函数共用性好还是函数功能细分好，这其实都是根据自己具体需求而定的，个人认为函数功能还是细分好，这样方便维护，功能实现代码逻辑清晰。 函数式编程就是书写清新的逻辑代码，其实也是一种解耦的形式罢了。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"}]},{"title":"nodejs的process.nextTick方法理解和使用","date":"2017-04-04T09:49:45.000Z","path":"2017-04-04/","text":"今天重新温习了下nodejs开发指南中的核心模块全局对象中的process进程模块，其实nextTick和我目前使用的vue中的nextTick方法有些异曲同工之妙，于是上网搜整理了一些资料，详细的了解下nextTick到底该如何理解并且在实际项目中哪些地方会用到这个方法。 Node.js是单线程的，基于事件循环，非阻塞IO的。事件循环中使用一个事件队列，在每个时间点上，系统只会处理一个事件，即使电脑有多个CPU核心，也无法同时并行的处理多个事件。因此，node.js适合处理I／O型的应用，不适合那种CPU运算密集型的应用。在I／O型的应用中，给每一个输入输出定义一个回调函数，node.js会自动将其加入到事件轮询的处理队列里，当I／O操作完成后，这个回调函数会被触发，系统会继续处理其他的请求。 理解在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。 在这种处理模式下，process.nextTick()的意思就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行。我们来看一个例子。例子中有一个foo()，你想在下一个时间点上调用他，可以这么做： 12345function foo() &#123; console.error('foo');&#125;process.nextTick(foo);console.error('bar'); 运行上面的代码，你从下面终端打印的信息会看到，”bar”的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。 12barfoo 你也可以使用setTimeout()函数来达到貌似同样的执行效果： 12setTimeout(foo, 0);console.log('bar'); 但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时。process.nextTick()定义的调用会创建一个新的队列。在当前的队列里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须结束队列操作。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的队列。 具体使用场景在多个事件里交叉执行CPU运算密集型的任务在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。 但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。 1234567891011var http = require('http');function compute() &#123; // performs complicated calculations continuously // ... process.nextTick(compute);&#125;http.createServer(function(req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('Hello World');&#125;).listen(5000, '127.0.0.1');compute(); 在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。 当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。 保持回调函数异步执行的原则当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则： 123456789101112function maybeSync(arg, cb) &#123; if (arg) &#123; cb(); return; &#125; fs.stat('file', cb);&#125;maybeSync(true, function() &#123; foo();&#125;);bar(); 这段代码不明确的地方是, 我们不清楚foo()和bar()哪个会被先调用，使用nextTick将回调函数变成异步的。这样写更好： function definitelyAsync(arg, cb) { if (arg) { process.nextTick(cb); return; } fs.stat('file', cb); } 用在事件触发过程中来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写： var EventEmitter = require('events').EventEmitter; function StreamLibrary(resourceName) { this.emit('start'); // read from the file, and for every chunk read, do: this.emit('data', chunkRead); } StreamLibrary.prototype.__proto__ = EventEmitter.prototype; // inherit from EventEmitter 下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件： var stream = new StreamLibrary('fooResource'); stream.on('start', function() { console.log('Reading has started'); }); stream.on('data', function(chunk) { console.log('Received: ' + chunk); }); 但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本： function StreamLibrary(resourceName) { var self = this; process.nextTick(function() { self.emit('start'); }); // read from the file, and for every chunk read, do: this.emit('data', chunkRead); }","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"node","slug":"node","permalink":"http://www.iwangqi.com/tags/node/"}]},{"title":"ajax如何截取302响应","date":"2017-04-02T12:09:11.000Z","path":"ajax/","text":"在ajax请求中，如果服务器端的响应是302 Found，在ajax的回调函数中能够获取这个状态码吗？能够从Response Headers中得到Location的值进行重定向吗？让我们来一起看看实际情况。 使用jQuery的$.ajax()发起ajax请求的JavaScript代码如下：1234567891011$.ajax(&#123;url: '/oauth/respond',type: 'post',data: data,complete: function(jqXHR)&#123; console.log(jqXHR.status);&#125;,error: function (xhr) &#123; console.log(xhr.status);&#125;&#125;); 当服务器端返回302 Found的响应时，浏览器中的运行结果如下： 在ajax的complete()与error()回调函数中得到的状态码都是404，而不是302。为什么呢？在stackoverflow上找到了答案： 原来，当服务器将302响应发给浏览器时，浏览器并不是直接进行ajax回调处理，而是先执行302重定向——从Response Headers中读取Location信息，然后向Location中的Url发出请求，在收到这个请求的响应后才会进行ajax回调处理。大致流程如下： ajax -&gt; browser -&gt; server -&gt; 302 -&gt; browser(redirect) -&gt; server -&gt; browser -&gt; ajax callback 而在我们的测试程序中，由于302返回的重定向URL在服务器上没有相应的处理程序，所以在ajax回调函数中得到的是404状态码；如果存在对应的URL，得到的状态码就是200。 所以，如果你想在ajax请求中根据302响应通过location.href进行重定向是不可行的。 如何解决？【方法一】继续用ajax，修改服务器端代码，将原来的302响应改为json响应，比如下面的ASP.NET MVC示例代码： 123456789101112131415return Json(new &#123; status = 302, location = \"/oauth/respond\" &#125;);ajax代码稍作修改即可：$.ajax(&#123; url: '/oauth/respond', type: 'post', data: data, dataType: 'json', success: function (data) &#123; if (data.status == 302) &#123; location.href = data.location; &#125; &#125;&#125;); 【方法二】不用ajax，改用form。 12&lt;form method=\"post\" action=\"/oauth/respond\"&gt;&lt;/form&gt;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.iwangqi.com/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://www.iwangqi.com/tags/ajax/"},{"name":"302","slug":"302","permalink":"http://www.iwangqi.com/tags/302/"}]}]